<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE event [<!ELEMENT zip_code (#PCDATA)><!ELEMENT url_link_display (#PCDATA)><!ELEMENT url (#PCDATA)><!ELEMENT tracks (track+)><!ELEMENT track (#PCDATA)><!ELEMENT title (#PCDATA)><!ELEMENT timeslot (slot_id?, event_id?, title, room, date, start_time, end_date?, end_time, description?, acm_doi?, persons?, tracks?, tags?)><!ELEMENT tags (tag+)><!ELEMENT tag (#PCDATA)><!ELEMENT suffix (#PCDATA)><!ELEMENT subevent_logo_url (#PCDATA)><!ELEMENT subevent_id (#PCDATA)><!ELEMENT subevent (subevent_id?, title, acronym?, subevent_type, description?, room, date, url?, url_link_display?, subevent_logo_url?, acm_doi?, persons?, tracks?, tags?, sponsor?, timeslot*)><!ELEMENT state (#PCDATA)><!ELEMENT start_time (#PCDATA)><!ELEMENT start_date (#PCDATA)><!ELEMENT sponsor (#PCDATA)><!ELEMENT sort_key (#PCDATA)><!ELEMENT slot_id (#PCDATA)><!ELEMENT subevent_type EMPTY><!ATTLIST subevent_type	type (case_study | demonstration | poster | regular | tutorial | workshop) #IMPLIED><!ELEMENT room (#PCDATA)><!ELEMENT role (#PCDATA)><!ELEMENT picture_url (#PCDATA)><!ELEMENT persons (person+)><!ELEMENT person (role, sort_key, first_name, middle_name?, last_name, suffix?, affiliation, acm_profile_id?, email?, bio?, homepage_url?, picture_url?, person_id?)><!ELEMENT middle_name (#PCDATA)><!ELEMENT location (facility_name, facility_map_url?, address, city, state?, country, zip_code?)><!ELEMENT last_name (#PCDATA)><!ELEMENT homepage_url (#PCDATA)><!ELEMENT first_name (#PCDATA)><!ELEMENT facility_name (#PCDATA)><!ELEMENT facility_map_url (#PCDATA)><!ELEMENT event_type EMPTY><!ATTLIST event_type	type (conference|workshop|symposium) #IMPLIED><!ELEMENT event (event_details, subevent*, timeslot*, timezone_id?)><!ELEMENT event_logo_url (#PCDATA)><!ELEMENT event_details (title, acronym, event_type, start_date, end_date, location, description, url?, url_link_display?, event_logo_url?, persons?)><!ELEMENT end_time (#PCDATA)><!ELEMENT end_date (#PCDATA)><!ELEMENT email (#PCDATA)><!ELEMENT description (#PCDATA)><!ELEMENT date (#PCDATA)><!ELEMENT country (#PCDATA)><!ELEMENT city (#PCDATA)><!ELEMENT bio (#PCDATA)><!ELEMENT affiliation (#PCDATA)><!ELEMENT address (#PCDATA)><!ELEMENT acronym (#PCDATA)><!ELEMENT acm_profile_id (#PCDATA)><!ELEMENT acm_doi (#PCDATA)>]>
<event>
  <event_details>
    <title>SPLASH 2021</title>
    <acronym>SPLASH 2021</acronym>
    <event_type type="conference"/>
    <start_date>2021/10/17</start_date>
    <end_date>2021/10/22</end_date>
    <location>
      <facility_name>Swissotel Chicago</facility_name>
      <address>323 East Wacker Drive</address>
      <city>Chicago</city>
      <state>Illinois</state>
      <country>United States</country>
    </location>
    <description>Welcome 
Welcome to SPLASH 2021, the ACM SIGPLAN conference on Systems, Programming, Languages, and Applications: Software for Humanity. SPLASH embraces all aspects of software construction and delivery, to make it the premier conference on the applications of programming languages—at the intersection of programming languages and software engineering. SPLASH takes place Sunday October 17th to Friday 22th. 
SPLASH 2021 registration is now open. Please register using this online registration form. Early registration closes on September 18, 2021. 
SPLASH 2021 will require in-person attendees to be fully vaccinated, as defined by the Center for Disease Control (CDC). According to the CDC, attendees “are considered fully vaccinated (a) 2 weeks after their second dose in a 2-dose series, such as the Pfizer or Moderna vaccines, or (b) 2 weeks after a single-dose vaccine, such as Johnson &amp;amp; Johnson’s Janssen vaccine. If you don’t meet these requirements, regardless of your age, you are NOT fully vaccinated.” SPLASH 2021 will offer virtual attendance options for those individuals who are not fully vaccinated. Vaccination validation will be conducted by a vendor contracted by the ACM to perform this validation for the SPLASH 2021 conference. Masks are required at SPLASH 2021. 
The virtual attendance option is available to unvaccinated attendees.</description>
    <url>https://2021.splashcon.org</url>
    <url_link_display>SPLASH 2021</url_link_display>
    <persons>
      <person>
        <role>Committee Member in Steering Committee, General Chair in Organizing Committee</role>
        <sort_key>1</sort_key>
        <first_name>Hridesh</first_name>
        <last_name>Rajan</last_name>
        <affiliation>Iowa State University</affiliation>
        <bio>Hridesh Rajan is a Professor and Chair of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the department chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a AAAS fellow, a distinguished member of the ACM, and a member of IEEE. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
        <homepage_url>https://hridesh.github.io</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
        <person_id>hrideshrajan</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee, OOPSLA Review Committee Chair in Organizing Committee</role>
        <sort_key>2</sort_key>
        <first_name>Sophia</first_name>
        <last_name>Drossopoulou</last_name>
        <affiliation>Facebook and Imperial College London</affiliation>
        <bio>I am leading the London Probable team at Facebook, and a Professor of Programming Languages at the Department of Computing, Imperial College, London, UK.</bio>
        <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
        <person_id>sophiadrossopoulou</person_id>
      </person>
      <person>
        <role>Chair in Steering Committee, SLE General Chair in Organizing Committee</role>
        <sort_key>3</sort_key>
        <first_name>Eelco</first_name>
        <last_name>Visser</last_name>
        <affiliation>Delft University of Technology</affiliation>
        <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science and chair of the Programming Languages Group at Delft University of Technology. His current research is on the foundation and implementation of declarative specification of programming languages. He studied at the University of Amsterdam (master 1993; doctorate 1997), and worked at the Oregon Graduate Institute (postdoc 1997-1998), Utrecht University (assistant professor 1998-2006), and TU Delft (associate professor 2006-2013, full professor since 2013). 
His research interests include (domain-specific) programming languages, language engineering, program transformation, and declarative language definition. With his students he has designed and implemented the Spoofax language workbench, as well as several domain-specific languages, including DSLs for syntax definition (SDF3), program transformation (Stratego), static semantics (Statix), software deployment (Nix), and web application development (WebDSL). Applications of WebDSL include the researchr conference hosting site and the WebLab learning management system.</bio>
        <homepage_url>http://eelcovisser.org</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
        <person_id>eelcovisser</person_id>
      </person>
      <person>
        <role>Hybridization Co-Chair in Organizing Committee</role>
        <sort_key>4</sort_key>
        <first_name>Jonathan</first_name>
        <last_name>Aldrich</last_name>
        <affiliation>Carnegie Mellon University</affiliation>
        <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
        <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
        <person_id>jonathanaldrich</person_id>
      </person>
      <person>
        <role>Hybridization Co-Chair in Organizing Committee</role>
        <sort_key>5</sort_key>
        <first_name>Steve</first_name>
        <last_name>Blackburn</last_name>
        <affiliation>Australian National University</affiliation>
        <bio>My research interests are centered on the challenge of making software run faster and more power-efficiently on modern hardware. My primary interests include: microarchitectural support for managed languages, fast and efficient garbage collection, and the design and implementation of virtual machines. As a backdrop to this I have a longstanding interest in role of sound methodology and infrastructure in successful research innovation.</bio>
        <homepage_url>http://users.cecs.anu.edu.au/~steveb/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/steveblackburn/1deee732-405d-4403-a974-a418751399c2/small.jpg</picture_url>
        <person_id>steveblackburn</person_id>
      </person>
      <person>
        <role>Hybridization Co-Chair in Organizing Committee</role>
        <sort_key>6</sort_key>
        <first_name>Benjamin</first_name>
        <last_name>Chung</last_name>
        <affiliation>Northeastern University</affiliation>
        <bio>undefined</bio>
        <picture_url>https://2021.splashcon.org/getProfileImage/benjaminchung/30978af0-bcee-4c1e-9dd1-f2588ea14f38/small.jpg</picture_url>
        <person_id>benjaminchung</person_id>
      </person>
      <person>
        <role>Hybridization Co-Chair in Organizing Committee</role>
        <sort_key>7</sort_key>
        <first_name>Youyou</first_name>
        <last_name>Cong</last_name>
        <affiliation>Tokyo Institute of Technology</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://prg.is.titech.ac.jp/people/cong/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/youyoucong/55f54fd9-cac5-44ae-93c1-921409269efc/small.jpg</picture_url>
        <person_id>youyoucong</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee, Hybridization Co-Chair in Organizing Committee</role>
        <sort_key>8</sort_key>
        <first_name>Alex</first_name>
        <last_name>Potanin</last_name>
        <affiliation>Victoria University of Wellington</affiliation>
        <bio>I am an Associate Professor in the School of Engineering and Computer Science at Victoria University of Wellington, New Zealand. 
I am originally from Moscow, Russia with a background in Mathematics. I have completed my PhD in programming languages in 2006 and took up a job as a Lecturer in Software Engineering at Victoria University of Wellington. During my studies, I took short breaks to work as a Visiting Researcher at Purdue University, and Software Engineer at two Wellington start-ups. I spent 2013 on sabbatical at Carnegie Mellon University in Pittsburgh, PA, USA. I spent winter 2019/2020 on sabbatical at Kyoto University in Japan.</bio>
        <homepage_url>http://homepages.ecs.vuw.ac.nz/~alex/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/alexpotanin/614f887b-90a3-4626-b67d-fa63309b44c8/small.jpg</picture_url>
        <person_id>alexpotanin</person_id>
      </person>
      <person>
        <role>Hybridization Co-Chair in Organizing Committee</role>
        <sort_key>9</sort_key>
        <first_name>Talia</first_name>
        <last_name>Ringer</last_name>
        <affiliation>University of Illinois at Urbana-Champaign</affiliation>
        <bio>I am an incoming assistant professor at University of Illinois at Urbana-Champaign. My main interest is in making program verification using interactive theorem provers more accessible through better proof engineering tools and practices, especially when it comes to maintaining proofs as programs change over time. My vision is a future of verification that is accessible to all programmers, not just to experts. I got my Ph.D. from University of Washington in June 2021, where I was an NSF GRFP fellow and a P.E.O fellow. Prior to graduate school, I earned my bachelor’s in mathematics and computer science from University of Maryland, then worked at Amazon as a software engineer for three years. I am the founder and chair of the SIGPLAN-M mentoring program, and a contributor to the Coq interactive theorem prover. 
Oh, and I am currently looking for students! Please apply!</bio>
        <homepage_url>https://dependenttyp.es</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/taliaringer/1a95a492-cf5a-4225-8efb-ac834a36fa16/small.jpg</picture_url>
        <person_id>taliaringer</person_id>
      </person>
      <person>
        <role>Onward! Essays Chair in Organizing Committee</role>
        <sort_key>10</sort_key>
        <first_name>Elisa</first_name>
        <last_name>Baniassad</last_name>
        <affiliation>University of British Columbia</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.ubc.ca/~ebani</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/elisabaniassad/ebb453ca-88ce-4678-823e-82b113c14751/small.jpg</picture_url>
        <person_id>elisabaniassad</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee, Onward! Papers Chair in Organizing Committee</role>
        <sort_key>11</sort_key>
        <first_name>Wolfgang</first_name>
        <last_name>De Meuter</last_name>
        <affiliation>Vrije Universiteit Brussel</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/wolfgangdemeuter/cb721b79-a1aa-4583-8ba0-b1a96f896900/small.jpg</picture_url>
        <person_id>wolfgangdemeuter</person_id>
      </person>
      <person>
        <role>DLS Chair in Organizing Committee</role>
        <sort_key>12</sort_key>
        <first_name>Arjun</first_name>
        <last_name>Guha</last_name>
        <affiliation>Northeastern University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
        <person_id>arjunguha</person_id>
      </person>
      <person>
        <role>SPLASH-E Co-Chair in Organizing Committee</role>
        <sort_key>13</sort_key>
        <first_name>Charlie</first_name>
        <last_name>Curtsinger</last_name>
        <affiliation>Grinnell College</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://ccurtsinger.net</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/charliecurtsinger/e779a4c9-ade3-4073-b660-866046d6c953/small.jpg</picture_url>
        <person_id>charliecurtsinger</person_id>
      </person>
      <person>
        <role>SPLASH-E Co-Chair in Organizing Committee</role>
        <sort_key>14</sort_key>
        <first_name>Tien N.</first_name>
        <last_name>Nguyen</last_name>
        <affiliation>University of Texas at Dallas</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.utdallas.edu/~tien.n.nguyen/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/tiennguyen/10e4533a-6059-499a-aa1c-a76131caeae5/small.jpg</picture_url>
        <person_id>tiennguyen</person_id>
      </person>
      <person>
        <role>Doctoral Symposium Chair in Organizing Committee</role>
        <sort_key>15</sort_key>
        <first_name>Robert</first_name>
        <last_name>Dyer</last_name>
        <affiliation>University of Nebraska-Lincoln</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://go.unl.edu/rdyer</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/robertdyer/774d6fd8-9a08-4c37-9113-f0bc0c5fb833/small.jpg</picture_url>
        <person_id>robertdyer</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee, Rebase Chair in Organizing Committee</role>
        <sort_key>16</sort_key>
        <first_name>Jan</first_name>
        <last_name>Vitek</last_name>
        <affiliation>Northeastern University / Czech Technical University</affiliation>
        <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
        <homepage_url>http://janvitek.org</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
        <person_id>janvitek</person_id>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>17</sort_key>
        <first_name>Mehdi</first_name>
        <last_name>Bagherzadeh</last_name>
        <affiliation>Oakland University</affiliation>
        <bio>Assistant Professor, Department of Computer Science and Engineering</bio>
        <homepage_url>https://mbagherz.bitbucket.io/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/mehdibagherzadeh/95dc6f53-51a0-4bf1-b822-7bbe8c4d223a/small.jpg</picture_url>
        <person_id>mehdibagherzadeh</person_id>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>18</sort_key>
        <first_name>Raffi</first_name>
        <last_name>Khatchadourian</last_name>
        <affiliation>CUNY Hunter College</affiliation>
        <bio>I am an Assistant Professor in the Department of Computer Science at Hunter College and the Graduate Center of the City University of New York (CUNY). My research is centered on techniques for automated software evolution, particularly those related to automated refactoring and source code recommendation systems. My goal is to ease the burden associated with correctly and efficiently evolving large and complex software by providing automated tools that can be easily used by developers. I am also interested in the automated analysis of Object-Oriented programs. 
I received my MS and Ph.D. degrees in Computer Science from Ohio State University and my BS degree in Computer Science from Monmouth University in New Jersey. Prior to joining CUNY, I was a Software Engineer at Apple, Inc. in Cupertino, California, where I worked on Digital Rights Management (DRM) for iTunes, iBooks, and the App Store. I also developed distributed software that tested various features of iPhones, iPads, and iPods. You may also find more information about me by visiting my CUNY Academic Commons profile, my vita, GitHub, and my blog (you can subscribe for updates here).</bio>
        <homepage_url>http://cs.hunter.cuny.edu/~Raffi.Khatchadourian99</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/raffikhatchadourian/5c884f46-e4aa-4dc5-b581-2e37f77d320a/small.jpg</picture_url>
        <person_id>raffikhatchadourian</person_id>
      </person>
      <person>
        <role>Student Research Competition Co-Chair in Organizing Committee</role>
        <sort_key>19</sort_key>
        <first_name>Julia</first_name>
        <last_name>Rubin</last_name>
        <affiliation>University of British Columbia</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.ece.ubc.ca/~mjulia/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/juliarubin/5846079d-0c90-4d9a-8f16-eef07002e37d/small.jpg</picture_url>
        <person_id>juliarubin</person_id>
      </person>
      <person>
        <role>Student Research Competition Co-Chair in Organizing Committee</role>
        <sort_key>20</sort_key>
        <first_name>Caterina</first_name>
        <last_name>Urban</last_name>
        <affiliation>INRIA &amp; École Normale Supérieure | Université PSL</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://caterinaurban.github.io</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/caterinaurban1/a945f9bd-bc13-4fe2-945a-59528d7d7e2a/small.jpg</picture_url>
        <person_id>caterinaurban1</person_id>
      </person>
      <person>
        <role>Publicity Chair in Organizing Committee</role>
        <sort_key>21</sort_key>
        <first_name>Juan</first_name>
        <last_name>Fumero</last_name>
        <affiliation>University of Manchester, UK</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://jjfumero.github.io</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/juanfumero/e76896d1-7e40-4e77-859f-dc51392013a2/small.jpg</picture_url>
        <person_id>juanfumero</person_id>
      </person>
      <person>
        <role>Web Chair in Organizing Committee</role>
        <sort_key>22</sort_key>
        <first_name>Rangeet</first_name>
        <last_name>Pan</last_name>
        <affiliation>Iowa State University, USA</affiliation>
        <bio>Rangeet Pan is a Ph.D. candidate at Iowa State University. His research interests include program analysis, machine learning, and software engineering. He has published works at ESEC/FSE and ICSE.</bio>
        <homepage_url>https://rangeetpan.github.io/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/rangeetpan/3f0551cd-7e73-4053-bb36-66f8d05daae5/small.jpg</picture_url>
        <person_id>rangeetpan</person_id>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>23</sort_key>
        <first_name>Breno</first_name>
        <last_name>Dantas Cruz</last_name>
        <affiliation>Virginia Tech</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://people.cs.vt.edu/~bdantasc/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/brenodantascruz/7407f1b4-cf3d-4a2e-8c5e-3a49f0405e8f/small.jpg</picture_url>
        <person_id>brenodantascruz</person_id>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>24</sort_key>
        <first_name>Samantha Syeda</first_name>
        <last_name>Khairunnesa</last_name>
        <affiliation>Florida Gulf Coast University</affiliation>
        <bio>Samantha Syeda Khairunnesa, Ph.D., is the Assistant Professor in the Department of Software Engineering at Florida Gulf Coast University, where she has been since August 2021. She earned her Ph.D. in Computer Science from Iowa State University in August 2021. She specializes in software engineering, programming languages, and machine learning.</bio>
        <homepage_url>https://www.linkedin.com/in/samantha-syeda/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/samanthasyedakhairunnesa/23aa8334-ebf0-4967-b8ab-6d4cbf1509c5/small.jpg</picture_url>
        <person_id>samanthasyedakhairunnesa</person_id>
      </person>
      <person>
        <role>Sponsorship Co-Chair in Organizing Committee</role>
        <sort_key>25</sort_key>
        <first_name>Ganesha</first_name>
        <last_name>Upadhyaya</last_name>
        <affiliation>Harmony.one</affiliation>
        <bio>I am currently a Research Engineer at Harmony.one, Mountain View, CA. I work on blockchain network, protocol, and smart contract verification. Previously, I was a Senior Staff Researcher at Futurewei Technologies (Huawei R&amp;amp;D), Champaign, IL, where I worked on researching and developing compiler, runtime, and frameworks for Huawei’s mobile, cloud, and IoT solutions. In addition, impactful software engineering research has always been my passion.</bio>
        <homepage_url>http://web.cs.iastate.edu/~ganeshau/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/ganeshaupadhyaya/e4cda76a-77e7-4064-a67e-a85da0616702/small.jpg</picture_url>
        <person_id>ganeshaupadhyaya</person_id>
      </person>
      <person>
        <role>Poster Co-Chair in Organizing Committee</role>
        <sort_key>26</sort_key>
        <first_name>Christos</first_name>
        <last_name>Dimoulas</last_name>
        <affiliation>PLT @ Northwestern University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://users.eecs.northwestern.edu/~chrdimo/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/christosdimoulas1/b0a0a408-c992-49cf-99f4-39e30fe9ce1d/small.jpg</picture_url>
        <person_id>christosdimoulas1</person_id>
      </person>
      <person>
        <role>Poster Co-Chair in Organizing Committee</role>
        <sort_key>27</sort_key>
        <first_name>Murali</first_name>
        <last_name>Krishna Ramanathan</last_name>
        <affiliation>Uber Technologies Inc.</affiliation>
        <bio>Murali Krishna Ramanathan is a Staff Software Engineer at Uber Technologies Inc. Previously, he was affiliated with IISc, Bangalore and Coverity Inc. He has designed and implemented several novel program analysis tools for detecting software bugs. He received his PhD in Computer Science from Purdue University.</bio>
        <homepage_url>https://sites.google.com/view/mkramanathan/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/muralikrishnaramanathan/52304999-046a-4d35-a2ed-9eb9ca2db709/small.jpg</picture_url>
        <person_id>muralikrishnaramanathan</person_id>
      </person>
      <person>
        <role>Publications Chair in Organizing Committee</role>
        <sort_key>28</sort_key>
        <first_name>Saba</first_name>
        <last_name>Alimadadi</last_name>
        <affiliation>Simon Fraser University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://ece.ubc.ca/~saba/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/sabaalimadadi/fb15cf5f-b2f9-4ff5-84d1-1b5aa9be2378/small.jpg</picture_url>
        <person_id>sabaalimadadi</person_id>
      </person>
      <person>
        <role>Artifact Evaluation Co-Chair in Organizing Committee</role>
        <sort_key>29</sort_key>
        <first_name>Colin</first_name>
        <last_name>Gordon</last_name>
        <affiliation>Drexel University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
        <person_id>colingordon</person_id>
      </person>
      <person>
        <role>Artifact Evaluation Co-Chair in Organizing Committee</role>
        <sort_key>30</sort_key>
        <first_name>Ana</first_name>
        <last_name>Milanova</last_name>
        <affiliation>Rensselaer Polytechnic Institute</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.rpi.edu/~milanova/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/anamilanova/4fa9038c-d0e6-44ca-b1b7-2420329714f4/small.jpg</picture_url>
        <person_id>anamilanova</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee, Artifact Evaluation Co-Chair in Organizing Committee</role>
        <sort_key>31</sort_key>
        <first_name>Anders</first_name>
        <last_name>Møller</last_name>
        <affiliation>Aarhus University</affiliation>
        <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
        <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
        <person_id>andersmoller</person_id>
      </person>
      <person>
        <role>Accessibility Chair in Organizing Committee</role>
        <sort_key>32</sort_key>
        <first_name>Sumon</first_name>
        <last_name>Biswas</last_name>
        <affiliation>Iowa State University, USA</affiliation>
        <bio>Sumon Biswas is a Ph.D. candidate of Computer&amp;nbsp;Science department at Iowa State University and Research Assistant at Laboratory of Software Design at ISU under the supervision of Hridesh Rajan. His research interests are in the blend of Data Science, Software Engineering, and Programming languages. He has worked on large scale data science program analysis using the Boa framework. He worked on building Python language support for Boa to analyze machine learning programs.&amp;nbsp;Currently, he is&amp;nbsp;working in the&amp;nbsp;D4 (Dependable Data-Driven Discovery) project and focusing on increasing the dependability of data-driven software. Specifically, he is conducting research on improving the fairness of machine learning models.</bio>
        <homepage_url>http://www.cs.iastate.edu/~sumon/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/sumonbiswas/7a793cc7-0e7e-4dca-8729-e35e8f495ff8/small.jpg</picture_url>
        <person_id>sumonbiswas</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>33</sort_key>
        <first_name>Jeffrey S.</first_name>
        <last_name>Foster</last_name>
        <affiliation>Tufts University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.cs.tufts.edu/~jfoster/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/jeffreysfoster/b22ce952-32b0-48bd-be56-12fd87bf3469/small.jpg</picture_url>
        <person_id>jeffreysfoster</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>34</sort_key>
        <first_name>Elisa</first_name>
        <last_name>Gonzalez Boix</last_name>
        <affiliation>Vrije Universiteit Brussel</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/elisagonzalezboix/51a3d0ba-7330-40d4-ad16-4568d31fe2e4/small.jpg</picture_url>
        <person_id>elisagonzalezboix</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>35</sort_key>
        <first_name>David</first_name>
        <last_name>Grove</last_name>
        <affiliation>IBM Research</affiliation>
        <bio>I am a Distinguished Research Staff Member at the IBM T.J. Watson Research Center. I joined IBM Research in 1998 after completing my PhD at the University of Washington. I am a software systems researcher, working primarily on problems in programming language implementation and scalable runtime systems. 
I have contributed to a number of technical topics in programming language design and implementation including the analysis and optimization of object-oriented languages, virtual machine design and implementation, scalable runtime systems, Just-In-Time compilation, online feedback-directed optimization, and garbage collection.</bio>
        <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-groved</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/davidgrove/5524049e-7d0a-4799-ad8c-93e1e76a77ec/small.jpg</picture_url>
        <person_id>davidgrove</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>36</sort_key>
        <first_name>Tony</first_name>
        <last_name>Hosking</last_name>
        <affiliation>Australian National University</affiliation>
        <bio>I am Professor and Director of the School of Computing at the Australian National University. I previously spent 22 years on the faculty at Purdue University. I studied computer science at the University of Adelaide, the University of Waikato, and the University of Massachusetts at Amherst, receiving BSc, MSc, and PhD degrees, respectively. My research interests lie in the area of programming language implementation, and I work on problems arising in object persistence, object databases, distribution, memory management (garbage collection), managed language runtimes, language virtual machines, optimizing compilers, and architectural support for programming languages and applications. 
I am a Life Member of the Association for Computing Machinery and a Member of the IEEE. I was named a Distinguished Scientist of the ACM in 2012.</bio>
        <homepage_url>https://hosking.github.io</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/tonyhosking/6d43d7a0-6e7b-47fe-8081-e4ae5207cda1/small.jpg</picture_url>
        <person_id>tonyhosking</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>37</sort_key>
        <first_name>Stephen</first_name>
        <last_name>Kell</last_name>
        <affiliation>King's College London</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cl.cam.ac.uk/users/srk31</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/stephenkell/53088184-3e8c-4a2c-b34f-b2a290cff411/small.jpg</picture_url>
        <person_id>stephenkell</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>38</sort_key>
        <first_name>Hidehiko</first_name>
        <last_name>Masuhara</last_name>
        <affiliation>Tokyo Institute of Technology</affiliation>
        <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
        <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
        <person_id>hidehikomasuhara</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>39</sort_key>
        <first_name>Yannis</first_name>
        <last_name>Smaragdakis</last_name>
        <affiliation>University of Athens</affiliation>
        <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
        <homepage_url>http://smaragd.org/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
        <person_id>yannissmaragdakis</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>40</sort_key>
        <first_name>Manu</first_name>
        <last_name>Sridharan</last_name>
        <affiliation>University of California at Riverside</affiliation>
        <bio>I’m an associate professor at the University of California, Riverside. Previously I worked at IBM Research, Samsung Research, and Uber. My research focuses on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
        <homepage_url>http://manu.sridharan.net</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
        <person_id>manusridharan</person_id>
      </person>
      <person>
        <role>SIGPLAN Conference Manager in Organizing Committee</role>
        <sort_key>41</sort_key>
        <first_name>Neringa</first_name>
        <last_name>Young</last_name>
        <affiliation>undefined</affiliation>
        <bio>undefined</bio>
        <picture_url>https://2021.splashcon.org/getProfileImage/neringayoung/76e430ed-594f-431f-83fe-5bc632116ade/small.jpg</picture_url>
        <person_id>neringayoung</person_id>
      </person>
    </persons>
  </event_details>
  <subevent>
    <subevent_id>ffeff4fb-27ad-43d0-ad2f-7459bc63f9d2</subevent_id>
    <title>SPLASH Student Research Competition: Talks</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>01e77226-c057-4ed6-8faf-03a8abc3985a</slot_id>
      <title>Session: SPLASH Student Research Competition - Talks</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>80ee839a-be36-4bc7-b409-d4421a727a4d</subevent_id>
    <title>SPLASH Student Research Competition: Posters</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>838483d2-4d30-40b4-965c-e2bf63232760</slot_id>
      <title>Session: SPLASH Student Research Competition - Posters</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2b32721e-1c4c-4e71-8e8e-d9db3466a025</slot_id>
      <event_id>85c599e1-d96a-411f-a451-b415c2a66022</event_id>
      <title>Implementation of an End-to-End Gradual Verification System</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>Static verification is used to ensure the correctness of programs. While useful in critical applications, the high overhead associated with writing specifications limits its general applicability. Similarly, the run-time costs introduced by dynamic verification limit its practicality. Gradual verification validates partially-specified code statically where possible and dynamically where necessary. As a result, software developers gain granular control over the trade-offs between static and dynamic verification. This paper contains an end-to-end presentation of gradual verification in action, with a focus on implementing the required dynamic verification and applying it to C0, a safe subset of C.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hemant</first_name>
          <last_name>Gouni</last_name>
          <affiliation>University of Minnesota, Twin Cities</affiliation>
          <bio>undefined</bio>
          <person_id>hemantgouni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Conrad</first_name>
          <last_name>Zimmerman</last_name>
          <affiliation>Brown University</affiliation>
          <bio>undefined</bio>
          <person_id>conradzimmerman</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>406d7711-ca24-4a8d-81d9-beb408639ee8</slot_id>
      <event_id>4110f3c6-8b43-4fd9-be43-e418a341f9f8</event_id>
      <title>Towards Decidable and Expressive DOT</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>Dependent Object Types (DOT) allows mostly object oriented languages to bring in functional features and the higher expressivity of bounds on types. However, this increase in expressivity leads to DOT systems being undecidable. While decidability may be a reasonable sacrifice to make in exchange for greatly increased expressivity, having a type checker that is guaranteed to terminate while maintaining a high degree of expressivity can be beneficial. Over the last few years there have been several papers and theses written describing decidable variants of DOT. Julian Mackay et al. present one such decidable variant in their 2020 paper. Yu Xiang Zhu presents another variant in his 2019 masters thesis describing Nominal Wyvern, a variant of the DOT based programming language Wyvern. Most practical languages use nominality for recursive types which comes with benefits such as more local error messages. Due to this, we chose to focus on increasing the expressivity of Zhu’s variant for this paper. However, both Zhu’s and Mackay’s variants present the same challenges in limitations on expressivity.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Roshal</last_name>
          <affiliation>Cornell University, Carnegie Mellon University (Institute for Software Research)</affiliation>
          <bio>undefined</bio>
          <person_id>sophiaroshal</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>55b5ee6b-e8eb-4616-9c07-34ef958ee644</slot_id>
      <event_id>5306e012-55f6-46a1-9f31-2383635e4404</event_id>
      <title>Programming-By-Example by Programming-By-Example: Synthesis of Looping Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shmuel</first_name>
          <last_name>Berman</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>shmuelberman</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5a2ab465-ae05-48a0-bb60-4b3ce8303b97</slot_id>
      <event_id>13cee821-35d0-46ba-9ddb-745a1cc31c4f</event_id>
      <title>Avoiding Monomorphization Bottlenecks with Phase-based Splitting</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>State-of-the-art managed runtimes apply aggressive optimizations often based on the speculative assumption that programs have low variability. However, the behaviour of programs may evolve over time and literature shows that programs are likely to experience different execution “phases”, i.e. intervals of time displaying an homogeneous behaviour. Taking such phases into account may further improve performance when applied to phase-sensitive optimizations such as lookup caches, that may contain entries that are phase-specific. In this paper, we introduce Phase-based splitting, an experimental compiler optimization that utilizes phase insight to guide monomorphization based on splitting. Preliminary results show speedups ranging from 10 to 20% on average, peaking up to 47.6% at phase granularity.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sophie</first_name>
          <last_name>Kaleba</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/sophiekaleba/83d4bbee-60e2-41f8-a354-707df6642dc8/small.jpg</picture_url>
          <person_id>sophiekaleba</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>66f03b4a-6dc9-4ed9-b7ec-d8b551c8fdba</slot_id>
      <event_id>5fc3df79-877d-49fa-92b9-8769711d1edd</event_id>
      <title>A Study of Call Graph Effectiveness for Framework-Based Web Applications</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>The world of modern web applications is continuously evolving and getting increasingly reliant on web frameworks to support their ever-changing fast-paced needs. This necessitates the realization of efficient static analysis methodologies for the purpose of bug finding and security auditing of such applications. Moreover, the majority of these frameworks are written in JavaScript, which itself is difficult to analyze due to its extremely dynamic nature. The primary goal of this work is to study the effectiveness of the present state-of-the-art call graph approaches for JavaScript and propose techniques to enhance them such that they discover more of the crucial functions and call edges in modern, framework-based JavaScript applications. Ideally, these new techniques must enhance function and call edge discovery without much impact on precision and scalability.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Madhurima</first_name>
          <last_name>Chakraborty</last_name>
          <affiliation>University of California, Riverside</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://madhunimmo.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/madhurimachakraborty/6a31660c-02b2-4256-94df-762aeabdba7f/small.jpg</picture_url>
          <person_id>madhurimachakraborty</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>98481755-1bf2-40c0-ac31-c5dc01990efe</slot_id>
      <event_id>38f57d62-8fe7-4f69-9ae2-b60fe02f0ad1</event_id>
      <title>Run-time Data Analysis to Drive Compiler Optimizations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>Throughout program execution, types may stabilize, variables may become constant, and code sections may turn out to be redundant - all information that is used by just-in-time (JIT) compilers to achieve peak performance. Yet, since JIT compilation is done on demand for individual code parts, global observations cannot be made. Global data analysis, however, is an inherently expensive process, that collects information over large data sets. Thus, it is infeasible in dynamic compilers. With this project, we propose integrating data analysis into a state-of-the-art runtime. The goal is to gather detailed run-time information for compiler optimizations to improve performance of data-heavy applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Kloibhofer</last_name>
          <affiliation>Johannes Kepler Universität Linz</affiliation>
          <bio>undefined</bio>
          <person_id>sebastiankloibhofer</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9c57926a-dbfd-4f2d-b370-6bd0cde7f69a</slot_id>
      <event_id>998d65ae-c201-476d-b518-fa20289ff193</event_id>
      <title>Edgeworth: Authoring Diagrammatic Math Problems Using Program Mutation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>Building connections between mathematical expressions and their visual representations increases conceptual understanding and flexibility. However, students rarely practice visualizing abstract mathematical relationships because developing diagrammatic problems is challenging, especially at scale. To address this issue, we introduce Edgeworth, a system that automatically generates correct and incorrect diagrams for a given question prompt. It does so by mutating declarative mathematical statements with visual semantics. We evaluated the system by recreating diagrammatic problems in a widely used geometry textbook.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hwei-Shin</first_name>
          <last_name>Harriman</last_name>
          <affiliation>Olin College of Engineering</affiliation>
          <bio>undefined</bio>
          <person_id>hweishinharriman</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4af227a-3025-4b38-a96c-103982c56bab</slot_id>
      <event_id>6f1bf3e5-2648-40c9-bf8a-ecb1e8f88b89</event_id>
      <title>Source code authorship attribution using file embeddings</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>The problem of source code authorship attribution is crucial nowadays for a few reasons. Security and legal issues are the most popular ones. However, this domain could also help to understand the nature of the personal code style. This type of information could be used, for instance, by IDEs to improve the developer’s experience of writing the code. The goal of this study is to construct an interpretable model for source code embeddings generation. Such embeddings should represent the correspondence of the source code to its author.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alina</first_name>
          <last_name>Bogdanova</last_name>
          <affiliation>Innopolis University</affiliation>
          <bio>undefined</bio>
          <person_id>alinabogdanova</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d485d4ce-7d4d-4b72-a2fc-fa7a24049e03</slot_id>
      <event_id>15828cbf-e1ac-4b4b-b10a-bee0b57e8722</event_id>
      <title>Run-Time Data Analysis in Dynamic Runtimes</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>Databases are typically faster in processing huge amounts of data than applications with hand-coded data access. Even though modern dynamic runtimes optimize applications intensively, they cannot perform certain optimizations that are traditionally used by database systems as they lack the required information. Thus, we propose to extend the capabilities of dynamic runtimes to allow them to collect fine-grained information of the processed data at run time and use it to perform database-like optimizations. By doing so, we want to enable dynamic runtimes to significantly boost the performance of data-processing workloads. Ideally, applications should be as fast as databases in data-processing workloads by detecting the data schema at run time. To show the feasibility of our approach, we are implementing it in a polyglot dynamic runtime.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Makor</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>undefined</bio>
          <person_id>lukasmakor</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dc581899-3e64-4567-a79a-a5e4f7a55e99</slot_id>
      <event_id>6aeadcaa-c6a6-49e9-8e8e-c953e4b1b001</event_id>
      <title>Can Reactive Synthesis and Syntax-Guided Synthesis Be Friends?</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wonhyuk</first_name>
          <last_name>Choi</last_name>
          <affiliation>Columbia University</affiliation>
          <bio>undefined</bio>
          <person_id>wonhyukchoi</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e81627dd-cd12-4947-afc6-8153f78bd262</subevent_id>
    <title>APLAS Keynote Talks: Invited talk 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-keynote-talks</url>
    <url_link_display>Keynote Talks</url_link_display>
    <tracks>
      <track>Keynote Talks</track>
    </tracks>
    <timeslot>
      <slot_id>fd4000f1-97ad-4e99-8dc2-24e282234796</slot_id>
      <title>Session: APLAS Keynote Talks - Invited talk 1</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0473613e-5217-489b-ab39-1177c0572288</slot_id>
      <event_id>dcfc0f60-1f4f-4dfa-bbaf-2da4274d67cc</event_id>
      <title> Solidifying and Advancing the Software Foundations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:00</end_time>
      <description>Software applications and technologies are built on top of foundational systems such as compilers, databases, and theorem provers. Such foundations form the trusted computing base, and fundamentally impact software quality and security. Thus, it is a critical challenge to solidify and advance them. This talk highlights general, effective techniques, and extensive, impactful efforts on finding hundreds of critical issues in widely-used compilers, database management systems, and SMT solvers. It focuses on the high-level principles and core techniques, their significant practical successes, and future opportunities and challenges.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>913de949-78af-49a7-b2ad-69c992004fb8</subevent_id>
    <title>REBLS: Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/rebls-2021</url>
    <url_link_display>REBLS 2021</url_link_display>
    <tracks>
      <track>REBLS 2021</track>
    </tracks>
    <timeslot>
      <slot_id>74712798-c714-45a7-abcf-0962daab4140</slot_id>
      <title>Session: REBLS - Session 1</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>494a0338-2ed1-43fd-be01-ebb5c0e1664b</slot_id>
      <event_id>9f274b48-fc19-4a0f-89ac-6f96fadd6cfc</event_id>
      <title>Poker: Visual Instrumentation of Reactive Programs With Programmable Probes</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>11:15</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:40</end_time>
      <description>This paper presents Poker, a visual instrumentation platform for reactive programs. Similar to other platforms, Poker features a visual dashboard that allows the programmer to inspect the flow of values through the reactive program. The novelty of Poker is that: (a) It features a canvas of so-called that can be dynamically wired into a running reactive program in order to instrument the running system. (b) In addition to focusing on the values flowing through the program, every probe measures a particular property about the way these values flow through the instrumented program. (c) The set of probes is open because a probe is programmed in the same language as the instrumented program. Poker is implemented for Stella, an experimental reactive programming language. The paper uses an application written in Stella to motivate the concepts provided by Poker. We show 4 different probes that help us understand the behaviour of the application and we measure the overhead of using Poker on the running application with some preliminary benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cloé</first_name>
          <last_name>Descheemaeker</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>cloedescheemaeker</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Van den Vonder</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>PhD candidate at the Software Languages Lab of the Vrije Universiteit Brussel.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/samvandenvonder/2ccd1dd4-a774-4f8b-b2a1-c601a5adc3d5/small.jpg</picture_url>
          <person_id>samvandenvonder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Thierry</first_name>
          <last_name>Renaux</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>thierryrenaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wolfgangdemeuter/cb721b79-a1aa-4583-8ba0-b1a96f896900/small.jpg</picture_url>
          <person_id>wolfgangdemeuter</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a07c40de-6341-4b47-aac2-875a4c72d7e2</slot_id>
      <event_id>32135946-a6f3-4412-9c05-a2dde9cdaf7b</event_id>
      <title>Dyninka: a FaaS framework for distributed dataflow applications</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:15</end_time>
      <description>The Internet of Things (IoT) requires applications to deal with a large amount of data - streamed, processed and stored from small devices to analytical systems. Cloud computing offers a hardware solution to this issue, providing on-demand resources to process IoT data. The newer programming paradigms simplify the use of those cloud resources. The Function-as-a-Service (FaaS) and the Serverless paradigm transformed the conception of micro-services applications to the definition and the composition of several callable functions. Although defined as a distributed architectures - mostly publicly available, solutions rely on either a gateway or an internal messaging middleware. These architectures create a single point of failure in exchange for more straightforward service to service communication. 
In this article, we present Dyninka, a framework to prototype FaaS-based distributed dataflow applications rapidly. Its programming model gathers the definition and the composition of services within a single file using the multitier-programming paradigm and compile into a multitude of services deployable on cloud computing infrastructure. Dyninka is built without a gateway or a messaging platform, and services communicate directly with each other or with the cloud abstracted infrastructure. As a consequence, we reduce the network and the computation overheads introduced by a framework. 
We validate Dyninka on a Fog computing scenario with limited resources and several load profiles. For all scenarios, Dyninka shows better stability, throughput and a reduced overhead compared to OpenFaaS.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Patrik</first_name>
          <last_name>Fortier</last_name>
          <affiliation>INSA Lyon</affiliation>
          <bio>undefined</bio>
          <person_id>patrikfortier</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Frédéric</first_name>
          <last_name>Le Mouël</last_name>
          <affiliation>INSA Lyon</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.le-mouel.net/</homepage_url>
          <person_id>fredericlemouel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Julien</first_name>
          <last_name>Ponge</last_name>
          <affiliation>Red Hat, Inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://julien.ponge.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/julienponge/52b328af-ff03-4e73-b071-42f8c4746373/small.jpg</picture_url>
          <person_id>julienponge</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bc9dd765-2b32-4532-a711-cea8cbd1f3c6</slot_id>
      <event_id>d91c021e-ca9f-4737-a191-f495d678c16f</event_id>
      <title>ShapeRank: Rank Polymorphism meets Reactive Streams</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>11:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>12:05</end_time>
      <description>ShapeRank is a statically typed, functional programming lan- guage designed for machine learning, data analytics and re- active programming. All ShapeRank values are multidimen- sional streams, known as hyperstreams, and all operations are automatically lifted to process hyperstreams in parallel. This lifting originates in the APL language family, and is known as rank polymorphism. ShapeRank extends rank polymorphism to hyperstreams. ShapeRank functions may be either synchronous or reactive. We introduce ShapeRank with a focus on its reactive behavior. 
**This is an in-progress paper **</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gilad</first_name>
          <last_name>Bracha</last_name>
          <affiliation>g.bracha@f5.com</affiliation>
          <bio>undefined</bio>
          <person_id>giladbracha1</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7afb2ab2-bed2-4898-a76b-20e9b44284df</subevent_id>
    <title>Scala: Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/17</date>
    <url>https://2021.splashcon.org/home/scala-2021</url>
    <url_link_display>12th ACM SIGPLAN Scala Symposium</url_link_display>
    <tracks>
      <track>12th ACM SIGPLAN Scala Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>9af66b7d-41f7-48f1-bc46-1fc55a748329</slot_id>
      <title>Session: Scala - Session 2</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>12th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9dc665e5-ddc5-4320-a9d6-959a0e15687a</slot_id>
      <event_id>833739da-488f-4958-8e24-1cfc764eb0df</event_id>
      <title>Safe Object Initialization, Abstractly</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/17</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>12:10</end_time>
      <description>Objects under initialization are fragile: some of their fields are not yet initialized. Consequently, accessing those uninitialized fields directly or indirectly may result in program crashes or abnormal behaviors at runtime. 
A newly created object goes through several states during its initialization, beginning with all fields being empty until all of them are filled. Therefore, accessing the field of an object has to respect its initialization \emph{typestate}. The problem of safe initialization of objects is in essence a typestate safety problem. However, ensuring typestate safety statically, without manual annotation of typestates in the source code, is a challenge, due to \emph{aliasing}, \emph{virtual method calls} and \emph{typestate polymorphism}. 
In this work, we introduce a novel analysis based on abstract interpreters. Compared to the previous approaches, our analysis is simpler and easier to extend, and it does not require any user annotations. The analysis is inter-procedural and context-sensitive, yet it has good performance thanks to \emph{local reasoning} and \emph{heap monotonicity}.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fengyun</first_name>
          <last_name>Liu</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/fengyunliu/0d2f6c57-4b56-43e2-8cdb-c53e0e55c7d8/small.jpg</picture_url>
          <person_id>fengyunliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Enze</first_name>
          <last_name>Xing</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>enzexing</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Nguyen Cao</first_name>
          <last_name>Pham</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>nguyencaopham</person_id>
        </person>
      </persons>
      <tracks>
        <track>12th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ba96c59d-b3cd-4d48-ad08-0f628d83031a</slot_id>
      <event_id>5c5bc51e-5c3c-441b-9977-da321fdfa3a2</event_id>
      <title>Implementing Path-Dependent GADT Reasoning for Scala 3</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:30</end_time>
      <description>Generalized Algebraic Data Types (GADT) are a popular programming language feature allowing advanced type-level properties to be encoded in the data types of a program. While Scala does not have direct support for them, GADT definitions can be encoded through Scala class hierarchies. Moreover, the Scala 3 compiler recently augmented its pattern matching capabilities to reason about such class hierarchies, making GADT-based programming practical in Scala. However, the current implementation can only reason about type parameters, but Scala’s type system also features singleton types and abstract type members (collectively known as path-dependent types), about which GADT-style reasoning is also useful and important. In this paper, we show how we extended the existing constraint-based GADT reasoning of the Scala 3 compiler to also consider path-dependent types, making Scala’s support for GADT programming complete and also bringing Scala closer to its formal foundations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yichen</first_name>
          <last_name>Xu</last_name>
          <affiliation>Beijing University of Posts and Telecommunications</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yichenxu.me</homepage_url>
          <person_id>yichenxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aleksander</first_name>
          <last_name>Boruch-Gruszecki</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <person_id>aleksanderboruchgruszecki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lionel</first_name>
          <last_name>Parreaux</last_name>
          <affiliation>HKUST</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cse.ust.hk/admin/people/faculty/profile/parreaux</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lionelparreaux/292d178a-af9d-419f-9e04-8a4672226fd5/small.jpg</picture_url>
          <person_id>lionelparreaux</person_id>
        </person>
      </persons>
      <tracks>
        <track>12th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a916e16b-7033-4301-88be-2b4a6bbb841c</subevent_id>
    <title>REBLS: Session 3</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/rebls-2021</url>
    <url_link_display>REBLS 2021</url_link_display>
    <tracks>
      <track>REBLS 2021</track>
    </tracks>
    <timeslot>
      <slot_id>7366778b-9f42-4184-95a8-ea704951c2dc</slot_id>
      <title>Session: REBLS - Session 3</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bd594d43-6bbf-4fa1-beb5-07aa9a867d7c</subevent_id>
    <title>VMIL: Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/vmil-2021</url>
    <url_link_display>VMIL 2021</url_link_display>
    <tracks>
      <track>VMIL 2021</track>
    </tracks>
    <timeslot>
      <slot_id>5ba01411-dfd0-4804-941b-520ad6daec2d</slot_id>
      <title>Session: VMIL - Session 2</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e3de60e-12d0-433a-ba9e-8ccc6cbd6df3</slot_id>
      <event_id>bec8bc68-e3ec-4d09-9050-50a3eef31f8b</event_id>
      <title>A Small Scheme VM, Compiler and REPL in 4K</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>11:16</end_time>
      <description>Compact language implementations are increasingly popular for use in resource constrained environments. For embedded applications such as robotics and home automation, it is useful to support a Read-Eval-Print-Loop (REPL) so that a basic level of interactive development is possible directly on the device. Due to its minimalistic design the Scheme language is particularly well suited for such applications and several implementations are available with different tradeoffs. In this paper we explain the design and implementation of a compact Scheme system that supports a REPL, is extensible and has a 4 KB executable code footprint.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Samuel</first_name>
          <last_name>Yvon</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>samuelyvon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marc</first_name>
          <last_name>Feeley</last_name>
          <affiliation>Université de Montréal</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iro.umontreal.ca/~feeley</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marcfeeley/2c882fdf-a3a8-4bbf-9e03-75b3d7d08909/small.jpg</picture_url>
          <person_id>marcfeeley</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c90dbc8c-e6b4-431e-8269-486eebe63a79</slot_id>
      <event_id>da0e5d77-5b53-4cb1-803d-2e6ca0f3a839</event_id>
      <title>Lightweight On-Stack Replacement in Languages with Unstructured Loops</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>11:16</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>11:43</end_time>
      <description>On-stack replacement (OSR) is a popular technique used by just in time (JIT) compilers. A JIT can use OSR to transfer from interpreted to compiled code in the middle of execution, immediately reaping the performance benefits of compilation. This technique typically relies on loop counters, so it cannot be easily applied to languages with unstructured control flow. It is possible to reconstruct the high-level loop structures of an unstructured language using a control flow analysis, but such an analysis can be complicated, expensive, and language-specific. In this paper, we present a more lightweight strategy for OSR in unstructured languages which relies only on detecting backward jumps. We design a simple, language-agnostic API around this strategy for language interpreters. We then discuss our implementation of the API in the Truffle framework, and the design choices we made to make it efficient and correct. In our evaluation, we integrate the API with Truffle’s LLVM bitcode interpreter, and find the technique is effective at improving start-up performance without harming warmed-up performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matt</first_name>
          <last_name>D'Souza</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>mattdsouza</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Gilles</first_name>
          <last_name>Duboscq</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/gillesduboscq/cfc3738c-9767-42e8-83d6-43eb891c50b9/small.jpg</picture_url>
          <person_id>gillesduboscq</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f9f8157c-71d1-4210-97ec-d447a8e01ca9</slot_id>
      <event_id>537c6354-c7c4-4b1c-991d-d7c64697a75d</event_id>
      <title>WOOD: Extending a WebAssembly VM with Out-of-Place Debugging for IoT applications</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>11:43</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>12:10</end_time>
      <description>Internet of Things (IoT) enables collaboration between humans and a diverse range of machines, including embedded devices and sensors. Software development of IoT applications is challenging given the distributed nature of the applications and the limited resources of some devices. This paper focuses on an extension to the WARDuino IoT platform that enhances debugging support, an integral part of the software development cycle. 
Popular offline debugging techniques such as logs, dumps, or record &amp;amp; replay are not suitable for IoT devices as they impose too much overhead on devices and often miss contextual information on the root cause of bugs. Online debuggers seem more suitable for IoT since they enable developers to remotely debug devices, but suffer from the probe-effect, non-reproducibility issues and high latency. 
In this paper, we explore an online debugging approach that deals with the constraints of IoT devices and enables low latency remote debugging. To this end, we bring ideas of out-of-place debugging, in which the state of a running application is moved to the developer’s machine, to IoT. We implement our out-of-place debugging approach for IoT in WOOD, an extension to the WARDuino VM that executes Web Assembly on embedded devices. The paper focuses on WOOD’s features including capturing, moving and reconstructing debugging sessions, as well as support for accessing remote resources and live code updating.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Carlos Javier</first_name>
          <last_name>Rojas Castillo</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>carlosjavierrojascastillo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Marra</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>I am a pre-doctoral researcher at the Vrije Universiteit Brussel (Belgium). After completing my bachelor studies in Italy (Università degli studi di Bologna), I moved to Brussels for a master at the Vrije Universiteit Brussel, in the Software Languages Lab, and decided to start a PhD under the guide of prof. Elisa Gonzalez Boix. I also cooperate with the RMoD research group at INRIA Lille Nord-Europe. 
My research focuses on debugging concurrent and parallel applications, particularly Big Data (or data intensive) applications.</bio>
          <homepage_url>https://soft.vub.ac.be/~mmarra</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/matteomarra/71e5312b-940b-4349-afaf-fa0a934b2c49/small.jpg</picture_url>
          <person_id>matteomarra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jim</first_name>
          <last_name>Bauwens</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jimbauwens/37b45fc6-5385-45e2-8dba-cfe6fb3399cd/small.jpg</picture_url>
          <person_id>jimbauwens</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Gonzalez Boix</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/elisagonzalezboix/51a3d0ba-7330-40d4-ad16-4568d31fe2e4/small.jpg</picture_url>
          <person_id>elisagonzalezboix</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>67c69020-2f94-437e-b6b8-b7081652895c</subevent_id>
    <title>APLAS Keynote Talks: Invited talk 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-keynote-talks</url>
    <url_link_display>Keynote Talks</url_link_display>
    <tracks>
      <track>Keynote Talks</track>
    </tracks>
    <timeslot>
      <slot_id>129055a2-6d77-46ce-ac35-4f657d8226dc</slot_id>
      <title>Session: APLAS Keynote Talks - Invited talk 2</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3d9800fa-a4f4-4f43-a55d-9b9fdd069c83</slot_id>
      <event_id>181db6e0-3cfe-45c3-98cd-f72b64ec7f58</event_id>
      <title>A Separation Logic for Probabilistic Independence</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>18:00</end_time>
      <description>Probabilistic independence is a useful concept for describing the result of random sampling—a basic operation in all probabilistic languages—and for reasoning about groups of random variables. Nevertheless, existing verification methods handle independence poorly, if at all. We propose a probabilistic separation logic PSL, where separation models probabilistic independence, based on a new, probabilistic model of the logic of bunched implications (BI). The program logic PSL is capable of verifying information-theoretic security of cryptographic constructions for several well-known tasks, including private information retrieval, oblivious transfer, secure multi-party addition, and simple oblivious RAM, while reasoning purely in terms of independence and uniformity. If time permits, we will also discuss ongoing work for reasoning about conditional independence.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Justin</first_name>
          <last_name>Hsu</last_name>
          <affiliation>University of Wisconsin-Madison, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.justinh.su</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/justinhsu/a2c25b60-0dc3-48ad-a41d-238071e3fbab/small.jpg</picture_url>
          <person_id>justinhsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3b54915c-4762-4723-882b-55cf1506d660</subevent_id>
    <title>APLAS Keynote Talks: Invited talk 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-keynote-talks</url>
    <url_link_display>Keynote Talks</url_link_display>
    <tracks>
      <track>Keynote Talks</track>
    </tracks>
    <timeslot>
      <slot_id>d426b18d-9e37-4c73-ac1b-daaba8872f7e</slot_id>
      <title>Session: APLAS Keynote Talks - Invited talk 1</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fbf088e0-3719-4e58-bb71-415e6e76ec78</slot_id>
      <event_id>dcfc0f60-1f4f-4dfa-bbaf-2da4274d67cc</event_id>
      <title> Solidifying and Advancing the Software Foundations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>18:00</end_time>
      <description>Software applications and technologies are built on top of foundational systems such as compilers, databases, and theorem provers. Such foundations form the trusted computing base, and fundamentally impact software quality and security. Thus, it is a critical challenge to solidify and advance them. This talk highlights general, effective techniques, and extensive, impactful efforts on finding hundreds of critical issues in widely-used compilers, database management systems, and SMT solvers. It focuses on the high-level principles and core techniques, their significant practical successes, and future opportunities and challenges.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>be8987da-531f-447e-8750-cb984c767d45</subevent_id>
    <title>REBLS: Welcome to REBLS &amp; Keynote</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/rebls-2021</url>
    <url_link_display>REBLS 2021</url_link_display>
    <tracks>
      <track>REBLS 2021</track>
    </tracks>
    <timeslot>
      <slot_id>350777b0-f0ea-474c-833f-fb103db07c61</slot_id>
      <title>Session: REBLS - Welcome to REBLS &amp; Keynote</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>295d33d0-09a5-424b-90d4-1cbdcb131109</slot_id>
      <event_id>433062d0-b019-4422-8345-a9fbcb66ca36</event_id>
      <title>Specification and End-to-End Proof of a Reactive Language and its Compiler</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>09:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Timothy</first_name>
          <last_name>Bourke</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tbrk.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/timothybourke/747739f4-e5f1-4d96-957d-a9e98c1ba4f7/small.jpg</picture_url>
          <person_id>timothybourke</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>346b8486-e351-49dc-9800-a6ffe8ebbe23</slot_id>
      <event_id>783d0e79-68fb-4c7f-a28b-75cdd888af85</event_id>
      <title>Welcome to REBLS</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM T.J. Watson Research Center</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ec86d05e-c657-4df0-8ff1-4d57af30cfc4</subevent_id>
    <title>Scala: Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/17</date>
    <url>https://2021.splashcon.org/home/scala-2021</url>
    <url_link_display>12th ACM SIGPLAN Scala Symposium</url_link_display>
    <tracks>
      <track>12th ACM SIGPLAN Scala Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>ff8fe7ab-4af4-4320-848d-635c3a41ab6e</slot_id>
      <title>Session: Scala - Session 1</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>12th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6292edc2-9203-47df-ab71-f7c4467024d2</slot_id>
      <event_id>187ddd31-abc4-4d88-ba57-70e22a33f44c</event_id>
      <title>Safer Exceptions for Scala</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>09:40</end_time>
      <description>We describe a scheme for reflecting exceptions as capabilities in the Scala type system that keeps notational overhead to a minimum and avoids well-known problems with Java’s checked exceptions framework. The scheme makes exceptions safer but not fully safe since the capability for throwing an exception may still yet escape its enclosing try block. To address this limitation, we also propose a type system which prevents capabilities from escaping.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>EPFL</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java. 
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as academic director of the Scala center.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinodersky/fc1dd696-d0d4-47cb-9d9a-bba012d98f9e/small.jpg</picture_url>
          <person_id>martinodersky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aleksander</first_name>
          <last_name>Boruch-Gruszecki</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <person_id>aleksanderboruchgruszecki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan Immanuel</first_name>
          <last_name>Brachthäuser</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanbrachthauser/f9c0b5dc-9b85-444f-baed-e807673f202d/small.jpg</picture_url>
          <person_id>jonathanbrachthauser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Edward</first_name>
          <last_name>Lee</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>edwardlee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>12th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9aa41b37-ac13-49dd-9263-578dbedd53b5</slot_id>
      <event_id>232f6e9a-08a4-4263-bd84-37be4e5978d8</event_id>
      <title>Pathless Scala: a calculus for the rest of Scala</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/17</date>
      <start_time>09:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:20</end_time>
      <description>Recent work on the DOT calculus successfully put core aspects of Scala on a sound foundation, but subtyping in DOT is structural and therefore not easily amenable to studying the parts of Scala that are deeply tied to its nominal subtyping system. On the other hand, the Featherweight Java calculus has proven to be a great basis for studying many aspects of Java and Java-like languages. Continuing this tradition, we present Pathless Scala: an extension of Featherweight Generic Java that closely models multiple inheritance and intersection types as they exist in the Scala language today. We define the semantics of Pathless Scala by erasing it to a simpler calculus in a way that closely models how Scala is compiled to Java bytecode in practice. More than a one-off, we believe that this calculus could be extended to describe many more features of Scala, although reconciling it with DOT remains an open problem.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Martres</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>PhD student at EPFL in the LAMP group working on Dotty, the next-generation Scala compiler.</bio>
          <homepage_url>http://guillaume.martres.me</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guillaumemartres/34840d2d-eb20-4dd2-8797-de6a5d8ce474/small.jpg</picture_url>
          <person_id>guillaumemartres</person_id>
        </person>
      </persons>
      <tracks>
        <track>12th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>86bf46f0-ff75-43fe-a31d-9afd7e3c1fa4</subevent_id>
    <title>DSM: Introduction and Cases</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/dsm-2021</url>
    <url_link_display>DSM'21</url_link_display>
    <tracks>
      <track>DSM'21</track>
    </tracks>
    <timeslot>
      <slot_id>7928925c-4cbc-4791-ab13-21e7777526c2</slot_id>
      <title>Session: DSM - Introduction and Cases</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e634c50-b575-49de-bc9b-9c1c7c68571f</slot_id>
      <event_id>c70dd60b-9e43-46bb-949b-9d9427ed3beb</event_id>
      <title>PrintTalk: a Constraint-based Imperative DSL for 3D Printing</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>09:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:00</end_time>
      <description>We present PrintTalk, a DSL to “program” 3D objects, called “gadgets”. PrintTalk also features “topologies”, which are predefined spacial arrangements of gadgets. Gadgets are composed by executing a gadget script (possibly consisting of subscripts) that ‘draws’ the gadget in the 3D scene. However, executing the script also returns a number of constraint variables. These variables can be constrained inside the gadget and can also be bound outside the gadget in order to constrain the produced gadgets after the facts. This is the essence of the gadget composition mechanism of PrintTalk. PrintTalk is implemented in DrRacket. Running a PrintTalk program generates a file that is sent to the 3D printer. We validate PrintTalk qualitatively by comparing the code for complex gadgets with the code needed to print those gadgets in existing languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jef</first_name>
          <last_name>Jacobs</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>jefjacobs</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jens</first_name>
          <last_name>Nicolay</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/~jnicolay/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jensnicolay/307f2d75-b933-43f4-ae6c-1cb9a2db8e92/small.jpg</picture_url>
          <person_id>jensnicolay</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christophe</first_name>
          <last_name>De Troyer</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>christophedetroyer2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wolfgangdemeuter/cb721b79-a1aa-4583-8ba0-b1a96f896900/small.jpg</picture_url>
          <person_id>wolfgangdemeuter</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>463fb80b-43f0-4000-8d61-50f57023394e</slot_id>
      <event_id>a23c6155-6f4f-44af-8039-6c4d961bc56d</event_id>
      <title>MOLEGA: Modeling Language for Educational Card Games</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>09:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:40</end_time>
      <description>Domain-specific modeling languages abstractly represent domain knowledge in a way that users can more easily understand the model content without technical expertise. These languages can be created for any domain, provided the necessary knowledge is available. This research uses educational game design as a demonstration of the power of domain-specific modeling. Games are useful tools in supplementing the traditional education of students, however, many educators often do not possess the design or technical skills to develop a custom game for their own use. MOLEGA (the Modeling Language for Educational Card Games) is a domain-specific modeling language that provides a guided model design environment for these users. Using MOLEGA, users can create visual models, inspired by UML class diagrams, to represent their desired card game, based on two selected variants. User models are then used to generate executable source code for a mobile-compatible, browser-based game that can be deployed on a server by following the provided instructions. MOLEGA is evaluated for validity and correctness using a suite of example models.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kaylynn</first_name>
          <last_name>Borror</last_name>
          <affiliation>Miami University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/kaylynnborror/924df1e3-c4c7-4e6c-8fdb-8d24fc003997/small.jpg</picture_url>
          <person_id>kaylynnborror</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eric</first_name>
          <last_name>Rapos</last_name>
          <affiliation>Miami University</affiliation>
          <bio>Dr Rapos is an Assistant Professor in the Department of Computer Science &amp;amp; Software Engineering at Miami University University, working primarily on research in Software Engineering. 
Dr Rapos obtained his PhD from Queen’s University in Kingston, Canada in 2017, while also working as a Teaching Fellow for the University, instructing several classes. Dr Rapos also completed his MSc and undergraduate degrees at Queen’s University. 
Dr Rapos’ research areas of interest are: model-driven engineering, model-based testing, software evolution, test co-evolution, and co-evolution of model based tests. Dr Rapos has worked closely with industry professionals in the automotive domain to conduct relevant and interesting research.</bio>
          <homepage_url>http://users.miamioh.edu/rapose/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ericrapos/f6037c85-cfb6-4d58-ab4a-7d607eaeffdf/small.jpg</picture_url>
          <person_id>ericrapos</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>46a0da8a-f383-4f7d-bd86-f39c44ca4121</slot_id>
      <event_id>88145197-c460-4e68-aa68-ab908fee3c7b</event_id>
      <title>Introduction</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:20</end_time>
      <description>Introduction to the workshop, Introduction of the participants</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeff</first_name>
          <last_name>Gray</last_name>
          <affiliation>University of Alabama</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gray.cs.ua.edu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeffgray/1f2fd602-bac6-49dd-86e4-549b5dc88528/small.jpg</picture_url>
          <person_id>jeffgray</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matti</first_name>
          <last_name>Rossi</last_name>
          <affiliation>Aalto University School of Business</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.aalto.fi/index.html?profilepage=isfor#!matti_rossi</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mattirossi/25339e6c-8192-48c1-8f9d-282bdef59e5f/small.jpg</picture_url>
          <person_id>mattirossi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Sprinkle</last_name>
          <affiliation>University of Arizona</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ece.arizona.edu/jonathan-sprinkle</homepage_url>
          <person_id>jonathansprinkle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Juha-Pekka</first_name>
          <last_name>Tolvanen</last_name>
          <affiliation>MetaCase</affiliation>
          <bio>Juha-Pekka Tolvanen (jpt@metacase.com) is the CEO of MetaCase. He has been involved in domain-specific approaches and tools, notably metamodeling and code generator development since 1991. Juha-Pekka holds a Ph.D. in computer science from the University of Jyväskylä, Finland and received best national dissertation award 1999. He acts as a consultant world-wide for modeling language and code generation development. Juha-Pekka has authored a book (Domain-Specific Modeling, Wiley) and over 90 articles in software development magazines, journals and conferences.</bio>
          <homepage_url>http://www.metacase.com/blogs/jpt/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juhapekkatolvanen/f9d40f6a-1246-473e-b3bd-048707e141a0/small.jpg</picture_url>
          <person_id>juhapekkatolvanen</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f43774c0-2194-4c4a-824c-5ef8e9d9728a</slot_id>
      <event_id>918c86c1-2823-491d-b3c9-9361ad63a46f</event_id>
      <title>Industrial Experiences With the Evolution of a DSL</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>10:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:20</end_time>
      <description>At Philips IGT, we develop and produce interventional X-ray systems. For a controller in these systems we have an approximately five years old domain specific language. Like general programming languages, domains specific languages also evolve. These languages co-evolve together with their domain. The language used at IGT was initially created for one system type. Because of our positive experiences with the language, we want to evolve the language to support a family of systems. In this paper we report on our experiences with the modifications we made to the original language. We made these changes preserving the behavior of the existing system instance. To prevent confidentiality issues we use a Lego robot in our examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mathijs</first_name>
          <last_name>Schuts</last_name>
          <affiliation>Philips &amp; Radboud University</affiliation>
          <bio>undefined</bio>
          <person_id>mathijsschuts</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marco</first_name>
          <last_name>Alonso</last_name>
          <affiliation>Philips</affiliation>
          <bio>undefined</bio>
          <person_id>marcoalonso</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jozef</first_name>
          <last_name>Hooman</last_name>
          <affiliation>TNO &amp; Radboud University</affiliation>
          <bio>undefined</bio>
          <person_id>jozefhooman</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1be47905-2e7b-40a8-8938-6e57fa051926</subevent_id>
    <title>APLAS Keynote Talks: Invited talk 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-keynote-talks</url>
    <url_link_display>Keynote Talks</url_link_display>
    <tracks>
      <track>Keynote Talks</track>
    </tracks>
    <timeslot>
      <slot_id>3191a99e-6d98-42e6-8695-a2ddcb9ea18d</slot_id>
      <title>Session: APLAS Keynote Talks - Invited talk 2</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>092f1bfe-3b34-426b-b568-381f47328c0c</slot_id>
      <event_id>181db6e0-3cfe-45c3-98cd-f72b64ec7f58</event_id>
      <title>A Separation Logic for Probabilistic Independence</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:00</end_time>
      <description>Probabilistic independence is a useful concept for describing the result of random sampling—a basic operation in all probabilistic languages—and for reasoning about groups of random variables. Nevertheless, existing verification methods handle independence poorly, if at all. We propose a probabilistic separation logic PSL, where separation models probabilistic independence, based on a new, probabilistic model of the logic of bunched implications (BI). The program logic PSL is capable of verifying information-theoretic security of cryptographic constructions for several well-known tasks, including private information retrieval, oblivious transfer, secure multi-party addition, and simple oblivious RAM, while reasoning purely in terms of independence and uniformity. If time permits, we will also discuss ongoing work for reasoning about conditional independence.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Justin</first_name>
          <last_name>Hsu</last_name>
          <affiliation>University of Wisconsin-Madison, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.justinh.su</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/justinhsu/a2c25b60-0dc3-48ad-a41d-238071e3fbab/small.jpg</picture_url>
          <person_id>justinhsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>577eb8a6-3182-40f3-b6bc-b345c1b912e9</subevent_id>
    <title>VMIL: Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/vmil-2021</url>
    <url_link_display>VMIL 2021</url_link_display>
    <tracks>
      <track>VMIL 2021</track>
    </tracks>
    <timeslot>
      <slot_id>3984dae9-c4ab-4275-b7a3-7a6d7619e94b</slot_id>
      <title>Session: VMIL - Session 1</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4f4eeb1d-4fd9-4bae-8f7c-d0a628ac4c84</slot_id>
      <event_id>f9d56ad2-304e-453c-b2e4-2aea951f734e</event_id>
      <title>Lightweight IOT abstractions for Embedded WebAssembly</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>10:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>10:20</end_time>
      <description>WebAssembly is a novel safe virtual machine instruction set supported by all major browsers. Its main strengths are safety, portability, compact code representation and fast code execution. These properties also make it an attractive target for execution on small embedded devices. In recent years we have seen several virtual machines such as WARDuino, wasm-micro-runtime and WASM3 supporting WebAssembly on a wide range of embedded devices. Unfortunately the WebAssembly instruction set does not lend itself to implementing IOT communication. In particular there are no instructions in the VM to interrupt code. On embedded devices, interrupts are a fundamental building block of responsive applications. 
In this paper we propose the inclusion of a set of IOT primitives which allows WebAssembly to support both synchronous and asynchronous communication primitives. To support the latter, we extended the VM with a lightweight interruption mechanism. We have formalized our extensions and implemented our extension in the WARDuino VM to support both HTTP and MQTT. An example IOT application written in Rust and compiled to WebAssembly running on an ESP32 shows that our extensions are stable and perform well over several testing days.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tom</first_name>
          <last_name>Lauwaerts</last_name>
          <affiliation>Universiteit Gent, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>tomlauwaerts</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Gurdeep Singh</last_name>
          <affiliation>Universiteit Gent, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://beardhatcode.be</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/robbertgurdeepsingh/755ae4c9-55dc-460f-b072-55cb8b62731c/small.jpg</picture_url>
          <person_id>robbertgurdeepsingh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Scholliers</last_name>
          <affiliation>Universiteit Gent, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~cfscholl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophescholliers/349aebe2-c428-4d19-8b70-9e1665dea5e6/small.jpg</picture_url>
          <person_id>christophescholliers</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>57d25081-4a6b-4a20-8c74-0a03acc8c31f</slot_id>
      <event_id>a3d3a71e-1d25-4fa6-b667-a72d7934c331</event_id>
      <title>Keynote 1 (TBD)</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Worthington</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanworthington/036820d9-7abf-4d19-be95-a0337a71707a/small.jpg</picture_url>
          <person_id>jonathanworthington</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>15ab0d6a-6b17-44fe-a5a7-9be8dc0a3ef4</subevent_id>
    <title>REBLS: Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/rebls-2021</url>
    <url_link_display>REBLS 2021</url_link_display>
    <tracks>
      <track>REBLS 2021</track>
    </tracks>
    <timeslot>
      <slot_id>20951738-e2f0-4cb5-b609-1116f11c188d</slot_id>
      <title>Session: REBLS - Session 2</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0818fe33-6976-45b2-8a68-fae7e0026df9</slot_id>
      <event_id>7ca4e63b-adfd-4272-b8ab-0a6e8f86faea</event_id>
      <title>Symmetric Distributed Applications</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>14:15</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:40</end_time>
      <description>A program is deterministic if multiple re-executions with the same inputs always lead to the same state. Even concurrent instances of a deterministic program should observe identical behavior—in real time—if assigned the same set of inputs. In this work, we propose real-time reproducibility for distributed programs. Multiple instances of the same interactive application can broadcast asynchronous inputs and yet conform to identical behavior. Collaborative networked applications, such as watch parties, document editing, and video games can benefit from this approach. We name this class of applications as symmetric distributed applications. Using a standard event-driven API to wait and emit events, programmers write code as if the application executes in a single machine. Our middleware intercepts event generation and synchronizes all instances in a consistent timeline so that receipt is identically reproducible. Not only distributed applications benefit from consistency and determinism but also development and testing can be done in a single instance with the same guarantees. In our experiments, the middleware can handle applications with 25 FPS, distributed in up to 25 nodes over the Internet, with an event latency below 350ms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Francisco</first_name>
          <last_name>Sant'Anna</last_name>
          <affiliation>Rio de Janeiro State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ceu-lang.org/chico</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/franciscosantanna/1f911a5d-2e99-444d-a3cc-07d7cd77804b/small.jpg</picture_url>
          <person_id>franciscosantanna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rodrigo</first_name>
          <last_name>Santos</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>rodrigosantos2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Noemi</first_name>
          <last_name>Rodriguez</last_name>
          <affiliation>PUC-Rio</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/noemirodriguez/17c7bbb7-e9bb-43ff-9bf5-90a641184444/small.jpg</picture_url>
          <person_id>noemirodriguez</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1fa43cb5-2f35-4ec3-9ea3-f4847016ce95</slot_id>
      <event_id>243cf145-cb8a-4895-953b-61cb1cbaa9bc</event_id>
      <title>Trampoline Variables: A General Method for State Accumulation in Reactive Programming</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:15</end_time>
      <description>Reactive programming is all about relegating the management of a program’s state changes to the realm of the runtime environment. Nevertheless, sometimes it is still necessary to enrich a reactive program with state variables that are explicitly updated by the programmer. In current reactive languages this is accomplished either by polluting the reactive paradigm with imperative constructs or by relying on built-in operators such as foldp. 
This paper introduces trampoline variables, a new general mechanism that allows reactive programs to manipulate state explicitly without resorting to imperative programming. We show that our proposal is at least as powerful as existing built-in reactive operators. We also analyse how reactive programs with trampoline variables can be composed and how they can form the basis to replace stateful constituents of a running reactive program — a.k.a. hotswapping — in a coherent way. The latter is an essential building block towards live IDEs for reactive programming languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bjarno</first_name>
          <last_name>Oeyen</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.bjarno.xyz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bjarnooeyen/c798be09-5fc6-45f6-9840-071793035cef/small.jpg</picture_url>
          <person_id>bjarnooeyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Van den Vonder</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>PhD candidate at the Software Languages Lab of the Vrije Universiteit Brussel.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/samvandenvonder/2ccd1dd4-a774-4f8b-b2a1-c601a5adc3d5/small.jpg</picture_url>
          <person_id>samvandenvonder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wolfgangdemeuter/cb721b79-a1aa-4583-8ba0-b1a96f896900/small.jpg</picture_url>
          <person_id>wolfgangdemeuter</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>41c0d95e-51d6-4990-95cf-7c000e5cf0c3</slot_id>
      <event_id>aa9d3672-ae76-4b40-aef7-56d80f1911a7</event_id>
      <title>Analysing the performance and costs of reactive programming libraries in Java</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>14:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>15:05</end_time>
      <description>Modern services running in cloud and edge environments need to be resource-efficient to increase deployment density and reduce operating costs. Asynchronous I/O combined with asynchronous programming provides a solid technical foundation to reach these goals. Reactive programming and reactive streams are gaining traction in the Java ecosystem. However, reactive streams implementations tend to be complex to work with and maintain. This paper discusses the performance of the three major reactive streams compliant libraries used in Java applications: RxJava, Project Reactor, and SmallRye Mutiny. As we will show, advanced optimization techniques such as operator fusion do not yield better performance on realistic I/O-bound workloads, and they significantly increase development and maintenance costs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julien</first_name>
          <last_name>Ponge</last_name>
          <affiliation>Red Hat, Inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://julien.ponge.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/julienponge/52b328af-ff03-4e73-b071-42f8c4746373/small.jpg</picture_url>
          <person_id>julienponge</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arthur</first_name>
          <last_name>Navarro</last_name>
          <affiliation>Red Hat</affiliation>
          <bio>undefined</bio>
          <person_id>arthurnavarro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Clément</first_name>
          <last_name>Escoffier</last_name>
          <affiliation>Red Hat</affiliation>
          <bio>undefined</bio>
          <person_id>clementescoffier1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Frédéric</first_name>
          <last_name>Le Mouël</last_name>
          <affiliation>INSA Lyon</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.le-mouel.net/</homepage_url>
          <person_id>fredericlemouel</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b6432640-f1c5-4091-82ce-378b69fbc524</subevent_id>
    <title>DSM: Verification and validation, Tooling</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/dsm-2021</url>
    <url_link_display>DSM'21</url_link_display>
    <tracks>
      <track>DSM'21</track>
    </tracks>
    <timeslot>
      <slot_id>1b0ed1d6-e068-4d6b-bdc1-3d17d9169577</slot_id>
      <title>Session: DSM - Verification and validation, Tooling</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>709c4707-0783-4e04-ab94-359e59cfcf64</slot_id>
      <event_id>f7827e83-8ce7-4d4d-89aa-80038702a796</event_id>
      <title>Differential-FORMULA: Towards a Semantic Backplane for Incremental Modeling</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:50</end_time>
      <description>This paper presents our preliminary results developing an incremental query and transformation engine for our modeling framework. Our prior framework combined WebGME, a cloud-based collaborative modeling tool, with FORMULA, a language and tool for specifying and analyzing domainspecific modeling languages. While this arrangement has been successful for defining non-trivial languages in domains like CPS, one ongoing challenge is the scalability of executing model queries and transformations on large models. The inherent incremental nature of the modeling process exacerbates this scalability issue: model queries and transformations are repeatedly performed on incrementally updated models. To address this issue, we are developing an incremental version of FORMULA that can perform efficient model queries and transformations in the face of continual model updates. This paper describes our experiences designing this incremental version, including the challenges we faced and design decisions. We also report encouraging benchmark results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qishen</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Vanderbilt University</affiliation>
          <bio>undefined</bio>
          <person_id>qishenzhang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Balasubramanian</last_name>
          <affiliation>Vanderbilt University</affiliation>
          <bio>undefined</bio>
          <person_id>danielbalasubramanian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tamas</first_name>
          <last_name>Kecskes</last_name>
          <affiliation>Vanderbilt University</affiliation>
          <bio>undefined</bio>
          <person_id>tamaskecskes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Janos</first_name>
          <last_name>Sztipanovits</last_name>
          <affiliation>Vanderbilt University</affiliation>
          <bio>undefined</bio>
          <person_id>janossztipanovits</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bce10ab5-5866-4032-940c-1e30dd158d0c</slot_id>
      <event_id>b7460eec-1acd-4e59-b9b1-243545fa2689</event_id>
      <title>Discussion and summary</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>12:10</end_time>
      <description>Discussion on the papers and themes of the workshop</description>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c11188a8-62e8-4381-b063-07940954811e</slot_id>
      <event_id>0e2794df-9a32-4a9a-9d7c-1204fd2c260e</event_id>
      <title>Co-designing DSL Quality Assurance Measures for and with Non-programming Experts</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:10</end_time>
      <description>Domain-specific languages seek to provide domain guarantees that eliminate many errors allowed by general-purpose languages. Still, a domain-specific language requires additional quality assurance measures to ensure that specifications behave as intended by the users. However, some domains may have specific quality assurance measures (e.g., proofs, experiments, or case studies) with little tradition of using quality assurance measures customary to software engineering. We investigate the possibility of accommodating such domains by conducting a workshop with 11 prospective users of a domain-specific language named MAL for the pension industry. The workshop emphasised the need for supporting actuaries with new analytical tools for quality assurance and resulted in three designs: quantity monitors let users identify outlier behaviour, fragment debugging lets users debug with limited evaluative power, and debugging spreadsheets let users visualise, analyse, and remodel concrete calculations with an established domain tool. Based on our experiences, we hypothesise that co-design workshops are a viable approach for DSLs in a similar situation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Holger</first_name>
          <last_name>Borum</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/holgerborum/bac7a92b-0aa5-4cc2-80b4-269eb6cf0a94/small.jpg</picture_url>
          <person_id>holgerborum</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Seidl</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophseidl/3e8becb0-bfa5-4cfe-a0ba-3c2439a9db0a/small.jpg</picture_url>
          <person_id>christophseidl</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Sestoft</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.itu.dk/people/sestoft/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/petersestoft/fb3cebdd-f127-45c3-b33d-53e917c431f7/small.jpg</picture_url>
          <person_id>petersestoft</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f13515fe-7910-4a75-9ca1-086f865392c5</slot_id>
      <event_id>7f0eb685-f8f4-4151-8564-674b997b9b70</event_id>
      <title>Integration of Modeling and Verification for System Model Based on KARMA Language</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:30</end_time>
      <description>Model-based systems engineering enables to verify the system performance using system behavior models, which can identify design faults that do not meet the stakeholders’ requirements as early as possible, thus reducing the R&amp;amp;D cost and error risks. Currently, different domain engineers make use of different modeling languages to create their own behavior models. Different behavior models are verified by different approaches. It is difficult to adopt a unified integrated platform to support the modeling and verification of heterogeneous behavior models during the conceptual design phase. This paper proposes a unified modeling and verification approach supporting system formalisms and verification. The KARMA language is used to support the unified formalisms across MBSE models and dynamic simulations for different domain specific models. In order to describe the behavior model more precisely and to facilitate verification, the syntax of hybrid automata is integrated into KARMA. We implemented behavior models and their verification in MetaGraph, a multi-architecture modeling tool. Finally, the effectiveness of the proposed approach is validated by two cases: 1) the scenario of booking railway tickets using BPMN models; 2) the behavior performance simulation of unmanned vehicles using a SysML state machine diagram.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jie</first_name>
          <last_name>Ding</last_name>
          <affiliation>Beijing Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>jieding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michel</first_name>
          <last_name>Reniers</last_name>
          <affiliation>TU/e</affiliation>
          <bio>undefined</bio>
          <person_id>michelreniers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jinzhi</first_name>
          <last_name>Lu</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <person_id>jinzhilu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Guoxin</first_name>
          <last_name>Wang</last_name>
          <affiliation>Beijing Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>guoxinwang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Lei</first_name>
          <last_name>Feng</last_name>
          <affiliation>KTH Royal Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>leifeng</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Kiritsis</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <person_id>dimitriskiritsis</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d957e057-6e1c-4661-a34b-77a5a6cd0bdf</subevent_id>
    <title>VMIL: Session 4</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/vmil-2021</url>
    <url_link_display>VMIL 2021</url_link_display>
    <tracks>
      <track>VMIL 2021</track>
    </tracks>
    <timeslot>
      <slot_id>1284a655-35cd-4b3c-a5e5-737a5a8e1f9c</slot_id>
      <title>Session: VMIL - Session 4</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>93eb6de2-779c-48da-97df-82e7a254ebe7</slot_id>
      <event_id>442348a9-49f0-4b3a-bf17-c0fd95ab7c59</event_id>
      <title>Keynote 3 (TBD)</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Wimmer</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Christian Wimmer is the architect of GraalVM Native Image. He was one of the first engineer of the GraalVM project, and helped growing it from a research project of Oracle Labs to a supported Oracle product. He believes that all languages should be equally fast, and that we therefore need to stop writing individual VMs and instead have one polyglot VM. His research interests span from compilers, virtual machines, and secure systems to component-based software architectures. 
He received a Dr. techn. degree in Computer Science (advisor: Prof. Hanspeter Mössenböck) and a Dipl.-Ing. degree in Computer Science, both from the Johannes Kepler University Linz, Austria. Before the time at Oracle, he was a postdoctoral researcher at the Department of Computer Science of the University of California, Irvine. He worked with Prof. Michael Franz at the Secure Systems and Software Laboratory on compiler optimizations, dynamic programming languages, and language-based security.</bio>
          <homepage_url>http://www.christianwimmer.at/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/christianwimmer/faa7e48f-04de-4752-83a4-efdf6b175be1/small.jpg</picture_url>
          <person_id>christianwimmer</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c34250bd-98c7-46bd-a118-20af9705389d</slot_id>
      <event_id>4a2f0ebb-6e41-4c00-a5bd-75e79e2f1c5f</event_id>
      <title>Closing</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gregor</first_name>
          <last_name>Richards</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://the.gregor.institute/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gregorrichards/bd8bf252-24c9-4721-a495-c06a6949a332/small.jpg</picture_url>
          <person_id>gregorrichards</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>556d9d66-73a2-4ea6-a761-e37b03cc8cf2</subevent_id>
    <title>VMIL: Session 3</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/vmil-2021</url>
    <url_link_display>VMIL 2021</url_link_display>
    <tracks>
      <track>VMIL 2021</track>
    </tracks>
    <timeslot>
      <slot_id>cf06ca12-1897-4881-8d0d-9e9a1904ac2a</slot_id>
      <title>Session: VMIL - Session 3</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>409430b4-8918-4260-b680-8433ea448b2d</slot_id>
      <event_id>485c4af5-dbf0-4f2f-80b2-5d7862fcd61e</event_id>
      <title>Keynote 2 (TBD)</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Grosser</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.grosser.es</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobiasgrosser/1ee43044-14e9-497e-a230-90f96a8da867/small.jpg</picture_url>
          <person_id>tobiasgrosser</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b53233ab-ff15-4e1b-960a-c6f3d474ad18</slot_id>
      <event_id>1c56fd67-b74f-4d53-9aaa-3bbb0208a232</event_id>
      <title>YJIT: A Basic Block Versioning JIT Compiler for CRuby</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>15:10</end_time>
      <description>Ruby is a dynamically typed programming language with a large breadth of features which has grown in popularity with the rise of the modern web, and remains at the core of the implementation of many widely-used websites. 
CRuby, the default implementation of the language, features a JIT compiler known as MJIT, but developers often do not enable it in production environments, because it does not always yield performance improvements on real-world software. Attempts to independently reimplement the Ruby language, such as JRuby and TruffleRuby have shown impressive performance results on benchmarks, but often lag behind CRuby when it comes to supporting new additions to the language, which limits their adoption. 
We introduce YJIT, a new JIT compiler built inside CRuby based on a Lazy Basic Block Versioning (LBBV) architecture. We show that while our compiler does not match the peak performance of TruffleRuby, it offers near-100% compatibility with existing Ruby code, impressively fast warmup, and speedups from 15% to 19% on sizeable benchmarks based on real-world software.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maxime</first_name>
          <last_name>Chevalier-Boisvert</last_name>
          <affiliation>Shopify</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://pointersgonewild.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/maximechevalierboisvert/8db10a92-e54a-484e-80b2-07662f398a11/small.jpg</picture_url>
          <person_id>maximechevalierboisvert</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Noah</first_name>
          <last_name>Giibbs</last_name>
          <affiliation>Shopify</affiliation>
          <bio>undefined</bio>
          <person_id>noahgiibbs</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean</first_name>
          <last_name>Boussier</last_name>
          <affiliation>Shopify</affiliation>
          <bio>undefined</bio>
          <person_id>jeanboussier</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Si Xing "Alan"</first_name>
          <last_name>Wu</last_name>
          <affiliation>Shopify</affiliation>
          <bio>undefined</bio>
          <person_id>sixingalanwu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Patterson</last_name>
          <affiliation>Shopify</affiliation>
          <bio>undefined</bio>
          <person_id>aaronpatterson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Newton</last_name>
          <affiliation>Shopify</affiliation>
          <bio>undefined</bio>
          <person_id>kevinnewton</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>John</first_name>
          <last_name>Hawthorn</last_name>
          <affiliation>GitHub</affiliation>
          <bio>undefined</bio>
          <person_id>johnhawthorn</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>65e2f8b3-7017-408f-af71-4334d33c42fd</subevent_id>
    <title>SPLASH PLMW: Mentoring</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot>
      <slot_id>7b58ed91-2584-4c6f-8ac0-e9d385122d03</slot_id>
      <title>Session: SPLASH PLMW - Mentoring</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ac5a3306-9fe5-4817-aaf1-a230e2536502</slot_id>
      <event_id>e6319e0c-481b-47b2-9c27-a66222ee940a</event_id>
      <title>Closing Remarks</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c0d58bb8-1fbf-41bc-ad12-6e1b0d3e263e</slot_id>
      <event_id>feb3456e-20e1-4145-80dc-76b9267690e5</event_id>
      <title>Mentoring Sessions</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:40</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8f84a6b2-4535-47a4-831c-c02698df3c99</subevent_id>
    <title>SPLASH PLMW: Introduction to SPLASH</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot>
      <slot_id>644dc139-8318-4474-a9d4-001035bd5c49</slot_id>
      <title>Session: SPLASH PLMW - Introduction to SPLASH</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>46c0ba38-d45f-4f60-b664-714ca605a84d</slot_id>
      <event_id>9df416db-af69-4b2c-abe6-4b16a5a780d2</event_id>
      <title>A Tour through the Program</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>09:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>09:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9e5aaac5-6612-4191-9b80-eaaa6d17b6e7</slot_id>
      <event_id>feb3456e-20e1-4145-80dc-76b9267690e5</event_id>
      <title>Mentoring Sessions</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>09:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>10:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>da896258-e712-4d9f-a14a-c30e98c093c8</slot_id>
      <event_id>c8cfd98d-a1c2-432d-b78a-b37bf9ce6f83</event_id>
      <title>How to Navigate SPLASH</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>09:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>83b8575e-1731-49cf-a25c-286ec535635e</subevent_id>
    <title>SPLASH PLMW: Graduate Student Perspectives</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot>
      <slot_id>9261ef36-cdb3-4093-96f2-9e669606568d</slot_id>
      <title>Session: SPLASH PLMW - Graduate Student Perspectives</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fc889a27-1ef5-407f-af5b-4b4b7e0aa0f4</slot_id>
      <event_id>40998865-4083-4932-b254-dc73d88f6fa5</event_id>
      <title>Current Student Panel</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>86f32777-c72e-4bfe-8212-75dad2ab617f</subevent_id>
    <title>SPLASH PLMW: Career Perspectives</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot>
      <slot_id>c8054045-16d4-4a2d-ad8e-dcfaef67f84c</slot_id>
      <title>Session: SPLASH PLMW - Career Perspectives</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0a141f90-f28c-4f92-9e44-21a2a751286c</slot_id>
      <event_id>7cec55c1-6dca-4fb5-8296-9086c8d221a3</event_id>
      <title>PL/SE Career Panel</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>675076c1-2083-4e03-9c75-702846634052</subevent_id>
    <title>SPLASH PLMW: Introduction to SPLASH</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot>
      <slot_id>a82aab2a-e674-47fb-9a69-fbb2b4f5e855</slot_id>
      <title>Session: SPLASH PLMW - Introduction to SPLASH</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5c40d758-f0a2-44c3-b55e-207c605ed501</slot_id>
      <event_id>9df416db-af69-4b2c-abe6-4b16a5a780d2</event_id>
      <title>A Tour through the Program</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>17:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>17:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9fbdd55a-df48-4afd-97e8-0fdd090c34ae</slot_id>
      <event_id>feb3456e-20e1-4145-80dc-76b9267690e5</event_id>
      <title>Mentoring Sessions</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>17:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>18:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f6e9ed35-63bb-4023-8932-e508fa6c4753</slot_id>
      <event_id>c8cfd98d-a1c2-432d-b78a-b37bf9ce6f83</event_id>
      <title>How to Navigate SPLASH</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>17:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>28e07262-ce6b-4203-aed9-1c4dd4462dbe</subevent_id>
    <title>SPLASH PLMW: Career Perspectives</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot>
      <slot_id>9fbc7fd7-e56c-4026-9b54-0b05e40ace8e</slot_id>
      <title>Session: SPLASH PLMW - Career Perspectives</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8c126525-fe9e-4270-b744-e2452f78ff2d</slot_id>
      <event_id>7cec55c1-6dca-4fb5-8296-9086c8d221a3</event_id>
      <title>PL/SE Career Panel</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6198204f-b651-449e-a0e0-f330d9222b78</subevent_id>
    <title>SPLASH Onward! Papers: Onward! Paper Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>e35825fd-5469-4326-afc4-3b46b247674b</slot_id>
      <title>Session: SPLASH Onward! Papers - Onward! Paper Session 2</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>44ac58b5-05e4-4ab3-b706-460d05c64932</slot_id>
      <event_id>2013a3de-a0a1-4586-91cf-a5c3d4b998b6</event_id>
      <title>Kotlin Coroutines: Design and Implementation</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:10</end_time>
      <description>Asynchronous programming is having its “renaissance” moment in recent years. Created in the 1980s, it was in use for quite some time, but with the advent of multi-core processors, it has been sidestepped by multi-threaded programming, which was (for a long time) the de facto standard of performing concurrent computations. However, since the 2000s, more and more programming languages have began to include the support for asynchronous programming, some built around asynchronicity from the start, others including it later in their evolution. 
In this paper, we explore the design and implementation of asynchronous programming in Kotlin, a multiplatform programming language from JetBrains, which uses coroutines for asynchronicity. Kotlin provides a compact built-in API for coroutine support, thus giving a lot of implementation freedom to the developer; this flexibility allows to transparently support different flavours of asynchronous programming within the same language. 
We overview existing approaches to asynchronous programming, zoom in and talk about coroutines in detail, and describe how they are used in Kotlin as the basis for asynchronous computations. Along the way, we show the flexibility of Kotlin coroutines, highlight several existing problems with asynchronicity, how they are fixed or worked-around in Kotlin, and also mention future directions asynchronous programming might explore.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Roman</first_name>
          <last_name>Elizarov</last_name>
          <affiliation>JetBrains</affiliation>
          <bio>undefined</bio>
          <person_id>romanelizarov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Belyaev</last_name>
          <affiliation>Saint Petersburg Polytechnic University / JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mikhail-belyaev.me</homepage_url>
          <person_id>mikhailbelyaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marat</first_name>
          <last_name>Akhin</last_name>
          <affiliation>Saint Petersburg Polytechnic University / JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://research.jetbrains.org/researchers/marat.akhin</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/maratakhin/611a55a5-2d2b-4633-9bf2-e5fd1952df56/small.jpg</picture_url>
          <person_id>maratakhin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ilmir</first_name>
          <last_name>Usmanov</last_name>
          <affiliation>JetBrains GmbH</affiliation>
          <bio>undefined</bio>
          <person_id>ilmirusmanov</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>59cde55d-dbaf-4e3a-ad5b-8abaffc2706c</slot_id>
      <event_id>9f76f988-b925-4637-b537-a889063cde4e</event_id>
      <title>Motivating Complexity Understanding By Profiling Energy Usage</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>22:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:50</end_time>
      <description>Computer science and software engineering students are typically taught to evaluate resource use in terms of time complexity. Developers use asymptotic analysis to compare algorithms by calculating how time grows as a function of input size. However, two factors have limited traditional models of complexity as pedagogical tools. First, modern systems are so fast that even relatively inefficient algorithms can quickly process large sets of data. Second, analysis is not universally engaging; only some students care about efficiency for the sake of efficiency. Our project proposes using measurements of energy consumption and concomitant environmental impact to better engage students with efficiency and its implications. 
Since current students have a strong level of concern about environmental consequences, we believe energy usage data will be more concrete and motivating than differences in time and will deepen the appreciation students have for computational complexity by using real-world measurements and by tying energy usage to climate change. We also believe that these future software engineers will be better equipped to contribute to the field by understanding the broader impact of software choices and resource usage. This approach is meant to augment and give meaning to traditional measurements of computational complexity, rather than supplant them.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Gross</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>joshuagross</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jacoby</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>danieljacoby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Coogan</last_name>
          <affiliation>Blackburn College</affiliation>
          <bio>undefined</bio>
          <person_id>kevincoogan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Helman</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>aaronhelman</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>703d79e0-9bcf-421d-9534-a077b554ff7a</slot_id>
      <event_id>f77a59ba-575f-4997-a122-2336da8c6a72</event_id>
      <title>SkyQuery: An Aerial Drone Video Sensing Platform</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>23:10</end_time>
      <description>Video-based sensing from aerial drones, especially small multirotor drones, can provide rich data for numerous applications, including traffic analysis (computing traffic flow volumes), precision agriculture (periodically evaluating plant health), and wildlife population management (estimating population sizes). However, aerial drone video sensing applications must handle a surprisingly wide range of tasks: video frames must be aligned so that we can equate coordinates of objects that appear in different frames, video data must be analyzed to extract application-specific insights, and drone routes must be computed that maximize the value of newly captured video. To address these challenges, we built SkyQuery, a novel aerial drone video sensing platform that provides an expressive, high-level programming language to make it straightforward for users to develop complex long-running sensing applications. SkyQuery combines novel methods for fast video frame alignment and detection of small objects in top-down aerial drone video to efficiently execute applications with diverse video analysis workflows and data distributions, thereby allowing application developers to focus on the unique qualities of their particular application rather than general video processing, data analysis, and drone routing tasks. We conduct diverse case studies using SkyQuery in parking monitoring, pedestrian activity mapping, and traffic hazard detection scenarios to demonstrate the generalizability and effectiveness of our system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Favyen</first_name>
          <last_name>Bastani</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>favyenbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Songtao</first_name>
          <last_name>He</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>songtaohe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziwen</first_name>
          <last_name>Jiang</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <person_id>ziwenjiang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Osbert</first_name>
          <last_name>Bastani</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://obastani.github.io</homepage_url>
          <person_id>osbertbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sam</first_name>
          <last_name>Madden</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sammadden</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7f115c65-b398-4d3d-893d-13e2ada1180b</slot_id>
      <event_id>6f69f227-02b2-4a33-941a-f0f43b49ac3e</event_id>
      <title>Dala: A Simple Capability-Based Dynamic Language Design For Data Race-Freedom</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>22:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:30</end_time>
      <description>Dynamic languages like Erlang, Clojure, JavaScript, and E adopted data-race freedom by design. To enforce data-race freedom, these languages either deep copy objects during actor (thread) communication or proxy back to their owning thread. We present Dala, a simple programming model that ensures data-race freedom while supporting efficient inter-thread communication. Dala is a dynamic, concurrent, capability-based language that relies on three core capabilities: immutable values can be shared freely; isolated mutable objects can be transferred between threads but not aliased; local objects can be aliased within their owning thread but not dereferenced by other threads. Objects with capabilities can co-exist with unsafe objects, that are unchecked and may suffer data races, without compromising the safety of safe objects. We present a formal model of Dala, prove data race-freedom and state and prove a dynamic gradual guarantee. These theorems guarantee data race-freedom when using safe capabilities and show that the addition of capabilities is semantics preserving modulo permission and cast errors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kiko</first_name>
          <last_name>Fernandez-Reyes</last_name>
          <affiliation>Uppsala University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.plresearcher.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kikofernandezreyes/83984e89-a3fc-4e54-b33f-b8d23ae5fd29/small.jpg</picture_url>
          <person_id>kikofernandezreyes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isaac Oscar</first_name>
          <last_name>Gariano</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>isaacoscargariano</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Noble</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.mcs.vuw.ac.nz/~kjx/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesnoble/397692f7-f014-4032-a93d-bc522e882d80/small.jpg</picture_url>
          <person_id>jamesnoble</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Erin</first_name>
          <last_name>Greenwood-Thessman</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/eringreenwoodthessman/72ea1c0a-3bbf-45af-a431-2f5d613ec270/small.jpg</picture_url>
          <person_id>eringreenwoodthessman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Homer</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ecs.vuw.ac.nz/~mwh</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelhomer/16fc38e2-021c-4b11-8ea6-752cf9b2c0a9/small.jpg</picture_url>
          <person_id>michaelhomer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobiaswrigstad/51b1bbdb-d077-4128-ad29-ec14657617a7/small.jpg</picture_url>
          <person_id>tobiaswrigstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0970f2f0-5f73-4605-9719-1c5b213ffb73</subevent_id>
    <title>SPLASH Onward! Papers: Onward! Paper Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>04e335fc-9ac6-41de-8977-68d171ff1527</slot_id>
      <title>Session: SPLASH Onward! Papers - Onward! Paper Session 1</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4467cf1e-dfa4-449b-8a4d-0a075270165e</slot_id>
      <event_id>645df455-35ac-42ea-bfb9-de49bf84c5d7</event_id>
      <title>Onward! Welcome</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>82acac3f-7e60-4c3a-bb00-8048352a2ce6</slot_id>
      <event_id>a7c8cbe2-0dca-4ddf-95b1-1261b79c3555</event_id>
      <title>Language-guided Programming</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>12:10</end_time>
      <description>In today’s software world with its cornucopia of reusable software libraries, when a programmer is faced with a programming task that they suspect can be completed through the use of a library, they often look for code examples using a search engine and then manually adapt found examples to their specific context of use. We put forward a vision based on a new breed of developer tools that have the potential to largely automate this process. The key idea is to adapt code autocompletion tools such that they take into account not only the developer’s already-written code but also the intent of the task the developer is trying to achieve next, formulated in plain natural language. We call this practice of enriching the code with natural language intent to facilitate its completion language-guided programming. 
To show that this idea is feasible we design, implement and benchmark a tool that solves this problem in the context of a specific domain (data science) and a specific programming language (Python). Central to the tool is the use of language models trained on a large corpus of documented code. Our initial experiments confirm the feasibility of the idea but also make it clear that we have only scratched the surface of what may become possible in the future. We end the paper with a comprehensive research agenda to stimulate additional research in the budding area of language-guided programming.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Geert</first_name>
          <last_name>Heyman</last_name>
          <affiliation>Nokia Bell Labs, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>geertheyman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rafael</first_name>
          <last_name>Huysegems</last_name>
          <affiliation>Nokia Bell Labs, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>rafaelhuysegems</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pascal</first_name>
          <last_name>Justen</last_name>
          <affiliation>Nokia Bell Labs, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>pascaljusten</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Van Cutsem</last_name>
          <affiliation>Nokia Bell Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.bell-labs.com/usr/tom.van_cutsem</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomvancutsem/d758e20f-3414-45b2-a82f-af50d8a3b6b3/small.jpg</picture_url>
          <person_id>tomvancutsem</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c55312ee-da20-492a-a3a2-50aae4c9db8f</slot_id>
      <event_id>ed615e6c-703b-40b2-adf5-3ba0be78f021</event_id>
      <title>Towards Self-Adaptable Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:50</end_time>
      <description>Over recent years, self-adaptation has become a concern for many software systems that have to operate in complex and changing environments. At the core of self-adaptation, there is a feedback loop and associated trade-off reasoning to decide on the best course of action. However, existing software languages do not abstract the development and execution of such feedback loops for self-adaptable systems. Developers have to fall back to ad-hoc solutions to implement self-adaptable systems, often with wide-ranging design implications (e.g., explicit MAPE-K loop). Furthermore, existing software languages do not capitalize on monitored usage data of a language and its modeling environment. This hinders the continuous and automatic evolution of a software language based on feedback loops from the modeling environment and runtime software system. To address the aforementioned issues, this paper introduces the concept of Self-Adaptable Language (SAL) to abstract the feedback loops at both system and language levels. We propose L-MODA (Language, Models, and Data) as a conceptual reference framework that characterizes the possible feedback loops abstracted into a SAL. To demonstrate SALs, we present emerging results on the abstraction of the system feedback loop into the language semantics. We report on the concept of Self-Adaptable Virtual Machines as an example of semantic adaptation in a language interpreter.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gwendal</first_name>
          <last_name>Jouneaux</last_name>
          <affiliation>Univ. Rennes, Inria, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.gwendal-jouneaux.fr/</homepage_url>
          <person_id>gwendaljouneaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes 1, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gunter</first_name>
          <last_name>Mussbacher</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/guntermussbacher/f1452019-54bd-4b93-bbdb-eaece6059e96/small.jpg</picture_url>
          <person_id>guntermussbacher</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f390fc4b-72a9-4b8c-a731-5900b1cc0c94</slot_id>
      <event_id>0f80dc7c-040a-4764-a133-5e55b5519014</event_id>
      <title>Neural Surrogates of Programs</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:30</end_time>
      <description>\emph{Neural surrogates}, neural networks that are trained to compute the same function as a given program, provide alternative representations of classical programs with different properties that are useful for a variety of programming tasks. With neural compilation, programmers develop a neural surrogate that replicates the behavior of the original program to deploy to end-users in place of the original program. With neural adaptation, programmers first develop a neural surrogate of a program then continue to train the neural surrogate on a different task. With neural surrogate optimization, programmers develop a neural surrogate of the original program, optimize input parameters of that neural surrogate using gradient descent, then plug the optimized input parameters back into the original program. Compared to standard programming approaches on these tasks, neural surrogates are more efficient and result in higher accuracy. 
However, the approaches in the literature for developing neural surrogates are disparate. We identify the \emph{neural surrogate programming methodology} common to these approaches, consisting of the \emph{specification} of the problem, the \emph{design} of the neural network architecture, the \emph{training} of the neural network, and the \emph{deployment} considerations of the system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alex</first_name>
          <last_name>Renda</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.alexrenda.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexrenda1/ac1a0658-f452-4012-9317-7b9828864eb7/small.jpg</picture_url>
          <person_id>alexrenda1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yi</first_name>
          <last_name>Ding</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://y-ding.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yiding/17d36271-6bb2-44b2-8274-88f3a520bf9c/small.jpg</picture_url>
          <person_id>yiding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c62bf10d-9303-4b79-b283-76c4813d1db7</subevent_id>
    <title>SPLASH Onward! Papers: Onward! Paper Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>47d157ab-d32c-4830-b55d-5c53df6c417d</slot_id>
      <title>Session: SPLASH Onward! Papers - Onward! Paper Session 2</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2572180f-63b8-4234-ae0f-d0873ebc53ea</slot_id>
      <event_id>9f76f988-b925-4637-b537-a889063cde4e</event_id>
      <title>Motivating Complexity Understanding By Profiling Energy Usage</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:50</end_time>
      <description>Computer science and software engineering students are typically taught to evaluate resource use in terms of time complexity. Developers use asymptotic analysis to compare algorithms by calculating how time grows as a function of input size. However, two factors have limited traditional models of complexity as pedagogical tools. First, modern systems are so fast that even relatively inefficient algorithms can quickly process large sets of data. Second, analysis is not universally engaging; only some students care about efficiency for the sake of efficiency. Our project proposes using measurements of energy consumption and concomitant environmental impact to better engage students with efficiency and its implications. 
Since current students have a strong level of concern about environmental consequences, we believe energy usage data will be more concrete and motivating than differences in time and will deepen the appreciation students have for computational complexity by using real-world measurements and by tying energy usage to climate change. We also believe that these future software engineers will be better equipped to contribute to the field by understanding the broader impact of software choices and resource usage. This approach is meant to augment and give meaning to traditional measurements of computational complexity, rather than supplant them.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Gross</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>joshuagross</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jacoby</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>danieljacoby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Coogan</last_name>
          <affiliation>Blackburn College</affiliation>
          <bio>undefined</bio>
          <person_id>kevincoogan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Helman</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>aaronhelman</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>28955cdf-2aba-4008-a7f9-353bf5129e5f</slot_id>
      <event_id>6f69f227-02b2-4a33-941a-f0f43b49ac3e</event_id>
      <title>Dala: A Simple Capability-Based Dynamic Language Design For Data Race-Freedom</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:30</end_time>
      <description>Dynamic languages like Erlang, Clojure, JavaScript, and E adopted data-race freedom by design. To enforce data-race freedom, these languages either deep copy objects during actor (thread) communication or proxy back to their owning thread. We present Dala, a simple programming model that ensures data-race freedom while supporting efficient inter-thread communication. Dala is a dynamic, concurrent, capability-based language that relies on three core capabilities: immutable values can be shared freely; isolated mutable objects can be transferred between threads but not aliased; local objects can be aliased within their owning thread but not dereferenced by other threads. Objects with capabilities can co-exist with unsafe objects, that are unchecked and may suffer data races, without compromising the safety of safe objects. We present a formal model of Dala, prove data race-freedom and state and prove a dynamic gradual guarantee. These theorems guarantee data race-freedom when using safe capabilities and show that the addition of capabilities is semantics preserving modulo permission and cast errors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kiko</first_name>
          <last_name>Fernandez-Reyes</last_name>
          <affiliation>Uppsala University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.plresearcher.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kikofernandezreyes/83984e89-a3fc-4e54-b33f-b8d23ae5fd29/small.jpg</picture_url>
          <person_id>kikofernandezreyes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isaac Oscar</first_name>
          <last_name>Gariano</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>isaacoscargariano</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Noble</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.mcs.vuw.ac.nz/~kjx/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesnoble/397692f7-f014-4032-a93d-bc522e882d80/small.jpg</picture_url>
          <person_id>jamesnoble</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Erin</first_name>
          <last_name>Greenwood-Thessman</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/eringreenwoodthessman/72ea1c0a-3bbf-45af-a431-2f5d613ec270/small.jpg</picture_url>
          <person_id>eringreenwoodthessman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Homer</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ecs.vuw.ac.nz/~mwh</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelhomer/16fc38e2-021c-4b11-8ea6-752cf9b2c0a9/small.jpg</picture_url>
          <person_id>michaelhomer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobiaswrigstad/51b1bbdb-d077-4128-ad29-ec14657617a7/small.jpg</picture_url>
          <person_id>tobiaswrigstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5fd333b6-5096-4078-8fb2-ae607eb993b7</slot_id>
      <event_id>2013a3de-a0a1-4586-91cf-a5c3d4b998b6</event_id>
      <title>Kotlin Coroutines: Design and Implementation</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:10</end_time>
      <description>Asynchronous programming is having its “renaissance” moment in recent years. Created in the 1980s, it was in use for quite some time, but with the advent of multi-core processors, it has been sidestepped by multi-threaded programming, which was (for a long time) the de facto standard of performing concurrent computations. However, since the 2000s, more and more programming languages have began to include the support for asynchronous programming, some built around asynchronicity from the start, others including it later in their evolution. 
In this paper, we explore the design and implementation of asynchronous programming in Kotlin, a multiplatform programming language from JetBrains, which uses coroutines for asynchronicity. Kotlin provides a compact built-in API for coroutine support, thus giving a lot of implementation freedom to the developer; this flexibility allows to transparently support different flavours of asynchronous programming within the same language. 
We overview existing approaches to asynchronous programming, zoom in and talk about coroutines in detail, and describe how they are used in Kotlin as the basis for asynchronous computations. Along the way, we show the flexibility of Kotlin coroutines, highlight several existing problems with asynchronicity, how they are fixed or worked-around in Kotlin, and also mention future directions asynchronous programming might explore.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Roman</first_name>
          <last_name>Elizarov</last_name>
          <affiliation>JetBrains</affiliation>
          <bio>undefined</bio>
          <person_id>romanelizarov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Belyaev</last_name>
          <affiliation>Saint Petersburg Polytechnic University / JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mikhail-belyaev.me</homepage_url>
          <person_id>mikhailbelyaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marat</first_name>
          <last_name>Akhin</last_name>
          <affiliation>Saint Petersburg Polytechnic University / JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://research.jetbrains.org/researchers/marat.akhin</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/maratakhin/611a55a5-2d2b-4633-9bf2-e5fd1952df56/small.jpg</picture_url>
          <person_id>maratakhin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ilmir</first_name>
          <last_name>Usmanov</last_name>
          <affiliation>JetBrains GmbH</affiliation>
          <bio>undefined</bio>
          <person_id>ilmirusmanov</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a4b0b1f4-66ff-4333-9c5b-7eadf89375ee</slot_id>
      <event_id>f77a59ba-575f-4997-a122-2336da8c6a72</event_id>
      <title>SkyQuery: An Aerial Drone Video Sensing Platform</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:10</end_time>
      <description>Video-based sensing from aerial drones, especially small multirotor drones, can provide rich data for numerous applications, including traffic analysis (computing traffic flow volumes), precision agriculture (periodically evaluating plant health), and wildlife population management (estimating population sizes). However, aerial drone video sensing applications must handle a surprisingly wide range of tasks: video frames must be aligned so that we can equate coordinates of objects that appear in different frames, video data must be analyzed to extract application-specific insights, and drone routes must be computed that maximize the value of newly captured video. To address these challenges, we built SkyQuery, a novel aerial drone video sensing platform that provides an expressive, high-level programming language to make it straightforward for users to develop complex long-running sensing applications. SkyQuery combines novel methods for fast video frame alignment and detection of small objects in top-down aerial drone video to efficiently execute applications with diverse video analysis workflows and data distributions, thereby allowing application developers to focus on the unique qualities of their particular application rather than general video processing, data analysis, and drone routing tasks. We conduct diverse case studies using SkyQuery in parking monitoring, pedestrian activity mapping, and traffic hazard detection scenarios to demonstrate the generalizability and effectiveness of our system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Favyen</first_name>
          <last_name>Bastani</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>favyenbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Songtao</first_name>
          <last_name>He</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>songtaohe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziwen</first_name>
          <last_name>Jiang</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <person_id>ziwenjiang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Osbert</first_name>
          <last_name>Bastani</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://obastani.github.io</homepage_url>
          <person_id>osbertbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sam</first_name>
          <last_name>Madden</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sammadden</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b5572da5-61d6-4cc1-b847-27939f3ba335</subevent_id>
    <title>SPLASH Onward! Papers: Onward! Paper Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>285c3128-2a49-46f9-ab47-4c0f365a520d</slot_id>
      <title>Session: SPLASH Onward! Papers - Onward! Paper Session 1</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>17dfc907-3ea3-48bc-941c-62f54493038a</slot_id>
      <event_id>ed615e6c-703b-40b2-adf5-3ba0be78f021</event_id>
      <title>Towards Self-Adaptable Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>19:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:50</end_time>
      <description>Over recent years, self-adaptation has become a concern for many software systems that have to operate in complex and changing environments. At the core of self-adaptation, there is a feedback loop and associated trade-off reasoning to decide on the best course of action. However, existing software languages do not abstract the development and execution of such feedback loops for self-adaptable systems. Developers have to fall back to ad-hoc solutions to implement self-adaptable systems, often with wide-ranging design implications (e.g., explicit MAPE-K loop). Furthermore, existing software languages do not capitalize on monitored usage data of a language and its modeling environment. This hinders the continuous and automatic evolution of a software language based on feedback loops from the modeling environment and runtime software system. To address the aforementioned issues, this paper introduces the concept of Self-Adaptable Language (SAL) to abstract the feedback loops at both system and language levels. We propose L-MODA (Language, Models, and Data) as a conceptual reference framework that characterizes the possible feedback loops abstracted into a SAL. To demonstrate SALs, we present emerging results on the abstraction of the system feedback loop into the language semantics. We report on the concept of Self-Adaptable Virtual Machines as an example of semantic adaptation in a language interpreter.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gwendal</first_name>
          <last_name>Jouneaux</last_name>
          <affiliation>Univ. Rennes, Inria, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.gwendal-jouneaux.fr/</homepage_url>
          <person_id>gwendaljouneaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes 1, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gunter</first_name>
          <last_name>Mussbacher</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/guntermussbacher/f1452019-54bd-4b93-bbdb-eaece6059e96/small.jpg</picture_url>
          <person_id>guntermussbacher</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1e770879-4010-4bc1-ab7b-c1fb83663bec</slot_id>
      <event_id>0f80dc7c-040a-4764-a133-5e55b5519014</event_id>
      <title>Neural Surrogates of Programs</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>19:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:30</end_time>
      <description>\emph{Neural surrogates}, neural networks that are trained to compute the same function as a given program, provide alternative representations of classical programs with different properties that are useful for a variety of programming tasks. With neural compilation, programmers develop a neural surrogate that replicates the behavior of the original program to deploy to end-users in place of the original program. With neural adaptation, programmers first develop a neural surrogate of a program then continue to train the neural surrogate on a different task. With neural surrogate optimization, programmers develop a neural surrogate of the original program, optimize input parameters of that neural surrogate using gradient descent, then plug the optimized input parameters back into the original program. Compared to standard programming approaches on these tasks, neural surrogates are more efficient and result in higher accuracy. 
However, the approaches in the literature for developing neural surrogates are disparate. We identify the \emph{neural surrogate programming methodology} common to these approaches, consisting of the \emph{specification} of the problem, the \emph{design} of the neural network architecture, the \emph{training} of the neural network, and the \emph{deployment} considerations of the system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alex</first_name>
          <last_name>Renda</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.alexrenda.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexrenda1/ac1a0658-f452-4012-9317-7b9828864eb7/small.jpg</picture_url>
          <person_id>alexrenda1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yi</first_name>
          <last_name>Ding</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://y-ding.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yiding/17d36271-6bb2-44b2-8274-88f3a520bf9c/small.jpg</picture_url>
          <person_id>yiding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>250790ad-588f-43c2-8b92-89e077b35b35</slot_id>
      <event_id>645df455-35ac-42ea-bfb9-de49bf84c5d7</event_id>
      <title>Onward! Welcome</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a328fca9-8159-4910-8706-f578270ceae8</slot_id>
      <event_id>a7c8cbe2-0dca-4ddf-95b1-1261b79c3555</event_id>
      <title>Language-guided Programming</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>20:10</end_time>
      <description>In today’s software world with its cornucopia of reusable software libraries, when a programmer is faced with a programming task that they suspect can be completed through the use of a library, they often look for code examples using a search engine and then manually adapt found examples to their specific context of use. We put forward a vision based on a new breed of developer tools that have the potential to largely automate this process. The key idea is to adapt code autocompletion tools such that they take into account not only the developer’s already-written code but also the intent of the task the developer is trying to achieve next, formulated in plain natural language. We call this practice of enriching the code with natural language intent to facilitate its completion language-guided programming. 
To show that this idea is feasible we design, implement and benchmark a tool that solves this problem in the context of a specific domain (data science) and a specific programming language (Python). Central to the tool is the use of language models trained on a large corpus of documented code. Our initial experiments confirm the feasibility of the idea but also make it clear that we have only scratched the surface of what may become possible in the future. We end the paper with a comprehensive research agenda to stimulate additional research in the budding area of language-guided programming.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Geert</first_name>
          <last_name>Heyman</last_name>
          <affiliation>Nokia Bell Labs, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>geertheyman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rafael</first_name>
          <last_name>Huysegems</last_name>
          <affiliation>Nokia Bell Labs, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>rafaelhuysegems</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pascal</first_name>
          <last_name>Justen</last_name>
          <affiliation>Nokia Bell Labs, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>pascaljusten</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Van Cutsem</last_name>
          <affiliation>Nokia Bell Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.bell-labs.com/usr/tom.van_cutsem</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomvancutsem/d758e20f-3414-45b2-a82f-af50d8a3b6b3/small.jpg</picture_url>
          <person_id>tomvancutsem</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>43f18afb-3e10-4bde-8938-bbb0e06d6c1b</subevent_id>
    <title>SPLASH Onward! Papers: Onward! Keynote Talk</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>0b738fc3-4ba5-4b2a-972b-ff2fd83211c2</slot_id>
      <title>Session: SPLASH Onward! Papers - Onward! Keynote Talk</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>09:20</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca7aa168-7548-45e2-85a6-31818f0272a9</slot_id>
      <event_id>35abc255-2ef4-4837-af5f-9c0784a6fcca</event_id>
      <title>TBD</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>09:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>10:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>81a3a7a3-7835-4b4a-b2ce-b40daab3f5c8</subevent_id>
    <title>SPLASH Onward! Papers: Onward! Keynote Talk</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>9d1c2f7a-6fa3-4054-9d0a-b88976d14e9f</slot_id>
      <title>Session: SPLASH Onward! Papers - Onward! Keynote Talk</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>17:20</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c17481a0-322c-4322-92b8-902d89d2d1f6</slot_id>
      <event_id>35abc255-2ef4-4837-af5f-9c0784a6fcca</event_id>
      <title>TBD</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>17:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>18:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b6e25e7c-8f98-4904-a1f8-a72d90981cbd</subevent_id>
    <title>SPLASH SIGPLAN Business: Future of Conferences</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-sigplan-business</url>
    <url_link_display>SIGPLAN Business</url_link_display>
    <tracks>
      <track>SIGPLAN Business</track>
    </tracks>
    <timeslot>
      <slot_id>27a87465-9bc5-4346-894e-96798b8f95ee</slot_id>
      <title>Session: SPLASH SIGPLAN Business - Future of Conferences</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science and chair of the Programming Languages Group at Delft University of Technology. His current research is on the foundation and implementation of declarative specification of programming languages. He studied at the University of Amsterdam (master 1993; doctorate 1997), and worked at the Oregon Graduate Institute (postdoc 1997-1998), Utrecht University (assistant professor 1998-2006), and TU Delft (associate professor 2006-2013, full professor since 2013). 
His research interests include (domain-specific) programming languages, language engineering, program transformation, and declarative language definition. With his students he has designed and implemented the Spoofax language workbench, as well as several domain-specific languages, including DSLs for syntax definition (SDF3), program transformation (Stratego), static semantics (Statix), software deployment (Nix), and web application development (WebDSL). Applications of WebDSL include the researchr conference hosting site and the WebLab learning management system.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>SIGPLAN Business</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88113db7-9f3c-4deb-b395-e61763db694f</slot_id>
      <event_id>b41962fe-f7e6-43cf-a9b7-e0d1ee39e8d9</event_id>
      <title>Future of Conferences</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science and chair of the Programming Languages Group at Delft University of Technology. His current research is on the foundation and implementation of declarative specification of programming languages. He studied at the University of Amsterdam (master 1993; doctorate 1997), and worked at the Oregon Graduate Institute (postdoc 1997-1998), Utrecht University (assistant professor 1998-2006), and TU Delft (associate professor 2006-2013, full professor since 2013). 
His research interests include (domain-specific) programming languages, language engineering, program transformation, and declarative language definition. With his students he has designed and implemented the Spoofax language workbench, as well as several domain-specific languages, including DSLs for syntax definition (SDF3), program transformation (Stratego), static semantics (Statix), software deployment (Nix), and web application development (WebDSL). Applications of WebDSL include the researchr conference hosting site and the WebLab learning management system.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>SIGPLAN Business</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b0ec864e-2e32-44f7-9c15-c5f5e0c79565</subevent_id>
    <title>SPLASH SIGPLAN Business: Future of Conferences</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-sigplan-business</url>
    <url_link_display>SIGPLAN Business</url_link_display>
    <tracks>
      <track>SIGPLAN Business</track>
    </tracks>
    <timeslot>
      <slot_id>433abd40-8649-43c5-8ed2-e04aab7f021a</slot_id>
      <title>Session: SPLASH SIGPLAN Business - Future of Conferences</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>SIGPLAN Business</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f6696639-1a27-4530-bc49-9ae0a3728df9</slot_id>
      <event_id>b41962fe-f7e6-43cf-a9b7-e0d1ee39e8d9</event_id>
      <title>Future of Conferences</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science and chair of the Programming Languages Group at Delft University of Technology. His current research is on the foundation and implementation of declarative specification of programming languages. He studied at the University of Amsterdam (master 1993; doctorate 1997), and worked at the Oregon Graduate Institute (postdoc 1997-1998), Utrecht University (assistant professor 1998-2006), and TU Delft (associate professor 2006-2013, full professor since 2013). 
His research interests include (domain-specific) programming languages, language engineering, program transformation, and declarative language definition. With his students he has designed and implemented the Spoofax language workbench, as well as several domain-specific languages, including DSLs for syntax definition (SDF3), program transformation (Stratego), static semantics (Statix), software deployment (Nix), and web application development (WebDSL). Applications of WebDSL include the researchr conference hosting site and the WebLab learning management system.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>SIGPLAN Business</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>73a2139a-6e8e-4e57-a154-7510d98deba1</subevent_id>
    <title>APLAS Research Papers: Language Design (mirror)</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>393de962-dd29-41b6-a150-f22b304d5bf2</slot_id>
      <title>Session: APLAS Research Papers - Language Design (mirror)</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>46f8963b-2495-4adf-b564-8bd3f60da60a</slot_id>
      <event_id>d75f138f-18d6-4382-9e30-3bf9e3b517f9</event_id>
      <title>The Choice Construct in the Soufflé Language</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>20:10</end_time>
      <description>Datalog has become a popular implementation language for solving large-scale, real world problems, including bug finders, network analysis tools, and disassemblers. These applications express complex behaviour with hundreds of relations and rules that often require a non-deterministic choice for tuples in relations to express worklist algorithms. 
This work is an experience report that describes the implementation of a \textit{choice} construct in the Datalog engine Soufflé. With the choice construct we can express worklist algorithms such as spanning trees in a few lines of code. We highlight the differences between rule-based choice as described in prior work, and relation-based choice introduced by this work. We show that a choice construct enables certain worklist algorithms to be computed up to 10k$\times$ faster than having no choice construct.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaowen</first_name>
          <last_name>Hu</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>xiaowenhu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Karp</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>joshuakarp</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Zhao</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>davidzhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Abdul</first_name>
          <last_name>Zreika</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>abdulzreika</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Xi</first_name>
          <last_name>Wu</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>xiwu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Bernhard</first_name>
          <last_name>Scholz</last_name>
          <affiliation>University of Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sydney.edu.au/engineering/people/bernhard.scholz.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bernhardscholz1/2ad1b16f-f423-4db2-bfce-56e86799d860/small.jpg</picture_url>
          <person_id>bernhardscholz1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8d3a021d-f45b-448a-a52e-ce26861d4abe</slot_id>
      <event_id>c504fd73-31ce-4375-a74d-fa36f0c6d31b</event_id>
      <title>A Typed Programmatic Interface to Contracts on the Blockchain</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:10</end_time>
      <description>Smart contract applications on the blockchain can only reach their full potential if they integrate seamlessly with traditional software systems via a programmatic interface. This interface should provide for originating and invoking contracts as well as observing the state of the blockchain. We propose a typed API for this purpose and establish some properties of the combined system. Specifically, we provide an execution model that enables us to prove type-safe interaction between programs and the blockchain. We establish further properties of the model that give rise to requirements on the API. A prototype of the interface is implemented in OCaml for the Tezos blockchain.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thi Thu Ha</first_name>
          <last_name>Doan</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <person_id>thithuhadoan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Peter</first_name>
          <last_name>Thiemann</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/peterthiemann/43fc0175-1745-4b3a-b626-86e10da76b86/small.jpg</picture_url>
          <person_id>peterthiemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ddfc1fa3-2c71-45bc-b881-26f17ecc5dda</slot_id>
      <event_id>5e8f5b7a-f99e-4413-9421-293ae8506852</event_id>
      <title>Latent Effects for Reusable Language Components</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>19:30</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:50</end_time>
      <description>The development of programming languages can be quite complicated and costly. Hence, much effort has been devoted to the modular definition of language features that can be reused in various combinations to define new languages and experiment with their semantics. A notable outcome of these efforts is the algebra-based “datatypes à la carte” (DTC) approach. When combined with algebraic effects, DTC can model a wide range of common language features. Unfortunately, the current state of the art does not cover modular definitions of advanced control-flow mechanisms that defer execution to an appropriate point, such as call-by-name and call-by-need evaluation, as well as (multi-)staging. 
This paper defines latent effects, a generic class of such control-flow mechanisms. We demonstrate how function abstractions, lazy computations and a MetaML-like staging can all be expressed in a modular fashion using latent effects, and how they can be combined in various ways to obtain complex semantics. We provide a full Haskell implementation of our effects and handlers with a range of examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Birthe</first_name>
          <last_name>van den Berg</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/birthevandenberg/21e3094e-6010-4629-bfe1-8490394a9f9d/small.jpg</picture_url>
          <person_id>birthevandenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Casper</first_name>
          <last_name>Bach Poulsen</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://casperbp.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/casperbachpoulsen/2cddd6a9-d920-4f73-9fcf-f4d9462eb0e3/small.jpg</picture_url>
          <person_id>casperbachpoulsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Wu</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://zenzike.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nicolaswu/16dfcd93-2531-4de2-baee-d5a8d1a95a47/small.jpg</picture_url>
          <person_id>nicolaswu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f899ef46-2a41-448d-a673-9f8dd9f53be2</slot_id>
      <event_id>eaee7960-f7b4-427d-8c7b-7bc3df70bc41</event_id>
      <title>Adaptable Traces for Program Explanations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>19:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:30</end_time>
      <description>Program traces are a sound basis for explaining the dynamic behavior of programs. Alas, program traces can grow big very quickly, even for small programs, which diminishes their value as explanations. 
In this paper we demonstrate how the systematic simplification of traces can yield succinct program explanations. Specifically, we introduce operations for transforming traces that facilitate the abstraction of details. The operations are the basis of a query language for the definition of trace filters that can adapt and simplify traces in a variety of ways. 
The generation of traces is governed by a variant of Call-By-Value semantics which specifically supports parsimony in trace representations. We show that our semantics is a conservative extension of Call-By-Value that can produce smaller traces and that the evaluation traces preserve the explanatory content of proof trees at a much smaller footprint.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Divya</first_name>
          <last_name>Bajaj</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>divyabajaj</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Erwig</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.engr.oregonstate.edu/~erwig/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinerwig/8fd12ecd-2d70-44d3-a670-d5ef12393f9c/small.jpg</picture_url>
          <person_id>martinerwig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Danila</first_name>
          <last_name>Fedorin</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>danilafedorin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kai</first_name>
          <last_name>Gay</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>kaigay</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fbd8eaf9-c5b9-49b0-9893-5592794a9438</subevent_id>
    <title>APLAS Research Papers: Language Design</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>9adf3337-ceca-40d2-a028-a1ce7395d715</slot_id>
      <title>Session: APLAS Research Papers - Language Design</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>118482de-4c35-4761-8cf2-e6c66deb0fa0</slot_id>
      <event_id>d75f138f-18d6-4382-9e30-3bf9e3b517f9</event_id>
      <title>The Choice Construct in the Soufflé Language</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>12:10</end_time>
      <description>Datalog has become a popular implementation language for solving large-scale, real world problems, including bug finders, network analysis tools, and disassemblers. These applications express complex behaviour with hundreds of relations and rules that often require a non-deterministic choice for tuples in relations to express worklist algorithms. 
This work is an experience report that describes the implementation of a \textit{choice} construct in the Datalog engine Soufflé. With the choice construct we can express worklist algorithms such as spanning trees in a few lines of code. We highlight the differences between rule-based choice as described in prior work, and relation-based choice introduced by this work. We show that a choice construct enables certain worklist algorithms to be computed up to 10k$\times$ faster than having no choice construct.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaowen</first_name>
          <last_name>Hu</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>xiaowenhu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Karp</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>joshuakarp</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Zhao</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>davidzhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Abdul</first_name>
          <last_name>Zreika</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>abdulzreika</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Xi</first_name>
          <last_name>Wu</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>xiwu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Bernhard</first_name>
          <last_name>Scholz</last_name>
          <affiliation>University of Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sydney.edu.au/engineering/people/bernhard.scholz.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bernhardscholz1/2ad1b16f-f423-4db2-bfce-56e86799d860/small.jpg</picture_url>
          <person_id>bernhardscholz1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>12a38d1c-066a-4400-96bb-cc6a445f2ed9</slot_id>
      <event_id>5e8f5b7a-f99e-4413-9421-293ae8506852</event_id>
      <title>Latent Effects for Reusable Language Components</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:50</end_time>
      <description>The development of programming languages can be quite complicated and costly. Hence, much effort has been devoted to the modular definition of language features that can be reused in various combinations to define new languages and experiment with their semantics. A notable outcome of these efforts is the algebra-based “datatypes à la carte” (DTC) approach. When combined with algebraic effects, DTC can model a wide range of common language features. Unfortunately, the current state of the art does not cover modular definitions of advanced control-flow mechanisms that defer execution to an appropriate point, such as call-by-name and call-by-need evaluation, as well as (multi-)staging. 
This paper defines latent effects, a generic class of such control-flow mechanisms. We demonstrate how function abstractions, lazy computations and a MetaML-like staging can all be expressed in a modular fashion using latent effects, and how they can be combined in various ways to obtain complex semantics. We provide a full Haskell implementation of our effects and handlers with a range of examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Birthe</first_name>
          <last_name>van den Berg</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/birthevandenberg/21e3094e-6010-4629-bfe1-8490394a9f9d/small.jpg</picture_url>
          <person_id>birthevandenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Casper</first_name>
          <last_name>Bach Poulsen</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://casperbp.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/casperbachpoulsen/2cddd6a9-d920-4f73-9fcf-f4d9462eb0e3/small.jpg</picture_url>
          <person_id>casperbachpoulsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Wu</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://zenzike.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nicolaswu/16dfcd93-2531-4de2-baee-d5a8d1a95a47/small.jpg</picture_url>
          <person_id>nicolaswu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1bb13709-47a1-40dc-b267-8cc31fda1179</slot_id>
      <event_id>eaee7960-f7b4-427d-8c7b-7bc3df70bc41</event_id>
      <title>Adaptable Traces for Program Explanations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:30</end_time>
      <description>Program traces are a sound basis for explaining the dynamic behavior of programs. Alas, program traces can grow big very quickly, even for small programs, which diminishes their value as explanations. 
In this paper we demonstrate how the systematic simplification of traces can yield succinct program explanations. Specifically, we introduce operations for transforming traces that facilitate the abstraction of details. The operations are the basis of a query language for the definition of trace filters that can adapt and simplify traces in a variety of ways. 
The generation of traces is governed by a variant of Call-By-Value semantics which specifically supports parsimony in trace representations. We show that our semantics is a conservative extension of Call-By-Value that can produce smaller traces and that the evaluation traces preserve the explanatory content of proof trees at a much smaller footprint.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Divya</first_name>
          <last_name>Bajaj</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>divyabajaj</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Erwig</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.engr.oregonstate.edu/~erwig/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinerwig/8fd12ecd-2d70-44d3-a670-d5ef12393f9c/small.jpg</picture_url>
          <person_id>martinerwig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Danila</first_name>
          <last_name>Fedorin</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>danilafedorin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kai</first_name>
          <last_name>Gay</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>kaigay</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f102028a-74fc-4bef-8707-7015d201c6b7</slot_id>
      <event_id>c504fd73-31ce-4375-a74d-fa36f0c6d31b</event_id>
      <title>A Typed Programmatic Interface to Contracts on the Blockchain</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:10</end_time>
      <description>Smart contract applications on the blockchain can only reach their full potential if they integrate seamlessly with traditional software systems via a programmatic interface. This interface should provide for originating and invoking contracts as well as observing the state of the blockchain. We propose a typed API for this purpose and establish some properties of the combined system. Specifically, we provide an execution model that enables us to prove type-safe interaction between programs and the blockchain. We establish further properties of the model that give rise to requirements on the API. A prototype of the interface is implemented in OCaml for the Tezos blockchain.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thi Thu Ha</first_name>
          <last_name>Doan</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <person_id>thithuhadoan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Peter</first_name>
          <last_name>Thiemann</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/peterthiemann/43fc0175-1745-4b3a-b626-86e10da76b86/small.jpg</picture_url>
          <person_id>peterthiemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>81d93fbf-00c1-4651-82fa-64e98ae6a545</subevent_id>
    <title>APLAS Research Papers: Compilation / Transformation</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>ee53eeba-812e-45c4-8490-3d711511fbe2</slot_id>
      <title>Session: APLAS Research Papers - Compilation / Transformation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>484b5a33-7865-41f5-b79d-9591166b3f77</slot_id>
      <event_id>e1a791fb-2102-4026-9fc8-3a9400cbe9c4</event_id>
      <title>A Dictionary-Passing Translation of Featherweight Go</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:10</end_time>
      <description>The Go programming language is an increasingly popular language but some of its features lack a formal investigation. This article explains Go’s resolution mechanism for overloaded methods and its support for structural subtyping by means of translation from Featherweight Go to a simple target language. The translation employs a form of dictionary passing known from type classes in Haskell and preserves the dynamic behavior of Featherweight Go programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Sulzmann</last_name>
          <affiliation>Karlsruhe University of Applied Sciences, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>martinsulzmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Wehr</last_name>
          <affiliation>Offenburg University of Applied Sciences</affiliation>
          <bio>undefined</bio>
          <person_id>stefanwehr</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>68d4f23f-cb8d-4650-8ed3-4cab2cd98771</slot_id>
      <event_id>0eb87a5c-311b-4a3b-b4b2-cf9a7aa967da</event_id>
      <title>Hybrid quantum-classical circuit simplification with the ZX-calculus</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>15:10</end_time>
      <description>We present a complete optimization procedure for hybrid quantum-classical circuits with classical parity logic. While common optimization techniques for quantum algorithms focus on rewriting solely the pure quantum segments, there is interest in applying a global optimization process for applications such as quantum error correction and quantum assertions. 
This work, based on the pure-quantum circuit optimization procedure by Duncan et al., uses an extension of the formal graphical ZX-calculus called ZX⏚ as an intermediary representation of the hybrid circuits to allow for granular optimizations below the quantum-gate level. We define a translation from hybrid circuits into diagrams that admit the graph-theoretical focused-gFlow property, needed for the final extraction back into a circuit. We then derive a number of gFlow-preserving optimization rules for ZX⏚ diagrams that reduce the size of the graph, and devise an strategy to find optimization opportunities by rewriting the diagram guided by a Gauss elimination process. Then, after extracting the circuit, we present a general procedure for detecting segments of circuit-like ZX⏚ diagrams which can be implemented with classical gates in the extracted circuit. We have implemented our optimization procedure as an extension to the open-source python library PyZX.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Agustín</first_name>
          <last_name>Borgna</last_name>
          <affiliation>Université de Lorraine, CNRS, Inria, LORIA F 54000 Nancy, France and Université Paris-Saclay, CNRS, Laboratoire Méthodes Formelles, 91405, Orsay, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://lmf.cnrs.fr/Perso/Agustin_Borgna</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/agustinborgna/54b0204f-16fa-459a-9354-1561aef2b474/small.jpg</picture_url>
          <person_id>agustinborgna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Perdrix</last_name>
          <affiliation>Université de Lorraine, CNRS, Inria, LORIA F 54000 Nancy, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://perdrix.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/simonperdrix/5f59b569-aef7-4704-9441-90a45a7981d4/small.jpg</picture_url>
          <person_id>simonperdrix</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Valiron</last_name>
          <affiliation>LRI, CentraleSupelec, Univ. Paris Saclay</affiliation>
          <bio>Assistant professor at CentraleSupelec.</bio>
          <homepage_url>http://www.monoidal.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitvaliron/ec85a2e3-534a-4377-8852-46bfe159b870/small.jpg</picture_url>
          <person_id>benoitvaliron</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7c6e6bef-8fd4-4460-8024-e058434e40df</slot_id>
      <event_id>9325b9d3-7399-47b6-a12b-9bdf3c315ab7</event_id>
      <title>A compilation method for dynamic typing in ML</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:30</end_time>
      <description>This paper develops a systematic method for extending a polymorphic type system of ML with dynamic typing, and implements the extension in SML#, a full-scale native code compiler of Standard ML. The core of the extension consists of an adaptation of the type-directed compilation method for non-parametric polymorphism to type tag abstraction and type tag generation guided by type abstraction and type application. To support existentially bound type variables in dynamic value elimination and user-level manipulation of dynamic values, the conventional type-directed compilation framework is extended with existential types and a mechanism to reify dynamic values to user-level datatypes. The resulting language achieves orthogonal integration of dynamic typing in ML; it supports all the standard features of ML, including polymorphic type inference, user-defined datatypes and pattern matching in programming with dynamic typing. The implementation readily provides various practical features, including polymorphic first-class pretty-printer, polymorphic deserialization, type-safe interface to database systems, and type-safe meta-programming. The paper demonstrates its practical usefulness through programming examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Ohori</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/atsushiohori/fb4f797b-bbfe-4073-8141-60f3fe8b2371/small.jpg</picture_url>
          <person_id>atsushiohori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Katsuhiro</first_name>
          <last_name>Ueno</last_name>
          <affiliation>Tohoku University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/katsuhiroueno/bd849dfa-47a5-43cd-92ef-8fe3a5fc7902/small.jpg</picture_url>
          <person_id>katsuhiroueno</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cb567c09-1019-48a2-9b12-26aa4b2447e0</slot_id>
      <event_id>1888d977-be71-4fae-b1d1-e7a23822c901</event_id>
      <title>Fully Abstract and Robust Compilation and How to Reconcile the Two, Abstractly</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:50</end_time>
      <description>The most prominent formal criterion for secure compilation is full abstraction, the preservation and reflection of contextual equivalence. Recent work introduced robust compilation, defined as the preservation of robust satisfaction of hyperproperties, i.e., their satisfaction against arbitrary attackers. In this paper, we initially set out to compare these two approaches to secure compilation. To that end, we provide an exact description of the hyperproperties that are robustly satisfied by programs compiled with a fully abstract compiler, and show that they can be meaningless or trivial. We then propose a novel criterion for secure compilation formulated in the framework of Mathematical Operational Semantics (MOS), guaranteeing both full abstraction and the preservation of robust satisfaction of hyperproperties in a more sensible manner.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Carmine</first_name>
          <last_name>Abate</last_name>
          <affiliation>Max Planck Institute for Security and Privacy, Bochum, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>carmineabate1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Busi</last_name>
          <affiliation>Università di Pisa - Dipartimento di Informatica</affiliation>
          <bio>undefined</bio>
          <person_id>matteobusi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stelios</first_name>
          <last_name>Tsampas</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://distrinet.cs.kuleuven.be/people/SteliosTsampas</homepage_url>
          <person_id>steliostsampas</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>efb54a3b-1ae4-46f9-bd58-03beef710999</subevent_id>
    <title>APLAS Research Papers: Analysis / Synthesis </title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>e50cd301-b400-4076-826b-40c5f13b76bf</slot_id>
      <title>Session: APLAS Research Papers - Analysis / Synthesis </title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>13bae0bd-98d7-4f31-a34d-8c7fcaa203ab</slot_id>
      <event_id>f4797ec2-3f39-4e93-87f9-3efc30cb9952</event_id>
      <title>Scalable and Modular Robustness Analysis of Deep Neural Networks</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:10</end_time>
      <description>As neural networks are trained to be deeper and larger, the scalability of neural network analyzer is urgently required. The main technical insight of our method is modularly analyzing neural networks by segmenting a network into blocks and conduct the analysis for each block. In particular, we propose the network block summarization technique to capture the behaviors within a network block using a block summary and leverage the summary to speed up the analysis process. We instantiate our method in the context of a CPU-version of the state-of-the-art analyzer DeepPoly and name our system as Bounded-Block Poly (BBPoly). We evaluate BBPoly extensively on various experiment settings. The experimental result indicates that our method yields comparable precision as DeepPoly but runs faster and requires less computational resources. For example, BBPoly can analyze really large neural networks like SkipNet or ResNet which contain up to one million neurons in less than around 1 hour per input image, while DeepPoly needs to spend even 40 hours to analyze one image.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuyi</first_name>
          <last_name>Zhong</last_name>
          <affiliation>School of Computing, National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>yuyizhong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Quang-Trung</first_name>
          <last_name>Ta</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>quangtrungta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tianzuo</first_name>
          <last_name>Luo</last_name>
          <affiliation>School of Computing, National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>tianzuoluo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fanlong</first_name>
          <last_name>ZHANG</last_name>
          <affiliation>School of Computer, Guangdong University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>fanlongzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Siau-Cheng</first_name>
          <last_name>Khoo</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~khoosc/</homepage_url>
          <person_id>siauchengkhoo</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>53ae5dbf-b7f9-499f-a830-58574682bac5</slot_id>
      <event_id>907e9700-9131-4487-bb17-c947fd91adb2</event_id>
      <title>Program Synthesis for Musicians: A Usability Testbed for Temporal Logic Specifications</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>11:43</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:56</end_time>
      <description>In recent years, program synthesis research has made significant progress in creating user-friendly tools for Programming by example (PBE) and Programming by demonstration (PBD) environments. However, program synthesis from logical specifications, such as reactive synthesis, still faces large challenges in widespread adoption. In order to bring reactive synthesis to a wider audience, more research is necessary to explore different interface options. We present The SynthSynthesizer, a music-based tool for designing and testing specification interfaces. The tool enables researchers to prototype different interfaces for reactive synthesis and run user studies on them. The tool is accessible to both researchers and users by running on a browser on top of a docker-containerized synthesis toolchain. We show sample implementations with the tool by creating dropdown interfaces, and by running a user study with 21 users.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wonhyuk</first_name>
          <last_name>Choi</last_name>
          <affiliation>Columbia University</affiliation>
          <bio>undefined</bio>
          <person_id>wonhyukchoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michel</first_name>
          <last_name>Vazirani</last_name>
          <affiliation>Columbia University</affiliation>
          <bio>undefined</bio>
          <person_id>michelvazirani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mark</first_name>
          <last_name>Santolucito</last_name>
          <affiliation>Barnard College, Columbia University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.marksantolucito.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marksantolucito/51821284-64c1-46e0-b979-96e8324079bf/small.jpg</picture_url>
          <person_id>marksantolucito</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>58ac6bd6-8550-452f-bd59-6eb9ebb936ad</slot_id>
      <event_id>764db38c-a04e-4c02-b590-2c2572e8c133</event_id>
      <title>Server-Side Computation of Package Dependencies in Package-Management Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:30</end_time>
      <description>Package managers are often used in recent software development to obtain directly-dependent packages recursively. Typically, package managers make requests to the package registry more than once when computing indirect dependencies. Moreover, much amount of computations are duplicated by clients of package managers. This duplication can be avoided by computing indirect dependencies in advance on the server-side of package-management systems. Therefore, we propose two algorithms functioning in parallel on the server-side: one to compute the indirect dependencies when copying all packages in existing package managers to the server and one to add packages to the server. Based on these parallelized algorithms, we implement a server {\tt fpms-server} and a client {\tt fpms} for npm packages. By our experiments, our client obtains dependencies of some package more than two times faster than clients in existing npm and yarn systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nobuhiro</first_name>
          <last_name>Kasai</last_name>
          <affiliation>Shibaura Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>nobuhirokasai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isao</first_name>
          <last_name>Sasano</last_name>
          <affiliation>Shibaura Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.sic.shibaura-it.ac.jp/~sasano/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/isaosasano/b77a139b-e948-4f6c-ad81-8afe7cb17d0e/small.jpg</picture_url>
          <person_id>isaosasano</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>923bbf0b-29a6-4487-8cc6-61fe53e5da3e</slot_id>
      <event_id>47844a39-78c0-49b3-8e9b-cfa59c9eb1d2</event_id>
      <title>Function Pointer Eliminator for C Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>11:56</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>12:09</end_time>
      <description>Verification of memory safety such as absence of null pointer dereferences and memory leaks in system software is important in practice. O’Hearn’s group proposed a new method of memory safety analysis/verification by modular abstract interpretation with separation logic and biabduction. To realize this method, one has to construct a call graph before the modular abstract interpretation. This paper aims to analyze/verify memory safety of system software written in C programming language by this method, and as the first step this paper provides a function pointer eliminator tool to eliminate function pointer calls in order to construct a call graph. The tool uses SVF for pointer analysis. First C programs are translated into LLVM programs by Clang and then SVF analyses the LLVM programs. The tool given in this paper finds correspondence between function pointer calls in C programs and those in LLVM programs, and transforms the C programs into C programs with the same functionality and without any function pointer calls. The experimental results for gzip, git, and OpenSSL using this function pointer eliminator are presented and they show that this tool is sufficiently efficient and precise for the purpose.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daisuke</first_name>
          <last_name>Kimura</last_name>
          <affiliation>Toho University	</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/daisukekimura/6b912400-e3bf-44b2-b9c9-9d6412dee364/small.jpg</picture_url>
          <person_id>daisukekimura</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mahmudul Faisal Al</first_name>
          <last_name>Ameen</last_name>
          <affiliation>University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>mahmudulfaisalalameen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Makoto</first_name>
          <last_name>Tatsuta</last_name>
          <affiliation>National Institute of Informatics</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.nii.ac.jp/~tatsuta/index-e.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/makototatsuta/a8798f89-7cfc-4ef4-af83-3c5b65ffa4df/small.jpg</picture_url>
          <person_id>makototatsuta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Koji</first_name>
          <last_name>Nakazawa</last_name>
          <affiliation>Nagoya University</affiliation>
          <bio>undefined</bio>
          <person_id>kojinakazawa1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ab5c4cd4-c583-4d0a-82be-00a8b202df09</slot_id>
      <event_id>2cf3b543-8892-48b1-956b-60a7954965d1</event_id>
      <title>PyCT: A Python Concolic Tester</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:43</end_time>
      <description>Concolic testing is a software testing technique for generating concrete inputs of programs to increase code coverage and has been developed for years. For programming languages such as C, JAVA, x86 binary code, and JavaScript, there are already plenty of available concolic testers. However, the concolic testers for Python are relatively less. Since Python is a popular programming language, we believe there is a strong need to develop a good one. 
Among the existing testers for Python, PyExZ3 is the most well-known and advanced. However, we found some issues of PyExZ3: (1) it implements only a limited number of base types’ (e.g., integer, string) member functions and(2) it automatically downcasts concolic objects and discards related symbolic information as it encounters built-in types’ constructors. 
Based on the concept of PyExZ3, we develop a new tool called PyCT to alleviate these two issues. PyCT supports a more complete set of member functions of data types including integer, string, and range. We also proposes a new method to upcast constants to concolic ones to prevent unnecessary downcasting. Our evaluation shows that with more member functions being supported, the coverage rate is raised to (80.20%) from (71.55%). It continues to go up to (85.68%) as constant upcasting is also implemented.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wei-Lun</first_name>
          <last_name>Tsai</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>weiluntsai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wei-Cheng</first_name>
          <last_name>Wu</last_name>
          <affiliation>University of Southern California, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://steel.isi.edu/members/weicheng</homepage_url>
          <person_id>weichengwu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Di-De</first_name>
          <last_name>Yen</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>dideyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fang</first_name>
          <last_name>Yu</last_name>
          <affiliation>National Chengchi University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/fangyu/4400f412-1da9-4bf0-80c5-3011774ce2cc/small.jpg</picture_url>
          <person_id>fangyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yu-Fang</first_name>
          <last_name>Chen</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iis.sinica.edu.tw/~yfc/doku.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yufangchen/87eecff2-df03-4022-9c4e-7d96872d36c4/small.jpg</picture_url>
          <person_id>yufangchen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>764c79f2-6419-4ad8-b498-890becb2043c</subevent_id>
    <title>APLAS Research Papers: Compilation / Transformation (mirror)</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>347f705b-85eb-477f-b22f-4bb7bd7aad04</slot_id>
      <title>Session: APLAS Research Papers - Compilation / Transformation (mirror)</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3978daec-464f-46dd-9134-26deb2308b49</slot_id>
      <event_id>e1a791fb-2102-4026-9fc8-3a9400cbe9c4</event_id>
      <title>A Dictionary-Passing Translation of Featherweight Go</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:10</end_time>
      <description>The Go programming language is an increasingly popular language but some of its features lack a formal investigation. This article explains Go’s resolution mechanism for overloaded methods and its support for structural subtyping by means of translation from Featherweight Go to a simple target language. The translation employs a form of dictionary passing known from type classes in Haskell and preserves the dynamic behavior of Featherweight Go programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Sulzmann</last_name>
          <affiliation>Karlsruhe University of Applied Sciences, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>martinsulzmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Wehr</last_name>
          <affiliation>Offenburg University of Applied Sciences</affiliation>
          <bio>undefined</bio>
          <person_id>stefanwehr</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6b214269-6887-4e14-9886-62843836a082</slot_id>
      <event_id>9325b9d3-7399-47b6-a12b-9bdf3c315ab7</event_id>
      <title>A compilation method for dynamic typing in ML</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>22:10</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:30</end_time>
      <description>This paper develops a systematic method for extending a polymorphic type system of ML with dynamic typing, and implements the extension in SML#, a full-scale native code compiler of Standard ML. The core of the extension consists of an adaptation of the type-directed compilation method for non-parametric polymorphism to type tag abstraction and type tag generation guided by type abstraction and type application. To support existentially bound type variables in dynamic value elimination and user-level manipulation of dynamic values, the conventional type-directed compilation framework is extended with existential types and a mechanism to reify dynamic values to user-level datatypes. The resulting language achieves orthogonal integration of dynamic typing in ML; it supports all the standard features of ML, including polymorphic type inference, user-defined datatypes and pattern matching in programming with dynamic typing. The implementation readily provides various practical features, including polymorphic first-class pretty-printer, polymorphic deserialization, type-safe interface to database systems, and type-safe meta-programming. The paper demonstrates its practical usefulness through programming examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Ohori</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/atsushiohori/fb4f797b-bbfe-4073-8141-60f3fe8b2371/small.jpg</picture_url>
          <person_id>atsushiohori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Katsuhiro</first_name>
          <last_name>Ueno</last_name>
          <affiliation>Tohoku University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/katsuhiroueno/bd849dfa-47a5-43cd-92ef-8fe3a5fc7902/small.jpg</picture_url>
          <person_id>katsuhiroueno</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a508fd0d-28bc-40af-894b-850ab3e12f5c</slot_id>
      <event_id>0eb87a5c-311b-4a3b-b4b2-cf9a7aa967da</event_id>
      <title>Hybrid quantum-classical circuit simplification with the ZX-calculus</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>23:10</end_time>
      <description>We present a complete optimization procedure for hybrid quantum-classical circuits with classical parity logic. While common optimization techniques for quantum algorithms focus on rewriting solely the pure quantum segments, there is interest in applying a global optimization process for applications such as quantum error correction and quantum assertions. 
This work, based on the pure-quantum circuit optimization procedure by Duncan et al., uses an extension of the formal graphical ZX-calculus called ZX⏚ as an intermediary representation of the hybrid circuits to allow for granular optimizations below the quantum-gate level. We define a translation from hybrid circuits into diagrams that admit the graph-theoretical focused-gFlow property, needed for the final extraction back into a circuit. We then derive a number of gFlow-preserving optimization rules for ZX⏚ diagrams that reduce the size of the graph, and devise an strategy to find optimization opportunities by rewriting the diagram guided by a Gauss elimination process. Then, after extracting the circuit, we present a general procedure for detecting segments of circuit-like ZX⏚ diagrams which can be implemented with classical gates in the extracted circuit. We have implemented our optimization procedure as an extension to the open-source python library PyZX.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Agustín</first_name>
          <last_name>Borgna</last_name>
          <affiliation>Université de Lorraine, CNRS, Inria, LORIA F 54000 Nancy, France and Université Paris-Saclay, CNRS, Laboratoire Méthodes Formelles, 91405, Orsay, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://lmf.cnrs.fr/Perso/Agustin_Borgna</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/agustinborgna/54b0204f-16fa-459a-9354-1561aef2b474/small.jpg</picture_url>
          <person_id>agustinborgna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Perdrix</last_name>
          <affiliation>Université de Lorraine, CNRS, Inria, LORIA F 54000 Nancy, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://perdrix.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/simonperdrix/5f59b569-aef7-4704-9441-90a45a7981d4/small.jpg</picture_url>
          <person_id>simonperdrix</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Valiron</last_name>
          <affiliation>LRI, CentraleSupelec, Univ. Paris Saclay</affiliation>
          <bio>Assistant professor at CentraleSupelec.</bio>
          <homepage_url>http://www.monoidal.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitvaliron/ec85a2e3-534a-4377-8852-46bfe159b870/small.jpg</picture_url>
          <person_id>benoitvaliron</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca1f1507-cecb-4997-8bbb-fe4055c85285</slot_id>
      <event_id>1888d977-be71-4fae-b1d1-e7a23822c901</event_id>
      <title>Fully Abstract and Robust Compilation and How to Reconcile the Two, Abstractly</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>22:30</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:50</end_time>
      <description>The most prominent formal criterion for secure compilation is full abstraction, the preservation and reflection of contextual equivalence. Recent work introduced robust compilation, defined as the preservation of robust satisfaction of hyperproperties, i.e., their satisfaction against arbitrary attackers. In this paper, we initially set out to compare these two approaches to secure compilation. To that end, we provide an exact description of the hyperproperties that are robustly satisfied by programs compiled with a fully abstract compiler, and show that they can be meaningless or trivial. We then propose a novel criterion for secure compilation formulated in the framework of Mathematical Operational Semantics (MOS), guaranteeing both full abstraction and the preservation of robust satisfaction of hyperproperties in a more sensible manner.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Carmine</first_name>
          <last_name>Abate</last_name>
          <affiliation>Max Planck Institute for Security and Privacy, Bochum, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>carmineabate1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Busi</last_name>
          <affiliation>Università di Pisa - Dipartimento di Informatica</affiliation>
          <bio>undefined</bio>
          <person_id>matteobusi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stelios</first_name>
          <last_name>Tsampas</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://distrinet.cs.kuleuven.be/people/SteliosTsampas</homepage_url>
          <person_id>steliostsampas</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1f150c98-7f85-40e1-8b01-1912bf3c6cf8</subevent_id>
    <title>APLAS Research Papers: Analysis / Synthesis (mirror)</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>c73123c7-03b5-428d-aafa-6869e065fc65</slot_id>
      <title>Session: APLAS Research Papers - Analysis / Synthesis (mirror)</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>36854ace-68ad-4b9d-9206-43bedbb3685c</slot_id>
      <event_id>907e9700-9131-4487-bb17-c947fd91adb2</event_id>
      <title>Program Synthesis for Musicians: A Usability Testbed for Temporal Logic Specifications</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>19:43</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:56</end_time>
      <description>In recent years, program synthesis research has made significant progress in creating user-friendly tools for Programming by example (PBE) and Programming by demonstration (PBD) environments. However, program synthesis from logical specifications, such as reactive synthesis, still faces large challenges in widespread adoption. In order to bring reactive synthesis to a wider audience, more research is necessary to explore different interface options. We present The SynthSynthesizer, a music-based tool for designing and testing specification interfaces. The tool enables researchers to prototype different interfaces for reactive synthesis and run user studies on them. The tool is accessible to both researchers and users by running on a browser on top of a docker-containerized synthesis toolchain. We show sample implementations with the tool by creating dropdown interfaces, and by running a user study with 21 users.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wonhyuk</first_name>
          <last_name>Choi</last_name>
          <affiliation>Columbia University</affiliation>
          <bio>undefined</bio>
          <person_id>wonhyukchoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michel</first_name>
          <last_name>Vazirani</last_name>
          <affiliation>Columbia University</affiliation>
          <bio>undefined</bio>
          <person_id>michelvazirani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mark</first_name>
          <last_name>Santolucito</last_name>
          <affiliation>Barnard College, Columbia University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.marksantolucito.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marksantolucito/51821284-64c1-46e0-b979-96e8324079bf/small.jpg</picture_url>
          <person_id>marksantolucito</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>533d993a-6f5c-488f-b9d8-83560ade1bbc</slot_id>
      <event_id>2cf3b543-8892-48b1-956b-60a7954965d1</event_id>
      <title>PyCT: A Python Concolic Tester</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>19:30</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:43</end_time>
      <description>Concolic testing is a software testing technique for generating concrete inputs of programs to increase code coverage and has been developed for years. For programming languages such as C, JAVA, x86 binary code, and JavaScript, there are already plenty of available concolic testers. However, the concolic testers for Python are relatively less. Since Python is a popular programming language, we believe there is a strong need to develop a good one. 
Among the existing testers for Python, PyExZ3 is the most well-known and advanced. However, we found some issues of PyExZ3: (1) it implements only a limited number of base types’ (e.g., integer, string) member functions and(2) it automatically downcasts concolic objects and discards related symbolic information as it encounters built-in types’ constructors. 
Based on the concept of PyExZ3, we develop a new tool called PyCT to alleviate these two issues. PyCT supports a more complete set of member functions of data types including integer, string, and range. We also proposes a new method to upcast constants to concolic ones to prevent unnecessary downcasting. Our evaluation shows that with more member functions being supported, the coverage rate is raised to (80.20%) from (71.55%). It continues to go up to (85.68%) as constant upcasting is also implemented.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wei-Lun</first_name>
          <last_name>Tsai</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>weiluntsai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wei-Cheng</first_name>
          <last_name>Wu</last_name>
          <affiliation>University of Southern California, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://steel.isi.edu/members/weicheng</homepage_url>
          <person_id>weichengwu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Di-De</first_name>
          <last_name>Yen</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>dideyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fang</first_name>
          <last_name>Yu</last_name>
          <affiliation>National Chengchi University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/fangyu/4400f412-1da9-4bf0-80c5-3011774ce2cc/small.jpg</picture_url>
          <person_id>fangyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yu-Fang</first_name>
          <last_name>Chen</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iis.sinica.edu.tw/~yfc/doku.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yufangchen/87eecff2-df03-4022-9c4e-7d96872d36c4/small.jpg</picture_url>
          <person_id>yufangchen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7e7848f4-a1a5-469c-836f-a3dd298bddf6</slot_id>
      <event_id>f4797ec2-3f39-4e93-87f9-3efc30cb9952</event_id>
      <title>Scalable and Modular Robustness Analysis of Deep Neural Networks</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:10</end_time>
      <description>As neural networks are trained to be deeper and larger, the scalability of neural network analyzer is urgently required. The main technical insight of our method is modularly analyzing neural networks by segmenting a network into blocks and conduct the analysis for each block. In particular, we propose the network block summarization technique to capture the behaviors within a network block using a block summary and leverage the summary to speed up the analysis process. We instantiate our method in the context of a CPU-version of the state-of-the-art analyzer DeepPoly and name our system as Bounded-Block Poly (BBPoly). We evaluate BBPoly extensively on various experiment settings. The experimental result indicates that our method yields comparable precision as DeepPoly but runs faster and requires less computational resources. For example, BBPoly can analyze really large neural networks like SkipNet or ResNet which contain up to one million neurons in less than around 1 hour per input image, while DeepPoly needs to spend even 40 hours to analyze one image.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuyi</first_name>
          <last_name>Zhong</last_name>
          <affiliation>School of Computing, National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>yuyizhong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Quang-Trung</first_name>
          <last_name>Ta</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>quangtrungta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tianzuo</first_name>
          <last_name>Luo</last_name>
          <affiliation>School of Computing, National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>tianzuoluo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fanlong</first_name>
          <last_name>ZHANG</last_name>
          <affiliation>School of Computer, Guangdong University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>fanlongzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Siau-Cheng</first_name>
          <last_name>Khoo</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~khoosc/</homepage_url>
          <person_id>siauchengkhoo</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b0ac3866-f7af-4c56-9f8d-1c232a7bc1ff</slot_id>
      <event_id>47844a39-78c0-49b3-8e9b-cfa59c9eb1d2</event_id>
      <title>Function Pointer Eliminator for C Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>19:56</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>20:09</end_time>
      <description>Verification of memory safety such as absence of null pointer dereferences and memory leaks in system software is important in practice. O’Hearn’s group proposed a new method of memory safety analysis/verification by modular abstract interpretation with separation logic and biabduction. To realize this method, one has to construct a call graph before the modular abstract interpretation. This paper aims to analyze/verify memory safety of system software written in C programming language by this method, and as the first step this paper provides a function pointer eliminator tool to eliminate function pointer calls in order to construct a call graph. The tool uses SVF for pointer analysis. First C programs are translated into LLVM programs by Clang and then SVF analyses the LLVM programs. The tool given in this paper finds correspondence between function pointer calls in C programs and those in LLVM programs, and transforms the C programs into C programs with the same functionality and without any function pointer calls. The experimental results for gzip, git, and OpenSSL using this function pointer eliminator are presented and they show that this tool is sufficiently efficient and precise for the purpose.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daisuke</first_name>
          <last_name>Kimura</last_name>
          <affiliation>Toho University	</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/daisukekimura/6b912400-e3bf-44b2-b9c9-9d6412dee364/small.jpg</picture_url>
          <person_id>daisukekimura</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mahmudul Faisal Al</first_name>
          <last_name>Ameen</last_name>
          <affiliation>University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>mahmudulfaisalalameen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Makoto</first_name>
          <last_name>Tatsuta</last_name>
          <affiliation>National Institute of Informatics</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.nii.ac.jp/~tatsuta/index-e.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/makototatsuta/a8798f89-7cfc-4ef4-af83-3c5b65ffa4df/small.jpg</picture_url>
          <person_id>makototatsuta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Koji</first_name>
          <last_name>Nakazawa</last_name>
          <affiliation>Nagoya University</affiliation>
          <bio>undefined</bio>
          <person_id>kojinakazawa1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c458ef6a-1a93-4a39-a71d-7b47b6471619</slot_id>
      <event_id>764db38c-a04e-4c02-b590-2c2572e8c133</event_id>
      <title>Server-Side Computation of Package Dependencies in Package-Management Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>19:10</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:30</end_time>
      <description>Package managers are often used in recent software development to obtain directly-dependent packages recursively. Typically, package managers make requests to the package registry more than once when computing indirect dependencies. Moreover, much amount of computations are duplicated by clients of package managers. This duplication can be avoided by computing indirect dependencies in advance on the server-side of package-management systems. Therefore, we propose two algorithms functioning in parallel on the server-side: one to compute the indirect dependencies when copying all packages in existing package managers to the server and one to add packages to the server. Based on these parallelized algorithms, we implement a server {\tt fpms-server} and a client {\tt fpms} for npm packages. By our experiments, our client obtains dependencies of some package more than two times faster than clients in existing npm and yarn systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nobuhiro</first_name>
          <last_name>Kasai</last_name>
          <affiliation>Shibaura Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>nobuhirokasai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isao</first_name>
          <last_name>Sasano</last_name>
          <affiliation>Shibaura Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.sic.shibaura-it.ac.jp/~sasano/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/isaosasano/b77a139b-e948-4f6c-ad81-8afe7cb17d0e/small.jpg</picture_url>
          <person_id>isaosasano</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0d862d47-34b5-4845-8874-2ffdda2bcb0f</subevent_id>
    <title>APLAS Research Papers: Verification / Theory (mirror)</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>a108d5af-3c9a-48bb-9fcb-dea304d1825c</slot_id>
      <title>Session: APLAS Research Papers - Verification / Theory (mirror)</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>59d2efb5-1fdd-4a96-ab34-9cd1de5674e1</slot_id>
      <event_id>3b8750a2-df2f-4f69-b8bc-4984930a61a6</event_id>
      <title>Termination Analysis for the $\pi$-Calculus by Reduction to Sequential Program Termination</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>23:10</end_time>
      <description>We propose an automated method for proving termination of $\pi$-calculus processes, based on a reduction to termination of sequential programs: we translate a $\pi$-calculus process to a sequential program, so that the termination of the latter implies that of the former. We can then use an off-the-shelf termination verification tool to check termination of the sequential program. Our approach has been partially inspired by Deng and Sangiorgi’s termination analysis for the $\pi$-calculus, and checks that there is no infinite chain of communications on replicated input channels, by converting such a chain of communications to a chain of recursive function calls in the target sequential program. We have implemented an automated tool based on the proposed method and confirmed its effectiveness.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tsubasa</first_name>
          <last_name>Shoshi</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>tsubasashoshi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Takuma</first_name>
          <last_name>Ishikawa</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>takumaishikawa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ken</first_name>
          <last_name>Sakayori</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>kensakayori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ryosuke</first_name>
          <last_name>Sato</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-kb.is.s.u-tokyo.ac.jp/~ryosuke/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ryosukesato/dde2fccf-e07f-48f8-9dc9-277cb124e664/small.jpg</picture_url>
          <person_id>ryosukesato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Takeshi</first_name>
          <last_name>Tsukada</last_name>
          <affiliation>Chiba University, Japan</affiliation>
          <bio>undefined</bio>
          <person_id>takeshitsukada</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aee683f7-3465-4816-942a-e73ffbd5f0c9</slot_id>
      <event_id>098ed30d-d2aa-4c91-bf58-0f28a84ad9b2</event_id>
      <title>Solving Not-Substring with Flat Abstraction</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>22:30</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:50</end_time>
      <description>Not-substring is currently among the least supported types of string constraints, and existing solvers use only relatively crude heuristics. Yet, not-substring occurs relatively often in practical examples and is useful in encoding other types of constraints. In this paper, we propose a systematic way to solve not-substring using the Counter-Example Guided Abstraction Refinement (CEGAR) framework based on flat abstraction. In such a framework, the domain of string variables is restricted to flat languages and subsequently, the whole constraints can be expressed as linear arithmetic formulae. We show that non-substring constraints can be flattened efficiently, and provide experimental evidence that the proposed solution for not-substring is competitive with the state-of-the-art string solvers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Parosh Aziz</first_name>
          <last_name>Abdulla</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://user.it.uu.se/~parosh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/paroshazizabdulla/342a7738-db1c-42a1-91cc-3b9467086b87/small.jpg</picture_url>
          <person_id>paroshazizabdulla</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mohamed Faouzi</first_name>
          <last_name>Atig</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>Mohamed Faouzi Atig is a senior lecturer at the Department of Information Technology, Uppsala University. Previously, he was a Post-doctoral researcher at Uppsala University from July 2010 to March 2012. He obtained his doctoral degree in Computer Science from the University of Paris Diderot- Paris 7 (France) in 2010. His research interests broadly span model checking, verification of infinite state systems, weak memory models, and automata theory.</bio>
          <homepage_url>http://www.it.uu.se/katalog/mohat117</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mohamedfaouziatig/5061fc57-1b58-42f4-965d-a1c64ca186dd/small.jpg</picture_url>
          <person_id>mohamedfaouziatig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yu-Fang</first_name>
          <last_name>Chen</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iis.sinica.edu.tw/~yfc/doku.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yufangchen/87eecff2-df03-4022-9c4e-7d96872d36c4/small.jpg</picture_url>
          <person_id>yufangchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bui Phi</first_name>
          <last_name>Diep</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://diepbp.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/phidiepbui/04bc8805-8f6c-407b-be9a-d693717be6b3/small.jpg</picture_url>
          <person_id>phidiepbui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Denghang</first_name>
          <last_name>Hu</last_name>
          <affiliation>State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
          <person_id>denghanghu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Wei-Lun</first_name>
          <last_name>Tsai</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>weiluntsai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Zhilin</first_name>
          <last_name>Wu</last_name>
          <affiliation>State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
          <person_id>zhilinwu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Di-De</first_name>
          <last_name>Yen</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>dideyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b8a114ab-8394-4bdd-ace8-ac7fc68f91ad</slot_id>
      <event_id>b9215798-f744-4c16-93b2-8d43afb864c8</event_id>
      <title>Preprocessing of Alternating Automata for Language Emptiness Testing</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:10</end_time>
      <description>We propose preprocessing techniques that improve efficiency of testing language emptiness of alternating automata. We target mainly automata that come from practical application such as string solving or processing of LTL formulae. Such automata often have large alphabets and transition relations represented by succinct and complex Boolean formulae that are more or less unrestricted and may even mix symbols with states. Our main contribution are simplification methods that can be seen as originating from a limited form determinisation, and we also use some simple Boolean transformations of the transition formulae. Our transformations simplify the transition formulae and decrease the number of states. We evaluate experimentally that our preprocessing is beneficial when used together with most of the existing algorithms. It generally improves running times and even allows to solve examples that could not be solved before within a reasonable timeout.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pavol</first_name>
          <last_name>Vargovčík</last_name>
          <affiliation>Brno University of Technology, Czech Republic</affiliation>
          <bio>undefined</bio>
          <person_id>pavolvargovcik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ba9a1fa7-f43f-49c4-924b-c8232a96927b</slot_id>
      <event_id>a4646d88-3a99-4d96-b6af-bf0af08c54cc</event_id>
      <title>Proving LTL Properties of Bitvector Programs and Decompiled Binaries</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>22:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:30</end_time>
      <description>There is increasing interest in applying verification tools to programs that have bitvector operations. SMT solvers, which serve as a foundation for these tools, have thus increased support for bitvector reasoning through bit-blasting and linear arithmetic approximations. In this paper we show that similar linear arithmetic approximation of bitvector operations can be done at the source level through transformations. Specifically, we introduce new paths that over-approximate bitvector operations with linear conditions/constraints, increasing branching but allowing us to better exploit the well-developed integer reasoning and interpolation of verification tools. We show that, for reachability of bitvector programs, increased branching incurs negligible overhead yet, when combined with integer interpolation optimizations, enables more programs to be verified. We further show this exploitation of integer interpolation in the common case also enables competitive termination verification of bitvector programs and leads to the first effective technique for LTL verification of bitvector programs. Finally, we provide an in-depth case study of decompiled (“lifted”) binary programs, which emulate X86 execution through frequent use of bitvector operations. We present a new tool DarkSea, the first tool capable of verifying reachability, termination, and LTL of lifted binaries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Liu</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/cyrusliu/73881ecf-5211-4146-9424-7f9670e3f77b/small.jpg</picture_url>
          <person_id>cyrusliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chengbin</first_name>
          <last_name>Pang</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>chengbinpang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Dietsch</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://swt.informatik.uni-freiburg.de/staff/dietsch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danieldietsch/965245d6-e31d-4645-94f0-10a113edfe53/small.jpg</picture_url>
          <person_id>danieldietsch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eric</first_name>
          <last_name>Koskinen</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.stevens.edu/~ejk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/erickoskinen/3413fc94-5f0f-4855-af65-da2309d2632f/small.jpg</picture_url>
          <person_id>erickoskinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ton Chanh</first_name>
          <last_name>Le</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://letonchanh.github.io/</homepage_url>
          <person_id>tonchanhle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Portokalidis</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>georgiosportokalidis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Jun</first_name>
          <last_name>Xu</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>junxu2</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cfc9ddc3-7f06-429a-b968-74bacf458b17</subevent_id>
    <title>APLAS Research Papers: Verification / Theory</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>785ac9f1-7973-4855-98c6-5e3607fc6665</slot_id>
      <title>Session: APLAS Research Papers - Verification / Theory</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>066dde5b-5e0a-44f8-a0ba-07ac6068b237</slot_id>
      <event_id>098ed30d-d2aa-4c91-bf58-0f28a84ad9b2</event_id>
      <title>Solving Not-Substring with Flat Abstraction</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:50</end_time>
      <description>Not-substring is currently among the least supported types of string constraints, and existing solvers use only relatively crude heuristics. Yet, not-substring occurs relatively often in practical examples and is useful in encoding other types of constraints. In this paper, we propose a systematic way to solve not-substring using the Counter-Example Guided Abstraction Refinement (CEGAR) framework based on flat abstraction. In such a framework, the domain of string variables is restricted to flat languages and subsequently, the whole constraints can be expressed as linear arithmetic formulae. We show that non-substring constraints can be flattened efficiently, and provide experimental evidence that the proposed solution for not-substring is competitive with the state-of-the-art string solvers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Parosh Aziz</first_name>
          <last_name>Abdulla</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://user.it.uu.se/~parosh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/paroshazizabdulla/342a7738-db1c-42a1-91cc-3b9467086b87/small.jpg</picture_url>
          <person_id>paroshazizabdulla</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mohamed Faouzi</first_name>
          <last_name>Atig</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>Mohamed Faouzi Atig is a senior lecturer at the Department of Information Technology, Uppsala University. Previously, he was a Post-doctoral researcher at Uppsala University from July 2010 to March 2012. He obtained his doctoral degree in Computer Science from the University of Paris Diderot- Paris 7 (France) in 2010. His research interests broadly span model checking, verification of infinite state systems, weak memory models, and automata theory.</bio>
          <homepage_url>http://www.it.uu.se/katalog/mohat117</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mohamedfaouziatig/5061fc57-1b58-42f4-965d-a1c64ca186dd/small.jpg</picture_url>
          <person_id>mohamedfaouziatig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yu-Fang</first_name>
          <last_name>Chen</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iis.sinica.edu.tw/~yfc/doku.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yufangchen/87eecff2-df03-4022-9c4e-7d96872d36c4/small.jpg</picture_url>
          <person_id>yufangchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bui Phi</first_name>
          <last_name>Diep</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://diepbp.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/phidiepbui/04bc8805-8f6c-407b-be9a-d693717be6b3/small.jpg</picture_url>
          <person_id>phidiepbui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Denghang</first_name>
          <last_name>Hu</last_name>
          <affiliation>State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
          <person_id>denghanghu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Wei-Lun</first_name>
          <last_name>Tsai</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>weiluntsai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Zhilin</first_name>
          <last_name>Wu</last_name>
          <affiliation>State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
          <person_id>zhilinwu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Di-De</first_name>
          <last_name>Yen</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>dideyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4133b75a-5d64-4cb8-a00c-bbddc9c9b193</slot_id>
      <event_id>3b8750a2-df2f-4f69-b8bc-4984930a61a6</event_id>
      <title>Termination Analysis for the $\pi$-Calculus by Reduction to Sequential Program Termination</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>15:10</end_time>
      <description>We propose an automated method for proving termination of $\pi$-calculus processes, based on a reduction to termination of sequential programs: we translate a $\pi$-calculus process to a sequential program, so that the termination of the latter implies that of the former. We can then use an off-the-shelf termination verification tool to check termination of the sequential program. Our approach has been partially inspired by Deng and Sangiorgi’s termination analysis for the $\pi$-calculus, and checks that there is no infinite chain of communications on replicated input channels, by converting such a chain of communications to a chain of recursive function calls in the target sequential program. We have implemented an automated tool based on the proposed method and confirmed its effectiveness.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tsubasa</first_name>
          <last_name>Shoshi</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>tsubasashoshi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Takuma</first_name>
          <last_name>Ishikawa</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>takumaishikawa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ken</first_name>
          <last_name>Sakayori</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>kensakayori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ryosuke</first_name>
          <last_name>Sato</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-kb.is.s.u-tokyo.ac.jp/~ryosuke/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ryosukesato/dde2fccf-e07f-48f8-9dc9-277cb124e664/small.jpg</picture_url>
          <person_id>ryosukesato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Takeshi</first_name>
          <last_name>Tsukada</last_name>
          <affiliation>Chiba University, Japan</affiliation>
          <bio>undefined</bio>
          <person_id>takeshitsukada</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>788c9e95-95bc-4d21-bf52-c42804302dd8</slot_id>
      <event_id>a4646d88-3a99-4d96-b6af-bf0af08c54cc</event_id>
      <title>Proving LTL Properties of Bitvector Programs and Decompiled Binaries</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:30</end_time>
      <description>There is increasing interest in applying verification tools to programs that have bitvector operations. SMT solvers, which serve as a foundation for these tools, have thus increased support for bitvector reasoning through bit-blasting and linear arithmetic approximations. In this paper we show that similar linear arithmetic approximation of bitvector operations can be done at the source level through transformations. Specifically, we introduce new paths that over-approximate bitvector operations with linear conditions/constraints, increasing branching but allowing us to better exploit the well-developed integer reasoning and interpolation of verification tools. We show that, for reachability of bitvector programs, increased branching incurs negligible overhead yet, when combined with integer interpolation optimizations, enables more programs to be verified. We further show this exploitation of integer interpolation in the common case also enables competitive termination verification of bitvector programs and leads to the first effective technique for LTL verification of bitvector programs. Finally, we provide an in-depth case study of decompiled (“lifted”) binary programs, which emulate X86 execution through frequent use of bitvector operations. We present a new tool DarkSea, the first tool capable of verifying reachability, termination, and LTL of lifted binaries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Liu</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/cyrusliu/73881ecf-5211-4146-9424-7f9670e3f77b/small.jpg</picture_url>
          <person_id>cyrusliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chengbin</first_name>
          <last_name>Pang</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>chengbinpang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Dietsch</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://swt.informatik.uni-freiburg.de/staff/dietsch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danieldietsch/965245d6-e31d-4645-94f0-10a113edfe53/small.jpg</picture_url>
          <person_id>danieldietsch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eric</first_name>
          <last_name>Koskinen</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.stevens.edu/~ejk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/erickoskinen/3413fc94-5f0f-4855-af65-da2309d2632f/small.jpg</picture_url>
          <person_id>erickoskinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ton Chanh</first_name>
          <last_name>Le</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://letonchanh.github.io/</homepage_url>
          <person_id>tonchanhle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Portokalidis</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>georgiosportokalidis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Jun</first_name>
          <last_name>Xu</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>junxu2</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9cc241da-919a-44d5-ba36-2ad2db5a67bb</slot_id>
      <event_id>b9215798-f744-4c16-93b2-8d43afb864c8</event_id>
      <title>Preprocessing of Alternating Automata for Language Emptiness Testing</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:10</end_time>
      <description>We propose preprocessing techniques that improve efficiency of testing language emptiness of alternating automata. We target mainly automata that come from practical application such as string solving or processing of LTL formulae. Such automata often have large alphabets and transition relations represented by succinct and complex Boolean formulae that are more or less unrestricted and may even mix symbols with states. Our main contribution are simplification methods that can be seen as originating from a limited form determinisation, and we also use some simple Boolean transformations of the transition formulae. Our transformations simplify the transition formulae and decrease the number of states. We evaluate experimentally that our preprocessing is beneficial when used together with most of the existing algorithms. It generally improves running times and even allows to solve examples that could not be solved before within a reasonable timeout.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pavol</first_name>
          <last_name>Vargovčík</last_name>
          <affiliation>Brno University of Technology, Czech Republic</affiliation>
          <bio>undefined</bio>
          <person_id>pavolvargovcik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>78264d05-989e-4eac-a748-8f4a0b751ef0</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2021 Papers 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>904fbd8a-9e47-4ca4-90ec-79cbf838ba20</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2021 Papers 2</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>24cfbbfd-4ad2-4486-97a3-3b4b9a05a12c</slot_id>
      <event_id>6e3b43aa-a419-4f7a-8c92-059c79283fec</event_id>
      <title>Concurrent Deferred Reference Counting for Non-garbage-collected Languages</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:10</end_time>
      <description>We present a safe automatic memory reclamation approach for non garbage-collected languages, and show that it is both theoretically and practically efficient. The approach combines ideas from referencing counting with ideas related to hazard pointers. It overcomes the limitations of previous approaches by significantly reducing modifications to, and hence contention on, the reference counts. The approach is much safer and easier to use than manual approaches such as direct usage of hazard pointers, epoch based reclamation, RCU, or interval-based reclamation. One of the key ideas is a generalization of hazard pointers that allows the same handle to be retired multiple times, which we call acquire-retire. This technique is then used to protect the reference counter of an object, which allows our method to defer decrements on the counter until no other process could be incrementing it. Another key idea is to defer or elide increments of reference counters for short-lived references by temporarily protecting the counter instead of eagerly incrementing it. 
We have implemented the approach as a C++ library, which is as simple to use as conventional C++ reference-counted pointers. We run experiments on the library, comparing it to several other methods including state-of-the-art atomic reference-counted pointers, and four manual techniques: hazard-pointers, epochs, hazard-eras and interval-based reclamation. Our results indicate that our technique is faster than existing reference-counted pointer implementations, and competitive with manual memory reclamation techniques. On a variety of data structures and workloads, it achieves throughput rates within a factor of $2$ of the fastest manual approaches, while using a small fraction of the memory. Perhaps most importantly, it is significantly safer since objects are reclaimed automatically.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Anderson</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>danielanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guy E.</first_name>
          <last_name>Blelloch</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>guyeblelloch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yuanhao</first_name>
          <last_name>Wei</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yuanhaowei</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3e8fe1b6-a1f4-41a6-9b30-7a6ed36c5551</slot_id>
      <event_id>d9f49557-d7b0-445f-aecb-398d265bd188</event_id>
      <title>Vectorized Secure Evaluation of Decision Forests</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:10</end_time>
      <description>As the demand for machine learning–based inference increases in tandem with concerns about privacy, there is a growing recognition of the need for secure machine learning, in which secret models can be used to classify private data without the model or data being leaked. Fully Homomorphic Encryption (FHE) allows arbitrary computation to be done over encrypted data, providing an attractive approach to providing such secure inference. While such computation is often orders of magnitude slower than its plaintext counterpart, the ability of FHE cryptosystems to do ciphertext packing—that is, encrypting an entire vector of plaintexts such that operations are evaluated elementwise on the vector—helps ameliorate this overhead, effectively creating a SIMD architecture where computation can be vectorized for more efficient evaluation. Most recent research in this area has targeted regular, easily vectorizable neural network models. Applying similar techniques to irregular ML models such as decision forests remains unexplored, due to their complex, hard-to-vectorize structures. 
In this paper we present COPSE, the first system that exploits ciphertext packing to perform decision-forest inference. COPSE consists of a staging compiler that automatically restructures and compiles decision forest models down to a new set of vectorizable primitives for secure inference.
We find that COPSE's compiled models outperform the state of the art across a range of decision forest models, often by more than an order of magnitude, while still scaling well.
</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raghav</first_name>
          <last_name>Malik</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/raghavmalik/772f3505-7946-4766-99b3-f6b6c97192cc/small.jpg</picture_url>
          <person_id>raghavmalik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vidush</first_name>
          <last_name>Singhal</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>vidushsinghal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Gottfried</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>benjamingottfried</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University. 
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures. 
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University. I received an NSF CAREER Award in 2012, a Department of Energy Early Career Research Award in 2013, and the Presidential Early Career Award for Scientists and Engineers in 2016.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
          <person_id>milindkulkarni</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>81a7acc6-29dd-44f7-b0b3-b8250fb3a0fd</slot_id>
      <event_id>3d57c41e-4d41-4f68-84cb-1db1cd1975da</event_id>
      <title>SyRust: Automatic Testing of Rust Libraries with Semantic-Aware Program Synthesis</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:50</end_time>
      <description>Rust’s type system ensures the safety of Rust programs; however, programmers can side-step some of the strict typing rules by using the unsafe keyword. A common use of unsafe Rust is by libraries. Bugs in these libraries undermine the safety of the entire Rust program. Therefore, it is crucial to thoroughly test library APIs to rule out bugs. Unfortunately, such testing relies on programmers to manually construct test cases, which is an inefficient and ineffective process. 
The goal of this paper is to develop a methodology for automatically generating Rust programs to effectively test Rust library APIs. The main challenge is to synthesize \emph{well-typed} Rust programs to account for proper chaining of API calls and Rust’s ownership type system and polymorphic types. We develop a program synthesis technique for Rust library API testing, which relies on a novel logical encoding of typing constraints from Rust’s ownership type system. We implement SyRust, a testing framework for Rust libraries that automatically synthesizes semantically valid test cases. Our experiments on 30 popular open-source Rust libraries found 4 new bugs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yoshiki</first_name>
          <last_name>Takashima</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/yoshikitakashima/fd8f57b7-f306-4991-83ff-450e9003622b/small.jpg</picture_url>
          <person_id>yoshikitakashima</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ruben</first_name>
          <last_name>Martins</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Ruben Martins is a Systems Scientist at the Carnegie Mellon University. Prior to joining CMU, he was a postdoctoral researcher at UT Austin where he pushed the frontiers of program synthesis and security with constraint solving. Before UT Austin, he was a postdoctoral researcher at the University of Oxford, UK where he worked on CBMC for software verification. He received his PhD with honors from the University of Lisbon, Portugal in 2013. His research aims to improve constraint solvers and broaden their applicability in program analysis, synthesis, and security. Dr. Martins has developed several award winning solvers and has consistently improved the state-of-the-art in MaxSAT solving. He is currently the main developer of Open-WBO: an open source MaxSAT solver that won several awards in the MaxSAT competitions.</bio>
          <homepage_url>https://sat-group.github.io/ruben/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rubenmartins/6cfee429-6785-4395-bcf6-ddb6dd674d58/small.jpg</picture_url>
          <person_id>rubenmartins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Limin</first_name>
          <last_name>Jia</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.andrew.cmu.edu/user/liminjia/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/liminjia/6bc50ee1-2333-4b59-bc4f-3bf74d1e3b64/small.jpg</picture_url>
          <person_id>liminjia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Corina S.</first_name>
          <last_name>Păsăreanu</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ti.arc.nasa.gov/profile/pcorina/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/corinaspasareanu1/1b534631-bd17-43e5-bc5e-335cef045e87/small.jpg</picture_url>
          <person_id>corinaspasareanu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e43f6701-151f-4f9a-9b8b-1812c4360f5d</slot_id>
      <event_id>f70cd23a-f34d-43a0-bbf4-244ede98baa6</event_id>
      <title>Snapshot-Free, Transparent, and Robust Memory Reclamation for Lock-Free Data Structures</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:30</end_time>
      <description>We present a family of new safe memory reclamation schemes, Hyaline, which are fast, scalable, and transparent to the underlying lock-free data structures. Hyaline is based on reference counting – considered impractical for memory reclamation in the past due to high overheads. Hyaline uses reference counters only during reclamation, but not while accessing individual objects, which reduces overheads for object accesses. Since with reference counters, an arbitrary thread ends up freeing memory, Hyaline’s reclamation workload is (almost) balanced across all threads, unlike most prior reclamation schemes such as epoch-based reclamation (EBR) or hazard pointers (HP). Hyaline often yields (excellent) EBR-grade performance with (good) HP-grade memory efficiency, which is a challenging trade-off with all existing schemes. 
Hyaline schemes offer the following properties: (i) high \emph{performance}; (ii) good memory \emph{efficiency}; (iii) \emph{robustness}: guaranteeing bounded memory usage even in the presence of stalled threads, a well-known problem with EBR; (iv) \emph{transparency}: supporting virtually unbounded number of threads (or any concurrent entities) that can be created and deleted dynamically, and effortlessly join existent workload; (v) \emph{autonomy}: are neither intrusive to runtime or compiler environments nor rely on OS mechanisms; (vi) \emph{simplicity}: API enables easy integration into unmanaged C/C++ code, while not causing any undue burden on programmers, making the entire process fully automatic through smart pointers; and (vii) \emph{generality}: supporting many data structures. All existing schemes lack one or more properties. 
We have implemented and tested Hyaline on x86(-64), ARM32/64, PowerPC, and MIPS. The general approach requires LL/SC or double-width CAS, while a specialized version also works with single-width CAS. Our evaluation reveals that Hyaline’s throughput is very high – it steadily outperforms EBR by 10% in one test and yields \textbf{2x} gains in oversubscribed scenarios. Hyaline’s superior memory efficiency is especially evident in read-dominated workloads.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruslan</first_name>
          <last_name>Nikolaev</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <person_id>ruslannikolaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Binoy</first_name>
          <last_name>Ravindran</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <person_id>binoyravindran</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>70dbe155-4648-49c1-9f60-afae30287250</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2020 Papers 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>ec394dae-02cb-4372-9ef8-f26b8d6815e6</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2020 Papers 1</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>333f8122-62fb-4de4-870f-db0761268b9e</slot_id>
      <event_id>54b900fa-94bc-4a6b-82fe-3382c71b2921</event_id>
      <title>Armada: Low-Effort Verification of High-Performance Concurrent Programs</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:10</end_time>
      <description>Safely writing high-performance concurrent programs is notoriously difficult. To aid developers, we introduce Armada, a language and tool designed to formally verify such programs with relatively little effort. Via a C-like language and a small-step, state-machine-based semantics, Armada gives developers the flexibility to choose arbitrary memory layout and synchronization primitives so they are never constrained in their pursuit of performance. To reduce developer effort, Armada leverages SMT-powered automation and a library of powerful reasoning techniques, including rely-guarantee, TSO elimination, reduction, and alias analysis. All these techniques are proven sound, and Armada can be soundly extended with additional strategies over time. Using Armada, we verify four concurrent case studies and show that we can achieve performance equivalent to that of unverified code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jacob R.</first_name>
          <last_name>Lorch</last_name>
          <affiliation>Microsoft Research, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>jacobrlorch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yixuan</first_name>
          <last_name>Chen</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://me.xlk.me</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yixuanchen1/cdfb8d9e-938f-4baf-86de-6607de5acc18/small.jpg</picture_url>
          <person_id>yixuanchen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Manos</first_name>
          <last_name>Kapritsos</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <person_id>manoskapritsos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bryan</first_name>
          <last_name>Parno</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.andrew.cmu.edu/user/bparno/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bryanparno/ee485e0e-04ea-44b0-9a83-816825899e78/small.jpg</picture_url>
          <person_id>bryanparno</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Shaz</first_name>
          <last_name>Qadeer</last_name>
          <affiliation>Novi, USA</affiliation>
          <bio>Shaz Qadeer has worked at Facebook, Microsoft, HP, and Compaq. He has studied at the University of California at Berkeley and the Indian Institute of Technology at Kanpur.</bio>
          <homepage_url>https://scholar.google.com/citations?user=EqIVfYcAAAAJ&amp;hl=en</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shazqadeer1/f224e8bb-da8c-4512-b63b-d56831c9f712/small.jpg</picture_url>
          <person_id>shazqadeer1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Upamanyu</first_name>
          <last_name>Sharma</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <person_id>upamanyusharma</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>James R.</first_name>
          <last_name>Wilcox</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>I am a lecturer in the Paul G. Allen School of Computer Science &amp;amp; Engineering at the University of Washington. My research interests are in programming languages and applications of PL techniques to systems. I also work on formal verification in industry at Certora.</bio>
          <homepage_url>https://jamesrwilcox.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesrwilcox/92dfd071-3ff1-4a52-8f23-86215aca7f43/small.jpg</picture_url>
          <person_id>jamesrwilcox</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Xueyuan</first_name>
          <last_name>Zhao</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>xueyuanzhao</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3fb0f598-bba4-43fe-9f1f-56e8e3db75a9</slot_id>
      <event_id>19ed4d1b-8452-44ad-a9b4-5f5a98a20491</event_id>
      <title>Verifying Concurrent Search Structure Templates</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>12:10</end_time>
      <description>Concurrent separation logics have had great success reasoning about concurrent data structures. This success stems from their application of modularity on multiple levels, leading to proofs that are decomposed according to program structure, program state, and individual threads. Despite these advances, it remains difficult to achieve proof reuse across different data structure implementations. For the large class of \emph{search structures}, we demonstrate how one can achieve further proof modularity by decoupling the proof of thread safety from the proof of structural integrity. We base our work on the \emph{template} algorithms of Shasha and Goodman that dictate how threads interact but abstract from the concrete layout of nodes in memory. Building on the recently proposed flow framework of compositional abstractions and the separation logic Iris, we show how to prove correctness of template algorithms, and how to instantiate them to obtain multiple verified implementations. 
We demonstrate our approach by mechanizing the proofs of three concurrent search structure templates, based on link, give-up, and lock-coupling synchronization, and deriving verified implementations based on B-trees, hash tables, and linked lists. These case studies include algorithms used in real-world file systems and databases, which have been beyond the capability of prior automated or mechanized verification techniques. In addition, our approach reduces proof complexity and is able to achieve significant proof reuse.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Siddharth</first_name>
          <last_name>Krishna</last_name>
          <affiliation>Microsoft Research, Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.nyu.edu/~siddharth/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/siddharthkrishna/fb064b85-b50f-4fba-9626-67ed7a75b358/small.jpg</picture_url>
          <person_id>siddharthkrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nisarg</first_name>
          <last_name>Patel</last_name>
          <affiliation>New York University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>nisargpatel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dennis</first_name>
          <last_name>Shasha</last_name>
          <affiliation>New York University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dennisshasha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Wies</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.nyu.edu/wies/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thomaswies/e43dd6b5-97dc-433f-9708-836bd6364a01/small.jpg</picture_url>
          <person_id>thomaswies</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>547b0884-7ccc-417b-924d-72c14f0c67dd</slot_id>
      <event_id>9cbe048a-668b-4d5a-ad1c-7baf24aec489</event_id>
      <title>Decidable Verification under a Causally Consistent Shared Memory</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:30</end_time>
      <description>Causal consistency is one of the most fundamental and widely used consistency models weaker than sequential consistency. In this paper, we study the verification of safety properties for finite-state concurrent programs running under a causally consistent shared memory model. We establish the decidability of this problem for a standard model of causal consistency (called also "Causal Convergence" and "Strong-Release-Acquire"). Our proof proceeds by developing an alternative operational semantics, based on the notion of a thread potential, that is equivalent to the existing declarative semantics and constitutes a well-structured transition system. In particular, our result allows for the verification of a large family of programs in the Release/Acquire fragment of C/C++11 (RA). Indeed, while verification under RA was recently shown to be undecidable for general programs, since RA coincides with the model we study here for write/write-race-free programs, the decidability of verification under RA for this widely used class of programs follows from our result. The novel operational semantics may also be of independent use in the investigation of weakly consistent shared memory models and their verification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Udi</first_name>
          <last_name>Boker</last_name>
          <affiliation>IDC Herzliya, Israel</affiliation>
          <bio>undefined</bio>
          <person_id>udiboker</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5fe29d49-79d4-442a-a9f7-e27a15a04c92</slot_id>
      <event_id>1c6fea5c-98b9-4bed-90d9-cedf21a3e095</event_id>
      <title>Efficient Handling of String-Number Conversion</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:50</end_time>
      <description>String-number conversion is an important class of constraints needed for the symbolic execution of string-manipulating programs. In particular solving string constraints with string-number conversion is necessary for the analysis of scripting languages such as JavaScript and Python, where string-number conversion is a part of the definition of the core semantics of these languages. However, solving this type of constraint is very challenging for the state-of-the-art solvers. We propose in this paper an approach that can efficiently support both string-number conversion and other common types of string constraints. Experimental results show that it significantly outperforms other state-of-the-art tools on benchmarks that involves string-number conversion.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Parosh Aziz</first_name>
          <last_name>Abdulla</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://user.it.uu.se/~parosh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/paroshazizabdulla/342a7738-db1c-42a1-91cc-3b9467086b87/small.jpg</picture_url>
          <person_id>paroshazizabdulla</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mohamed Faouzi</first_name>
          <last_name>Atig</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>Mohamed Faouzi Atig is a senior lecturer at the Department of Information Technology, Uppsala University. Previously, he was a Post-doctoral researcher at Uppsala University from July 2010 to March 2012. He obtained his doctoral degree in Computer Science from the University of Paris Diderot- Paris 7 (France) in 2010. His research interests broadly span model checking, verification of infinite state systems, weak memory models, and automata theory.</bio>
          <homepage_url>http://www.it.uu.se/katalog/mohat117</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mohamedfaouziatig/5061fc57-1b58-42f4-965d-a1c64ca186dd/small.jpg</picture_url>
          <person_id>mohamedfaouziatig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yu-Fang</first_name>
          <last_name>Chen</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iis.sinica.edu.tw/~yfc/doku.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yufangchen/87eecff2-df03-4022-9c4e-7d96872d36c4/small.jpg</picture_url>
          <person_id>yufangchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bui Phi</first_name>
          <last_name>Diep</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://diepbp.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/phidiepbui/04bc8805-8f6c-407b-be9a-d693717be6b3/small.jpg</picture_url>
          <person_id>phidiepbui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
          <person_id>juliandolby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Petr</first_name>
          <last_name>Janků</last_name>
          <affiliation>Brno University of Technology, Czechia</affiliation>
          <bio>undefined</bio>
          <person_id>petrjanku</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Hsin-Hung</first_name>
          <last_name>Lin</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <person_id>hsinhunglin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Wei-Cheng</first_name>
          <last_name>Wu</last_name>
          <affiliation>University of Southern California, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://steel.isi.edu/members/weicheng</homepage_url>
          <person_id>weichengwu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b3fe0e57-fe30-4edd-86e7-cfa59855a845</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2020 Papers 4</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>d4e83b59-2d48-41c8-8333-f62af0756e1b</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2020 Papers 4</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>05c21d14-eaa0-4f91-98d4-264c14625eb2</slot_id>
      <event_id>c089d48c-138d-455e-9764-41a12be6f673</event_id>
      <title>SCAF: A Speculation-Aware Collaborative Dependence Analysis Framework</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>11:43</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>12:10</end_time>
      <description>Program analysis determines the potential dataflow and control flow relationships among instructions so that compiler optimizations can respect these relationships to transform code correctly. Since many of these relationships rarely or never occur, speculative optimizations assert they do not exist while optimizing the code. To preserve correctness, speculative optimizations add validation checks to activate recovery code when these assertions prove untrue. This approach results in many missed opportunities because program analysis and thus other optimizations remain unaware of the full impact of these dynamically-enforced speculative assertions. To address this problem, this paper presents SCAF, a Speculation-aware Collaborative dependence Analysis Framework. SCAF learns of available speculative assertions via profiling, computes their full impact on memory dependence analysis, and makes this resulting information available for all code optimizations. SCAF is modular (adding new analysis modules is easy) and collaborative (modules cooperate to produce a result more precise than the confluence of all individual results). Relative to the best prior speculation-aware dependence analysis technique, by computing the full impact of speculation on memory dependence analysis, SCAF dramatically reduces the need for expensive-to-validate memory speculation in the hot loops of all 16 evaluated C/C++ SPEC benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sotiris</first_name>
          <last_name>Apostolakis</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sapostolakis.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sotirisapostolakis/538416ca-ec5a-4441-b330-832a65a0bac2/small.jpg</picture_url>
          <person_id>sotirisapostolakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ziyang</first_name>
          <last_name>Xu</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.princeton.edu/~ziyangx/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ziyangxu/4d095217-b7d0-4159-9508-7cae73aa6bf5/small.jpg</picture_url>
          <person_id>ziyangxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zujun</first_name>
          <last_name>Tan</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/zujuntan/ad30ef1a-77e1-4829-b5c8-d969eac74289/small.jpg</picture_url>
          <person_id>zujuntan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Greg</first_name>
          <last_name>Chan</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>gregchan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Simone</first_name>
          <last_name>Campanoni</last_name>
          <affiliation>Northwestern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.northwestern.edu/~simonec</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/simonecampanoni/7b306233-75f2-4593-bd85-6774e1e27797/small.jpg</picture_url>
          <person_id>simonecampanoni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>David I.</first_name>
          <last_name>August</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>davidiaugust</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>255f94e6-2587-4e8f-9d93-e3b45f80af86</slot_id>
      <event_id>8bfe5d3b-1e01-4f72-acf3-fce8afee84a2</event_id>
      <title>BlankIt Library Debloating: Getting What You Want Instead of Cutting What You Don’t</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:16</end_time>
      <description>Modern software systems make extensive use of libraries derived from C and C++. Because of the lack of memory safety in these languages, however, the libraries may suffer from vulnerabilities, which can expose the applications to potential attacks. For example, a very large number of return-oriented programming gadgets exist in glibc that allow stitching together semantically valid but malicious Turing-complete and -incomplete programs. While CVEs get discovered and often patched and remedied, such gadgets serve as building blocks of future undiscovered attacks, opening an ever-growing set of possibilities for generating malicious programs. Thus, significant reduction in the quantity and expressiveness (utility) of such gadgets for libraries is an important problem. 
In this work, we propose a new approach for handling an application's library functions that focuses on the principle of getting only what you want.&amp;amp;#39;&amp;amp;#39; This is a significant departure from the current approaches that focus oncutting what is unwanted.'' Our approach focuses on activating/deactivating library functions on demand in order to reduce the dynamically linked code surface, so that the possibilities of constructing malicious programs diminishes substantially. The key idea is to load only the set of library functions that will be used at each library call site within the application at runtime. This approach of demand-driven loading relies on an input-aware oracle that predicts a near-exact set of library functions needed at a given call site during the execution. The predicted functions are loaded just in time and unloaded on return. 
We present a decision-tree based predictor, which acts as an oracle, and an optimized runtime system, which works directly with library binaries like GNU libc and libstdc++. We show that on average, the proposed scheme cuts the exposed code surface of libraries by 97.2%, reduces ROP gadgets present in linked libraries by 97.9%, achieves a prediction accuracy in most cases of at least 97%, and adds a runtime overhead of 18% on all libraries (16% for glibc, 2% for others) across all benchmarks of SPEC 2006. Further, we demonstrate BlankIt on two real-world applications, sshd and nginx, with a high amount of debloating and low overheads.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chris</first_name>
          <last_name>Porter</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>chrisporter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Girish</first_name>
          <last_name>Mururu</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>girishmururu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Prithayan</first_name>
          <last_name>Barua</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>prithayanbarua</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Santosh</first_name>
          <last_name>Pande</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>santoshpande1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fd89a05c-590f-4303-8f6d-c9e8911ad42c</slot_id>
      <event_id>e14c3aaf-48a4-413c-abd5-69d222c5ad50</event_id>
      <title>Crafty: Efficient, HTM-Compatible Persistent Transactions</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>11:16</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:43</end_time>
      <description>Byte-addressable persistent memory, such as Intel/Micron 3D XPoint, is an emerging technology that bridges the gap between volatile memory and persistent storage. Data in persistent memory survives crashes and restarts; however, it is challenging to ensure that this data is consistent after failures. Existing approaches incur significant performance costs to ensure crash consistency. 
This paper introduces &amp;lt;em&amp;gt;Crafty&amp;lt;/em&amp;gt;, a new approach for ensuring consistency and atomicity on persistent memory operations using &amp;lt;em&amp;gt;commodity hardware&amp;lt;/em&amp;gt; with existing hardware transactional memory (HTM) capabilities, while incurring low overhead. Crafty employs a novel technique called &amp;lt;em&amp;gt;nondestructive undo logging&amp;lt;/em&amp;gt; that leverages commodity HTM to control persist ordering. Our evaluation shows that Crafty outperforms state-of-the-art prior work under low contention, and performs competitively under high contention.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kaan</first_name>
          <last_name>Genç</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/kaangenc/8f0ac613-3bf5-4300-bc95-157afd5fe4ad/small.jpg</picture_url>
          <person_id>kaangenc</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael D.</first_name>
          <last_name>Bond</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ohio-state.edu/~mikebond</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelbond/92c528d2-84b3-4369-8b57-6555f1016a8e/small.jpg</picture_url>
          <person_id>michaelbond</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Guoqing Harry</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of California at Los Angeles</affiliation>
          <bio>I am an Associate Professor of Computer Science at University of California, Los Angeles (UCLA). I am interested broadly in software and hardware systems — including programming languages, compilers, big data analytics, distributed systems, and computer architecture.</bio>
          <homepage_url>http://web.cs.ucla.edu/~harryxu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/harryxu/5d680c47-2b02-4f5f-a2fb-55c72b5d63ed/small.jpg</picture_url>
          <person_id>harryxu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1a20a341-5615-406f-bf12-bae72e8fabce</subevent_id>
    <title>SPLASH SIGPLAN Papers: ICFP 2020 Papers</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>89cc4f6b-ce66-4a9f-b8f3-bc5b5cad14d8</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - ICFP 2020 Papers</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Stefan K.</first_name>
          <last_name>Muller</last_name>
          <affiliation>Illinois Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.iit.edu/~smuller/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefankmuller/db0c31ad-55ec-4010-948d-d405e6483cde/small.jpg</picture_url>
          <person_id>stefankmuller</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>45bffb55-9788-4104-8594-4171bd548c38</slot_id>
      <event_id>31f15d44-24f8-43b8-a197-500c0327e88a</event_id>
      <title>Program Sketching with Live Bidirectional Evaluation</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:50</end_time>
      <description>We present a system called Smyth for program sketching in a typed functional language whereby the concrete evaluation of ordinary assertions gives rise to input-output examples, which are then used to guide the search to complete the holes. The key innovation, called live bidirectional evaluation, propagates examples "backward" through partially evaluated sketches. Live bidirectional evaluation enables Smyth to (a) synthesize recursive functions without trace-complete sets of examples and (b) specify and solve interdependent synthesis goals. Eliminating the trace-completeness requirement resolves a significant limitation faced by prior synthesis techniques when given partial specifications in the form of input-output examples. 
To assess the practical implications of our techniques, we ran several experiments on benchmarks used to evaluate Myth, a state-of-the-art example-based synthesis tool. First, given expert examples (and no partial implementations), we find that Smyth requires on average 66% of the number of expert examples required by Myth. Second, we find that Smyth is robust to randomly-generated examples, synthesizing many tasks with relatively few more random examples than those provided by an expert. Third, we create a suite of small sketching tasks by systematically employing a simple sketching strategy to the Myth benchmarks; we find that user-provided sketches in Smyth often further reduce the total specification burden (i.e. the combination of partial implementations and examples). Lastly, we find that Leon and Synquid, two state-of-the-art logic-based synthesis tools, fail to complete several tasks on which Smyth succeeds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Justin</first_name>
          <last_name>Lubin</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jlubin.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/justinlubin1/20ea84ad-9355-48d7-924c-af6d84fdb568/small.jpg</picture_url>
          <person_id>justinlubin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nick</first_name>
          <last_name>Collins</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>undefined</bio>
          <person_id>nickcollins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Omar</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>https://fplab.mplse.org/</bio>
          <homepage_url>https://web.eecs.umich.edu/~comar</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/cyrusomar/6f85cfe7-5130-42cf-9976-450725051201/small.jpg</picture_url>
          <person_id>cyrusomar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ravi</first_name>
          <last_name>Chugh</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>Associate Professor at the University of Chicago, longing for more user-friendly programming languages and more programmable user interfaces</bio>
          <homepage_url>http://people.cs.uchicago.edu/~rchugh</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ravichugh/2d96c4d6-6a97-418a-870b-b217c5ad5401/small.jpg</picture_url>
          <person_id>ravichugh</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>912476c7-5348-401e-b683-9b07f9ffef11</slot_id>
      <event_id>b4d4b5a5-3a84-4731-bf48-3d2b5b5b0a64</event_id>
      <title>Recovering Purity with Comonads and Capabilities</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>12:10</end_time>
      <description>In this paper, we take a pervasively effectful (in the style of ML) typed lambda calculus, and show how to \emph{extend} it to permit capturing pure expressions with types. Our key observation is that, just as the pure simply-typed lambda calculus can be extended to support effects with a monadic type discipline, an impure typed lambda calculus can be extended to support purity with a \emph{comonadic} type discipline. 
We establish the correctness of our type system via a simple denotational model, which we call the \emph{capability space} model. Our model formalises the intuition common to systems programmers that the ability to perform effects should be controlled via access to a permission or capability, and that a program is \emph{capability-safe} if it performs no effects that it does not have a runtime capability for. We then identify the axiomatic categorical structure that the capability space model validates, and use these axioms to give a categorical semantics for our comonadic type system. We then give an equational theory (substitution and the call-by-value $\beta$ and $\eta$ laws) for the imperative lambda calculus, and show its soundness relative to this semantics. 
Finally, we give a translation of the pure simply-typed lambda calculus into our comonadic imperative calculus, and show that any two terms which are $\beta\eta$-equal in the STLC are equal in the equational theory of the comonadic calculus, establishing that pure programs can be mapped in an equation-preserving way into our imperative calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vikraman</first_name>
          <last_name>Choudhury</last_name>
          <affiliation>Indiana University &amp; University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://vikraman.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vikramanchoudhury/8592fa31-2552-463b-912f-7c40fbb869e7/small.jpg</picture_url>
          <person_id>vikramanchoudhury</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neel</first_name>
          <last_name>Krishnaswami</last_name>
          <affiliation>Computer Laboratory, University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~nk480</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/neelakantankrishnaswami/6fcce903-7ebb-4b0e-93c2-cfe6425ca322/small.jpg</picture_url>
          <person_id>neelakantankrishnaswami</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dac796d2-6e1e-489f-8cee-67d7f0627e56</slot_id>
      <event_id>15d2cc8c-7389-41fa-9ce3-ec96ee968493</event_id>
      <title>Denotational Recurrence Extraction for Amortized Analysis</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:30</end_time>
      <description>A typical way of analyzing the time complexity of functional programs is to extract a recurrence expressing the running time of the program in terms of the size of its input, and then to solve the recurrence to obtain a big-O bound. For recurrence extraction to be compositional, it is also necessary to extract recurrences for the size of outputs of helper functions. Previous work has developed techniques for using logical relations to state a formal correctness theorem for a general recurrence extraction translation: a program is bounded by a recurrence when the operational cost is bounded by the extracted cost, and the output value is bounded, according to a value bounding relation defined by induction on types, by the extracted size. This previous work supports higher-order functions by viewing recurrences as programs in a lambda-calculus, or as mathematical entities in a denotational semantics thereof. In this paper, we extend these techniques to support amortized analysis, where costs are rearranged from one portion of a program to another to achieve more precise bounds. We give an intermediate language in which programs can be annotated according to the banker's method of amortized analysis; this language has an affine type system to ensure credits are not spent more than once. We give a recurrence extraction translation of this language into a recurrence language, a simply-typed lambda-calculus with a cost type, and state and prove a bounding logical relation expressing the correctness of this translation. The recurrence language has a denotational semantics in preorders, and we use this semantics to solve recurrences, e.g analyzing binary counters and splay trees.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joseph W.</first_name>
          <last_name>Cutler</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cis.upenn.edu/~jwc</homepage_url>
          <person_id>josephwcutler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dan</first_name>
          <last_name>Licata</last_name>
          <affiliation>Wesleyan University</affiliation>
          <bio>I am an assistant professor at Wesleyan University. I received my PhD from Carnegie Mellon University in 2011, and was a postdoc at the Institute for Advanced Study in 2012-2013.</bio>
          <homepage_url>http://dlicata.web.wesleyan.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danlicata/0b1942ed-7b74-4b6b-b624-03ded7f26a62/small.jpg</picture_url>
          <person_id>danlicata</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Norman</first_name>
          <last_name>Danner</last_name>
          <affiliation>Wesleyan University</affiliation>
          <bio>undefined</bio>
          <person_id>normandanner</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fd59d852-5270-42a9-95e2-234b68308b7f</slot_id>
      <event_id>2766c230-ddb4-4cb5-b03a-2dedcef1e8e3</event_id>
      <title>A General Approach to Define Binders using Matching Logic</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:10</end_time>
      <description>We propose a novel definition of binders using matching logic, where the binding behavior of object-level binders is directly inherited from the built-in exists binder of matching logic. We show that the behavior of binders in various logical systems such as lambda-calculus, System F, pi-calculus, pure type systems, can be axiomatically defined in matching logic as notations and logical theories. We show the correctness of our definitions by proving conservative extension theorems, which state that a sequent/judgment is provable in the original system if and only if it is provable in matching logic, in the corresponding theory. Our matching logic definition of binders also yields models to all binders, which are deductively complete with respect to formal reasoning in the original systems. For lambda-calculus, we further show that the yielded models are representationally complete, a desired property that is not enjoyed by many existing lambda-calculus semantics. This work is part of a larger effort to develop a logical foundation for the programming language semantics framework K (http://kframework.org).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaohong</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/~xchen</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaohongchen1/e982c014-9fda-495c-93d6-b5fdc8158320/small.jpg</picture_url>
          <person_id>xiaohongchen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Grigore</first_name>
          <last_name>Roşu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/index.php/Grigore_Rosu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/grigorerosu/5b147c13-0a15-45fe-bbf0-3ce641260478/small.jpg</picture_url>
          <person_id>grigorerosu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1bf45ed3-5deb-4f5f-a1e6-62e291e02ef8</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2021 Papers 5</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>aec54e3f-d029-4fe5-8a36-7484e2df1df9</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2021 Papers 5</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>37a68103-ac04-4ba7-8eeb-1cfec3d50dfe</slot_id>
      <event_id>88f04613-2e4f-4d20-b0f1-57778d79d7e6</event_id>
      <title>Cyclic Program Synthesis</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>15:10</end_time>
      <description>We describe the first approach to automatically synthesizing heap-manipulating programs with auxiliary recursive procedures. Such procedures occur routinely in data structure transformations (e.g., flattening a tree into a list) or traversals of composite structures (e.g., n-ary trees). Our approach, dubbed cyclic program synthesis, enhances deductive program synthesis with a novel application of cyclic proofs. Specifically, we observe that the machinery used to form cycles in cyclic proofs can be reused to systematically and efficiently abduce recursive auxiliary procedures. 
We develop the theory of cyclic program synthesis by extending Synthetic Separation Logic (SSL), a logical framework for deductive synthesis of heap-manipulating programs from Separation Logic specifications. We implement our approach as a tool called Cypress, and showcase it by automatically synthesizing a number of programs manipulating linked data structures using recursive auxiliary procedures and mutual recursion, many of which were beyond the reach of existing program synthesis tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shachar</first_name>
          <last_name>Itzhaky</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~shachari</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shacharitzhaky/649d5921-4057-4ac3-8fc7-75471ee8527b/small.jpg</picture_url>
          <person_id>shacharitzhaky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.technion.ac.il/~hilap</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of 2020 Intel Rising Stars Award and the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Reuben N. S.</first_name>
          <last_name>Rowe</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>BA Cambridge University (Fitzwilliam) 2001-2004 MSc/PhD Imperial College London, 2007-2012 Teaching Fellow, Imperial College London, 2012-2014 Postdoc, University College London, 2014-2016 Postdoc, University of Kent, 2016-2019 Lecturer, Royal Holloway, 2019-</bio>
          <homepage_url>https://www.cs.kent.ac.uk/people/staff/rnsr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/reubennsrowe/33d179dc-b2b1-42f6-8d09-a2bf6bdd60c6/small.jpg</picture_url>
          <person_id>reubennsrowe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ilya</first_name>
          <last_name>Sergey</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>I am a tenured Associate Professor at National University of Singapore and Yale-NUS College. I do research in programming language design and implementation, software verification, distributed systems, program synthesis and repair. I am the recipient of the AITO Dahl-Nygaard Junior Prize 2019. I designed and co-developed Scilla, a programming language for safe smart contracts, used by Zilliqa. I organised the ICFP Programming Contest 2019. 
Before moving to Singapore, I was a faculty at University College London in 2015-2018. Prior to that, I was a postdoc at IMDEA Software Institute. I hold a PhD in Computer Science from KU Leuven, and an MSc in mathematics from St Petersburg University. Before joining academia I worked as a software engineer at JetBrains.</bio>
          <homepage_url>http://ilyasergey.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ilyasergey/b2941c89-4843-4194-852a-81c8a30814fa/small.jpg</picture_url>
          <person_id>ilyasergey</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5e3a5e4b-c145-4b2e-8091-f88ed7649981</slot_id>
      <event_id>5759aea9-c9ab-452b-a4a6-733a2dd07329</event_id>
      <title>Symbolic Boolean Derivatives for Efficiently Solving Extended Regular Expression Constraints</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:50</end_time>
      <description>The manipulation of raw string data is ubiquitous in security-critical software, and verification of such software relies on efficiently solving string and regular expression constraints via SMT. However, the typical case of Boolean combinations of regular expression constraints exposes blowup in existing techniques. To address solvability of such constraints, we propose a new theory of derivatives of symbolic extended regular expressions (extended meaning that complement and intersection are incorporated), and show how to apply this theory to obtain more efficient decision procedures. Our implementation of these ideas, built on top of Z3, matches or outperforms state-of-the-art solvers on standard and handwritten benchmarks, showing particular benefits on examples with Boolean combinations. 
Our work is the first formalization of derivatives of regular expressions which both handles intersection and complement and works symbolically over an arbitrary character theory. It unifies existing approaches involving derivatives of extended regular expressions, alternating automata and Boolean automata by lifting them to a common symbolic platform. It relies on a parsimonious augmentation of regular expressions: a construct for symbolic conditionals is shown to be sufficient to obtain relevant closure properties for derivatives over extended regular expressions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Caleb</first_name>
          <last_name>Stanford</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cis.upenn.edu/~castan/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/calebstanford/ecc7c13b-42ab-49e9-a867-dd26542ae449/small.jpg</picture_url>
          <person_id>calebstanford</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Margus</first_name>
          <last_name>Veanes</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/margusveanes/a5174253-0401-46f7-aff1-e92a3a3ace77/small.jpg</picture_url>
          <person_id>margusveanes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nikolaj</first_name>
          <last_name>Bjørner</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/nikolajbjrner/63324744-c6ad-450e-b412-3472986a6ca0/small.jpg</picture_url>
          <person_id>nikolajbjrner</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>601b2b92-8931-4138-99d7-e8b19f6e8cdf</slot_id>
      <event_id>ba7fc024-d6b8-4ba2-8214-c9e5972f224b</event_id>
      <title>Repairing Serializability Bugs in Distributed Database Programs via Automated Schema Refactoring</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:10</end_time>
      <description>Serializability is a well-understood concurrency control mechanism that eases reasoning about highly-concurrent database programs. Unfortunately, enforcing serializability has a high performance cost, especially on geographically distributed database clusters. Consequently, many databases allow programmers to choose when a transaction must be executed under serializability, with the expectation that transactions would only be so marked when necessary to avoid serious concurrency bugs. However, this is a significant burden to impose on developers, requiring them to (a) reason about subtle concurrent interactions among potentially interfering transactions, (b) determine when such interactions would violate desired invariants, and (c) then identify the minimum number of transactions whose executions should be serialized to prevent these violations. To mitigate this burden, this paper presents a sound fully-automated schema refactoring procedure that refactors a program’s data layout – rather than its concurrency control logic – to eliminate statically identified concurrency bugs, allowing more transactions to be safely executed under weaker and more performant database guarantees. Experimental results over a range of realistic database benchmarks indicate that our approach is highly effective in eliminating concurrency bugs, with safe refactored programs showing an average of 120% higher throughput and 45% lower latency compared to a serialized baseline.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kia</first_name>
          <last_name>Rahmani</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am a PhD candidate of computer science at Purdue University. I am a member of the programming languages group, working under the supervision of Professor Suresh Jagannathan and Professor Benjamin Delaware. 
My PhD thesis is focused around compilation, synthesis, and testing of modern database-backed programs. More broadly, I am interested in all formal methods for modeling and analysis of (classical or quantum) computer programs. 
I was previously a research intern at Microsoft, working on a new program synthesis technique based on pre-trained language models. My work was supervised by Dr. Mohammad Raza and Dr. Sumit Gulwani.</bio>
          <homepage_url>https://kiarahmani.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kiarahmani/745190a9-35f0-49e9-b5a9-f8831bce9162/small.jpg</picture_url>
          <person_id>kiarahmani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kartik</first_name>
          <last_name>Nagar</last_name>
          <affiliation>IIT Madras</affiliation>
          <bio>undefined</bio>
          <person_id>kartiknagar1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Delaware</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/bendy/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benjamindelaware/39bbf6b3-d145-435c-8956-8acf8cfcaffa/small.jpg</picture_url>
          <person_id>benjamindelaware</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Suresh</first_name>
          <last_name>Jagannathan</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/suresh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sureshjagannathan/70e51299-573f-4211-a895-b2028c19c585/small.jpg</picture_url>
          <person_id>sureshjagannathan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e052cb9b-a4f8-4f8b-b204-0880b4132cda</slot_id>
      <event_id>dbc12cea-10ed-407c-9f83-0d9fa6119085</event_id>
      <title>Scooter &amp; Sidecar: A domain-specific approach to writing secure migrations</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:30</end_time>
      <description>Web applications often handle large amounts of sensitive user data. Modern secure web frameworks protect this data by (1) using declarative languages to specify security policies alongside database schemas and (2) automatically enforcing these policies at runtime. Unfortunately, these frameworks do not handle the very common situation in which the schemas or the policies need to evolve over time—and updates to schemas and policies need to be performed in a carefully coordinated way. Mistakes during schema or policy migrations can unintentionally leak sensitive data or introduce privilege escalation bugs. In this work, we present a domain-specific language (Scooter) for expressing schema and policy migrations, and an associated SMT-based verifier (Sidecar) which ensures that migrations are secure as the application evolves. We describe the design of Scooter and Sidecar and show that our framework can be used to express realistic schemas, policies, and migrations, without giving up on runtime or verification performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Renner</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnrenner/ee473e3c-537b-4d92-afc9-8cb18e611337/small.jpg</picture_url>
          <person_id>johnrenner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alex</first_name>
          <last_name>Sanchez-Stern</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~alexss/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexsanchezstern/8f8df577-1227-40b6-86e8-2b553ee0c66d/small.jpg</picture_url>
          <person_id>alexsanchezstern</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fraser</first_name>
          <last_name>Brown</last_name>
          <affiliation>Stanford University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/fraserbrown/bbe0a77f-703c-4bc8-bd43-4fac9c0a93b1/small.jpg</picture_url>
          <person_id>fraserbrown</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sorin</first_name>
          <last_name>Lerner</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/users/lerner/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sorinlerner/3d3b1a70-e2f8-4d3a-a1bc-9c4e17dad80b/small.jpg</picture_url>
          <person_id>sorinlerner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Deian</first_name>
          <last_name>Stefan</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~dstefan/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/deianstefan/55e73d29-9671-4740-9ef2-3b45f485fc24/small.jpg</picture_url>
          <person_id>deianstefan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5707c8d1-8c2b-4095-be94-be4db9122730</subevent_id>
    <title>SPLASH SIGPLAN Papers: OOPSLA 2020 Papers 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>e31020bc-48da-4705-a191-5a99e8d1a705</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - OOPSLA 2020 Papers 1</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>21545e2a-3b98-4cd2-bf7f-d6a55ad0ed2e</slot_id>
      <event_id>2df18741-5ff8-441b-aca8-1dce4e59560c</event_id>
      <title>Designing Types for R, Empirically</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:30</end_time>
      <description>The R programming language is widely used in a variety of domains. It was designed to favor an interactive style of programming with minimal syntactic and conceptual overhead. This design is well suited to interactive data analysis, but a bad fit for tools such as compilers or program analyzers which must generate native code or catch programming errors. In particular, R has no type annotations, all operations are dynamically checked at run-time. The starting point for our work are the twin questions, \emph{what expressive power is needed to accurately type R code?} and \emph{which type system is the R community willing to adopt?} Both questions are difficult to answer without actually experimenting with a type system. The goal of this paper is to provide data that can feed into that design process. To this end, we perform a large corpus analysis to gain insights in the degree of polymorphism exhibited by idiomatic R code and explore potential benefits that the R community could accrue from a simple type system. As a starting point, we infer type signatures for 20214 functions from 412 packages among the most widely used open source R libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexi</first_name>
          <last_name>Turcotte</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://reallytg.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexiturcotte/6881a0a0-5145-40cb-aab4-ff41754a0640/small.jpg</picture_url>
          <person_id>alexiturcotte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Filip</first_name>
          <last_name>Křikava</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fikovnik.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/filipkrikava/12cc1e57-732c-4b7e-880e-ca7b51a07d77/small.jpg</picture_url>
          <person_id>filipkrikava</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4b29f0b3-8dbb-48f5-851c-530ff8f2823e</slot_id>
      <event_id>e0dc810f-1fc6-49e8-b5fb-daf967847ac9</event_id>
      <title>Can Advanced Type Systems Be Usable? An Empirical Study of Ownership, Assets, and Typestate in Obsidian</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:10</end_time>
      <description>Some blockchain programs (smart contracts) have included serious security vulnerabilities. Obsidian is a new typestate-oriented programming language that uses a strong type system to rule out some of these vulnerabilities. Although Obsidian was designed to promote usability to make it as easy as possible to write programs, strong type systems can cause a language to be difficult to use. In particular, ownership, typestate, and assets, which Obsidian uses to provide safety guarantees, have not seen broad adoption in popular languages and result in significant usability challenges. We performed an empirical study with 20 participants comparing Obsidian to Solidity, which is the language most commonly used for writing smart contracts today. We observed that Obsidian participants were able to successfully complete more of the programming tasks than the Solidity participants. We also found that asset-related bugs, which Obsidian detects at compile time, were commonly accidentally inserted by the Solidity participants.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>University of Maryland at College Park</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umd.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brad A.</first_name>
          <last_name>Myers</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~bam/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bradmyers/7d93ede9-5674-40e8-9ba5-f9dfab4873e1/small.jpg</picture_url>
          <person_id>bradmyers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>I am a Senior Research Fellow in the Institute for Software Research at Carnegie Mellon University. I have broad research interests at the intersection of programming languages and human-computer interaction. I am particularly interested in better understanding of the factors that influence the usability of reusable software components.</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>771e0ff6-479c-4524-9500-fd9c8fa35475</slot_id>
      <event_id>a24306c7-71e8-4345-8ecd-4a83171c21d8</event_id>
      <title>Digging for Fold: Synthesis-Aided API Discovery for Haskell</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>12:10</end_time>
      <description>We present Hoogle+, a component-based synthesizer for Haskell that takes as input a specification in the form of a type, a set of input-output tests, or both, and returns a list of candidate programs composed of functions from popular Haskell libraries. Hoogle+ focuses on the end-to-end usability of synthesis: i.e., how to help programmers solve their tasks faster. Usability depends crucially on whether and how the programmer can specify their own intent and comprehend the tools results. Hoogle+ addresses the specification problem by allowing the user to specify goals via tests from which it automatically infers type signatures that facilitate rapid synthesis. Hoogle+ uses property based testing to ensure the user only sees _useful and _unique candidates, and generates example usages to illustrate the _functionality of each candidate to help the user comprehend their semantics in order to choose the right result. We evaluate the usability of Hoogle+, with a user study with 30 participants of varying Haskell proficiency,that shows that programmers generally solve tasks faster with Hoogle+, and that they were able to solve 50% more tasks when equipped with Hoogle+.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael B.</first_name>
          <last_name>James</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Michael James is a 3rd year PhD student at University of California, San Diego studying programming languages and program synthesis under Nadia Polikarpova. He worked as a software engineer for three years before starting his degree. His experience has guided him to research topics that will ultimately flow back to help other engineers and make programming easier for all.</bio>
          <homepage_url>http://michaelbjames.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelbjames/8360df32-2f8d-4f7c-99c1-523f1f811bec/small.jpg</picture_url>
          <person_id>michaelbjames</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zheng</first_name>
          <last_name>Guo</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~zhg069</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhengguo1/cf77f323-ab54-4b33-8d59-36608178b41e/small.jpg</picture_url>
          <person_id>zhengguo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziteng</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wzt.me/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zitengwang/bf349a37-8935-4553-bcf7-c78094e369c5/small.jpg</picture_url>
          <person_id>zitengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shivani</first_name>
          <last_name>Doshi</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Current Cornell Tech MEng Student, UC San Diego 2020 BS in CS graduate.</bio>
          <homepage_url>https://shivanidoshi26.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shivanidoshi/a3bdf8b0-e4df-4be6-8c43-1cd1aee38f69/small.jpg</picture_url>
          <person_id>shivanidoshi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.technion.ac.il/~hilap</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Ranjit</first_name>
          <last_name>Jhala</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nom nom. Chomp. Burp.</bio>
          <homepage_url>http://ranjitjhala.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
          <person_id>ranjitjhala</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of 2020 Intel Rising Stars Award and the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cc4608db-358d-42a5-8fe2-eb57414eca13</slot_id>
      <event_id>b7de8362-c8f6-4916-a31f-43dd240bf2d2</event_id>
      <title>Deductive Optimization of Relational Data Storage</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:50</end_time>
      <description>Optimizing the physical data storage and retrieval of data are two key database management problems. In this paper, we propose a language that can express both a relational query and the layout of its data. Our language can express a wide range of physical database layouts, going well beyond the row- and column-based methods that are widely used in database management systems. We use deductive program synthesis to turn a high-level relational representation of a database query into a highly optimized low-level implementation which operates on a specialized layout of the dataset. We build an optimizing compiler for this language and conduct experiments using a popular database benchmark, which shows that the performance of our specialized queries is better than a state-of-the-art in memory compiled database system while achieving an order-of-magnitude reduction in memory use.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Feser</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>John Feser is a PhD student in the Computer Science and Artificial Intelligence Laboratory at MIT, advised by Armando Solar-Lezama. He is interested in program synthesis and databases.</bio>
          <homepage_url>http://people.csail.mit.edu/feser/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnfeser/edee5cf7-267b-4a87-90ca-94f278378c37/small.jpg</picture_url>
          <person_id>johnfeser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Madden</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sammadden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nan</first_name>
          <last_name>Tang</last_name>
          <affiliation>QCRI HBKU</affiliation>
          <bio>undefined</bio>
          <person_id>nantang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Armando</first_name>
          <last_name>Solar-Lezama</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Armando Solar-Lezama is an associate professor at MIT where he leads the Computer Aided Programming Group. His research interests include software synthesis and its applications in diverse areas such as high-performance computing, information flow security and probabilistic programming.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/armandosolarlezama/7befe52d-6968-4786-9841-408800f80c71/small.jpg</picture_url>
          <person_id>armandosolarlezama</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5b755f5c-b324-4bb0-82a0-0f2a207f550e</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2021 Papers 3</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>ba6b7ca6-8d90-4a9e-a5c2-7c61a698f817</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2021 Papers 3</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18a55322-731a-4a94-9d4f-65f1d6ddf760</slot_id>
      <event_id>b5a23572-33f6-4325-abeb-9044c22287b6</event_id>
      <title>Integration Verification Across Software and Hardware for a Simple Embedded System</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:40</end_time>
      <description>The interfaces between layers of a system are susceptible to bugs if developers of adjacent layers proceed under subtly different assumptions. Formal verification of two layers against the same formal model of the interface between them can be used to shake out these bugs. Doing so for every interface in the system can, in principle, yield unparalleled assurance of the correctness and security of the system as a whole. However, there have been remarkably few efforts that carry out this exercise, and all of them have simplified the task by restricting interactivity of the application, inventing new simplified instruction sets, and using unrealistic input and output mechanisms. We report on the first verification of a realistic embedded system, with its application software, device drivers, compiler, and RISC-V processor represented inside the Coq proof assistant as one mathematical object, with a machine-checked proof of functional correctness. A key challenge is structuring the proof modularly, so that further refinement of the components or expansion of the system can proceed without revisiting the rest of the system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andres</first_name>
          <last_name>Erbsen</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/andreserbsen/31e6ebcb-eb52-4e58-bdbc-34cfbf74952e/small.jpg</picture_url>
          <person_id>andreserbsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Samuel</first_name>
          <last_name>Gruetter</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/samgruetter/6a0b8f86-7d75-4dee-8238-fc3f483b8edd/small.jpg</picture_url>
          <person_id>samgruetter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Joonwon</first_name>
          <last_name>Choi</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://joonwon.net/c</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/joonwonchoi/e47297a8-182a-4ed5-99ab-0c070f982299/small.jpg</picture_url>
          <person_id>joonwonchoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Clark</first_name>
          <last_name>Wood</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>clarkwood</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Adam</first_name>
          <last_name>Chlipala</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Started hacking on compilers &amp;amp; web-development tools in the late 1990s. Finished CS undergrad at Carnegie Mellon in 2003 and CS PhD at Berkeley in 2007, picking up mechanized proof of executable, decently practical systems with Coq as a main focus in between. Postdoc at Harvard through 2011, then faculty at MIT since. Author of Certified Programming with Dependent Types, a popular online &amp;amp; in-print introduction to using Coq at scale. Lately into building practical but clean-slate hardware-software stacks with end-to-end Coq proofs of everything digital, at the same time as developing a startup-company idea to trick ordinary people into using dependent types (with Ur/Web) to generate their business applications.</bio>
          <homepage_url>http://adam.chlipala.net/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/adamchlipala/def72d03-2975-4c5a-a726-e8a944b77dc9/small.jpg</picture_url>
          <person_id>adamchlipala</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>35402944-f107-4d1b-8539-f12b42196ba4</slot_id>
      <event_id>9c1e1ce9-514f-4879-9a20-f5ec85774d13</event_id>
      <title>Automatically Enforcing Fresh and Consistent Inputs in Intermittent Systems</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:00</end_time>
      <description>Intermittently powered energy-harvesting devices enable new applications in inaccessible environments. Program executions must be robust to unpredictable power failures, introducing new challenges in programmability and correctness. One hard problem is that input operations have implicit constraints, embedded in the behavior of continuously powered executions, on when input values can be collected and used. We identify two key properties—freshness (i.e., uses of inputs must satisfy the same time constraints as in continuous executions) and temporal consistency (i.e., the collection of a set of inputs must satisfy the same time constraints as in continuous executions). We show that these properties can be enforced using atomic regions. We develop Ocelot, an LLVM-based analysis and transformation tool targeting Rust, to automatically enforce these properties. Ocelot provides the programmer with annotations to express these constraints and infers atomic region placement in a program to satisfy them. We formalize these properties and Ocelot’s design and show that Ocelot enables correct execution at little performance cost and low programmer effort.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milijana</first_name>
          <last_name>Surbatovich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>milijanasurbatovich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Limin</first_name>
          <last_name>Jia</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.andrew.cmu.edu/user/liminjia/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/liminjia/6bc50ee1-2333-4b59-bc4f-3bf74d1e3b64/small.jpg</picture_url>
          <person_id>liminjia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brandon</first_name>
          <last_name>Lucia</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://brandonlucia.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/brandonlucia/16fdd4eb-8f38-4c24-b29c-fa7ed8a15fb8/small.jpg</picture_url>
          <person_id>brandonlucia</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>abb8512f-7ef1-49f9-a022-5d62e3dba28e</slot_id>
      <event_id>bcf40f70-def3-4d71-b41e-9ae586b0b12f</event_id>
      <title>Reproducing Production Failures with ExecutionReconstruction</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>17:00</end_time>
      <description>Reproducing production failures is crucial for software reliability. Alas, existing bug reproduction systems do not simultaneously provide properties such as efficiency, effectiveness, and accuracy for production uses. In this work, we argue this is because existing approaches over-prioritize a subset of these properties, which hurts the remaining properties. 
We propose Execution Reconstruction (ER), a technique that strikes a good balance between efficiency, effectiveness and accuracy for reproducing production failures. ER uses hardware-assisted control and data tracing to shepherd symbolic execution and reproduce failures. As a key novelty, ER continuously analyzes the constraints generated by symbolic execution to identify constraint solving bottlenecks and steer runtime recording accordingly to reproduce failures. 
ER reproduces failures in executions that are more than two orders of magnitude longer than what the state-of-the-art production failure reproduction systems can handle. Unlike any production failure reproduction system we are aware of, ER can reproduce fully replayable executions that can power a variety of debugging and reliabilty use cases. ER incurs on average 0.3% (up to 1.1%) runtime monitoring overhead for a broad range of real-world systems, making itpractical for real-world deployment.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gefei</first_name>
          <last_name>Zuo</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <person_id>gefeizuo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jiacheng</first_name>
          <last_name>Ma</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <person_id>jiachengma1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Quinn</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <person_id>andrewquinn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Pramod</first_name>
          <last_name>Bhatotia</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/pbhatoti/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/pramodbhatotia/ec5f1655-1bc6-4194-aee7-c66a8332e516/small.jpg</picture_url>
          <person_id>pramodbhatotia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Pedro</first_name>
          <last_name>Fonseca</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>pedrofonseca</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Baris</first_name>
          <last_name>Kasikci</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/bariskasikci/5cddda04-d175-4a54-8b16-ee1938e4885d/small.jpg</picture_url>
          <person_id>bariskasikci</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e80be6ad-5a4a-43fb-b6e4-77df55b589b2</slot_id>
      <event_id>8b16b550-72bf-4b35-aa21-8d02458d1a64</event_id>
      <title>IOOpt- Automatic Derivation of I/O complexity bounds for affine programs</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:20</end_time>
      <description>Evaluating the complexity of an algorithm is an important step when developing applications as it highly impact both its time and energy performance. The arithmetic complexity which is the number of operations, regardless of the execution order, is, for neural networks (or more generally affine programs), easy to characterize. The data-movement (or, I/O) complexity characterization is way more complex as it refers to the minimum required number of I/O between a slow (e.g. main memory) and a fast (e.g. local scratchpad) storage location when considering all possible valid schedules. 
This paper presents \IOOpt, a fully automated tool that automatically bounds the data movement of an affine (tilable) program. Given a tilable program described in a DSL, it automatically computes: 1.~a lower bound of the I/O complexity as a symbolic expression of the cache size and program parameters; 2.~an upper bound that allows to assess the tightness of the lower bound; 3.~a tiling recommendation (loop permutation and tile’s sizes) that matches the upper bound. While the associated algorithms for computing lower bound (and the associated implementations) that are described in this paper can be applied to any affine programs, a substantial effort has been made to provide bounds that are as tight as possible for neural networks. In particular, it extends the previous work of Olivry et al. so as to handle multi-dimensional reductions and expose the constraints associated to small dimensions that are both present in convolutions. As for the upper bound algorithm, if the input can be a general tilable affine program (e.g. output of a polyhedral compiler such as PluTo), the involved algebraic computations are tuned to behave well on tensor computations such as direct tensor contractions or direct convolutions. As a bonus, the upper bound algorithm that has been extended to multi-level cache can provide a useful tiling recommendation to the programmer. 
We demonstrate the effectiveness of our tool by deriving the symbolic lower and upper bounds for several tensor contraction and convolution kernels. Then, we evaluate numerically the tightness of our bound using Yolo9000 convolution layer sizes and representative tensor contractions from the TCCG benchmark suite. Finally, we show the pertinence of our I/O complexity model by reporting the run-time of the recommended tiled code for the convolution layers from Yolo9000.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Auguste</first_name>
          <last_name>Olivry</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <person_id>augusteolivry</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Iooss</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <person_id>guillaumeiooss</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Tollenaere</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <person_id>nicolastollenaere</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Atanas</first_name>
          <last_name>Rountev</last_name>
          <affiliation>Ohio State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ohio-state.edu/~rountev</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/atanasrountev/57ea0ee0-eebe-48f0-91fe-1ed3a28b5d92/small.jpg</picture_url>
          <person_id>atanasrountev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Saday</first_name>
          <last_name>Sadayappan</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <person_id>psadayappan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Fabrice</first_name>
          <last_name>Rastello</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://team.inria.fr/corse/team-members/fabrice-rastello/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fabricerastello/5aa67b58-1ce2-4d43-b1c7-b102214c546b/small.jpg</picture_url>
          <person_id>fabricerastello</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fa007ee4-8cc8-4578-a2f1-712e82ab381e</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2021 Papers 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>a30f0bae-e35e-4c9d-aa87-1ccbcb8509a0</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2021 Papers 1</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0e927f4c-ba2d-4fe5-a92c-3413f41ee4f9</slot_id>
      <event_id>c039b113-8d8d-4924-844c-4d00bc24d92d</event_id>
      <title>Example-Guided Synthesis of Relational Queries</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:10</end_time>
      <description>Program synthesis tasks are commonly specified via input-output examples. Existing techniques for such tasks are primarily guided by program syntax and only make indirect use of the examples. We present a new approach called example-guided synthesis, or EGS, which exploits data patterns in the examples to construct the desired program. We demonstrate EGS for the synthesis of relational queries and evaluate it on 86 tasks from three application domains: knowledge discovery, program analysis, and database querying. Our evaluation shows that EGS outperforms state-of-the-art synthesizers based on enumerative search, constraint solving, and hybrid techniques in terms of synthesis time, quality of synthesized programs, and ability to prove unrealizability.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aalok</first_name>
          <last_name>Thakkar</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <person_id>aalokthakkar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aaditya</first_name>
          <last_name>Naik</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <person_id>aadityanaik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nathaniel</first_name>
          <last_name>Sands</last_name>
          <affiliation>University of Southern California</affiliation>
          <bio>undefined</bio>
          <person_id>nathanielsands</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Mukund</first_name>
          <last_name>Raghothaman</last_name>
          <affiliation>University of Southern California</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://r-mukund.github.io</homepage_url>
          <person_id>mukundraghothaman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mayur</first_name>
          <last_name>Naik</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.seas.upenn.edu/~mhnaik/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mayurnaik/681e8d43-e5b6-4a09-a8a5-11053f830db6/small.jpg</picture_url>
          <person_id>mayurnaik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Rajeev</first_name>
          <last_name>Alur</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~alur/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rajeevalur/3b3a4dca-8d4b-4db9-9986-376b2352a264/small.jpg</picture_url>
          <person_id>rajeevalur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>24af84a7-aa2f-4fc5-b9a0-d3002849abdf</slot_id>
      <event_id>588c09ed-48d8-4dff-bdd2-eadca4f32699</event_id>
      <title>Synthesizing Data Structure Refinements from Integrity Constraints</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:50</end_time>
      <description>Implementations of many data structures use several correlated fields to improve their performance; however, inconsistencies between these fields can be a source of serious program errors. To address this problem, we propose a new technique for automatically refining data structures from integrity constraints. In particular, consider a data structure $D$ with fields $F$ and methods $M$, as well as a new set of auxiliary fields $F’$ that should be added to $D$. Given this input and an integrity constraint $\Phi$ relating $F$ and $F’$, our method automatically generates a refinement of $D$ that satisfies the provided integrity constraint. Our method is based on a \emph{modular} instantiation of the CEGIS paradigm and uses a novel inductive synthesizer that augments top-down search with three key ideas. First, it computes \emph{necessary preconditions} of partial programs to dramatically prune its search space. Second, it augments the grammar with promising new productions by leveraging the computed preconditions. Third, it guides top-down search using a \emph{probabilistic} context-free grammar obtained by statically analyzing the integrity checking function and the original code base. We have evaluated our method on 25 data structures from popular Java projects and compare it against three state-of-the-art tools. Our evaluation shows that (1) our method is successful at refining many data structure implementations in the wild, (2) it advances the state-of-the-art in synthesis, and (3) our proposed ideas are crucial for making this technique practical.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shankara</first_name>
          <last_name>Pailoor</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>shankarapailoor</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yuepeng</first_name>
          <last_name>Wang</last_name>
          <affiliation>Simon Fraser University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.sfu.ca/~yuepeng</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuepengwang/3a584315-d81a-4b0b-ad47-e8489b6a18c5/small.jpg</picture_url>
          <person_id>yuepengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xinyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>I’m an assistant professor in the Computer Science and Engineering Department at the University of Michigan, Ann Arbor.</bio>
          <homepage_url>https://web.eecs.umich.edu/~xwangsd/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xinyuwang/ccbe37b1-293c-4205-8386-295e20bce0d7/small.jpg</picture_url>
          <person_id>xinyuwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
          <person_id>isildillig</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2988127-ddf6-4069-9497-d1509177103c</slot_id>
      <event_id>0a97a00b-29f7-420a-9275-2d100ec5a606</event_id>
      <title>Web Question Answering with Neurosymbolic Program Synthesis</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>12:10</end_time>
      <description>In this paper, we propose a new technique based on program synthesis for extracting information from webpages. Given a natural language query and a few labeled webpages, our method synthesizes a program that can be used to extract similar types of information from other unlabeled webpages. To handle websites with diverse structure, our approach employs a neurosymbolic DSL that incorporates both neural NLP models as well as standard language constructs for tree navigation and string manipulation. We also propose an optimal synthesis algorithm that generates all DSL programs that achieve optimal $F_1$ score on the training examples. Our synthesis technique is compositional, prunes the search space by exploiting a monotonicity property of the DSL, and uses self-supervision to select programs with good generalization power. We have implemented these ideas in a new tool called WebQA and evaluate it on 25 different tasks across multiple domains. Our experiments show that WebQA significantly outperforms existing tools such as state-of-the-art question answering models and wrapper induction systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qiaochu</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>qiaochuchen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Lamoreaux</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>aaronlamoreaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xinyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>I’m an assistant professor in the Computer Science and Engineering Department at the University of Michigan, Ann Arbor.</bio>
          <homepage_url>https://web.eecs.umich.edu/~xwangsd/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xinyuwang/ccbe37b1-293c-4205-8386-295e20bce0d7/small.jpg</picture_url>
          <person_id>xinyuwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Greg</first_name>
          <last_name>Durrett</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>gregdurrett</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Osbert</first_name>
          <last_name>Bastani</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://obastani.github.io</homepage_url>
          <person_id>osbertbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
          <person_id>isildillig</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f277e032-fcbf-4961-a107-feac5394520e</slot_id>
      <event_id>bb08d2d8-7696-45ce-925a-a534dae46006</event_id>
      <title>Filling Typed Holes with Live GUIs</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:30</end_time>
      <description>Although text editing is powerful, some types of expressions are more naturally represented and manipulated graphically. This paper introduces live literals, or livelits, which allow clients to fill holes of these types by directly manipulating a provider-defined GUI embedded persistently into otherwise symbolic code. Uniquely, livelits are compositional: the GUI can itself contain spliced expressions, which have full editor support and can in turn contain other livelits. Splices are typed and the system ensures that livelits treat splices hygienically. Livelits are also uniquely live: they can offer immediate feedback about the run-time implications of the client’s choices even when splices mention bound variables, because the system continuously gathers closures associated with the hole that the livelit is tasked with filling. This paper introduces livelits with case studies that exercise these novel capabilities. We implement livelits in Hazel, a live programming environment able to typecheck and run programs with holes. We then define a typed lambda calculus that captures the essence of livelits as live graphical macros. The macro expansion process has been mechanized in Agda.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Omar</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>https://fplab.mplse.org/</bio>
          <homepage_url>https://web.eecs.umich.edu/~comar</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/cyrusomar/6f85cfe7-5130-42cf-9976-450725051201/small.jpg</picture_url>
          <person_id>cyrusomar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Moon</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidmoon/07fbf417-4cfe-4fd0-93b2-05c3dbeb61ec/small.jpg</picture_url>
          <person_id>davidmoon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Blinn</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://andrewblinn.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/andrewblinn1/28b227e5-162d-4b3e-913d-39d8506402f8/small.jpg</picture_url>
          <person_id>andrewblinn1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ian</first_name>
          <last_name>Voysey</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~iev</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ianvoysey/74b47e65-ac6a-44b1-94cb-217c6fecdeb5/small.jpg</picture_url>
          <person_id>ianvoysey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nick</first_name>
          <last_name>Collins</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>undefined</bio>
          <person_id>nickcollins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Ravi</first_name>
          <last_name>Chugh</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>Associate Professor at the University of Chicago, longing for more user-friendly programming languages and more programmable user interfaces</bio>
          <homepage_url>http://people.cs.uchicago.edu/~rchugh</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ravichugh/2d96c4d6-6a97-418a-870b-b217c5ad5401/small.jpg</picture_url>
          <person_id>ravichugh</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7c9aacb5-2322-4b11-a6d0-95615a1d6c2a</subevent_id>
    <title>SPLASH SIGPLAN Papers: ICFP 2020 and Onward 2020 Papers</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>f03dab73-d93b-4402-89b4-1ddb9433d134</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - ICFP 2020 and Onward 2020 Papers</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6353e5c8-7ef8-4d68-9fa2-842f57cf8074</slot_id>
      <event_id>11f4df12-5d8b-45e7-b96f-e18ef79e7f27</event_id>
      <title>How (Not) to Write Java Pointer Analyses after 2020</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:30</end_time>
      <description>Despite being a very old discipline, pointer analysis still attracts several research papers every year in premier programming language venues. While a major goal of contemporary pointer analysis research is to improve its efficiency without sacrificing precision, we also see works that introduce novel ways of solving the problem itself. What does this mean? Research in this area is not going to die soon. 
I too have been writing pointer analyses of various kinds, specially for object-oriented languages such as Java. While some standard ways of writing such analyses are clear, I have realized that there are an umpteen number of nooks and pitfalls that make the task difficult and error prone. In particular, there are several misconceptions and undocumented practices, being aware of which would save significant research time. On the other hand, there are lessons from my own research that might go a long way in writing correct, precise and efficient pointer analyses, faster. This paper summarizes some such learnings, with a hope to help readers beat the state-of-the-art in (Java) pointer analysis, as they move into their research careers beyond 2020.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manas</first_name>
          <last_name>Thakur</last_name>
          <affiliation>Indian Institute of Technology Mandi</affiliation>
          <bio>undefined</bio>
          <person_id>manasthakur1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a8e568bc-8442-4933-8313-f5f3ab26dcff</slot_id>
      <event_id>296dae82-e37b-40dd-9cf5-68d4f84b5e78</event_id>
      <title>Liquid Information Flow Control</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>15:10</end_time>
      <description>We present Lifty, a domain-specific language for data-centric applications that manipulate sensitive data. A Lifty programmer annotates the sources of sensitive data with declarative security policies, and the language statically and automatically verifies that the application handles the data according to the policies. Moreover, if verification fails, Lifty suggests a provably correct repair, thereby easing the programmer burden of implementing policy enforcing code throughout the application. 
The main insight behind Lifty is to encode information flow control using liquid types, an expressive yet decidable type system. Liquid types enable fully automatic checking of complex, data dependent policies, and power our repair mechanism via type-driven error localization and patch synthesis. Our experience using Lifty to implement three case studies from the literature shows that (1) the Lifty policy language is sufficiently expressive to specify many real-world policies, (2) the Lifty type checker is able to verify secure programs and find leaks in insecure programs quickly, and (3) even if the programmer leaves out all policy enforcing code, the Lifty repair engine is able to patch all leaks automatically within a reasonable time.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of 2020 Intel Rising Stars Award and the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Deian</first_name>
          <last_name>Stefan</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~dstefan/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/deianstefan/55e73d29-9671-4740-9ef2-3b45f485fc24/small.jpg</picture_url>
          <person_id>deianstefan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean</first_name>
          <last_name>Yang</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>jeanyang@csail.mit.edu </homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeanyang/728ddfd8-02f1-426b-9006-87ba458c369f/small.jpg</picture_url>
          <person_id>jeanyang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shachar</first_name>
          <last_name>Itzhaky</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~shachari</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shacharitzhaky/649d5921-4057-4ac3-8fc7-75471ee8527b/small.jpg</picture_url>
          <person_id>shacharitzhaky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Travis</first_name>
          <last_name>Hance</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>travishance1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Armando</first_name>
          <last_name>Solar-Lezama</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Armando Solar-Lezama is an associate professor at MIT where he leads the Computer Aided Programming Group. His research interests include software synthesis and its applications in diverse areas such as high-performance computing, information flow security and probabilistic programming.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/armandosolarlezama/7befe52d-6968-4786-9841-408800f80c71/small.jpg</picture_url>
          <person_id>armandosolarlezama</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e19487bf-4614-4370-825a-c5ccbe5aa3af</subevent_id>
    <title>SPLASH SIGPLAN Papers: OOPSLA 2020 Papers 3</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>824d69d5-bcc4-4182-a0cc-28af28d2fb51</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - OOPSLA 2020 Papers 3</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>069a8f68-af8d-4705-8efc-726d9ef26505</slot_id>
      <event_id>7f0f7e60-d8f2-4530-9c09-3df6e57fc9cc</event_id>
      <title>DynamiTe: Dynamic Termination and Non-termination Proofs</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:00</end_time>
      <description>There is growing interest in termination reasoning for non-linear programs and, meanwhile, recent dynamic strategies have shown they are able to infer invariants for such challenging programs. These advances led us to hypothesize that perhaps such dynamic strategies for non-linear invariants could be adapted to learn recurrent sets (for non-termination) and/or ranking functions (for termination). 
In this paper, we exploit dynamic analysis and draw termination and non-termination as well as static and dynamic strategies closer together in order to tackle non-linear programs. For termination, our algorithm infers ranking functions from concrete transitive closures, and, for non-termination, the algorithm iteratively collects executions and dynamically learns conditions to refine recurrent sets. Finally, we describe an integrated algorithm that allows these algorithms to mutually inform each other, taking counterexamples from a failed validation in one endeavor and crossing both the static/dynamic and term./non-term.~ lines, to create new execution samples for the other one. 
We have implemented these algorithms in a new tool called DynamiTe. For non-linear programs, there are currently no SV-COMP termination benchmarks so we created new sets of 37 terminating and 37 non-terminating programs. Our empirical evaluation shows that we can effectively guess (and sometimes even validate) ranking functions and recurrent sets for programs with non-linear behaviors. Furthermore, we show that counterexamples from one failed validation can be used to generate executions for a dynamic analysis of the opposite property. Although we are focused on non-linear programs, as a point of comparison, we compare DynamiTe’s performance on linear programs with that of the state-of-the-art tool, Ultimate. Although DynamiTe is an order of magnitude slower it is nonetheless somewhat competitive and sometimes finds ranking functions where Ultimate was unable to. Ultimate cannot, however, handle the non-linear programs in our new benchmark suite.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ton Chanh</first_name>
          <last_name>Le</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://letonchanh.github.io/</homepage_url>
          <person_id>tonchanhle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Timos</first_name>
          <last_name>Antonopoulos</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <person_id>timosantonopoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Parisa</first_name>
          <last_name>Fathololumi</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>parisafathololumi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eric</first_name>
          <last_name>Koskinen</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.stevens.edu/~ejk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/erickoskinen/3413fc94-5f0f-4855-af65-da2309d2632f/small.jpg</picture_url>
          <person_id>erickoskinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>ThanhVu</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>George Mason University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nguyenthanhvuh.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thanhvunguyen/db337089-c863-4086-ad33-88d7dbfeb025/small.jpg</picture_url>
          <person_id>thanhvunguyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>62cbf0e1-db93-40e4-a357-c5f9c219c8e0</slot_id>
      <event_id>cc230051-4fa5-4060-bf31-ac34561cfdb6</event_id>
      <title>Towards A Unified Proof Framework for Automated Fixpoint Reasoning Using Matching Logic</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:40</end_time>
      <description>Automation of fixpoint reasoning has been extensively studied for various mathematical structures, logical formalisms, and computational domains, resulting in specialized fixpoint provers for heaps, for streams, for term algebras, for temporal properties, for program correctness, and for many other formal systems and inductive and coinductive properties. However, in spite of great theoretical and practical interest, there is no unified framework for automated fixpoint reasoning. Although several attempts have been made, there is no evidence that such a unified framework is possible, or practical. In this paper, we propose a candidate based on matching logic, a formalism that is recently shown to theoretically unify the above mentioned formal systems. Unfortunately, the Knaster-Tarski proof rule of matching logic, which enables inductive reasoning, is not syntax-driven. Worse, it can be applied at any step during a proof, making automation seem hopeless. Inspired by recent advances in automation of inductive proofs in separation logic, we propose an alternative proof system for matching logic, which is amenable for automation. We then discuss our implementation of it, which although not superior to specialized state-of-the-art automated provers for specific domains, we believe brings some evidence and hope that a unified framework for automated reasoning is not out of reach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaohong</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/~xchen</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaohongchen1/e982c014-9fda-495c-93d6-b5fdc8158320/small.jpg</picture_url>
          <person_id>xiaohongchen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Minh-Thai</first_name>
          <last_name>Trinh</last_name>
          <affiliation>Advanced Digital Sciences Center</affiliation>
          <bio>undefined</bio>
          <person_id>thaitrinh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nishant</first_name>
          <last_name>Rodrigues</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>nishantrodrigues</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Peña</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>lucaspena</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Grigore</first_name>
          <last_name>Roşu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/index.php/Grigore_Rosu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/grigorerosu/5b147c13-0a15-45fe-bbf0-3ce641260478/small.jpg</picture_url>
          <person_id>grigorerosu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>694250b4-cd61-4182-9242-1ea5e0d1bd31</slot_id>
      <event_id>903d1eb4-6ac1-41bf-bd02-7e9fb4f1d045</event_id>
      <title>Verifying and Improving Halide’s Term Rewriting System with Program Synthesis</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>17:00</end_time>
      <description>Halide is a domain-specific language for high-performance image processing and tensor computations, widely adopted in industry. Internally, the Halide compiler relies on a term rewriting system to prove properties of code required for efficient and correct compilation. This rewrite system is a collection of handwritten transformation rules that incrementally rewrite expressions into simpler forms; the system requires high performance in both time and memory usage to keep compile times low. In this work, we apply formal techniques to prove the correctness of existing rewrite rules and provide a guarantee of termination. Then, we build an automatic program synthesis system that operates over the undecidable theory of integers in order to craft new, provably correct rules from failure cases where the compiler was unable to prove properties. We identify and fix 5 incorrect rules as well as 8 rules which could give rise to infinite rewriting loops. We demonstrate that the synthesizer can produce better rules than hand-authored ones in five bug fixes, and describe four cases in which it has served as an assistant to a human compiler engineer. We further show that it can proactively improve weaknesses in the compiler by synthesizing a large number of rules without human supervision and showing that the enhanced ruleset lowers peak memory usage of compiled code without appreciably increasing compilation times.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julie L.</first_name>
          <last_name>Newcomb</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jn80842.github.io/</homepage_url>
          <person_id>julielnewcomb</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Adams</last_name>
          <affiliation>Adobe</affiliation>
          <bio>undefined</bio>
          <person_id>andrewadams</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Steven</first_name>
          <last_name>Johnson</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>stevenjohnson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rastislav</first_name>
          <last_name>Bodik</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://homes.cs.washington.edu/~bodik</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rastislavbodik/ae16ae8e-9d00-41c4-9067-0c37da65dde7/small.jpg</picture_url>
          <person_id>rastislavbodik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f90e8367-f739-424a-ba13-6917f3f7e3c5</slot_id>
      <event_id>99f34b89-8833-47df-bf8e-7144361d659e</event_id>
      <title>TacTok: Semantics-Aware Proof Synthesis</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:20</end_time>
      <description>Formally verifying software correctness is a highly manual process. However, because verification proofs often share structure, it is possible to learn from existing proofs to fully automate some formal verification. The goal of this paper is to improve proof synthesis and enable fully automating more verification. Interactive theorem provers, such as the Coq proof assistant, allow developers to write partial proofs, observe the semantics of the proof state thus far, and then attempt more progress. Knowing the proof state semantics is a significant aid. Recent research has shown that the proof state can help predict the next step. In this paper, we present TacTok, the first technique that attempts to fully automate proof synthesis by modeling proofs using both the partial proof written thus far and the semantics of the proof state. Thus, TacTok more completely models the information the developer has access to when writing proofs manually. TacTok is open-source. We evaluate TacTok on a benchmark of 26 software projects in Coq, consisting of over 10 thousand theorems. We compare our approach to two tools, CoqHammer, the state-of-the-art proof synthesis technique, and ASTactic, a proof synthesis technique that models proof state. We find that TacTok is complementary to CoqHammer and ASTactic: for 24 out of the 26 projects, TacTok can synthesize proofs for some theorems prior tools cannot. Together with TacTok, 11.5% more theorems can be proven automatically than by CoqHammer alone, and 20.0% than by ASTactic alone. Compared to a combination of CoqHammer and ASTactic, TacTok can prove an additional 3.6% more theorems, proving 115 theorems no tool could previously prove. Overall, our experiments provide evidence that partial proof and proof state semantics, together, provide useful information for proof modeling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Emily</first_name>
          <last_name>First</last_name>
          <affiliation>University of Massachusetts at Amherst</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/emilyfirst/76db7ede-1a2f-4b56-9974-9bb109e78ed1/small.jpg</picture_url>
          <person_id>emilyfirst</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yuriy</first_name>
          <last_name>Brun</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>My research is in software engineering. I am interested in improving our ability to build systems that are smart, and self-adapt to their environment. I am particularly interested in ensuring fairness in software systems. Watch a video describing my latest work on software fairness testing here: http://tinyurl.com/FairnessVideo</bio>
          <homepage_url>http://people.cs.umass.edu/~brun/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuriybrun/15eff225-fb71-4b2c-9925-a0d731136238/small.jpg</picture_url>
          <person_id>yuriybrun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4cffdf85-839c-4f50-b3b8-d25f29938f53</subevent_id>
    <title>SPLASH SIGPLAN Papers: ICFP 2021 Papers</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>7e766bbc-4b28-42ee-b851-5710d6736c9f</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - ICFP 2021 Papers</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Omar</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>https://fplab.mplse.org/</bio>
          <homepage_url>https://web.eecs.umich.edu/~comar</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/cyrusomar/6f85cfe7-5130-42cf-9976-450725051201/small.jpg</picture_url>
          <person_id>cyrusomar</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4c1ca292-20e3-492a-ac73-da288870b66e</slot_id>
      <event_id>13ad6230-f0bf-48bf-8970-e4cee488a606</event_id>
      <title>Compositional Optimizations for CertiCoq</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:20</end_time>
      <description>Compositional compiler verification is a difficult problem that focuses on separate compilation of program components with possibly different verified compilers. Logical relations are widely used in proving correctness of program transformations in higher-order languages; however, they do not scale to compositional verification of multi-pass compilers due to their lack of transitivity. The only known technique to apply to compositional verification of multi-pass compilers for higher-order languages is parametric inter-language simulations (PILS), which is however significantly more complicated than traditional proof techniques for compiler correctness. In this paper, we present a novel verification framework for \emph{lightweight compositional compiler correctness}. We demonstrate that by imposing the additional restriction that program components are compiled by pipelines that go through \emph{the same sequence of intermediate representations}, logical relation proofs can be transitively composed in order to derive an end-to-end compositional specification for multi-pass compiler pipelines. Unlike traditional logical-relation frameworks, our framework supports divergence preservation—even when transformations reduce the number of program steps. We achieve this by parameterizing our logical relations with a pair of \emph{relational invariants}. 
We apply this technique to verify a multi-pass, optimizing middle-end pipeline for CertiCoq, a compiler from Gallina (Coq's specification language) to C. The pipeline optimizes and closure-converts an untyped functional intermediate language (ANF or CPS) to a subset of that language without nested functions, which can be easily code-generated to low-level languages. Notably, our pipeline performs more complex closure-allocation optimizations than the state of the art in verified compilation. Using our novel verification framework, we prove an end-to-end theorem for our pipeline that covers both termination and divergence and applies to whole-program and separate compilation, even when different modules are compiled with different optimizations. Our results are mechanized in the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zoe</first_name>
          <last_name>Paraskevopoulou</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zoep.github.io/</homepage_url>
          <person_id>zoeparaskevopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>John M.</first_name>
          <last_name>Li</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>johnmli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Appel</last_name>
          <affiliation>Princeton</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.Princeton.EDU/~appel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/andrewappel/b75d69e5-5153-4248-8233-8018bb878e67/small.jpg</picture_url>
          <person_id>andrewappel</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>69524df3-9ef1-494b-b26d-bed050fa05d8</slot_id>
      <event_id>05712618-e38b-459d-9eb5-3ca6de2baae1</event_id>
      <title>Reasoning about the Garden of Forking Paths</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>17:00</end_time>
      <description>Lazy evaluation is a powerful tool for functional programmers. It enables the concise expression of on-demand computation and a form of compositionality not available under other evaluation strategies. However, the stateful nature of lazy evaluation makes it hard to analyze a program's computational cost, either informally or formally. In this work, we present a novel and simple framework for formally reasoning about lazy computation costs based on a recent model of lazy evaluation: clairvoyant call-by-value. The key feature of our framework is its simplicity, as expressed by our definition of the clairvoyance monad. This monad is both simple to define (around 20 lines of Coq) and simple to reason about. We show that this monad can be effectively used to mechanically reason about the computational cost of lazy functional programs written in Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yao</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lastland.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yaoli/ac58cfa1-acf7-454b-a4fc-cbdf519f65fb/small.jpg</picture_url>
          <person_id>yaoli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Li-yao</first_name>
          <last_name>Xia</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <person_id>liyaoxia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stephanie</first_name>
          <last_name>Weirich</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cis.upenn.edu/~sweirich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stephanieweirich/1f63ace9-e52a-4efc-b20b-ee75b5d7d091/small.jpg</picture_url>
          <person_id>stephanieweirich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>92ebdc9d-da55-444b-b253-98d1444f4925</slot_id>
      <event_id>957aebb0-7295-437f-93f4-e39983dc8e82</event_id>
      <title>An Order-Aware Dataflow Model for Parallel Unix Pipelines</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:00</end_time>
      <description>We present a dataflow model for modelling parallel Unix shell pipelines. To accurately capture the semantics of complex Unix pipelines, the dataflow model is order-aware, i.e., the order in which a node in the dataflow graph consumes inputs from different edges plays a central role in the semantics of the computation and therefore in the resulting parallelization. We use this model to capture the semantics of transformations that exploit data parallelism available in Unix shell computations and prove their correctness. We additionally formalize the translations from the Unix shell to the dataflow model and from the dataflow model back to a parallel shell script. We implement our model and transformations as the compiler and optimization passes of a system parallelizing shell pipelines, and use it to evaluate the speedup achieved on 47 pipelines.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shivam</first_name>
          <last_name>Handa</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>shivamhanda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Kallas</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://angelhof.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/konstantinoskallas/532ec21f-35f9-482a-afc9-d7c8b7118a65/small.jpg</picture_url>
          <person_id>konstantinoskallas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nikos</first_name>
          <last_name>Vasilakis</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>I am a Research Scientist at the Computer Science &amp;amp; Artificial Intelligence Laboratory of the Massachusetts Institute of Technology. I work on parallel and distributed systems, programming languages, and computer security—with recent focus on program analysis, transformation, and synthesis for automated parallelization, distribution, compartmentalization, and regeneration of computer programs or program fragments.</bio>
          <homepage_url>http://nikos.vasilak.is</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nikosvasilakis/822e63da-c64c-4f56-b9ed-54d49ce5bc0d/small.jpg</picture_url>
          <person_id>nikosvasilakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Martin C.</first_name>
          <last_name>Rinard</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.csail.mit.edu/rinard/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinrinard/cc4278df-192e-490f-87e5-a0649c420584/small.jpg</picture_url>
          <person_id>martinrinard</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e35c25fa-264a-438f-84cc-565310534aa9</slot_id>
      <event_id>3a3de5ec-71c8-4ec4-b17f-ce869d94710c</event_id>
      <title>Efficient Tree-Traversals: Reconciling Parallelism and Dense Data Representations</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:40</end_time>
      <description>Recent work showed that compiling functional programs to use dense, serialized memory representations for recursive algebraic datatypes can yield significant constant-factor speedups for sequential programs. But serializing data in a maximally dense format consequently serializes the processing of that data, yielding a tension between density and parallelism. This paper shows that a disciplined, practical compromise is possible. We present Parallel Gibbon, a compiler that obtains the benefits of dense data formats and parallelism. We formalize the semantics of the parallel location calculus underpinning this novel implementation strategy, and show that it is type-safe. Parallel Gibbon exceeds the parallel performance of existing compilers for purely functional programs that use recursive algebraic datatypes, including, notably, abstract-syntax-tree traversals as in compilers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chaitanya</first_name>
          <last_name>Koparkar</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/chaitanyakoparkar/139d8599-0098-4c4a-b576-f472f5309d6d/small.jpg</picture_url>
          <person_id>chaitanyakoparkar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mike</first_name>
          <last_name>Rainey</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mike-rainey.site</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mikerainey/1a4d7530-303c-4513-aa1f-c897cfe8556e/small.jpg</picture_url>
          <person_id>mikerainey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Vollmer</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelvollmer2/a2e0bce9-52e0-47f8-a385-d93681e01165/small.jpg</picture_url>
          <person_id>michaelvollmer2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University. 
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures. 
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University. I received an NSF CAREER Award in 2012, a Department of Energy Early Career Research Award in 2013, and the Presidential Early Career Award for Scientists and Engineers in 2016.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
          <person_id>milindkulkarni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ryan R.</first_name>
          <last_name>Newton</last_name>
          <affiliation>Facebook</affiliation>
          <bio>From South Florida. Ph.D. 2009 at MIT.</bio>
          <homepage_url>https://www.linkedin.com/in/rrnewton/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ryanrnewton/4dff7d06-8ca4-46f3-981b-52049bc71c54/small.jpg</picture_url>
          <person_id>ryanrnewton</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a1aeb248-f730-43a1-b350-8bfac771cc46</subevent_id>
    <title>SPLASH SIGPLAN Papers: OOPSLA 2020 Papers 4</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>20f259bb-b992-4f48-945d-546a9acdbac3</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - OOPSLA 2020 Papers 4</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>563371f3-6b70-456d-a3d1-ebd5bf2ed689</slot_id>
      <event_id>439d0e01-844a-4ab2-b493-0fc5220f4dcb</event_id>
      <title>A Sparse Iteration Space Transformation Framework for Sparse Tensor Algebra</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:10</end_time>
      <description>We address the problem of optimizing sparse tensor algebra in a compiler and show how to define standard loop transformations (such as splitting, collapsing, and reordering) for sparse iteration spaces. The key idea is that these transformations map sparse iteration spaces into \textit{derived} iteration spaces. This results in a new iteration order that respects the constraints inherent in sparse data structures. We further demonstrate that derived iteration spaces can be used to tile over both the indexes (coordinates) and the nonzeros; the former is equivalent to tiling dense iteration spaces, while the latter tiles sparse iteration spaces into statically load-balanced blocks of nonzeros. Tiling the space of nonzeros lets the compiler efficiently exploit heterogeneous compute resources such as threads, vector units, and GPUs. 
We implemented these concepts and an associated scheduling API on top of the open-source TACO system. The scheduling API can be used manually by performance engineers or be the target of an automatic scheduling system. We outline a heuristics-based autoscheduling system in this paper, but many other systems are possible and enabled by our API. Using the scheduling API, we show how to optimize sparse and mixed sparse-dense tensor algebra expressions on both CPUs and GPUs. Our results show that the sparse transformations are sufficient to generate code with competitive performance to hand-optimized implementations from the literature, while generalizing to all of the tensor algebra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Senanayake</last_name>
          <affiliation>Reservoir Labs</affiliation>
          <bio>undefined</bio>
          <person_id>ryansenanayake</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Changwan</first_name>
          <last_name>Hong</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>changwanhong2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziheng</first_name>
          <last_name>Wang</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>zihengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Amalee</first_name>
          <last_name>Wilson</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>amaleewilson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>samanamarsinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>650d332d-b3e1-447b-bab9-5c07108837fa</slot_id>
      <event_id>fa613957-c680-4b57-b5f6-2ba3b3c3910b</event_id>
      <title>Regex Matching with Counting-Set Automata</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>12:10</end_time>
      <description>We propose a solution to the problem of efficient matching regular expressions (regexes) with bounded repetition, such as $\mathtt{(ab){1,100}}$, using deterministic automata. For this, we introduce novel \emph{counting set automata (CsAs)}, automata with registers that can hold sets of bounded integers and can be manipulated by a limited portfolio of constant-time operations. We present an algorithm that compiles a large sub-class of regexes to deterministic CsAs. This includes (1) a novel Antimirov-style translation of regexes with counting to \emph{counting automata (CAs)}, nondeterministic automata with bounded counters, and (2) our main technical contribution, a determinization of CAs that outputs CsAs. The main advantage of this workflow is that the size of the produced CsAs does not depend on the repetition bounds used in the regex (while the size of the DFA is exponential to them). Our experimental results confirm that deterministic CsAs produced from practical regexes with repetition are indeed vastly smaller than the corresponding DFAs. More importantly, our prototype matcher based on CsA simulation handles practical regexes with repetition regardless of sizes of counter bounds. It easily copes with regexes with repetition where state-of-the-art matchers struggle.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lengál</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>Ph.D. (2015) Brno University of Technology</bio>
          <homepage_url>http://www.fit.vutbr.cz/~lengal</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ondrejlengal/3f99d935-777e-4b43-9494-5cfc0fe8894b/small.jpg</picture_url>
          <person_id>ondrejlengal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Olli</first_name>
          <last_name>Saarikivi</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/ollisaarikivi2/3e6d3eb8-2ea9-456c-9c3d-76fe37bd855c/small.jpg</picture_url>
          <person_id>ollisaarikivi2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lenka</first_name>
          <last_name>Turoňová</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lenkatoronova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Margus</first_name>
          <last_name>Veanes</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/margusveanes/a5174253-0401-46f7-aff1-e92a3a3ace77/small.jpg</picture_url>
          <person_id>margusveanes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tomáš</first_name>
          <last_name>Vojnar</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fit.vutbr.cz/~vojnar</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomasvojnar/6b1ea9ee-acf7-413d-be4d-431c460af426/small.jpg</picture_url>
          <person_id>tomasvojnar</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a4dc7a98-c7bb-4c43-b243-6052b5315866</slot_id>
      <event_id>e2b697be-04ac-4b14-adc9-8b9725358b0d</event_id>
      <title>Guided Linking: Dynamic Linking Without the Costs</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:50</end_time>
      <description>Dynamic linking is extremely common in modern software systems, thanks to the flexibility and space savings it offers. However, this flexibility comes at a cost: every library call has an extra layer of indirection, and it’s impossible to perform interprocedural optimizations that involve calls to a dynamic library. The basic problem is that the run-time behavior of the dynamic linker can’t be predicted at compile time, so the compiler can make no assumptions about how external calls will behave. 
This paper introduces guided linking, a technique for optimizing dynamically linked software when some information about the dynamic linker’s behavior is known in advance. The developer provides an arbitrary set of programs, libraries, and plugins to our tool, along with constraints that limit the possible dynamic linking behavior of the software. Given a software set and a list of constraints, our tool takes advantage of the constraints to optimize the software for speed and size. For example, the “no dynamic redefinitions” constraint can be applied to a function when the developer knows the function will never be unexpectedly overridden with a different definition at run time; this constraint allows dynamic references between libraries in the set to be resolved to static references, which can then be optimized with standard link-time optimizations. As an additional optimization, we deduplicate identical functions that appear anywhere in the software set. 
By applying guided linking to a dynamically linked distribution of Clang and LLVM, and using the constraint that no other software will use the LLVM libraries, we can increase speed by 6% and reduce file size by 11%. If we relax the constraint to allow other software to use the LLVM libraries, we can still increase speed by 5.5% and reduce file size by 3%. If we apply guided linking to the Python interpreter and a set of loadable Python modules, applying the constraint that no other programs or modules will be used, we can increase speed by an average of 6.6%. If we use guided linking to combine 11 different versions of the Boost library, applying minimal constraints, we can reduce the total library size by 57%.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sean</first_name>
          <last_name>Bartell</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>seanbartell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Will</first_name>
          <last_name>Dietz</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wdtz.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/willdietz/f5b6948e-d200-44b1-ba05-8d21549414f8/small.jpg</picture_url>
          <person_id>willdietz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vikram S.</first_name>
          <last_name>Adve</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://vikram.cs.illinois.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vikramadve/35b054ac-a4c0-4aef-a0b7-70b5234fbda8/small.jpg</picture_url>
          <person_id>vikramadve</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c6f11027-4d3d-402b-97cb-ef02b89d6d04</slot_id>
      <event_id>8a697ca3-0fe2-459e-88d0-2dc6969bd0ee</event_id>
      <title>DiffStream: Differential Output Testing for Stream Processing Programs</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:30</end_time>
      <description>High performance architectures for processing distributed data streams, such as Flink, Spark, and Storm, are increasingly deployed in emerging data-driven computing systems. Exploiting the parallelism afforded by such platforms, while preserving the semantics of the desired computation, is prone to errors, and motivates the development of tools for specification, testing, and verification. We focus on the problem of differential output testing for distributed stream processing systems, that is, checking whether two implementations produce equivalent output streams in response to a given input stream. The notion of equivalence allows reordering of logically independent data items, and the main technical contribution of the paper is an optimal online algorithm for checking this equivalence. Our testing framework is implemented as a library called \library in Flink. We present four case studies to illustrate how our framework can be used to (1) correctly identify bugs in a set of benchmark MapReduce programs, (2) facilitate the development of difficult-to-parallelize high performance applications, and (3) monitor an application for a long period of time using minimal computational resources.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Kallas</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://angelhof.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/konstantinoskallas/532ec21f-35f9-482a-afc9-d7c8b7118a65/small.jpg</picture_url>
          <person_id>konstantinoskallas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniksic.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/filipniksic/404f7660-8944-48cb-b97d-7b25a191367c/small.jpg</picture_url>
          <person_id>filipniksic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Caleb</first_name>
          <last_name>Stanford</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cis.upenn.edu/~castan/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/calebstanford/ecc7c13b-42ab-49e9-a867-dd26542ae449/small.jpg</picture_url>
          <person_id>calebstanford</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rajeev</first_name>
          <last_name>Alur</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~alur/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rajeevalur/3b3a4dca-8d4b-4db9-9986-376b2352a264/small.jpg</picture_url>
          <person_id>rajeevalur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9a203d7a-17db-46fb-9341-562a24a5d725</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2020 Papers 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>3787d486-5439-4470-91b6-242f06024564</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2020 Papers 2</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>199618d2-4728-48f8-b150-87d50e1b9a93</slot_id>
      <event_id>0030b6c0-b9bf-4381-abfd-88608ddffd0d</event_id>
      <title>Automated Derivation of Parametric Data Movement Lower Bounds for Affine Programs</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:10</end_time>
      <description>Researchers and practitioners have for long worked on improving the computational complexity of algorithms, focusing on reducing the number of operations needed to perform a computation. However the hardware trend nowadays clearly shows a higher performance and energy cost for data movements than computations: quality algorithms have to minimize data movements as much as possible. 
The theoretical operational complexity of an algorithm is a function of the total number of operations that must be executed, regardless of the order in which they will actually be executed. But theoretical data movement (or, I/O) complexity is fundamentally different: one must consider all possible legal schedules of the operations to determine the minimal number of data movements achievable, a major theoretical challenge. I/O complexity has been studied via complex manual proofs, e.g., refined from $\Omega(n^3/\sqrt{S})$ for matrix-multiply on a cache size $S$ by Hong &amp;amp;#38; Kung to $2n^3/\sqrt{S}$ by Smith et al. While asymptotic complexity may be sufficient to compare I/O potential between broadly different algorithms, the accuracy of the reasoning depends on the tightness of these I/O lower bounds. Precisely, exposing constants is essential to enable precise comparison between different algorithms: for example the $2n^3/\sqrt{S}$ lower bound allows to demonstrate the optimality of panel-panel tiling for matrix-multiplication. 
\emph{We present the first static analysis to automatically derive non-asymptotic parametric expressions of data movement lower bounds with scaling constants, for arbitrary affine computations}. Our approach is fully automatic, assisting algorithm designers to reason about I/O complexity and make educated decisions about algorithmic alternatives.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Auguste</first_name>
          <last_name>Olivry</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <person_id>augusteolivry</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julien</first_name>
          <last_name>Langou</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julienlangou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Louis-Noël</first_name>
          <last_name>Pouchet</last_name>
          <affiliation>Colorado State University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/louisnoelpouchet/d72d9a63-a296-4c80-bb9e-201cf64a0294/small.jpg</picture_url>
          <person_id>louisnoelpouchet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Saday</first_name>
          <last_name>Sadayappan</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <person_id>psadayappan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Fabrice</first_name>
          <last_name>Rastello</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://team.inria.fr/corse/team-members/fabrice-rastello/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fabricerastello/5aa67b58-1ce2-4d43-b1c7-b102214c546b/small.jpg</picture_url>
          <person_id>fabricerastello</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>50981510-d245-464a-86ad-dc7a9e64b654</slot_id>
      <event_id>5d69dcb0-f1ea-412a-8a82-74d531f2c6d7</event_id>
      <title>The Essence of Bluespec: A Core Language for Rule-Based Hardware Design</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:10</end_time>
      <description>The Bluespec hardware-description language presents a significantly higher-level view than hardware engineers are used to, exposing a simpler concurrency model that promotes formal proof, without compromising on performance of compiled circuits. Unfortunately, the cost model of Bluespec has been unclear, with performance details depending on a mix of user hints and opaque static analysis of potential concurrency conflicts within a design. In this paper we present Koika, a derivative of Bluespec that preserves its desirable properties and yet gives direct control over the \emph{scheduling} decisions that determine performance. Koika has a novel and deterministic operational semantics that uses dynamic analysis to avoid concurrency anomalies. Our implementation includes Coq definitions of syntax, semantics, key metatheorems, and a verified compiler to circuits. We argue that most of the extra circuitry required for dynamic analysis can be eliminated by compile-time BSV-style static analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Bourgeat</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>thomasbourgeat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Clément</first_name>
          <last_name>Pit-Claudel</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>clementpitclaudel1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adam</first_name>
          <last_name>Chlipala</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Started hacking on compilers &amp;amp; web-development tools in the late 1990s. Finished CS undergrad at Carnegie Mellon in 2003 and CS PhD at Berkeley in 2007, picking up mechanized proof of executable, decently practical systems with Coq as a main focus in between. Postdoc at Harvard through 2011, then faculty at MIT since. Author of Certified Programming with Dependent Types, a popular online &amp;amp; in-print introduction to using Coq at scale. Lately into building practical but clean-slate hardware-software stacks with end-to-end Coq proofs of everything digital, at the same time as developing a startup-company idea to trick ordinary people into using dependent types (with Ur/Web) to generate their business applications.</bio>
          <homepage_url>http://adam.chlipala.net/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/adamchlipala/def72d03-2975-4c5a-a726-e8a944b77dc9/small.jpg</picture_url>
          <person_id>adamchlipala</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>undefined</first_name>
          <last_name>Arvind</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>arvind</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>59443d2c-313a-478e-8ac2-b209804019c5</slot_id>
      <event_id>43894d59-6f1c-429c-a793-3ace5507be1b</event_id>
      <title>Responsive Parallelism with Futures and State</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:50</end_time>
      <description>Motivated by the increasing shift to multicore computers, recent work has developed language support for responsive parallel applications that mix compute-intensive tasks with latency-sensitive, usually interactive, tasks. These developments include calculi that allow assigning priorities to threads, type systems that can rule out priority inversions, and accompanying cost models for predicting responsiveness. These advances share one important limitation: all of this work assumes purely functional programming. This is a significant restriction, because many realistic interactive applications, from games to robots to web servers, use mutable state, e.g., for communication between threads. 
In this paper, we lift the restriction concerning the use of state. We present $\lambda_i^4$, a calculus with implicit parallelism in the form of prioritized futures and mutable state in the form of references. Because both futures and references are first-class values, $\lambda_i^4$ programs can exhibit complex dependencies, including interaction between threads and with the external world (users, network, etc). To reason about the responsiveness of $\lambda_i^4$ programs, we extend traditional graph-based cost models for parallelism to account for dependencies created via mutable state, and we present a type system to outlaw priority inversions that can lead to unbounded blocking. We show that these techniques are practical by implementing them in C++ and present an empirical evaluation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefan K.</first_name>
          <last_name>Muller</last_name>
          <affiliation>Illinois Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.iit.edu/~smuller/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefankmuller/db0c31ad-55ec-4010-948d-d405e6483cde/small.jpg</picture_url>
          <person_id>stefankmuller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kyle</first_name>
          <last_name>Singer</last_name>
          <affiliation>Washington University in St. Louis, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/kylesinger/f1f462b8-279e-492d-aba1-6490429a7eeb/small.jpg</picture_url>
          <person_id>kylesinger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Noah</first_name>
          <last_name>Goldstein</last_name>
          <affiliation>Washington University in St. Louis, USA</affiliation>
          <bio>undefined</bio>
          <person_id>noahgoldstein</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Umut A.</first_name>
          <last_name>Acar</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/umutacar/645140f1-714c-4def-ab34-8c78d85a50bf/small.jpg</picture_url>
          <person_id>umutacar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Kunal</first_name>
          <last_name>Agrawal</last_name>
          <affiliation>Washington University in St. Louis, USA</affiliation>
          <bio>undefined</bio>
          <person_id>kunalagrawal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>I-Ting Angelina</first_name>
          <last_name>Lee</last_name>
          <affiliation>Washington University in St. Louis, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.wustl.edu/~angelee/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/itingangelinalee/00a1b413-75df-4051-b7ad-c3a5842e8ab9/small.jpg</picture_url>
          <person_id>itingangelinalee</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5a79a174-3901-481b-8e5a-ad4b7523984a</slot_id>
      <event_id>ba8a4a58-19f2-460f-8f54-3af24617738f</event_id>
      <title>Reactive Probabilistic Programming</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:30</end_time>
      <description>Synchronous modeling is at the heart of programming languages like Lustre, Esterel, or Scade used routinely for implementing safety critical control software, e.g., fly-by-wire and engine control in planes. However, to date these languages have had limited modern support for modeling uncertainty — probabilistic aspects of the software's environment or behavior — even though modeling uncertainty is a primary activity when designing a control system. 
In this paper we present ProbZelus the first synchronous probabilistic programming language. ProbZelus conservatively provides the facilities of a synchronous language to write control software, with probabilistic constructs to model uncertainties and perform inference-in-the-loop. 
We present the design and implementation of the language. We propose a measure-theoretic semantics of probabilistic stream functions and a simple type discipline to separate deterministic and probabilistic expressions. We demonstrate a semantics-preserving compilation into a first-order functional language that lends itself to a simple presentation of inference algorithms for streaming models. We also redesign the delayed sampling inference algorithm to provide efficient streaming inference. Together with an evaluation on several reactive applications, our results demonstrate that ProbZelus enables the design of reactive probabilistic applications and efficient, bounded memory inference.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Baudart</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://guillaume.baudart.eu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guillaumebaudart/0ef21d31-ea41-4cfc-8df8-a62b2f483c64/small.jpg</picture_url>
          <person_id>guillaumebaudart</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM T.J. Watson Research Center</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Sherman</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ben-sherman.net</homepage_url>
          <person_id>benjaminsherman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Marc</first_name>
          <last_name>Pouzet</last_name>
          <affiliation>École normale supérieure</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.ens.fr/~pouzet</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marcpouzet/c783c4e5-a8e9-491d-9534-7a5e138e6a39/small.jpg</picture_url>
          <person_id>marcpouzet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1427512d-5ca4-47b5-a201-c82a1cf44e2d</subevent_id>
    <title>SPLASH SIGPLAN Papers: OOPSLA 2020 Papers 5</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>e7337a09-be54-4585-84ba-adff4f99538b</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - OOPSLA 2020 Papers 5</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>086bcd83-4658-4918-aaf9-f5103e38fdc0</slot_id>
      <event_id>a48af140-c6dd-4af5-892a-69f685efa99d</event_id>
      <title>Compiling Symbolic Execution with Staging and Algebraic Effects</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:50</end_time>
      <description>Building effective symbolic execution engines is challenging in multiple dimensions: an engine must \emph{correctly} model the program semantics, provide \emph{flexibility} in terms of various symbolic execution strategies, and execute these strategies \emph{efficiently}. 
This paper proposes a principled approach to building \emph{correct}, \emph{flexible}, and \emph{efficient} symbolic execution engines, directly rooted in the semantics of the underlying language expressed as a high-level definitional interpreter. Starting from this definitional interpreter, we use algebraic effects to model the semantics of symbolic execution, e.g., collecting path conditions as a state effect, and exploring multiple paths as a nondeterminism effect. Different handlers of these effects give rise to different symbolic execution strategies which make execution strategies orthogonal to the symbolic semantics, thus improving flexibility. Furthermore, by annotating the symbolic definitional interpreter with binding-times and specializing it to the input program via the first Futamura projection, we obtain a ``symbolic compiler,'' generating efficient code that is instrumented with the symbolic execution semantics. This staging approach reconciles the interpretation- and instrumentation-based approaches to building symbolic execution engines in a uniform framework. 
We illustrate the approach for a simple imperative language step-by-step, and then scale up to a significant subset of LLVM IR. We also show effect handlers for a number of common path selection strategies. We evaluate the performance of our prototype and compare with KLEE, showing that the compiled symbolic execution is an order of magnitude faster than the pure interpretation-based counterpart, as well as being on par with KLEE on single execution path traversal.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guannan</first_name>
          <last_name>Wei</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://continuation.passing.style</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guannanwei/e1971b4b-ebd3-429b-b28c-0c2cfb0f0289/small.jpg</picture_url>
          <person_id>guannanwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Bračevac</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://bracevac.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/oliverbracevac/17c0ac71-a156-4868-8df9-d4ae4cd669e7/small.jpg</picture_url>
          <person_id>oliverbracevac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1fcda129-a0a2-46e6-b7ff-a649fc33bbc6</slot_id>
      <event_id>a4868989-67f1-4ae4-915e-0ff8d0bbd08d</event_id>
      <title>Gradual Verification of Recursive Heap Data Structures</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:10</end_time>
      <description>Current static verification techniques do not provide good support for incrementality, making it difficult for developers to focus their limited effort on specifying and verifying the properties and components that are most important. Dynamic verification approaches support incrementality, but cannot provide static guarantees. To bridge this gap, prior work proposed gradual verification, which supports incrementality by allowing every assertion to be complete, partial, or omitted, and provides sound verification that smoothly scales from dynamic to static checking. The prior approach to gradual verification, however, was limited to toy programs without recursive data structures. This paper extends gradual verification to realistic programs that manipulate recursive, mutable data structures on the heap. We solve key technical challenges, semantically connecting iso- and equi-recursive interpretations of abstract predicates as well as gradual verification of heap ownership. Our work thus lays the foundation for future tools that work on realistic programs and support verification within an engineering process in which cost-benefit trade-offs can be made.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jenna</first_name>
          <last_name>Wise</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jlwise/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jennawise/614a00d0-d8ab-4b2f-8ec7-96abcb5c3d5b/small.jpg</picture_url>
          <person_id>jennawise</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Bader</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.johannes-bader.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johannesbader/0b7e635c-fba7-4113-a53d-4451edd44ca5/small.jpg</picture_url>
          <person_id>johannesbader</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cameron</first_name>
          <last_name>Wong</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>Wannabe type theorist.</bio>
          <homepage_url>https://camdar.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/cameronwong/1e4412d3-e79b-4f6a-8465-6b756986e1d0/small.jpg</picture_url>
          <person_id>cameronwong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>I am a Senior Research Fellow in the Institute for Software Research at Carnegie Mellon University. I have broad research interests at the intersection of programming languages and human-computer interaction. I am particularly interested in better understanding of the factors that influence the usability of reusable software components.</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>421aca2e-efb6-46c2-a6e2-bc413be7d349</slot_id>
      <event_id>73dd1774-0e95-40c6-b867-d06562e4cda9</event_id>
      <title>Formulog: Datalog for SMT-based Static Analysis</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:30</end_time>
      <description>Satisfiability modulo theories (SMT) solving has become a critical part of many static analyses, including symbolic execution, refinement type checking, and model checking. We propose Formulog, a domain-specific language that makes it possible to write a range of SMT-based static analyses in a way that is both close to their formal specifications and amenable to high-level optimizations and efficient evaluation. 
Formulog extends the logic programming language Datalog with a first-order functional language and mechanisms for representing and reasoning about SMT formulas; a novel type system supports the construction of expressive formulas, while ensuring that neither normal evaluation nor SMT solving goes wrong. Our case studies demonstrate that a range of SMT-based analyses can naturally and concisely be encoded in Formulog, and that — thanks to this encoding — high-level Datalog-style optimizations can be automatically and advantageously applied to these analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Bembenek</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Aaron Bembenek is currently a computer science PhD candidate at Harvard University working under Stephen Chong. He previously earned an undergraduate degree in classics from Princeton University.</bio>
          <homepage_url>http://people.seas.harvard.edu/~bembenek/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aaronbembenek/def526d3-8049-43ee-a891-2437ec903da6/small.jpg</picture_url>
          <person_id>aaronbembenek</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mgree.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chong</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Stephen Chong is a Gordon McKay Professor of Computer Science in the Harvard John A. Paulson School of Engineering and Applied Sciences. Steve’s research focuses on programming languages, information security, and the intersection of these two areas. He is the recipient of an NSF CAREER award, an AFOSR Young Investigator award, and a Sloan Research Fellowship. He received a PhD from Cornell University, and a bachelor’s degree from Victoria University of Wellington, New Zealand.</bio>
          <homepage_url>https://people.seas.harvard.edu/~chong/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stephenchong/91e43651-bcd6-40dc-b231-4c92711b0e95/small.jpg</picture_url>
          <person_id>stephenchong</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>11490c57-3488-4410-8a25-3d2e89464fd4</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2020 Papers 3</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>5d57197e-397f-4510-810e-495d7131f6e6</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2020 Papers 3</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>385f21ca-90c0-40ad-a28f-4fe2d14588a3</slot_id>
      <event_id>1386bc54-3b1b-4f9b-8417-a8afe021eafb</event_id>
      <title>Synthesizing Structured CAD Models with Equality Saturation and Inverse Transformations</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>17:00</end_time>
      <description>Recent program synthesis techniques help users customize CAD models(e.g., for 3D printing) by decompiling low-level triangle meshes to Constructive Solid Geometry (CSG) expressions. Without loops or functions, editing CSG can require many coordinated changes, and existing mesh decompilers use heuristics that can obfuscate high-level structure. 
This paper proposes a second decompilation stage to robustly "shrink" unstructured CSG expressions into more editable programs with map and fold operators. We present Szalinski, a tool that uses Equality Saturation with semantics-preserving CAD rewrites to efficiently search for smaller equivalent programs. Szalinski relies on inverse transformations, a novel way for solvers to speculatively add equivalences to an E-graph. We qualitatively evaluate Szalinski in case studies, show how it composes with an existing mesh decompiler, and demonstrate that Szalinski can shrink large models in seconds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chandrakana</first_name>
          <last_name>Nandi</last_name>
          <affiliation>Certora, inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cnandi.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chandrakananandi/a90ad233-62bb-4a90-8e9d-9afd969ef245/small.jpg</picture_url>
          <person_id>chandrakananandi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Max</first_name>
          <last_name>Willsey</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.mwillsey.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/maxwillsey/ff552459-e263-42a5-b17b-1301d482943d/small.jpg</picture_url>
          <person_id>maxwillsey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adam</first_name>
          <last_name>Anderson</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <person_id>adamanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>James R.</first_name>
          <last_name>Wilcox</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>I am a lecturer in the Paul G. Allen School of Computer Science &amp;amp; Engineering at the University of Washington. My research interests are in programming languages and applications of PL techniques to systems. I also work on formal verification in industry at Certora.</bio>
          <homepage_url>https://jamesrwilcox.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesrwilcox/92dfd071-3ff1-4a52-8f23-86215aca7f43/small.jpg</picture_url>
          <person_id>jamesrwilcox</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Eva</first_name>
          <last_name>Darulova</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mpi-sws.org/~eva/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/evadarulova/0d98744b-ec94-4a27-b1c0-0d728d54bdb7/small.jpg</picture_url>
          <person_id>evadarulova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Dan</first_name>
          <last_name>Grossman</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~djg/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dangrossman/941e0321-e962-4f03-9027-ba9f0448e7df/small.jpg</picture_url>
          <person_id>dangrossman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Tatlock</last_name>
          <affiliation>University of Washington, Seattle</affiliation>
          <bio>Associate Professor at the University of Washington</bio>
          <homepage_url>https://ztatlock.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zacharytatlock/87af1196-2d8d-4bd5-a692-018d3939a00f/small.jpg</picture_url>
          <person_id>zacharytatlock</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7707b5ce-ed6d-4a2b-b59e-de689e4fbcf1</slot_id>
      <event_id>22f0395c-ef67-4027-80a3-4216f1272ae0</event_id>
      <title>Reconciling Enumerative and Deductive Program Synthesis</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:40</end_time>
      <description>Syntax-guided synthesis (SyGuS) aims to find a program satisfying semantic specification as well as user-provided structural hypotheses. There are two main synthesis approaches: enumerative synthesis, which repeatedly enumerates possible candidate programs and checks their correctness, and deductive synthesis, which leverages a symbolic procedure to construct implementations from specifications. Neither approach is strictly better than the other: automated deductive synthesis is usually very efficient but only works for special grammars or applications; enumerative synthesis is very generally applicable but limited in scalability. 
In this paper, we propose a cooperative synthesis technique for SyGuS problems with the conditional linear integer arithmetic (CLIA) background theory, as a novel integration of the two approaches, combining the best of the two worlds. The technique exploits several novel divide-and-conquer strategies to split a large synthesis problem to smaller subproblems. The subproblems are solved separately and their solutions are combined to form a final solution. The technique integrates two synthesis engines: a pure deductive component that can efficiently solve some problems, and a height-based enumeration algorithm that can handle arbitrary grammar. We implemented the cooperative synthesis technique, and evaluated it on a wide range of benchmarks. Experiments showed that our technique can solve many challenging synthesis problems not possible before, and tends to be more scalable than state-of-the-art synthesis algorithms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kangjing</first_name>
          <last_name>Huang</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>kangjinghuang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xiaokang</first_name>
          <last_name>Qiu</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>I am an assistant professor with the School of Electrical and Computer Engineering at Purdue University.</bio>
          <homepage_url>https://engineering.purdue.edu/~xqiu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaokangqiu/be55b21e-fb5d-4540-a2c2-1110cac11fc6/small.jpg</picture_url>
          <person_id>xiaokangqiu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peiyuan</first_name>
          <last_name>Shen</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>peiyuanshen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yanjun</first_name>
          <last_name>Wang</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yanjunwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8c63853b-05ca-4f06-a585-c413db7d7df8</slot_id>
      <event_id>2b9c125a-05d7-4740-b12a-c49da95ee7dc</event_id>
      <title>Data-Driven Inference of Representation Invariants</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:20</end_time>
      <description>A representation invariant is a property that holds of all values of abstract type produced by a module. Representation invariants play important roles in software engineering and program verification. In this paper, we develop a counterexample-driven algorithm for inferring a representation invariant that is sufficient to imply a desired specification for a module. The key novelty is a type-directed notion of visible inductiveness, which ensures that the algorithm makes progress toward its goal as it alternates between weakening and strengthening candidate invariants. The algorithm is parameterized by an example-based synthesis engine and a verifier, and we prove that it is sound and complete for first-order modules over finite types, assuming that the synthesizer and verifier are as well. We implement these ideas in a tool called Hanoi, which synthesizes representation invariants for recursive data types. Hanoi not only handles invariants for first-order code, but higher-order code as well. In its back end, Hanoi uses an enumerative synthesizer called Myth and an enumerative testing tool as a verifier. Because Hanoi uses testing for verification, it is not sound, though our empirical evaluation shows that it is successful on the benchmarks we investigated.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Miltner</last_name>
          <affiliation>The University of Texas at Austin, Texas, USA</affiliation>
          <bio>Postdoctoral Fellow at UT Austin. PhD from Princeton University.</bio>
          <homepage_url>https://www.cs.utexas.edu/~amiltner/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/andersmiltner1/2ea1a602-4b63-48e5-b479-32936848075f/small.jpg</picture_url>
          <person_id>andersmiltner1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Saswat</first_name>
          <last_name>Padhi</last_name>
          <affiliation>Amazon Web Services, USA</affiliation>
          <bio>I am an Applied Scientist within the Automated Reasoning Group (ARG) at AWS. I work on program verification and synthesis technologies.</bio>
          <homepage_url>https://saswat.padhi.me</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/saswatpadhi/bb633be0-bbe7-4e77-9f5b-e0c8841ae7cf/small.jpg</picture_url>
          <person_id>saswatpadhi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/toddmillstein1/a55642b6-6fa2-40f6-99ba-8b9003ee61d9/small.jpg</picture_url>
          <person_id>toddmillstein1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>David</first_name>
          <last_name>Walker</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~dpw/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidwalker/8763137a-03a5-4963-8639-e9f2a3cc8ac9/small.jpg</picture_url>
          <person_id>davidwalker</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f6e5d620-7506-46e5-9150-46402ae07c8b</slot_id>
      <event_id>222e7ceb-2f63-4135-89da-77264de73a2d</event_id>
      <title>A Study of the Learnability of Relational Properties: Model Counting Meets Machine Learning (MCML)</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:00</end_time>
      <description>This paper introduces the MCML approach for empirically studying the learnability of relational properties that can be expressed in the well-known software design language Alloy. A key novelty of MCML is quantification of the performance of and semantic differences among trained machine learning (ML) models, specifically decision trees, with respect to entire (bounded) input spaces, and not just for given training and test datasets (as is the common practice). MCML reduces the quantification problems to the classic complexity theory problem of model counting, and employs state-of-the-art model counters. The results show that relatively simple ML models can achieve surprisingly high performance (accuracy and F1-score) when evaluated in the common setting of using training and test datasets – even when the training dataset is much smaller than the test dataset – indicating the seeming simplicity of learning relational properties. However, MCML metrics based on model counting show that the performance can degrade substantially when tested against the entire (bounded) input space, indicating the high complexity of precisely learning these properties, and the usefulness of model counting in quantifying the true performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Muhammad</first_name>
          <last_name>Usman</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>muhammadusman2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wenxi</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wenxiwang.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wenxiwang/f8f4edcf-6e85-436c-8285-4b07c04ae265/small.jpg</picture_url>
          <person_id>wenxiwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marko</first_name>
          <last_name>Vasic</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://marko-vasic.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/markovasic/18058c03-9483-411f-aec5-77907a350e73/small.jpg</picture_url>
          <person_id>markovasic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kaiyuan</first_name>
          <last_name>Wang</last_name>
          <affiliation>Google, Inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kaiyuanw.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kaiyuanwang/031824e1-c711-4674-9d66-a9d89e055192/small.jpg</picture_url>
          <person_id>kaiyuanwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Haris</first_name>
          <last_name>Vikalo</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>harisvikalo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Sarfraz</first_name>
          <last_name>Khurshid</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/sarfrazkhurshid/b998e03f-4c99-458b-a9f9-b6c470511e3b/small.jpg</picture_url>
          <person_id>sarfrazkhurshid</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cc2763d8-8575-40b0-a417-37e5e7fd632d</subevent_id>
    <title>SPLASH SIGPLAN Papers: OOPSLA 2020 Papers 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>510c9da7-51b8-45e7-8649-90589644457c</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - OOPSLA 2020 Papers 2</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8beb9ec6-a3d3-4f76-b8d8-70d0db1c4590</slot_id>
      <event_id>3e4d4392-b927-476a-8548-8e90e3372d98</event_id>
      <title>Pomsets with Preconditions: A Simple Model of Relaxed Memory</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:30</end_time>
      <description>Relaxed memory models must simultaneously achieve efficient implementability and thread-compositional reasoning. Is that why they have become so complicated? We argue that the answer is no: It is possible to achieve these goals by combining an idea from the 60s (preconditions) with an idea from the 80s (pomsets), at least for X64 and ARMv8. We show that the resulting model (1) supports compositional reasoning for temporal safety properties, (2) supports all reasonable sequential compiler optimizations, (3) satisfies the DRF-SC criterion, and (4) compiles to X64 and ARMv8 microprocessors without requiring extra fences on relaxed accesses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Radha</first_name>
          <last_name>Jagadeesan</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
          <person_id>radhajagadeesan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alan</first_name>
          <last_name>Jeffrey</last_name>
          <affiliation>Roblox</affiliation>
          <bio>Software Engineer at Roblox, working on gradual typing and type inference for the Luau programming language.</bio>
          <homepage_url>http://asaj.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alanjeffrey1/85292841-a6a7-416c-8808-fc36002bf1bd/small.jpg</picture_url>
          <person_id>alanjeffrey1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Riely</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesriely/3e1c46e0-9695-4c0f-aa5e-63f6577a3720/small.jpg</picture_url>
          <person_id>jamesriely</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8ef95b5a-5959-4949-a35a-4d0d66932460</slot_id>
      <event_id>72bc5829-c8cb-4bda-9b42-09147bcb08ab</event_id>
      <title>Koord: a language for programming and verifying distributed robotics applications</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:50</end_time>
      <description>A robot’s code needs to sense the environment, control the hardware, and communicate with other robots. Cur- rent programming languages do not provide the necessary hardware platform-independent abstractions, and therefore, developing robot applications require detailed knowledge of signal processing, control, path plan- ning, network protocols, and various platform-specific details. Further, porting applications across hardware platforms becomes tedious. We present Koord—a domain specific language for distributed robotics—which abstracts platform-specific functions for sensing, communication, and low-level control. Koord makes the platform-independent control and coordination code portable and modularly verifiable. It raises the level of abstraction in programming by providing distributed shared memory for coordination and port interfaces for sensing and control. We have developed the formal executable semantics of Koord in the K framework. With this symbolic execution engine, we can identify assumptions (proof obligations) needed for gaining high assurance from Koord applications. We illustrate the power of Koord through three applications: formation flight, distributed delivery, and distributed mapping. We also use the formation flight and distributed delivery applications to demonstrate how platform-independent proof obligations can be discharged using the Koord Prover while platform-specific proof obligations can be checked by verifying the obligations using physics-based models and hybrid verification tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ritwika</first_name>
          <last_name>Ghosh</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>ritwikaghosh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chiao</first_name>
          <last_name>Hsieh</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>chiaohsieh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sasa</first_name>
          <last_name>Misailovic</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://misailo.cs.illinois.edu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sasamisailovic/6e3299c7-e0f5-4e78-a5f3-7ea49e488545/small.jpg</picture_url>
          <person_id>sasamisailovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sayan</first_name>
          <last_name>Mitra</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>Sayan Mitra is a Professor of Electrical and Computer Engineering at the University of Illinois at Urbana-Champaign. His research interests are in formal verification, autonomous systems, and robotics. He holds a PhD from MIT, MSc from the Indian Institute of Science, Bangalore, and an undergraduate degree in Electrical Engineering from Jadavpur University, Kolkata. He was a postdoctoral fellow at the Center for Mathematics of Information of CalTech, and held visiting faculty positions at Oxford University and Kirtland Air Force Research Laboratory. Sayan received the National Science Foundation’s CAREER Award in 2011, AFOSR Young Investigator Research Program Award in 2012, IEEE-HKN C. Holmes MacDonald Outstanding Teaching Award (2013), a RiSE Fellowship from TU Vienna, and several best paper awards.</bio>
          <homepage_url>http://mitras.ece.illinois.edu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sayanmitra/62982710-8e2c-4be7-98f8-068227c8a067/small.jpg</picture_url>
          <person_id>sayanmitra</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>be15501e-5886-4f06-b86a-f8387d135728</slot_id>
      <event_id>e2ce6b38-f65e-4b51-8b17-c477f9e5245c</event_id>
      <title>Programming and Reasoning with Partial Observability</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:10</end_time>
      <description>Computer programs are increasingly being deployed in partially-observable environments. A partially observable environment is an environment whose state is not completely visible to the program, but from which the program receives partial information in the form of observations. Developers typically deal with partial observability by writing a state estimator that, given observations, attempts to deduce the hidden state of the environment. In safety-critical domains, to formally verify safety properties developers may write an environment model. The model captures the relationship between observations and hidden states and is used to prove the software correct. 
In this paper, we present a new methodology for writing and verifying programs in partially observable environments. We present belief programming, a programming methodology where developers write an environment model that the program runtime automatically uses to perform state estimation. A belief program dynamically updates and queries a belief state that captures the possible states the environment could be in. To enable verification, we present epistemic Hoare logic that reasons about the possible belief states of a belief program the same way that classical Hoare logic reasons about the possible states of a program. We develop these concepts by defining a semantics and a program logic for a simple core language called BLIMP. In a case study, we show how belief programming could be used to write and verify a controller for the Mars Polar Lander in BLIMP.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e74fa09f-c402-4a47-92bb-ca9427daaae1</slot_id>
      <event_id>b0397b2f-1f51-4dcd-8571-850e407bdb40</event_id>
      <title>Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:10</end_time>
      <description>Lighthouse projects such as CompCert, seL4, IronFleet, and DeepSpec have demonstrated that full verification of entire systems is feasible by establishing a refinement relation between an abstract system specification and an executable implementation. Existing approaches however impose severe restrictions on either the abstract system specifications due to their limited expressiveness or versatility, or on the executable code due to their reliance on suboptimal code extraction or inexpressive program logics. 
We propose a novel methodology that combines the compositional refinement of abstract, event-based models of distributed systems with the verification of full-fledged program code using expressive separation logics, which support features of realistic programming languages like mutable heap data structures and concurrency. The main technical contribution of our work is a formal framework that soundly relates event-based system models to program specifications in separation logics, such that successful verification establishes a refinement relation between the model and the code. We formalized our framework, \emph{Igloo}, in Isabelle/HOL. 
Our approach leverages existing program verifiers. We report on three case studies, a leader election protocol, a replication protocol, and a security protocol, for which we refine formal requirements into program specifications that we implement in Java and Python and prove correct using the VeriFast and Nagini tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Sprenger</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christophsprenger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Klenze</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>tobiasklenze</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marco</first_name>
          <last_name>Eilers</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch/people/personal/meilers-pers.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marcoeilers/fbfa4a0a-c277-440b-af64-20c5dbf19d0c/small.jpg</picture_url>
          <person_id>marcoeilers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Felix A.</first_name>
          <last_name>Wolf</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>felixwolf2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Martin</first_name>
          <last_name>Clochard</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>martinclochard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>David</first_name>
          <last_name>Basin</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>davidbasin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4e296277-ea6c-4a71-8e9b-112d83fe5b34</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2021 Papers 4</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>8a57f9e4-0fcf-4906-ba24-7de7065a8113</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2021 Papers 4</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>169f96a1-ff99-4149-ad87-08f9df717353</slot_id>
      <event_id>69c80d5e-4a47-4aff-92c5-b752b120ae6f</event_id>
      <title>SPPL: A Probabilistic Programming System with Exact and Scalable Symbolic Inference</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>12:10</end_time>
      <description>We present the Sum-Product Probabilistic Language (SPPL), a new system that automatically delivers exact solutions to a broad range of probabilistic inference queries. SPPL uses a new class of symbolic expressions to represent the distribution on execution traces of a probabilistic program that generalize sum-product networks by handling mixed-type distributions, numeric transformations, logical formulas, and pointwise and set-valued constraints. We formalize SPPL in terms of a novel translation strategy from probabilistic programs to sum-product expressions and present new and sound algorithms for exactly conditioning on and computing probabilities of events. We present new techniques for improving the scalability of translation and inference by automatically exploiting conditional independences and repeated structure in SPPL programs. We implement a prototype of SPPL with a modular architecture and evaluate it on a suite of benchmarks that the system is designed to solve, which establish that SPPL is up to 3500x faster than state-of-the-art systems for fairness verification; up to 1000x faster than state-of-the-art symbolic algebra techniques; and can compute exact probabilities of rare events in milliseconds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Feras A.</first_name>
          <last_name>Saad</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsaad.mit.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ferassaad/b74984fe-f070-4ab4-a808-a34ad2982d6f/small.jpg</picture_url>
          <person_id>ferassaad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin C.</first_name>
          <last_name>Rinard</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.csail.mit.edu/rinard/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinrinard/cc4278df-192e-490f-87e5-a0649c420584/small.jpg</picture_url>
          <person_id>martinrinard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vikash K.</first_name>
          <last_name>Mansinghka</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>vikashmansinghka1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2a3034d5-4a06-4a1c-81c0-f2869ed845b5</slot_id>
      <event_id>87e9c1c8-97fe-4e86-a14f-507dfff2337d</event_id>
      <title>Robustness Certification with Generative Models</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:50</end_time>
      <description>Generative neural networks are powerful models capable of learning a wide range of rich semantic image transformations such as altering person’s age, head orientation, adding mustache, changing the hair color and many more. At a high level, a generative model effectively produces new and previously unseen images with the desired properties, which can then be used to improve the accuracy of existing models. 
In this work, we advance the state-of-the-art in verification by bridging the gap between (i) the well studied but limited norm-based and geometric transformations, and (ii) the rich set of semantic transformations used in practice. This problem is especially hard since the images are generated from a highly non-convex image manifold, preventing the use of most existing verifiers, which often rely on convex relaxations. We present a new verifier, called GenProve, which is capable of certifying the rich set of semantic transformations of generative models. GenProve can provide both sound deterministic and probabilistic guarantees, by capturing infinite non-convex sets of activation vectors and distributions over them, while scaling to realistic networks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Mirman</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.mirman.com</homepage_url>
          <person_id>matthewmirman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Hägele</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexanderhagele/e182e347-f317-4175-b1af-ab836bab836a/small.jpg</picture_url>
          <person_id>alexanderhagele</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Timon</first_name>
          <last_name>Gehr</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.sri.inf.ethz.ch/people/timon</homepage_url>
          <person_id>timongehr</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Pavol</first_name>
          <last_name>Bielik</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.sri.inf.ethz.ch/bielik</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/pavolbielik/4d88e716-a415-4ac8-a36c-7e0c3d18b48c/small.jpg</picture_url>
          <person_id>pavolbielik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Martin</first_name>
          <last_name>Vechev</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.srl.inf.ethz.ch/vechev.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinvechev/4ae74bfd-22ac-4e29-a171-3fc706a85e3a/small.jpg</picture_url>
          <person_id>martinvechev</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ab69c552-c9a5-4793-9ade-26f7e4c6ce33</slot_id>
      <event_id>e986eee5-f6d7-4fd8-baeb-ec2c599c71b6</event_id>
      <title>On Probabilistic Termination of Functional Programs with Continuous Distributions</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:30</end_time>
      <description>We study termination of higher-order probabilistic functional programs with recursion, stochastic conditioning and sampling from continuous distributions. 
Reasoning about the termination probability of programs with continuous distributions is hard, because the enumeration of terminating executions cannot provide any non-trivial bounds. We present a new operational semantics based on traces of intervals, which is sound and complete with respect to the standard sampling-based semantics, in which (countable) enumeration can provide arbitrarily tight lower bounds. Consequently we obtain the first proof that deciding almost-sure termination (AST) for programs with continuous distributions is $\Pi^0_2$-complete. We also provide a compositional representation of our semantics in terms of an intersection type system. 
In the second part, we present a method of proving AST for non-affine programs, i.e., recursive programs that can, during the evaluation of the recursive body, make multiple recursive calls (of a first-order function) from distinct call sites. Unlike in a deterministic language, the number of recursion call sites has direct consequences on the termination probability. Our framework supports a proof system that can verify AST for programs that are well beyond the scope of existing methods. 
We have constructed prototype implementations of our method of computing lower bounds of termination probability, and AST verification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raven</first_name>
          <last_name>Beutner</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <person_id>ravenbeutner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>C.-H. Luke</first_name>
          <last_name>Ong</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/luke.ong/personal</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lukeong/c257d95e-8eb2-4f79-a47b-c6c31c4a4db4/small.jpg</picture_url>
          <person_id>lukeong</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f06b9549-e666-4263-ab09-418946d7611b</slot_id>
      <event_id>47b14b22-75f2-4b34-b637-a94e5222130d</event_id>
      <title>Compiling Stan to Generative Probabilistic Languages and Extension to Deep Probabilistic Programming</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:10</end_time>
      <description>Stan is a probabilistic programming language that is popular in the statistics community, with a high-level syntax for expressing probabilistic models. Stan differs by nature from generative probabilistic programming languages like Church, Anglican, or Pyro. This paper presents a comprehensive compilation scheme to compile any Stan model to a generative language and proves its correctness. 
We use our compilation scheme to build two new backends for the Stanc3 compiler targeting Pyro and NumPyro. Experimental results show that the NumPyro backend yields a 3.7x speedup in geometric mean compared to Stan on 27 existing benchmarks. 
Building on Pyro we extend Stan with support for explicit variational inference guides and deep probabilistic models. That way, users familiar with Stan get access to new features without having to learn a fundamentally new language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Baudart</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <person_id>guillaumebaudart1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Javier</first_name>
          <last_name>Burroni</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/javierburroni/dc65c155-74c5-40ce-b81f-e638faeff433/small.jpg</picture_url>
          <person_id>javierburroni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Hirzel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hirzels.com/martin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinhirzel/8ffffeeb-b25c-4f90-b2e3-4949c2871a2a/small.jpg</picture_url>
          <person_id>martinhirzel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM T.J. Watson Research Center</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Avraham</first_name>
          <last_name>Shinnar</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <person_id>avrahamshinnar</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>60e521c2-ef60-49c5-995a-8ab8b5078b88</subevent_id>
    <title>SAS: Session 2B</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>abc1935c-11d4-4978-adcf-872da2d5182d</slot_id>
      <title>Session: SAS - Session 2B</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4f198fdf-940d-458c-8ea5-744d8b2837bc</slot_id>
      <event_id>b08a178c-7f0c-4bc7-b0f8-680f11280a67</event_id>
      <title>Thread-modular Analysis of Release-Acquire Concurrency</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>11:43</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>12:10</end_time>
      <description>We present a thread-modular abstract interpretation(TMAI) technique to verify programs under the release-acquire (RA) memory model for safety property violations. The main contributions of our work are: we capture the execution order of program statements as an abstract domain, and propose a sound upper approximation over this domain to efficiently reason over RA concurrency. The proposed domain is general in its application and captures the ordering relations as a first-class feature in the abstract interpretation theory. In particular, the domain represents a set of sequences of modifications of a global variable in concurrent programs as a partially ordered set. Under this approximation, older sequenced-before stores of a global variable are forgotten and only the latest stores per variable are preserved. We establish the soundness of our proposed abstractions and implement them in a prototype abstract interpreter called PRIORI. The evaluations of PRIORI on existing and challenging RA benchmarks demonstrate that the proposed technique is not only competitive in refutation, but also in verification. PRIORI shows significantly fast analysis runtimes with higher precision compared to recent state-of-the-art tools for RA concurrency.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Divyanjali</first_name>
          <last_name>Sharma</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cse.iitd.ac.in/~divyanjali/</homepage_url>
          <person_id>divyanjalisharma</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Subodh</first_name>
          <last_name>Sharma</last_name>
          <affiliation>IIT Delhi</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://subodhvsharma.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/subodhsharma/fd4e07cc-8466-455b-ad82-3d85138da23f/small.jpg</picture_url>
          <person_id>subodhsharma</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9efad856-91d3-4b1a-8ff4-e9920c8cb9cd</slot_id>
      <event_id>1bce6dfa-6838-46f2-a5a1-5ef566fa1b5f</event_id>
      <title>Compositional Verification of Smart Contracts Through Communication Abstraction</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:16</end_time>
      <description>Solidity smart contracts are programs that manage up to 2^160 users on a blockchain. Verifying a smart contract relative to all users is intractable due to state explosion. Existing solutions either restrict the number of users to under-approximate behaviour, or rely on manual proofs. In this paper, we present local bundles that reduce contracts with arbitrarily many users to sequential programs with a few representative users. Each representative user abstracts concrete users that are locally symmetric to each other relative to the contract and the property. Our abstraction is semi-automated. The representatives depend on communication patterns, and are computed via static analysis. A summary for the behaviour of each representative is provided manually, but a default summary is often sufficient. Once obtained, a local bundle is amenable to sequential static analysis. We show that local bundles are relatively complete for parameterized safety verification, under moderate assumptions. We implement local bundle abstraction in Tool, and show order-of-magnitude speedups compared to a state-of-the-art verifier.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Scott</first_name>
          <last_name>Wesley</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>scottwesley</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maria</first_name>
          <last_name>Christakis</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mariachris.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mariachristakis/b7bf39cc-368b-44aa-bbcb-c83734e1e8fa/small.jpg</picture_url>
          <person_id>mariachristakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arie</first_name>
          <last_name>Gurfinkel</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ece.uwaterloo.ca/~agurfink</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ariegurfinkel/afd05be2-69c7-40dd-990c-230fef4cacf9/small.jpg</picture_url>
          <person_id>ariegurfinkel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Navas</last_name>
          <affiliation>SRI International</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jorgenavas.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgeanavas/662b4942-5460-4898-98cd-2c4e2c701960/small.jpg</picture_url>
          <person_id>jorgeanavas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Richard</first_name>
          <last_name>Trefler</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>richardtrefler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Valentin</first_name>
          <last_name>Wüstholz</last_name>
          <affiliation>ConsenSys</affiliation>
          <bio>Valentin is a software security researcher at ConsenSys Diligence and has held positions both in academia (at ETH Zürich and UT Austin) and in industry (at Microsoft and Google). He is passionate about developing tools and techniques that allow us to produce more reliable and correct software.</bio>
          <homepage_url>http://www.wuestholz.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/valentinwustholz/c6ff5691-4f3e-472c-8454-168eaaebb7eb/small.jpg</picture_url>
          <person_id>valentinwustholz</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>be7e435f-d27d-4295-8f39-24c5ebf1124e</slot_id>
      <event_id>978b8bed-74af-46a6-b73a-7bc39813dbc5</event_id>
      <title>Selectively-Amortized Resource Bounding</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>11:16</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:43</end_time>
      <description>We consider the problem of automatically proving resource bounds. That is, we study how to prove that an integer-valued resource variable is bounded by a given program expression. Automatic resource-bound analysis has recently received significant attention because of a number of important applications (e.g., detecting performance bugs, preventing algorithmic-complexity attacks, identifying side-channel vulnerabilities), where the focus has often been on developing precise amortized reasoning techniques to infer the most exact resource usage. While such innovations remain critical, we observe that fully precise amortization is not always necessary to prove a bound of interest. And in fact, by amortizing selectively, the needed supporting invariants can be simpler, We present a framework for selectively-amortized analysis that mixes worst-case and amortized reasoning via a property decomposition and a program transformation. We show that proving bounds in any such decomposition yields a sound resource bound in the original program, and we give an algorithm for selecting a reasonable decomposition.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tianhan</first_name>
          <last_name>Lu</last_name>
          <affiliation>University of Colorado Boulder</affiliation>
          <bio>undefined</bio>
          <person_id>tianhanlu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bor-Yuh Evan</first_name>
          <last_name>Chang</last_name>
          <affiliation>University of Colorado Boulder &amp; Amazon</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.colorado.edu/~bec/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/boryuhevanchang/0cbe7e94-aaf8-458b-9670-3892350bc209/small.jpg</picture_url>
          <person_id>boryuhevanchang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ashutosh</first_name>
          <last_name>Trivedi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>ashutoshtrivedi</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7c4994a3-9a96-496b-b555-3a003828de5e</subevent_id>
    <title>SAS: Session 2B</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>5759cb83-4e50-46f3-abb4-853effc1c162</slot_id>
      <title>Session: SAS - Session 2B</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0a002b73-7d17-4bb9-96f1-443ebab21ed4</slot_id>
      <event_id>1bce6dfa-6838-46f2-a5a1-5ef566fa1b5f</event_id>
      <title>Compositional Verification of Smart Contracts Through Communication Abstraction</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:16</end_time>
      <description>Solidity smart contracts are programs that manage up to 2^160 users on a blockchain. Verifying a smart contract relative to all users is intractable due to state explosion. Existing solutions either restrict the number of users to under-approximate behaviour, or rely on manual proofs. In this paper, we present local bundles that reduce contracts with arbitrarily many users to sequential programs with a few representative users. Each representative user abstracts concrete users that are locally symmetric to each other relative to the contract and the property. Our abstraction is semi-automated. The representatives depend on communication patterns, and are computed via static analysis. A summary for the behaviour of each representative is provided manually, but a default summary is often sufficient. Once obtained, a local bundle is amenable to sequential static analysis. We show that local bundles are relatively complete for parameterized safety verification, under moderate assumptions. We implement local bundle abstraction in Tool, and show order-of-magnitude speedups compared to a state-of-the-art verifier.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Scott</first_name>
          <last_name>Wesley</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>scottwesley</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maria</first_name>
          <last_name>Christakis</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mariachris.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mariachristakis/b7bf39cc-368b-44aa-bbcb-c83734e1e8fa/small.jpg</picture_url>
          <person_id>mariachristakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arie</first_name>
          <last_name>Gurfinkel</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ece.uwaterloo.ca/~agurfink</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ariegurfinkel/afd05be2-69c7-40dd-990c-230fef4cacf9/small.jpg</picture_url>
          <person_id>ariegurfinkel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Navas</last_name>
          <affiliation>SRI International</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jorgenavas.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgeanavas/662b4942-5460-4898-98cd-2c4e2c701960/small.jpg</picture_url>
          <person_id>jorgeanavas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Richard</first_name>
          <last_name>Trefler</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>richardtrefler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Valentin</first_name>
          <last_name>Wüstholz</last_name>
          <affiliation>ConsenSys</affiliation>
          <bio>Valentin is a software security researcher at ConsenSys Diligence and has held positions both in academia (at ETH Zürich and UT Austin) and in industry (at Microsoft and Google). He is passionate about developing tools and techniques that allow us to produce more reliable and correct software.</bio>
          <homepage_url>http://www.wuestholz.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/valentinwustholz/c6ff5691-4f3e-472c-8454-168eaaebb7eb/small.jpg</picture_url>
          <person_id>valentinwustholz</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>265bce67-c5ec-4066-bd4a-f094e6607df8</slot_id>
      <event_id>978b8bed-74af-46a6-b73a-7bc39813dbc5</event_id>
      <title>Selectively-Amortized Resource Bounding</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>19:16</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:43</end_time>
      <description>We consider the problem of automatically proving resource bounds. That is, we study how to prove that an integer-valued resource variable is bounded by a given program expression. Automatic resource-bound analysis has recently received significant attention because of a number of important applications (e.g., detecting performance bugs, preventing algorithmic-complexity attacks, identifying side-channel vulnerabilities), where the focus has often been on developing precise amortized reasoning techniques to infer the most exact resource usage. While such innovations remain critical, we observe that fully precise amortization is not always necessary to prove a bound of interest. And in fact, by amortizing selectively, the needed supporting invariants can be simpler, We present a framework for selectively-amortized analysis that mixes worst-case and amortized reasoning via a property decomposition and a program transformation. We show that proving bounds in any such decomposition yields a sound resource bound in the original program, and we give an algorithm for selecting a reasonable decomposition.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tianhan</first_name>
          <last_name>Lu</last_name>
          <affiliation>University of Colorado Boulder</affiliation>
          <bio>undefined</bio>
          <person_id>tianhanlu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bor-Yuh Evan</first_name>
          <last_name>Chang</last_name>
          <affiliation>University of Colorado Boulder &amp; Amazon</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.colorado.edu/~bec/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/boryuhevanchang/0cbe7e94-aaf8-458b-9670-3892350bc209/small.jpg</picture_url>
          <person_id>boryuhevanchang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ashutosh</first_name>
          <last_name>Trivedi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>ashutoshtrivedi</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8179f8d0-4636-4be7-84bd-cd8a92c1a121</slot_id>
      <event_id>b08a178c-7f0c-4bc7-b0f8-680f11280a67</event_id>
      <title>Thread-modular Analysis of Release-Acquire Concurrency</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>19:43</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>20:10</end_time>
      <description>We present a thread-modular abstract interpretation(TMAI) technique to verify programs under the release-acquire (RA) memory model for safety property violations. The main contributions of our work are: we capture the execution order of program statements as an abstract domain, and propose a sound upper approximation over this domain to efficiently reason over RA concurrency. The proposed domain is general in its application and captures the ordering relations as a first-class feature in the abstract interpretation theory. In particular, the domain represents a set of sequences of modifications of a global variable in concurrent programs as a partially ordered set. Under this approximation, older sequenced-before stores of a global variable are forgotten and only the latest stores per variable are preserved. We establish the soundness of our proposed abstractions and implement them in a prototype abstract interpreter called PRIORI. The evaluations of PRIORI on existing and challenging RA benchmarks demonstrate that the proposed technique is not only competitive in refutation, but also in verification. PRIORI shows significantly fast analysis runtimes with higher precision compared to recent state-of-the-art tools for RA concurrency.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Divyanjali</first_name>
          <last_name>Sharma</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cse.iitd.ac.in/~divyanjali/</homepage_url>
          <person_id>divyanjalisharma</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Subodh</first_name>
          <last_name>Sharma</last_name>
          <affiliation>IIT Delhi</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://subodhvsharma.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/subodhsharma/fd4e07cc-8466-455b-ad82-3d85138da23f/small.jpg</picture_url>
          <person_id>subodhsharma</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>599baa9f-41d8-4e44-96b7-917974a2be69</subevent_id>
    <title>SAS: Session 2C</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>689ae573-f2b7-488d-9763-325932967822</slot_id>
      <title>Session: SAS - Session 2C</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6b9b1fdf-a599-41cf-9028-a9af0e5b966e</slot_id>
      <event_id>5b184311-60b5-4fbb-8372-ab77441e91d5</event_id>
      <title>Pointer Analysis of Bytecode Programs for Eective Formal Verication of Smart Contracts</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>12:10</end_time>
      <description>Low-level bytecode programs are dicult to handle by formal reasoning, particularly in the case of sound and precise reasoning about memory operations. There is often no distinguished allocation operation: high-level object allocations are aected via pointer arithmetic. Type information is lost in the compilation: the abstraction of memory is simply a at unstructured array of bytes. To recover high-level information, a sound pointer analysis is an invaluable resource. Such an analysis enables optimizations and elucidates program behavior that would otherwise be obscured in a low-level setting. This talk describes a new static analysis algorithm we have developed for sound pointer analysis for low-level bytecode. We make this broad problem tractable by rst restricting our focus to bytecode programs that manage memory via a bump allocator that operates on a distinguished free pointer. In other words, we target bytecode programs where memory is divided into disjoint regions, each of which corresponds to an “object”. Our analysis algorithm uses a novel technique for mapping updates of a distinguished free pointer to provably non-aliased abstract addresses, which enables standard pointer analysis techniques. Our static pointer analysis uses a “trust but verify” approach: we build our analysis on the expectation that the compiler has properly managed memory via the free pointer/bump allocator, but at each step, we verify that regions of memory allocated via the bump allocator are properly disjoint, i.e., every read/write of memory provably accesses only one, distinct region. This talk discusses our practical experience using this analysis in verifying smart contracts that run on the Ethereum Virtual Machine. In particular, we outline multiple high-profi le memory management bugs uncovered by our analysis, and the downstream optimizations and precision improvements unlocked by our pointer analysis results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mooly</first_name>
          <last_name>Sagiv</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>My research focuses on easing the task of developing reliable and efficient software systems. I am particularly interested in static program analysis which combines two disciplines: automated theorem proving and abstract interpretation. In the next decade, I am hoping to develop useful techniques in order to change the ways modern software is built. I am particularly interested in proof automation, given a program and a requirement, automatically prove or disprove that all executions of the program satisfy the requirements. This problem is in general undecidable and untractable. I am interested in developing practical solutions to proof-automation by: (i) exploring modularity of the system and (ii) relying on semi-automatic and interactive process, where the user manually and interactively guides the proof automation, and (iii) simplifying the verification task by using domain-specific abstractions expressed in a decidable logic. I am applying these techniques to verify safety of liveness of distributed systems.</bio>
          <homepage_url>http://www.cs.tau.ac.il/~msagiv/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/moolysagiv/5ff34ce2-4812-410c-aa6d-e1457fc2f1ac/small.jpg</picture_url>
          <person_id>moolysagiv</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bc5fbd62-1bc1-4dc3-95cc-25b4a29d9f2d</subevent_id>
    <title>SAS: Session 4A</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>9350c359-a249-4133-ab89-5389e608eb03</slot_id>
      <title>Session: SAS - Session 4A</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>793a6a97-b31c-4af9-b969-fc2af61b7fdd</slot_id>
      <event_id>e9f054af-c0e2-4c0e-9e9d-3e223f756061</event_id>
      <title>Backward Symbolic Execution with Loop Folding</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>16:20</end_time>
      <description>Symbolic execution is an established program analysis technique that aims to search all possible execution paths starting in the initial program location. Due to the so-called path explosion problem, symbolic execution is usually unable to analyze all execution paths and thus it is not convenient for program verification as a standalone method. This paper focuses on backward symbolic execution (BSE), which searches program paths backward from the error location whose reachability should be proven or refuted. We show that this technique is equivalent to performing k-induction on control-flow paths. While standard BSE simply unwinds all program loops, we present an extension called loop folding that aims to derive loop invariants during BSE that are sufficient to prove the unreachability of the error location. The resulting technique called backward symbolic execution with loop folding (BSELF) can infer disjunctive loop invariants that are hard to derive for current techniques. Indeed, our experiments show that BESLF can verify some standard benchmarks that cannot be verified by state-of-the-art tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marek</first_name>
          <last_name>Chalupa</last_name>
          <affiliation>Masaryk University</affiliation>
          <bio>undefined</bio>
          <person_id>marekchalupa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Strejcek</last_name>
          <affiliation>Masaryk University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.fi.muni.cz/~xstrejc/</homepage_url>
          <person_id>janstrejcek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a767d7a5-8669-4c01-8efd-6cbee3af8d29</slot_id>
      <event_id>64e069c6-2609-4d24-a969-3dc6d81d48fe</event_id>
      <title>Symbolic Automatic Relations and Their Applications to SMT and CHC Solving</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>17:00</end_time>
      <description>Despite the recent advance of automated program verification, reasoning about recursive data structures remains as a challenge for verification tools and their backends such as SMT and CHC solvers. To address the challenge, we introduce the notion of symbolic automatic relations (SARs), which combines symbolic automata and automatic relations, and inherits their good properties such as the closure under Boolean operations. We consider the satisfiability problem for SARs, and show that it is undecidable in general, but that we can construct a sound (but incomplete) and automated satisfiability checker by a reduction to CHC solving. We discuss applications to SMT and CHC solving on data structures, and show the effectiveness of our approach through experiments.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Takumi</first_name>
          <last_name>Shimoda</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>takumishimoda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ken</first_name>
          <last_name>Sakayori</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>kensakayori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ryosuke</first_name>
          <last_name>Sato</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-kb.is.s.u-tokyo.ac.jp/~ryosuke/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ryosukesato/dde2fccf-e07f-48f8-9dc9-277cb124e664/small.jpg</picture_url>
          <person_id>ryosukesato</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aa08c004-bf4c-4471-8d1d-f4607fa64a18</slot_id>
      <event_id>6086e00a-20aa-4a82-b0ff-a48a99c3a839</event_id>
      <title>Improving Thread-Modular Abstract Interpretation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>16:40</end_time>
      <description>We give thread-modular non-relational value analyses as abstractions of a local trace semantics. The semantics as well as the analyses are formulated by means of global invariants and side-effecting constraint systems. We show that a generalization of the analysis provided by the static analyzer Goblint as well as a natural improvement of Antoine Miné’s approach can be obtained as instances of this general scheme. We show that these two analyses are incomparable w.r.t. precision and provide a refinement which improves on both precision-wise. We also report on a preliminary experimental comparison of the given analyses on a meaningful suite of benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Schwarz</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.in.tum.de/i02/personen/michael-schwarz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelschwarz/d579481e-b407-434d-9f91-04548d70b912/small.jpg</picture_url>
          <person_id>michaelschwarz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Saan</last_name>
          <affiliation>University of Tartu, Estonia</affiliation>
          <bio>undefined</bio>
          <person_id>simonsaan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kalmer</first_name>
          <last_name>Apinis</last_name>
          <affiliation>University of Tartu, Estonia</affiliation>
          <bio>undefined</bio>
          <person_id>kalmerapinis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Julian</first_name>
          <last_name>Erhard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julianerhard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Vesal</first_name>
          <last_name>Vojdani</last_name>
          <affiliation>University of Tartu</affiliation>
          <bio>undefined</bio>
          <person_id>vesalvojdani</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f9525b6a-0ed9-4b17-a83a-78ce877271e2</slot_id>
      <event_id>60f4fa55-a96f-4db6-9954-a94ad5243bcc</event_id>
      <title>Automated Verification of the Parallel Bellman--Ford Algorithm</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>16:00</end_time>
      <description>Many real-world problems such as internet routing are actually graph problems. To develop efficient solutions to such problems, more and more parallel graph algorithms are proposed. This paper discusses the mechanized verification of a commonly used parallel graph algorithm, namely the Bellman–Ford algorithm, which provides an inherently parallel solution to the Single-Source Shortest Path problem. Concretely, we verify an unoptimized GPU version of the Bellman–Ford algorithm, using the VerCors verifier. The main challenge that we had to address was to find suitable global invariants of the graph-based properties for automated verification. This case study is the first deductive verification to prove functional correctness of the parallel Bellman–Ford algorithm. It provides the basis to verify other, optimized implementations of the algorithm. Moreover, it may also provide a good starting point to verify other parallel graph-based algorithms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohsen</first_name>
          <last_name>Safari</last_name>
          <affiliation>University of Twente, The Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.utwente.nl/m.safari</homepage_url>
          <person_id>mohsensafari</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wytse</first_name>
          <last_name>Oortwijn</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wwwhome.ewi.utwente.nl/~oortwijnwhm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wytseoortwijn/079f1ba3-77ed-4f76-93e5-136adc3b291e/small.jpg</picture_url>
          <person_id>wytseoortwijn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marieke</first_name>
          <last_name>Huisman</last_name>
          <affiliation>University of Twente</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wwwhome.cs.utwente.nl/~marieke/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mariekehuisman/22505ee7-e6f4-4999-abda-0c8325ff501f/small.jpg</picture_url>
          <person_id>mariekehuisman</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c95bd3c4-aa9a-4179-9db6-69d3844a6684</subevent_id>
    <title>SAS: Session 4B</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>b969e594-b9fa-4246-87d4-9ebb473611bb</slot_id>
      <title>Session: SAS - Session 4B</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cd7dd05e-a07a-4821-b747-2aee6458743a</slot_id>
      <event_id>7e2633f1-97fd-426d-a081-22c7758eefa7</event_id>
      <title>Oracle Parfait: The Flavour of Real-World Vulnerability Detection and Intelligent Conguration</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>17:00</end_time>
      <description>The Parfait static code analysis tool focuses on detecting vulnerabilities that matter in C, C++, Java and Python languages. Its focus has been on key items expected out of a commercial tool that lives in a commercial organisation, namely, precision of results (i.e., high true positive rate), scalability (i.e., being able to run quickly over millions of lines of code), incremental analysis (i.e., being able to run over deltas of the code quickly), and usability (i.e., ease of integration into standard build processes, reporting of traces to the vulnerable location, etc). Today, Parfait is used by thousands of developers at Oracle worldwide on a day-to-day basis. In this presentation we’ll sample a flavour of Parfait – we explore some real world challenges faced in the creation of a robust vulnerability detection tool, look into two examples of vulnerabilities that severely affected the Java platform in 2012/2013 and most machines since 2017, and con- clude by recounting what matters to developers for integration into to- days continuous integration and continuous delivery (CI/CD) pipelines. Key to deployment of static code analysis tools is con guration of the tool itself – we present our experiences with use of machine learning to automatically con gure the tool, providing users with a better out-of-the-box experience.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Cristina</first_name>
          <last_name>Cifuentes</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://labs.oracle.com/people/cristina</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/cristinacifuentes/d6962ceb-c967-49bf-8a95-34899c2d8863/small.jpg</picture_url>
          <person_id>cristinacifuentes</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bda4e8f6-ba6d-4fa8-8bf6-ec23cc601cdc</subevent_id>
    <title>SAS: Session 1A</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>b6e90b1f-ac7a-409f-a3f3-111ce5410e1b</slot_id>
      <title>Session: SAS - Session 1A</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18b96aef-d776-4ec0-8743-6aba7ad5b5db</slot_id>
      <event_id>95da4eb7-6b2a-4e6b-849d-03f3c2019e40</event_id>
      <title>Accelerating Program Analyses in Datalog by Merging Library Facts</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>17:26</end_time>
      <description>Static program analysis uses sensitivity to balance between precision and scalability. However, finer sensitivity does not necessar- ily lead to more precise results but may reduce scalability. Recently, a number of approaches have been proposed to finely tune the sensitivity of different program parts. However, these approaches are usually de- signed for specific program analyses, and their abstraction adjustments are coarse-grained as they directly drop sensitivity elements. 
In this paper, we propose a new technique, 4DM, to tune abstractions for program analyses in Datalog. 4DM merges values in a domain, allowing fine-grained sensitivity tuning. 4DM uses a data-driven algorithm for automatically learning a merging strategy for a library from a training set of programs. Unlike existing approaches that rely on the properties of a certain analysis, our learning algorithm works for a wide range of Datalog analyses. We have evaluated our approach on a points-to analysis and a liveness analysis, on the DaCapo benchmark suite. Our evaluation results suggest that our technique achieves a significant speedup and negligible precision loss, reaching a good balance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yifan</first_name>
          <last_name>Chen</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>yifanchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chenyang</first_name>
          <last_name>Yang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>chenyangyang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xin</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Xin Zhang is an Assistant Professor at the Department of Computer Science and Technology, the School of Electronics Engineering and Computer Science, Peking University. While he is broadly interested in topics related to programming languages (PL) and software engineering (SE), his current focus is on program analysis and its interplay with machine learning (ML) and artificial intelligence (AI). On one hand, he leverages ideas from ML/AI to build better program analyses. On the other hand, he develops program analyses and languages for improving intepretability, fairness, robustness, and safety of ML/AI systems.</bio>
          <homepage_url>http://xinpl.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xinzhang/a4dbba61-3d43-4702-818f-94cad593fbec/small.jpg</picture_url>
          <person_id>xinzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hao</first_name>
          <last_name>Tang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>haotang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Xiaoyin</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Texas at San Antonio</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.utsa.edu/~xwang/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaoyinwang/cb4e92d4-fdd0-4b49-8bd5-f3d867af9188/small.jpg</picture_url>
          <person_id>xiaoyinwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Lu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~zhanglu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/luzhang/bd50fc81-b47a-415a-a9ac-6c041db44562/small.jpg</picture_url>
          <person_id>luzhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6bcf1752-cb31-4ef8-9043-468d50d7df81</slot_id>
      <event_id>07d7e99b-7049-483c-bfc8-b77b31d2e4b4</event_id>
      <title>Verifying Low-dimensional Input Neural Networks via Input Quantization</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>17:53</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>18:20</end_time>
      <description>Deep neural networks are an attractive tool for compressing the control policy lookup tables in systems such as the Airborne Collision Avoidance System (ACAS). It is vital to ensure the safety of such neural controllers via verification techniques. The problem of analyzing ACAS Xu networks has motivated many successful neural network verifiers. These verifiers typically analyze the internal computation of neural networks to decide whether a property regarding the input/output holds. The intrinsic complexity of neural network computation renders such verifiers slow to run and vulnerable to floating-point error. 
This paper revisits the original problem of verifying ACAS Xu networks. The networks take low-dimensional sensory inputs with training data extracted from a lookup table. We propose to prepend an input quantization layer to the network. Quantization allows efficient verification via input state enumeration, whose complexity is bounded by the size of the quantization space. Quantization is equivalent to nearest-neighbor interpolation at run time, which has been shown to provide acceptable accuracy for ACAS in simulation. Moreover, our technique can deliver exact verification results immune to floating-point error if we directly enumerate the network outputs on the target inference implementation or on an accurate simulation of the target implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kai</first_name>
          <last_name>Jia</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>kaijia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin C.</first_name>
          <last_name>Rinard</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.csail.mit.edu/rinard/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinrinard/cc4278df-192e-490f-87e5-a0649c420584/small.jpg</picture_url>
          <person_id>martinrinard</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7a62d34a-dba1-4d05-aacd-619ea77539a6</slot_id>
      <event_id>f90ffbc6-0cc9-4f1a-9361-fb6dc9e9dc39</event_id>
      <title>Exploiting Verified Neural Networks via Floating Point Numerical Error</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>17:26</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>17:53</end_time>
      <description>Motivated by the need to reliably characterize the robustness of deep neural networks, researchers have developed neural network verification algorithms. The verifiers aspire to answer whether certain properties are guaranteed with respect to all inputs in a space for a neural network. However, many verifiers inaccurately model floating point arithmetic but do not fully discuss the consequences. 
We show that the negligence of floating point error leads to unsound verification that can be systematically exploited in practice. For a pretrained neural network, we present a method that efficiently searches inputs as witnesses for the incorrectness of robustness claims made by a complete verifier. We also present a method to construct neural network architectures and weights that induce wrong results of an incomplete verifier. Our results highlight that, to achieve practically reliable verification of neural networks, any verification system must accurately (or conservatively) model the effects of any floating point computations in the network inference or verification system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kai</first_name>
          <last_name>Jia</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>kaijia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin C.</first_name>
          <last_name>Rinard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>martincrinard</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>211eab7c-8126-4543-ae59-ebff96e6db7a</subevent_id>
    <title>SAS: Session 1A</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>4cf6e2de-d79e-4955-98d2-7a2a871bf9c2</slot_id>
      <title>Session: SAS - Session 1A</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5472b8cc-c2f1-4ff3-a867-c0b19095ae0b</slot_id>
      <event_id>f90ffbc6-0cc9-4f1a-9361-fb6dc9e9dc39</event_id>
      <title>Exploiting Verified Neural Networks via Floating Point Numerical Error</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>09:26</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>09:53</end_time>
      <description>Motivated by the need to reliably characterize the robustness of deep neural networks, researchers have developed neural network verification algorithms. The verifiers aspire to answer whether certain properties are guaranteed with respect to all inputs in a space for a neural network. However, many verifiers inaccurately model floating point arithmetic but do not fully discuss the consequences. 
We show that the negligence of floating point error leads to unsound verification that can be systematically exploited in practice. For a pretrained neural network, we present a method that efficiently searches inputs as witnesses for the incorrectness of robustness claims made by a complete verifier. We also present a method to construct neural network architectures and weights that induce wrong results of an incomplete verifier. Our results highlight that, to achieve practically reliable verification of neural networks, any verification system must accurately (or conservatively) model the effects of any floating point computations in the network inference or verification system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kai</first_name>
          <last_name>Jia</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>kaijia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin C.</first_name>
          <last_name>Rinard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>martincrinard</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>caaf9fd3-df60-48fb-86ee-f4f908a30b9a</slot_id>
      <event_id>95da4eb7-6b2a-4e6b-849d-03f3c2019e40</event_id>
      <title>Accelerating Program Analyses in Datalog by Merging Library Facts</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>09:26</end_time>
      <description>Static program analysis uses sensitivity to balance between precision and scalability. However, finer sensitivity does not necessar- ily lead to more precise results but may reduce scalability. Recently, a number of approaches have been proposed to finely tune the sensitivity of different program parts. However, these approaches are usually de- signed for specific program analyses, and their abstraction adjustments are coarse-grained as they directly drop sensitivity elements. 
In this paper, we propose a new technique, 4DM, to tune abstractions for program analyses in Datalog. 4DM merges values in a domain, allowing fine-grained sensitivity tuning. 4DM uses a data-driven algorithm for automatically learning a merging strategy for a library from a training set of programs. Unlike existing approaches that rely on the properties of a certain analysis, our learning algorithm works for a wide range of Datalog analyses. We have evaluated our approach on a points-to analysis and a liveness analysis, on the DaCapo benchmark suite. Our evaluation results suggest that our technique achieves a significant speedup and negligible precision loss, reaching a good balance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yifan</first_name>
          <last_name>Chen</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>yifanchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chenyang</first_name>
          <last_name>Yang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>chenyangyang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xin</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Xin Zhang is an Assistant Professor at the Department of Computer Science and Technology, the School of Electronics Engineering and Computer Science, Peking University. While he is broadly interested in topics related to programming languages (PL) and software engineering (SE), his current focus is on program analysis and its interplay with machine learning (ML) and artificial intelligence (AI). On one hand, he leverages ideas from ML/AI to build better program analyses. On the other hand, he develops program analyses and languages for improving intepretability, fairness, robustness, and safety of ML/AI systems.</bio>
          <homepage_url>http://xinpl.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xinzhang/a4dbba61-3d43-4702-818f-94cad593fbec/small.jpg</picture_url>
          <person_id>xinzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hao</first_name>
          <last_name>Tang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>haotang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Xiaoyin</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Texas at San Antonio</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.utsa.edu/~xwang/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaoyinwang/cb4e92d4-fdd0-4b49-8bd5-f3d867af9188/small.jpg</picture_url>
          <person_id>xiaoyinwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Lu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~zhanglu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/luzhang/bd50fc81-b47a-415a-a9ac-6c041db44562/small.jpg</picture_url>
          <person_id>luzhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f724a5ac-b4d7-43c6-ad39-34a98127fbba</slot_id>
      <event_id>07d7e99b-7049-483c-bfc8-b77b31d2e4b4</event_id>
      <title>Verifying Low-dimensional Input Neural Networks via Input Quantization</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>09:53</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:20</end_time>
      <description>Deep neural networks are an attractive tool for compressing the control policy lookup tables in systems such as the Airborne Collision Avoidance System (ACAS). It is vital to ensure the safety of such neural controllers via verification techniques. The problem of analyzing ACAS Xu networks has motivated many successful neural network verifiers. These verifiers typically analyze the internal computation of neural networks to decide whether a property regarding the input/output holds. The intrinsic complexity of neural network computation renders such verifiers slow to run and vulnerable to floating-point error. 
This paper revisits the original problem of verifying ACAS Xu networks. The networks take low-dimensional sensory inputs with training data extracted from a lookup table. We propose to prepend an input quantization layer to the network. Quantization allows efficient verification via input state enumeration, whose complexity is bounded by the size of the quantization space. Quantization is equivalent to nearest-neighbor interpolation at run time, which has been shown to provide acceptable accuracy for ACAS in simulation. Moreover, our technique can deliver exact verification results immune to floating-point error if we directly enumerate the network outputs on the target inference implementation or on an accurate simulation of the target implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kai</first_name>
          <last_name>Jia</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>kaijia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin C.</first_name>
          <last_name>Rinard</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.csail.mit.edu/rinard/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinrinard/cc4278df-192e-490f-87e5-a0649c420584/small.jpg</picture_url>
          <person_id>martinrinard</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>741f52cf-e040-49df-8f27-940f6c33707f</subevent_id>
    <title>SAS: Session 3A</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>18ce5b4f-6097-4a55-b39b-add89d99b656</slot_id>
      <title>Session: SAS - Session 3A</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b0194a46-b0a8-461c-b2d4-a019e12ede4a</slot_id>
      <event_id>277b5be0-47ca-44d7-8c34-1f84145614be</event_id>
      <title>Interactive Code Analysis</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>15:10</end_time>
      <description>Static code analyzers have become indispensable especially for safety critical software development. But, they do have a few drawbacks as well. For starters, and for good reason, the commercial tools can be quite slow, and they are certainly not suitable for interactive use. I’ll describe a new tool called Cobra, that I’m currently developing, which can resolve types of queries interactively, even on very large code bases. Queries can be scripted or prede ned in libraries. The tool is designed to be easy to use, and is freely available.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Gerard</first_name>
          <last_name>Holzmann</last_name>
          <affiliation>NASA/Caltech Jet Propulsion Laboratory</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://spinroot.com/gerard</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gerardholzmann/c5072b2e-ad04-419b-b08c-1338fb4219d9/small.jpg</picture_url>
          <person_id>gerardholzmann</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cb389a99-d9aa-454d-a2b1-76f2358489d4</subevent_id>
    <title>SAS: Session 4B</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>e9c536a4-6599-41e7-a7fe-f47d151d5c83</slot_id>
      <title>Session: SAS - Session 4B</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b08bea08-3454-41f0-b047-2f08d79e8461</slot_id>
      <event_id>7e2633f1-97fd-426d-a081-22c7758eefa7</event_id>
      <title>Oracle Parfait: The Flavour of Real-World Vulnerability Detection and Intelligent Conguration</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:00</end_time>
      <description>The Parfait static code analysis tool focuses on detecting vulnerabilities that matter in C, C++, Java and Python languages. Its focus has been on key items expected out of a commercial tool that lives in a commercial organisation, namely, precision of results (i.e., high true positive rate), scalability (i.e., being able to run quickly over millions of lines of code), incremental analysis (i.e., being able to run over deltas of the code quickly), and usability (i.e., ease of integration into standard build processes, reporting of traces to the vulnerable location, etc). Today, Parfait is used by thousands of developers at Oracle worldwide on a day-to-day basis. In this presentation we’ll sample a flavour of Parfait – we explore some real world challenges faced in the creation of a robust vulnerability detection tool, look into two examples of vulnerabilities that severely affected the Java platform in 2012/2013 and most machines since 2017, and con- clude by recounting what matters to developers for integration into to- days continuous integration and continuous delivery (CI/CD) pipelines. Key to deployment of static code analysis tools is con guration of the tool itself – we present our experiences with use of machine learning to automatically con gure the tool, providing users with a better out-of-the-box experience.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Cristina</first_name>
          <last_name>Cifuentes</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://labs.oracle.com/people/cristina</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/cristinacifuentes/d6962ceb-c967-49bf-8a95-34899c2d8863/small.jpg</picture_url>
          <person_id>cristinacifuentes</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>be1a3916-c86f-4a97-bb70-c5595b9f02dd</subevent_id>
    <title>SAS: Session 3B</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>58fbc480-a611-4b39-b306-eea771090cf3</slot_id>
      <title>Session: SAS - Session 3B</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1b4f7d14-84cb-4f78-85cb-cce4e8a1c59f</slot_id>
      <event_id>6e4c887f-ca9b-4171-a7bf-d5cdf413503e</event_id>
      <title>A Multi-Language Static Analysis of Python Programs with Native C Extensions</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>22:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:30</end_time>
      <description>Modern programs are increasingly multilanguage, to benefit from each programming language’s advantages and to reuse libraries. For example, developers may want to combine high-level Python code with low-level, performance-oriented C code. In fact one in five of the 200 most-downloaded Python libraries available on GitHub contains C code. Static analyzers tend to focus on a single language, and may use stubs to model the behavior of foreign function calls. However, stubs are costly to implement and undermine soundness of analyzers. In this work we design a static analyzer by abstract interpretation that can handle Python programs calling C extensions. It analyses directly and fully automatically both the Python and the C source codes. It reports runtime errors that may happen in Python, in C, and at the interface. We implemented our analysis in a modular fashion: it reuses off-the-shelf C and Python analyses written in the same analyzer. This approach allows sharing between abstract domains of different languages. Our analyzer can tackle tests of real-world libraries a few thousand lines of C and Python long.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raphaël</first_name>
          <last_name>Monat</last_name>
          <affiliation>Sorbonne Université  — LIP6</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://rmonat.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/raphaelmonat/2405755c-6e69-4ac2-a6af-8231b7b11c81/small.jpg</picture_url>
          <person_id>raphaelmonat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2d7f4dca-0229-4a85-b6c4-7775cf19872f</slot_id>
      <event_id>e8cf7f79-77ce-44b2-b4fd-a19e24245cc6</event_id>
      <title>Data Abstraction: A General Framework to Handle Program Verification of Data Structures</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>23:10</end_time>
      <description>Proving properties on programs operating over arrays, or array-like data structures, most often involves universally quantified invariants, e.g., “all elements below index i are nonzero”. In this article, we propose a general data abstraction scheme operating on Horn Formula for which we provide a relative completeness resolution scheme: the generated purely scalar invariant search problem has a solution if and only if the original problem has one expressible by the abstraction.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julien</first_name>
          <last_name>Braine</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julienbraine</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laure</first_name>
          <last_name>Gonnord</last_name>
          <affiliation>University of Lyon &amp; LIP, France</affiliation>
          <bio>Laure Gonnord received her PhD degree in computer science from the University Joseph Fourier (Grenoble, France), in 2007. She currently holds an assistant professor position at University Lyon I/UCBL, France. She got her Habilitation in 2017. 
Her main research interests lie in the design of static analyses, with emphasis on the automatic synthesis of numerical and memory invariants and application in compilation (scheduling) and termination proofs. She belongs to the CASH team of the LIP laboratory (ENS de Lyon, France).</bio>
          <homepage_url>http://laure.gonnord.org/pro</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lauregonnord/6b741986-7933-4cba-9205-8e5e8451d8fa/small.jpg</picture_url>
          <person_id>lauregonnord</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Monniaux</last_name>
          <affiliation>CNRS/VERIMAG</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-verimag.imag.fr/~monniaux/</homepage_url>
          <person_id>davidmonniaux1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a3cc570c-a9c3-4c28-897f-5b4acd5ee2b0</slot_id>
      <event_id>55890513-6497-44fd-a3a9-838f69361366</event_id>
      <title>Static Analysis of Endian Portability by Abstract Interpretation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:10</end_time>
      <description>We present a static analysis of endian portability for C programs. Our analysis can infer that a given program, or two syntactically close versions thereof, compute the same outputs, when run with the same inputs on platforms with different byte-orders, a.k.a. endiannesses. We target low-level C programs that abuse C pointers and unions, hence rely on implementation-specific behaviors undefined in the C standard. Our method is based on abstract interpretation, and parametric in the choice of a numerical abstract domain. We first present a novel concrete collecting semantics, relating the behaviors of two versions of a program, running on platforms with different endiannesses. We propose a joint memory abstraction, able to infer equivalence relations between little- and big-endian memories. We introduce a novel symbolic predicate domain, to infer relations between individual bytes of the variables in the two programs, which has near-linear cost, and the right amount of relationality to express (bitwise) arithmetic properties relevant to endian portability. We implemented a prototype static analyzer, able to scale to large real-world industrial software, with zero false alarms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Delmas</last_name>
          <affiliation>Airbus &amp; Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.di.ens.fr/~delmas/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/daviddelmas/c73d6e1c-9527-4287-b059-67e4e36354c8/small.jpg</picture_url>
          <person_id>daviddelmas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c69454ea-3bb8-4fa7-bbdc-04ec8dce9e11</slot_id>
      <event_id>8ba2c7e3-b473-4cc6-978b-cb5e94764f5e</event_id>
      <title>Verified Functional Programming of an Abstract Interpreter</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>22:30</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:50</end_time>
      <description>Abstract interpreters are complex pieces of software: even if the abstract interpretation theory and companion algorithms are well understood, their implementations are subject to bugs, that might question the soundness of their computations. 
While some formally verified abstract interpreters have been written in the past, writing and understanding them requires expertise in the use of proof assistants, and requires a non-trivial amount of interactive proofs. 
This paper presents a formally verified abstract interpreter fully programmed and proved correct in the F* verified programming environment. Thanks to F* refinement types and SMT prover capabilities we demonstrate a substantial saving in proof effort compared to previous works based on interactive proofs assistants. Almost all the code of our implementation, proofs included, written in a functional style, are presented directly in the paper.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Franceschino</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <person_id>lucasfranceschino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Pichardie</last_name>
          <affiliation>Univ Rennes, ENS Rennes, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/celtique/pichardie/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidpichardie/b0f30e9b-c1d3-4e4f-9923-4cf150989f86/small.jpg</picture_url>
          <person_id>davidpichardie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean-Pierre</first_name>
          <last_name>Talpin</last_name>
          <affiliation>INRIA, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/prive/talpin</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeanpierretalpin/b5285496-0c64-4e5e-8ce5-f162f8f92881/small.jpg</picture_url>
          <person_id>jeanpierretalpin</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8339f483-572e-4fab-834f-434747ecc851</subevent_id>
    <title>SAS: Session 3C</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>d752c28f-b15a-4cda-9ef4-f75beea4b416</slot_id>
      <title>Session: SAS - Session 3C</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>205d43bf-75dd-4100-bc46-c146fe4e5fac</slot_id>
      <event_id>08c40c54-313a-4b25-88d0-c5d351b1521f</event_id>
      <title>Disjunctive Interval Analysis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:30</end_time>
      <description>We revisit disjunctive interval analysis based on the Boxes abstract domain. We propose the use of what we call range decision diagrams (RDDs) to implement Boxes, and we provide algorithms for the necessary RDD operations. RDDs tend to be more compact than the linear decision diagrams (LDDs) that have traditionally been used for Boxes. Representing information more directly, RDDs also allow for the implementation of more accurate abstract operations. This comes at no cost in terms of analysis efficiency, whether LDDs utilise dynamic variable ordering or not. RDD and LDD implementations are available in the Crab analyzer, and our experiments confirm that RDDs are well suited for disjunctive interval analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Graeme</first_name>
          <last_name>Gange</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>graemegange</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Navas</last_name>
          <affiliation>SRI International</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jorgenavas.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgeanavas/662b4942-5460-4898-98cd-2c4e2c701960/small.jpg</picture_url>
          <person_id>jorgeanavas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Schachte</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>peterschachte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Harald</first_name>
          <last_name>Sondergaard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>haraldsondergaard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Peter J.</first_name>
          <last_name>Stuckey</last_name>
          <affiliation>Monash University</affiliation>
          <bio>undefined</bio>
          <person_id>peterjstuckey</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3a353b90-3292-4e16-af98-631785a4708a</slot_id>
      <event_id>2c3eebff-50b9-4105-85f2-b8ccbd1eed98</event_id>
      <title>Automatic Synthesis of Data-Flow Analyzers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:10</end_time>
      <description>Data-flow analyzers (DFAs) are widely deployed in many stages of software development, such as compiler optimization, bug detection, and program verification. Automating their synthesis is non-trivial but will be practically beneficial. In this paper, we propose DFASy, a framework for the automatic synthesis of DFAs. Given a specification consisting of a control flow graph and the expected data-flow facts before and after each of its nodes, DFASy automatically synthesizes a DFA that satisfies the specification, including its flow direction, meet operator, and transfer function. DFASy synthesizes transfer functions by working with a domain-specific language that supports rich data-flow fact extraction operations, set operations, and logic operations. To avoid exploding the search space, we introduce an abstraction-guided pruning technique to assess the satisfiability of partially instantiated candidates and drop unsatisfiable ones from further consideration as early as possible. In addition, we also introduce a brevity-guided pruning technique to improve the readability and simplicity of synthesized DFAs and further accelerate the search. We have built a benchmark suite, which consists of seven classic (e.g., live variable analysis and null pointer detection) and seven custom data-flow problems. DFASy has successfully solved all the 14 data-flow problems in 21.8 seconds on average, outperforming significantly the three baselines compared. Both DFASy and its associated benchmark suite will be open-sourced.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xuezheng</first_name>
          <last_name>Xu</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>I am a Ph.D. student (September 2017 - now) at UNSW Sydney (Supervisor: Prof.Jingling Xue, Co-Supervisor: Dr. Yulei Sui).</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~xuezhengxu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xuezhengxu/bcb2bb20-169f-4a68-97d3-c9afd426cd41/small.jpg</picture_url>
          <person_id>xuezhengxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xudong</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of New South Wales</affiliation>
          <bio>undefined</bio>
          <person_id>xudongwang3</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Xue</last_name>
          <affiliation>UNSW</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~jingling/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jinglingxue/1045ace0-547f-4dc6-b960-79be78997c50/small.jpg</picture_url>
          <person_id>jinglingxue</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a42f2ceb-a178-429f-ae15-9bd49b9c19d3</slot_id>
      <event_id>0a214e99-fc0c-4b38-ad7b-7b27f94df17b</event_id>
      <title>Hash Consed Points-To Sets</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:50</end_time>
      <description>Points-to analysis is a fundamental static analysis, on which many other analyses and optimisations are built. The goal of points-to analysis is to statically approximate the set of abstract objects that a pointer can point to at runtime. Due to the nature of static analysis, points-to analysis introduces much redundancy which can result in duplicate points-to sets and duplicate set union operations, particularly when analysing large programs precisely. To improve performance, there has been extensive effort in mitigating duplication at the algorithmic level through, for example, cycle elimination and variable substitution. 
Unlike previous approaches which make algorithmic changes to points-to analysis, this work aims to improve the underlying data structure, which is less studied. Inspired by hash consing from the functional programming community, this paper introduces the use of hash consed points-to sets to reduce the effects of this duplication on both space and time without any high-level algorithmic change. Hash consing can effectively handle duplicate points-to set by representing points-to sets once, and referring to such representations through references, and can speed up duplicate union operations through efficient memoisation. We have implemented and evaluated our approach using 16 real-world C/C++ programs (more than 9.5 million lines of LLVM instructions). Our results show that our approach speeds up state-of-the-art Andersen’s analysis by 1.86× on average (up to 3.21×) and staged flow-sensitive analysis (SFS) by 1.69× on average (up to 2.23×). We also observe an average ≥4.93× (up to ≥15.52×) memory usage reduction in SFS.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohamad</first_name>
          <last_name>Barbar</last_name>
          <affiliation>University of Technology Sydney, Australia and CSIRO's Data61, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mbarbar.net</homepage_url>
          <person_id>mohamadbarbar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dbe89066-2d84-4214-83d9-4d6de88e8da5</slot_id>
      <event_id>90b4e2a4-4af7-4e89-aa86-9d042700e863</event_id>
      <title>Selective Context-Sensitivity for k-CFA with CFL-Reachability</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>15:10</end_time>
      <description>k-CFA provides the most well-known context abstraction for program analysis, especially pointer analysis, for a wide range of programming languages. However, its inherent context explosion problem has hindered its applicability. To mitigate this problem, selective context-sensitivity is promising as context-sensitivity is applied only selectively to some parts of the program. This paper introduces a new approach to selective context-sensitivity for supporting k-CFA-based pointer analysis, based on CFL-reachability. Our approach can make k-CFA-based pointer analysis run significantly faster while losing little precision, based on an evaluation using a set of 11 popular Java benchmarks and applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jingbo</first_name>
          <last_name>Lu</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>jingbolu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dongjie</first_name>
          <last_name>He</last_name>
          <affiliation>University of New South Wales</affiliation>
          <bio>He is currently a third-year Ph.D. student at the University of New South Wales. His research interests include programming languages, security analysis, and software engineering. Specifically, he is familiar with Java pointer analysis, Android taint analysis, and Android compatibility issues.</bio>
          <homepage_url>https://dongjiehe.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dongjiehe/a0baf664-c972-4207-8d58-84197971110e/small.jpg</picture_url>
          <person_id>dongjiehe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Xue</last_name>
          <affiliation>UNSW</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~jingling/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jinglingxue/1045ace0-547f-4dc6-b960-79be78997c50/small.jpg</picture_url>
          <person_id>jinglingxue</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e149ef5a-ff0c-4c01-b259-1f54cf1c6d43</subevent_id>
    <title>SAS: Session 2C</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>7d4cde15-2270-46e7-ae3f-18994f5b5561</slot_id>
      <title>Session: SAS - Session 2C</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1674e5a5-700a-40a2-b06b-3739fa134e47</slot_id>
      <event_id>5b184311-60b5-4fbb-8372-ab77441e91d5</event_id>
      <title>Pointer Analysis of Bytecode Programs for Eective Formal Verication of Smart Contracts</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>20:10</end_time>
      <description>Low-level bytecode programs are dicult to handle by formal reasoning, particularly in the case of sound and precise reasoning about memory operations. There is often no distinguished allocation operation: high-level object allocations are aected via pointer arithmetic. Type information is lost in the compilation: the abstraction of memory is simply a at unstructured array of bytes. To recover high-level information, a sound pointer analysis is an invaluable resource. Such an analysis enables optimizations and elucidates program behavior that would otherwise be obscured in a low-level setting. This talk describes a new static analysis algorithm we have developed for sound pointer analysis for low-level bytecode. We make this broad problem tractable by rst restricting our focus to bytecode programs that manage memory via a bump allocator that operates on a distinguished free pointer. In other words, we target bytecode programs where memory is divided into disjoint regions, each of which corresponds to an “object”. Our analysis algorithm uses a novel technique for mapping updates of a distinguished free pointer to provably non-aliased abstract addresses, which enables standard pointer analysis techniques. Our static pointer analysis uses a “trust but verify” approach: we build our analysis on the expectation that the compiler has properly managed memory via the free pointer/bump allocator, but at each step, we verify that regions of memory allocated via the bump allocator are properly disjoint, i.e., every read/write of memory provably accesses only one, distinct region. This talk discusses our practical experience using this analysis in verifying smart contracts that run on the Ethereum Virtual Machine. In particular, we outline multiple high-profi le memory management bugs uncovered by our analysis, and the downstream optimizations and precision improvements unlocked by our pointer analysis results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mooly</first_name>
          <last_name>Sagiv</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>My research focuses on easing the task of developing reliable and efficient software systems. I am particularly interested in static program analysis which combines two disciplines: automated theorem proving and abstract interpretation. In the next decade, I am hoping to develop useful techniques in order to change the ways modern software is built. I am particularly interested in proof automation, given a program and a requirement, automatically prove or disprove that all executions of the program satisfy the requirements. This problem is in general undecidable and untractable. I am interested in developing practical solutions to proof-automation by: (i) exploring modularity of the system and (ii) relying on semi-automatic and interactive process, where the user manually and interactively guides the proof automation, and (iii) simplifying the verification task by using domain-specific abstractions expressed in a decidable logic. I am applying these techniques to verify safety of liveness of distributed systems.</bio>
          <homepage_url>http://www.cs.tau.ac.il/~msagiv/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/moolysagiv/5ff34ce2-4812-410c-aa6d-e1457fc2f1ac/small.jpg</picture_url>
          <person_id>moolysagiv</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f929a6a0-2cd1-4aa2-96db-d3b5cb89f4ea</subevent_id>
    <title>SAS: Session 3B</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>6218f22b-a6cd-42e2-9a5e-5823b4a2ebbf</slot_id>
      <title>Session: SAS - Session 3B</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>23a8c5b8-bf26-4069-84a7-12f185d1d905</slot_id>
      <event_id>8ba2c7e3-b473-4cc6-978b-cb5e94764f5e</event_id>
      <title>Verified Functional Programming of an Abstract Interpreter</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:50</end_time>
      <description>Abstract interpreters are complex pieces of software: even if the abstract interpretation theory and companion algorithms are well understood, their implementations are subject to bugs, that might question the soundness of their computations. 
While some formally verified abstract interpreters have been written in the past, writing and understanding them requires expertise in the use of proof assistants, and requires a non-trivial amount of interactive proofs. 
This paper presents a formally verified abstract interpreter fully programmed and proved correct in the F* verified programming environment. Thanks to F* refinement types and SMT prover capabilities we demonstrate a substantial saving in proof effort compared to previous works based on interactive proofs assistants. Almost all the code of our implementation, proofs included, written in a functional style, are presented directly in the paper.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Franceschino</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <person_id>lucasfranceschino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Pichardie</last_name>
          <affiliation>Univ Rennes, ENS Rennes, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/celtique/pichardie/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidpichardie/b0f30e9b-c1d3-4e4f-9923-4cf150989f86/small.jpg</picture_url>
          <person_id>davidpichardie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean-Pierre</first_name>
          <last_name>Talpin</last_name>
          <affiliation>INRIA, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/prive/talpin</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeanpierretalpin/b5285496-0c64-4e5e-8ce5-f162f8f92881/small.jpg</picture_url>
          <person_id>jeanpierretalpin</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2f3b5e8a-9f73-44d1-b0b8-87999d0ff376</slot_id>
      <event_id>e8cf7f79-77ce-44b2-b4fd-a19e24245cc6</event_id>
      <title>Data Abstraction: A General Framework to Handle Program Verification of Data Structures</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>15:10</end_time>
      <description>Proving properties on programs operating over arrays, or array-like data structures, most often involves universally quantified invariants, e.g., “all elements below index i are nonzero”. In this article, we propose a general data abstraction scheme operating on Horn Formula for which we provide a relative completeness resolution scheme: the generated purely scalar invariant search problem has a solution if and only if the original problem has one expressible by the abstraction.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julien</first_name>
          <last_name>Braine</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julienbraine</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laure</first_name>
          <last_name>Gonnord</last_name>
          <affiliation>University of Lyon &amp; LIP, France</affiliation>
          <bio>Laure Gonnord received her PhD degree in computer science from the University Joseph Fourier (Grenoble, France), in 2007. She currently holds an assistant professor position at University Lyon I/UCBL, France. She got her Habilitation in 2017. 
Her main research interests lie in the design of static analyses, with emphasis on the automatic synthesis of numerical and memory invariants and application in compilation (scheduling) and termination proofs. She belongs to the CASH team of the LIP laboratory (ENS de Lyon, France).</bio>
          <homepage_url>http://laure.gonnord.org/pro</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lauregonnord/6b741986-7933-4cba-9205-8e5e8451d8fa/small.jpg</picture_url>
          <person_id>lauregonnord</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Monniaux</last_name>
          <affiliation>CNRS/VERIMAG</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-verimag.imag.fr/~monniaux/</homepage_url>
          <person_id>davidmonniaux1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7b76d369-4c81-4eab-96bb-e71a08d1af68</slot_id>
      <event_id>55890513-6497-44fd-a3a9-838f69361366</event_id>
      <title>Static Analysis of Endian Portability by Abstract Interpretation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:10</end_time>
      <description>We present a static analysis of endian portability for C programs. Our analysis can infer that a given program, or two syntactically close versions thereof, compute the same outputs, when run with the same inputs on platforms with different byte-orders, a.k.a. endiannesses. We target low-level C programs that abuse C pointers and unions, hence rely on implementation-specific behaviors undefined in the C standard. Our method is based on abstract interpretation, and parametric in the choice of a numerical abstract domain. We first present a novel concrete collecting semantics, relating the behaviors of two versions of a program, running on platforms with different endiannesses. We propose a joint memory abstraction, able to infer equivalence relations between little- and big-endian memories. We introduce a novel symbolic predicate domain, to infer relations between individual bytes of the variables in the two programs, which has near-linear cost, and the right amount of relationality to express (bitwise) arithmetic properties relevant to endian portability. We implemented a prototype static analyzer, able to scale to large real-world industrial software, with zero false alarms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Delmas</last_name>
          <affiliation>Airbus &amp; Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.di.ens.fr/~delmas/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/daviddelmas/c73d6e1c-9527-4287-b059-67e4e36354c8/small.jpg</picture_url>
          <person_id>daviddelmas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>abdf3d41-c628-471e-a714-0575b703d36d</slot_id>
      <event_id>6e4c887f-ca9b-4171-a7bf-d5cdf413503e</event_id>
      <title>A Multi-Language Static Analysis of Python Programs with Native C Extensions</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:30</end_time>
      <description>Modern programs are increasingly multilanguage, to benefit from each programming language’s advantages and to reuse libraries. For example, developers may want to combine high-level Python code with low-level, performance-oriented C code. In fact one in five of the 200 most-downloaded Python libraries available on GitHub contains C code. Static analyzers tend to focus on a single language, and may use stubs to model the behavior of foreign function calls. However, stubs are costly to implement and undermine soundness of analyzers. In this work we design a static analyzer by abstract interpretation that can handle Python programs calling C extensions. It analyses directly and fully automatically both the Python and the C source codes. It reports runtime errors that may happen in Python, in C, and at the interface. We implemented our analysis in a modular fashion: it reuses off-the-shelf C and Python analyses written in the same analyzer. This approach allows sharing between abstract domains of different languages. Our analyzer can tackle tests of real-world libraries a few thousand lines of C and Python long.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raphaël</first_name>
          <last_name>Monat</last_name>
          <affiliation>Sorbonne Université  — LIP6</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://rmonat.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/raphaelmonat/2405755c-6e69-4ac2-a6af-8231b7b11c81/small.jpg</picture_url>
          <person_id>raphaelmonat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2092679f-60e5-4051-9def-54e2324a0080</subevent_id>
    <title>SAS: Session 3C</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>9bb48f44-48a8-4897-9ff5-6deaeabf6ff4</slot_id>
      <title>Session: SAS - Session 3C</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>251ef49a-a302-4165-9f86-4290fff8f9d9</slot_id>
      <event_id>0a214e99-fc0c-4b38-ad7b-7b27f94df17b</event_id>
      <title>Hash Consed Points-To Sets</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>22:30</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>22:50</end_time>
      <description>Points-to analysis is a fundamental static analysis, on which many other analyses and optimisations are built. The goal of points-to analysis is to statically approximate the set of abstract objects that a pointer can point to at runtime. Due to the nature of static analysis, points-to analysis introduces much redundancy which can result in duplicate points-to sets and duplicate set union operations, particularly when analysing large programs precisely. To improve performance, there has been extensive effort in mitigating duplication at the algorithmic level through, for example, cycle elimination and variable substitution. 
Unlike previous approaches which make algorithmic changes to points-to analysis, this work aims to improve the underlying data structure, which is less studied. Inspired by hash consing from the functional programming community, this paper introduces the use of hash consed points-to sets to reduce the effects of this duplication on both space and time without any high-level algorithmic change. Hash consing can effectively handle duplicate points-to set by representing points-to sets once, and referring to such representations through references, and can speed up duplicate union operations through efficient memoisation. We have implemented and evaluated our approach using 16 real-world C/C++ programs (more than 9.5 million lines of LLVM instructions). Our results show that our approach speeds up state-of-the-art Andersen’s analysis by 1.86× on average (up to 3.21×) and staged flow-sensitive analysis (SFS) by 1.69× on average (up to 2.23×). We also observe an average ≥4.93× (up to ≥15.52×) memory usage reduction in SFS.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohamad</first_name>
          <last_name>Barbar</last_name>
          <affiliation>University of Technology Sydney, Australia and CSIRO's Data61, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mbarbar.net</homepage_url>
          <person_id>mohamadbarbar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>54730bda-14ee-4e3f-8457-71bcb959d2ea</slot_id>
      <event_id>2c3eebff-50b9-4105-85f2-b8ccbd1eed98</event_id>
      <title>Automatic Synthesis of Data-Flow Analyzers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>22:10</end_time>
      <description>Data-flow analyzers (DFAs) are widely deployed in many stages of software development, such as compiler optimization, bug detection, and program verification. Automating their synthesis is non-trivial but will be practically beneficial. In this paper, we propose DFASy, a framework for the automatic synthesis of DFAs. Given a specification consisting of a control flow graph and the expected data-flow facts before and after each of its nodes, DFASy automatically synthesizes a DFA that satisfies the specification, including its flow direction, meet operator, and transfer function. DFASy synthesizes transfer functions by working with a domain-specific language that supports rich data-flow fact extraction operations, set operations, and logic operations. To avoid exploding the search space, we introduce an abstraction-guided pruning technique to assess the satisfiability of partially instantiated candidates and drop unsatisfiable ones from further consideration as early as possible. In addition, we also introduce a brevity-guided pruning technique to improve the readability and simplicity of synthesized DFAs and further accelerate the search. We have built a benchmark suite, which consists of seven classic (e.g., live variable analysis and null pointer detection) and seven custom data-flow problems. DFASy has successfully solved all the 14 data-flow problems in 21.8 seconds on average, outperforming significantly the three baselines compared. Both DFASy and its associated benchmark suite will be open-sourced.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xuezheng</first_name>
          <last_name>Xu</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>I am a Ph.D. student (September 2017 - now) at UNSW Sydney (Supervisor: Prof.Jingling Xue, Co-Supervisor: Dr. Yulei Sui).</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~xuezhengxu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xuezhengxu/bcb2bb20-169f-4a68-97d3-c9afd426cd41/small.jpg</picture_url>
          <person_id>xuezhengxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xudong</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of New South Wales</affiliation>
          <bio>undefined</bio>
          <person_id>xudongwang3</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Xue</last_name>
          <affiliation>UNSW</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~jingling/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jinglingxue/1045ace0-547f-4dc6-b960-79be78997c50/small.jpg</picture_url>
          <person_id>jinglingxue</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8889a918-8614-4f1e-a6df-48fbffcf2d62</slot_id>
      <event_id>08c40c54-313a-4b25-88d0-c5d351b1521f</event_id>
      <title>Disjunctive Interval Analysis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>22:10</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>22:30</end_time>
      <description>We revisit disjunctive interval analysis based on the Boxes abstract domain. We propose the use of what we call range decision diagrams (RDDs) to implement Boxes, and we provide algorithms for the necessary RDD operations. RDDs tend to be more compact than the linear decision diagrams (LDDs) that have traditionally been used for Boxes. Representing information more directly, RDDs also allow for the implementation of more accurate abstract operations. This comes at no cost in terms of analysis efficiency, whether LDDs utilise dynamic variable ordering or not. RDD and LDD implementations are available in the Crab analyzer, and our experiments confirm that RDDs are well suited for disjunctive interval analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Graeme</first_name>
          <last_name>Gange</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>graemegange</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Navas</last_name>
          <affiliation>SRI International</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jorgenavas.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgeanavas/662b4942-5460-4898-98cd-2c4e2c701960/small.jpg</picture_url>
          <person_id>jorgeanavas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Schachte</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>peterschachte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Harald</first_name>
          <last_name>Sondergaard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>haraldsondergaard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Peter J.</first_name>
          <last_name>Stuckey</last_name>
          <affiliation>Monash University</affiliation>
          <bio>undefined</bio>
          <person_id>peterjstuckey</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c72a7717-94a5-4923-a5d8-bca70aacf88e</slot_id>
      <event_id>90b4e2a4-4af7-4e89-aa86-9d042700e863</event_id>
      <title>Selective Context-Sensitivity for k-CFA with CFL-Reachability</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>23:10</end_time>
      <description>k-CFA provides the most well-known context abstraction for program analysis, especially pointer analysis, for a wide range of programming languages. However, its inherent context explosion problem has hindered its applicability. To mitigate this problem, selective context-sensitivity is promising as context-sensitivity is applied only selectively to some parts of the program. This paper introduces a new approach to selective context-sensitivity for supporting k-CFA-based pointer analysis, based on CFL-reachability. Our approach can make k-CFA-based pointer analysis run significantly faster while losing little precision, based on an evaluation using a set of 11 popular Java benchmarks and applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jingbo</first_name>
          <last_name>Lu</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>jingbolu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dongjie</first_name>
          <last_name>He</last_name>
          <affiliation>University of New South Wales</affiliation>
          <bio>He is currently a third-year Ph.D. student at the University of New South Wales. His research interests include programming languages, security analysis, and software engineering. Specifically, he is familiar with Java pointer analysis, Android taint analysis, and Android compatibility issues.</bio>
          <homepage_url>https://dongjiehe.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dongjiehe/a0baf664-c972-4207-8d58-84197971110e/small.jpg</picture_url>
          <person_id>dongjiehe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Xue</last_name>
          <affiliation>UNSW</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~jingling/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jinglingxue/1045ace0-547f-4dc6-b960-79be78997c50/small.jpg</picture_url>
          <person_id>jinglingxue</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0175770f-85a8-40a2-8563-60075e61515a</subevent_id>
    <title>SAS: Session 4C</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>58fd6cb9-d999-4dfb-8cb6-695ff6d700bc</slot_id>
      <title>Session: SAS - Session 4C</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2c3b1cae-5b56-41bd-b73a-834db45a08c7</slot_id>
      <event_id>0a69e561-77a5-4b4d-88c5-de8c3a0dd7d2</event_id>
      <title>Fast and Efficient Bit-Level Precision Tuning</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>08:00</end_time>
      <description>In this article, we introduce a new technique for precision tuning. This problem consists of finding the least data types for numerical values such that the result of the computation satisfies some accuracy requirement. State of the art techniques for precision tuning use a try and fail approach. They change the data types of some variables of the program and evaluate the accuracy of the result. Depending on what is obtained, they change more or less data types and repeat the process. Our technique is radically different. Based on semantic equations, we generate an Integer Linear Problem (ILP) from the program source code. Basically, this is done by reasoning on the most significant bit and the number of significant bits of the values which are integer quantities. The integer solution to this problem, computed in polynomial time by a classical linear programming solver, gives the optimal data types at the bit level. A finer set of semantic equations is also proposed which does not reduce directly to an ILP problem. So we use policy iteration to find the solution. Both techniques have been implemented and we show that our results encompass the results of state-of-the-art tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Assalé</first_name>
          <last_name>Adjé</last_name>
          <affiliation>Université de Perpignan Via Domitia</affiliation>
          <bio>undefined</bio>
          <person_id>assaleadje</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dorra</first_name>
          <last_name>Ben Khalifa</last_name>
          <affiliation>Université de Perpignan Via Domitia</affiliation>
          <bio>undefined</bio>
          <person_id>dorrabenkhalifa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Martel</last_name>
          <affiliation>Université de Perpignan Via Domitia</affiliation>
          <bio>undefined</bio>
          <person_id>matthieumartel</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>73600e84-1ade-4172-a0a9-120fd2500442</slot_id>
      <event_id>fb0761d9-16c7-4e3e-93d8-8a386f88a71d</event_id>
      <title>Reduced Products of Abstract Domains for Fairness Certification of Neural Networks</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>08:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>08:20</end_time>
      <description>We present Tool, an open-source abstract interpretation-based static analyzer for certifying fairness of ReLU neural network classifiers for tabular data. Tool combines a sound forward pre-analysis with an exact backward analysis that leverages the polyhedra abstract domain to provide definite fairness guarantees when possible, and to otherwise quantify and describe the biased input space regions. The analysis is configurable in terms of scalability and precision. We equipped Tool with new abstract domains to use in the pre-analysis, including a generic reduced product domain construction, as well as search heuristics to find the best analysis configuration. We additionally set up the backward analysis to allow further parallelization. Our experimental evaluation demonstrates the effectiveness of the approach on neural networks trained on a popular dataset in the fairness literature.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Denis</first_name>
          <last_name>Mazzucato</last_name>
          <affiliation>INRIA &amp; École Normale Supérieure</affiliation>
          <bio>undefined</bio>
          <person_id>denismazzucato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Caterina</first_name>
          <last_name>Urban</last_name>
          <affiliation>INRIA &amp; École Normale Supérieure | Université PSL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://caterinaurban.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/caterinaurban1/a945f9bd-bc13-4fe2-945a-59528d7d7e2a/small.jpg</picture_url>
          <person_id>caterinaurban1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b7294443-2e99-4c83-9946-50a0c65409ee</slot_id>
      <event_id>4c218694-b052-4c87-9e69-81d7076e6850</event_id>
      <title>Static analysis of ReLU neural networks with tropical polyhedra</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>08:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>08:40</end_time>
      <description>This paper studies the problem of range analysis for feedforward neural networks, which is a basic primitive for applications such as robustness of neural networks, compliance to specifications and reachability analysis of neural-network feedback systems. Our approach focuses on ReLU (rectified linear unit) feedforward neural nets that present specific difficulties: approaches that exploit derivatives do not apply in general, the number of patterns of neuron activations can be quite large even for small networks, and convex approximations are generally too coarse. In this paper, we employ set-based methods and abstract interpretation that have been very successful in coping with similar difficulties in classical program verification. We present an approach that abstracts ReLU feedforward neural networks using tropical polyhedra. We show that tropical polyhedra can efficiently abstract ReLU activation function, while being able to control the loss of precision due to linear computations. We show how the connection between ReLU networks and tropical rational functions can provide approaches for range analysis of ReLU neural networks. We report on a preliminary evaluation of our approach using a prototype implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Goubault</last_name>
          <affiliation>Ecole Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>ericgoubault</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastien</first_name>
          <last_name>Palumby</last_name>
          <affiliation>Ecole Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>sebastienpalumby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sylvie</first_name>
          <last_name>Putot</last_name>
          <affiliation>École Polytechnique</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lix.polytechnique.fr/Labo/Sylvie.Putot/</homepage_url>
          <person_id>sylvieputot</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Louis</first_name>
          <last_name>Rustenholz</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>louisrustenholz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Sankaranarayanan</last_name>
          <affiliation>University of Colorado, Boulder</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.colorado.edu/~srirams/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sriramsankaranarayanan/cc1e5234-6137-4a38-8d5d-3fac7abb93eb/small.jpg</picture_url>
          <person_id>sriramsankaranarayanan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ba67ac56-3438-4564-ba07-b870def25c47</slot_id>
      <event_id>e6d9543d-594e-4e03-83e7-6464df6cc24e</event_id>
      <title>Toward Neural-Network-Guided Program Synthesis and Verification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>09:00</end_time>
      <description>We propose a novel framework of program and invariant synthesis called neural network-guided synthesis. We first show that, by suitably designing and training neural networks, we can extract logical formulas over integers from the weights and biases of the trained neural networks. Based on the idea, we have implemented a tool to synthesize formulas from positive/negative examples and implication constraints, and obtained promising experimental results. We also discuss an application of our method for improving the qualifier discovery in the framework of ICE-learning-based CHC solving, which can in turn be applied to program verification and inductive invariant synthesis. Another potential application is to a neural-network-guided variation of Solar-Lezama’s program synthesis by sketching.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Taro</first_name>
          <last_name>Sekiyama</last_name>
          <affiliation>National Institute of Informatics</affiliation>
          <bio>I’m an assistant professor at National Institute of Informatics in Japan. I am interested in theory and applications of programming languages, such as type theory, program verification, type inference, program reasoning, and so on.</bio>
          <homepage_url>https://researchmap.jp/t-sekiym/?lang=english</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tarosekiyama/dd6fb4ca-8161-4bbd-9392-01e4b94374e6/small.jpg</picture_url>
          <person_id>tarosekiyama</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Issei</first_name>
          <last_name>Sato</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>isseisato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hiroshi</first_name>
          <last_name>Unno</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tsukuba.ac.jp/~uhiro/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hiroshiunno/c5c1b748-082d-4abd-93f0-dbebf6ab1d98/small.jpg</picture_url>
          <person_id>hiroshiunno</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9d52658c-5129-429a-ba2b-14f75ea3a60e</subevent_id>
    <title>SAS: Session 3A </title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>b25863ac-b766-4816-b3b3-3eb6deef208f</slot_id>
      <title>Session: SAS - Session 3A </title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>683d274e-e839-483b-b1d8-b8e8a260f486</slot_id>
      <event_id>277b5be0-47ca-44d7-8c34-1f84145614be</event_id>
      <title>Interactive Code Analysis</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>23:10</end_time>
      <description>Static code analyzers have become indispensable especially for safety critical software development. But, they do have a few drawbacks as well. For starters, and for good reason, the commercial tools can be quite slow, and they are certainly not suitable for interactive use. I’ll describe a new tool called Cobra, that I’m currently developing, which can resolve types of queries interactively, even on very large code bases. Queries can be scripted or prede ned in libraries. The tool is designed to be easy to use, and is freely available.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Gerard</first_name>
          <last_name>Holzmann</last_name>
          <affiliation>NASA/Caltech Jet Propulsion Laboratory</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://spinroot.com/gerard</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gerardholzmann/c5072b2e-ad04-419b-b08c-1338fb4219d9/small.jpg</picture_url>
          <person_id>gerardholzmann</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>24dbbd5d-f929-48f3-8748-3ca5274a30b7</subevent_id>
    <title>SAS: Session 4A</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>4a44fd86-0785-4db9-9f8d-809d9bc08acd</slot_id>
      <title>Session: SAS - Session 4A</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3c619807-b7ae-46ff-abd7-b3aec7b4ba0a</slot_id>
      <event_id>e9f054af-c0e2-4c0e-9e9d-3e223f756061</event_id>
      <title>Backward Symbolic Execution with Loop Folding</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>08:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>08:20</end_time>
      <description>Symbolic execution is an established program analysis technique that aims to search all possible execution paths starting in the initial program location. Due to the so-called path explosion problem, symbolic execution is usually unable to analyze all execution paths and thus it is not convenient for program verification as a standalone method. This paper focuses on backward symbolic execution (BSE), which searches program paths backward from the error location whose reachability should be proven or refuted. We show that this technique is equivalent to performing k-induction on control-flow paths. While standard BSE simply unwinds all program loops, we present an extension called loop folding that aims to derive loop invariants during BSE that are sufficient to prove the unreachability of the error location. The resulting technique called backward symbolic execution with loop folding (BSELF) can infer disjunctive loop invariants that are hard to derive for current techniques. Indeed, our experiments show that BESLF can verify some standard benchmarks that cannot be verified by state-of-the-art tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marek</first_name>
          <last_name>Chalupa</last_name>
          <affiliation>Masaryk University</affiliation>
          <bio>undefined</bio>
          <person_id>marekchalupa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Strejcek</last_name>
          <affiliation>Masaryk University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.fi.muni.cz/~xstrejc/</homepage_url>
          <person_id>janstrejcek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3cc1ac13-39c3-487f-a1d4-65d067056f72</slot_id>
      <event_id>6086e00a-20aa-4a82-b0ff-a48a99c3a839</event_id>
      <title>Improving Thread-Modular Abstract Interpretation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>08:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>08:40</end_time>
      <description>We give thread-modular non-relational value analyses as abstractions of a local trace semantics. The semantics as well as the analyses are formulated by means of global invariants and side-effecting constraint systems. We show that a generalization of the analysis provided by the static analyzer Goblint as well as a natural improvement of Antoine Miné’s approach can be obtained as instances of this general scheme. We show that these two analyses are incomparable w.r.t. precision and provide a refinement which improves on both precision-wise. We also report on a preliminary experimental comparison of the given analyses on a meaningful suite of benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Schwarz</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.in.tum.de/i02/personen/michael-schwarz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelschwarz/d579481e-b407-434d-9f91-04548d70b912/small.jpg</picture_url>
          <person_id>michaelschwarz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Saan</last_name>
          <affiliation>University of Tartu, Estonia</affiliation>
          <bio>undefined</bio>
          <person_id>simonsaan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kalmer</first_name>
          <last_name>Apinis</last_name>
          <affiliation>University of Tartu, Estonia</affiliation>
          <bio>undefined</bio>
          <person_id>kalmerapinis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Julian</first_name>
          <last_name>Erhard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julianerhard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Vesal</first_name>
          <last_name>Vojdani</last_name>
          <affiliation>University of Tartu</affiliation>
          <bio>undefined</bio>
          <person_id>vesalvojdani</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>832ea2aa-0001-465b-aa28-f80fe8923264</slot_id>
      <event_id>64e069c6-2609-4d24-a969-3dc6d81d48fe</event_id>
      <title>Symbolic Automatic Relations and Their Applications to SMT and CHC Solving</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>09:00</end_time>
      <description>Despite the recent advance of automated program verification, reasoning about recursive data structures remains as a challenge for verification tools and their backends such as SMT and CHC solvers. To address the challenge, we introduce the notion of symbolic automatic relations (SARs), which combines symbolic automata and automatic relations, and inherits their good properties such as the closure under Boolean operations. We consider the satisfiability problem for SARs, and show that it is undecidable in general, but that we can construct a sound (but incomplete) and automated satisfiability checker by a reduction to CHC solving. We discuss applications to SMT and CHC solving on data structures, and show the effectiveness of our approach through experiments.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Takumi</first_name>
          <last_name>Shimoda</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>takumishimoda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ken</first_name>
          <last_name>Sakayori</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>kensakayori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ryosuke</first_name>
          <last_name>Sato</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-kb.is.s.u-tokyo.ac.jp/~ryosuke/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ryosukesato/dde2fccf-e07f-48f8-9dc9-277cb124e664/small.jpg</picture_url>
          <person_id>ryosukesato</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8bd9f55b-29dc-4c9f-b456-a62914a30bcb</slot_id>
      <event_id>60f4fa55-a96f-4db6-9954-a94ad5243bcc</event_id>
      <title>Automated Verification of the Parallel Bellman--Ford Algorithm</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>08:00</end_time>
      <description>Many real-world problems such as internet routing are actually graph problems. To develop efficient solutions to such problems, more and more parallel graph algorithms are proposed. This paper discusses the mechanized verification of a commonly used parallel graph algorithm, namely the Bellman–Ford algorithm, which provides an inherently parallel solution to the Single-Source Shortest Path problem. Concretely, we verify an unoptimized GPU version of the Bellman–Ford algorithm, using the VerCors verifier. The main challenge that we had to address was to find suitable global invariants of the graph-based properties for automated verification. This case study is the first deductive verification to prove functional correctness of the parallel Bellman–Ford algorithm. It provides the basis to verify other, optimized implementations of the algorithm. Moreover, it may also provide a good starting point to verify other parallel graph-based algorithms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohsen</first_name>
          <last_name>Safari</last_name>
          <affiliation>University of Twente, The Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.utwente.nl/m.safari</homepage_url>
          <person_id>mohsensafari</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wytse</first_name>
          <last_name>Oortwijn</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wwwhome.ewi.utwente.nl/~oortwijnwhm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wytseoortwijn/079f1ba3-77ed-4f76-93e5-136adc3b291e/small.jpg</picture_url>
          <person_id>wytseoortwijn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marieke</first_name>
          <last_name>Huisman</last_name>
          <affiliation>University of Twente</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wwwhome.cs.utwente.nl/~marieke/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mariekehuisman/22505ee7-e6f4-4999-abda-0c8325ff501f/small.jpg</picture_url>
          <person_id>mariekehuisman</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ee0239b6-cba1-4049-8701-8fea6f98f165</subevent_id>
    <title>SAS: Session 4C</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>de46c75f-0caf-4f97-aa56-ce72c5e02419</slot_id>
      <title>Session: SAS - Session 4C</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>601927dc-aa10-4069-a631-75e2d89cc5c6</slot_id>
      <event_id>fb0761d9-16c7-4e3e-93d8-8a386f88a71d</event_id>
      <title>Reduced Products of Abstract Domains for Fairness Certification of Neural Networks</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:20</end_time>
      <description>We present Tool, an open-source abstract interpretation-based static analyzer for certifying fairness of ReLU neural network classifiers for tabular data. Tool combines a sound forward pre-analysis with an exact backward analysis that leverages the polyhedra abstract domain to provide definite fairness guarantees when possible, and to otherwise quantify and describe the biased input space regions. The analysis is configurable in terms of scalability and precision. We equipped Tool with new abstract domains to use in the pre-analysis, including a generic reduced product domain construction, as well as search heuristics to find the best analysis configuration. We additionally set up the backward analysis to allow further parallelization. Our experimental evaluation demonstrates the effectiveness of the approach on neural networks trained on a popular dataset in the fairness literature.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Denis</first_name>
          <last_name>Mazzucato</last_name>
          <affiliation>INRIA &amp; École Normale Supérieure</affiliation>
          <bio>undefined</bio>
          <person_id>denismazzucato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Caterina</first_name>
          <last_name>Urban</last_name>
          <affiliation>INRIA &amp; École Normale Supérieure | Université PSL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://caterinaurban.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/caterinaurban1/a945f9bd-bc13-4fe2-945a-59528d7d7e2a/small.jpg</picture_url>
          <person_id>caterinaurban1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a072597d-70d3-4843-892d-9870ad6cce6b</slot_id>
      <event_id>e6d9543d-594e-4e03-83e7-6464df6cc24e</event_id>
      <title>Toward Neural-Network-Guided Program Synthesis and Verification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>17:00</end_time>
      <description>We propose a novel framework of program and invariant synthesis called neural network-guided synthesis. We first show that, by suitably designing and training neural networks, we can extract logical formulas over integers from the weights and biases of the trained neural networks. Based on the idea, we have implemented a tool to synthesize formulas from positive/negative examples and implication constraints, and obtained promising experimental results. We also discuss an application of our method for improving the qualifier discovery in the framework of ICE-learning-based CHC solving, which can in turn be applied to program verification and inductive invariant synthesis. Another potential application is to a neural-network-guided variation of Solar-Lezama’s program synthesis by sketching.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Taro</first_name>
          <last_name>Sekiyama</last_name>
          <affiliation>National Institute of Informatics</affiliation>
          <bio>I’m an assistant professor at National Institute of Informatics in Japan. I am interested in theory and applications of programming languages, such as type theory, program verification, type inference, program reasoning, and so on.</bio>
          <homepage_url>https://researchmap.jp/t-sekiym/?lang=english</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tarosekiyama/dd6fb4ca-8161-4bbd-9392-01e4b94374e6/small.jpg</picture_url>
          <person_id>tarosekiyama</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Issei</first_name>
          <last_name>Sato</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>isseisato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hiroshi</first_name>
          <last_name>Unno</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tsukuba.ac.jp/~uhiro/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hiroshiunno/c5c1b748-082d-4abd-93f0-dbebf6ab1d98/small.jpg</picture_url>
          <person_id>hiroshiunno</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>acd5e4ce-04e5-4485-a3e4-838366c76d16</slot_id>
      <event_id>0a69e561-77a5-4b4d-88c5-de8c3a0dd7d2</event_id>
      <title>Fast and Efficient Bit-Level Precision Tuning</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:00</end_time>
      <description>In this article, we introduce a new technique for precision tuning. This problem consists of finding the least data types for numerical values such that the result of the computation satisfies some accuracy requirement. State of the art techniques for precision tuning use a try and fail approach. They change the data types of some variables of the program and evaluate the accuracy of the result. Depending on what is obtained, they change more or less data types and repeat the process. Our technique is radically different. Based on semantic equations, we generate an Integer Linear Problem (ILP) from the program source code. Basically, this is done by reasoning on the most significant bit and the number of significant bits of the values which are integer quantities. The integer solution to this problem, computed in polynomial time by a classical linear programming solver, gives the optimal data types at the bit level. A finer set of semantic equations is also proposed which does not reduce directly to an ILP problem. So we use policy iteration to find the solution. Both techniques have been implemented and we show that our results encompass the results of state-of-the-art tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Assalé</first_name>
          <last_name>Adjé</last_name>
          <affiliation>Université de Perpignan Via Domitia</affiliation>
          <bio>undefined</bio>
          <person_id>assaleadje</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dorra</first_name>
          <last_name>Ben Khalifa</last_name>
          <affiliation>Université de Perpignan Via Domitia</affiliation>
          <bio>undefined</bio>
          <person_id>dorrabenkhalifa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Martel</last_name>
          <affiliation>Université de Perpignan Via Domitia</affiliation>
          <bio>undefined</bio>
          <person_id>matthieumartel</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e9b2cb4b-4d2a-4a3c-8e40-e9b4c2785e3e</slot_id>
      <event_id>4c218694-b052-4c87-9e69-81d7076e6850</event_id>
      <title>Static analysis of ReLU neural networks with tropical polyhedra</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:40</end_time>
      <description>This paper studies the problem of range analysis for feedforward neural networks, which is a basic primitive for applications such as robustness of neural networks, compliance to specifications and reachability analysis of neural-network feedback systems. Our approach focuses on ReLU (rectified linear unit) feedforward neural nets that present specific difficulties: approaches that exploit derivatives do not apply in general, the number of patterns of neuron activations can be quite large even for small networks, and convex approximations are generally too coarse. In this paper, we employ set-based methods and abstract interpretation that have been very successful in coping with similar difficulties in classical program verification. We present an approach that abstracts ReLU feedforward neural networks using tropical polyhedra. We show that tropical polyhedra can efficiently abstract ReLU activation function, while being able to control the loss of precision due to linear computations. We show how the connection between ReLU networks and tropical rational functions can provide approaches for range analysis of ReLU neural networks. We report on a preliminary evaluation of our approach using a prototype implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Goubault</last_name>
          <affiliation>Ecole Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>ericgoubault</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastien</first_name>
          <last_name>Palumby</last_name>
          <affiliation>Ecole Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>sebastienpalumby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sylvie</first_name>
          <last_name>Putot</last_name>
          <affiliation>École Polytechnique</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lix.polytechnique.fr/Labo/Sylvie.Putot/</homepage_url>
          <person_id>sylvieputot</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Louis</first_name>
          <last_name>Rustenholz</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>louisrustenholz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Sankaranarayanan</last_name>
          <affiliation>University of Colorado, Boulder</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.colorado.edu/~srirams/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sriramsankaranarayanan/cc1e5234-6137-4a38-8d5d-3fac7abb93eb/small.jpg</picture_url>
          <person_id>sriramsankaranarayanan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>30b33d29-b088-4297-874d-fd400615ee4d</subevent_id>
    <title>SPLASH OOPSLA: Rust</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>ef5128d1-9903-4f28-846a-013c71b754cb</slot_id>
      <title>Session: SPLASH OOPSLA - Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8757f43f-995a-498a-989a-11de3166a255</slot_id>
      <event_id>d6067c7f-9230-454c-9672-66c980a2da21</event_id>
      <title>Safer at Any Speed: Automatic Context-Aware Safety Enhancement for Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>14:43</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:10</end_time>
      <description>Type-safe languages improve application safety by eliminating whole classes of vulnerabilities, such as buffer overflows, by construction. But safety sometimes comes at a cost. As a result, modern type-safe languages often provide escape hatches that allow developers to manually bypass dynamic safety checks in hopes of improving performance. However, this requires applications to implicitly inherit whatever performance vs. safety trade-offs are made in libraries they depend on. Without knowing the importance of safety to each application, their performance requirements, the compiler used, or the hardware upon which applications will run, library developers have no hope of navigating such trade-offs appropriately for all cases. We find that in the Rust ecosystem, library developers have given up type safety in at least 10% of the 500 most downloaded packages in exchange for very little or no performance gains in many contexts. We present NADER, a Rust development tool that makes applications safer by automatically transforming unsafe code into equivalent safe code according to developer preferences and application context. In an end-to-end system evaluation, NADER automatically reintroduces dozens of bounds checks with no performance loss.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Natalie</first_name>
          <last_name>Popescu</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.princeton.edu/~npopescu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nataliepopescu1/7e11a54e-61c9-49bc-bc69-07f19db73a1b/small.jpg</picture_url>
          <person_id>nataliepopescu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ziyang</first_name>
          <last_name>Xu</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.princeton.edu/~ziyangx/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ziyangxu/4d095217-b7d0-4159-9508-7cae73aa6bf5/small.jpg</picture_url>
          <person_id>ziyangxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sotiris</first_name>
          <last_name>Apostolakis</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sapostolakis.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sotirisapostolakis/538416ca-ec5a-4441-b330-832a65a0bac2/small.jpg</picture_url>
          <person_id>sotirisapostolakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>David I.</first_name>
          <last_name>August</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>davidiaugust</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Amit</first_name>
          <last_name>Levy</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>amitlevy</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e53480a7-b1f8-41ce-ab61-4e4566589840</slot_id>
      <event_id>9c148540-5a2f-4370-b1e1-f409b281e5e6</event_id>
      <title>Modular Specification and Verification of Closures in Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>14:16</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:43</end_time>
      <description>Closures are a language feature supported by many mainstream languages, combining the ability to package up references to code blocks with the possibility of capturing state from the environment of the closure’s declaration. Closures are powerful, but complicate understanding and formal reasoning, especially when closure invocations may mutate objects reachable from the captured state or from closure arguments. This paper presents a novel technique for the modular specification and verification of closure-manipulating code in Rust. Our technique combines Rust’s type system guarantees and novel specification features to enable formal verification of rich functional properties. It encodes higher-order concerns into a first-order logic, which enables automation via SMT solvers. Our technique is implemented as an extension of the deductive verifier Prusti, with which we have successfully verified many common idioms of closure usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabian</first_name>
          <last_name>Wolff</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>fabianwolff</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aurel</first_name>
          <last_name>Bílý</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>aurelbily</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Matheja</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christophmatheja1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alexander J.</first_name>
          <last_name>Summers</last_name>
          <affiliation>University of British Columbia (UBC)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.ubc.ca/~alexsumm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexanderjsummers/f97b84a8-d46a-4e76-aa73-cc4b38c4ec41/small.jpg</picture_url>
          <person_id>alexanderjsummers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f127293d-9649-4e0f-9c50-3f9e4a433441</slot_id>
      <event_id>66f57c5c-e9da-44bf-9914-726337159123</event_id>
      <title>Translating C to Safer Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:16</end_time>
      <description>Rust is a relatively new programming language that targets efficient and safe systems-level applications. It includes a sophisticated type system that allows for provable memory- and thread-safety, and is explicitly designed to take the place of unsafe languages such as C and C++ in the coding ecosystem. There is a large existing C and C++ codebase (many of which have been affected by bugs and security vulnerabilities due to unsafety) that would benefit from being rewritten in Rust to remove an entire class of potential bugs. However, porting these applications to Rust manually is a daunting task. 
In this paper we investigate the problem of automatically translating C programs into safer Rust programs—that is, Rust programs that improve on the safety guarantees of the original C programs. We conduct an in-depth study into the underlying causes of unsafety in translated programs and the relative impact of fixing each cause. We also describe a novel technique for automatically removing a particular cause of unsafety and evaluate its effectiveness and impact. This paper presents the first empirical study of unsafety in translated Rust programs (as opposed to programs originally written in Rust) and also the first technique for automatically removing causes of unsafety in translated Rust programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mehmet</first_name>
          <last_name>Emre</last_name>
          <affiliation>University of California, Santa Barbara</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.ucsb.edu/~emre</homepage_url>
          <person_id>mehmetemre</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Schroeder</last_name>
          <affiliation>University of California, Santa Barbara</affiliation>
          <bio>undefined</bio>
          <person_id>ryanschroeder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kyle</first_name>
          <last_name>Dewey</last_name>
          <affiliation>California State University, Northridge</affiliation>
          <bio>undefined</bio>
          <person_id>kyledewey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ben</first_name>
          <last_name>Hardekopf</last_name>
          <affiliation>UC Santa Barbara</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.cs.ucsb.edu/~benh</homepage_url>
          <person_id>benhardekopf</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>36500c80-ba51-44b3-9fcf-f771701a4cce</subevent_id>
    <title>SPLASH OOPSLA: Security - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>5ffde632-68d8-419b-856e-ab6b07b6653c</slot_id>
      <title>Session: SPLASH OOPSLA - Security - mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2a0c24e5-ca1a-43b7-b3a4-73bdc301e99e</slot_id>
      <event_id>b8e58c10-44b0-4c96-94ba-19e9d23a0e86</event_id>
      <title>SpecSafe: Detecting Cache Side Channels in a Speculative World</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:10</end_time>
      <description>The high-profile Spectre attack and its variants have revealed that speculative execution may leave secret-dependent footprints in the cache, allowing an attacker to learn confidential data. However, existing static side-channel detectors either ignore speculative execution, leading to false negatives, or lack a precise cache model, leading to false positives. In this paper, somewhat surprisingly, we show that it is challenging to develop a speculation-aware static analysis with precise cache models: a combination of existing works does not necessarily catch all cache side channels. Motivated by this observation, we present a new semantic definition of security against cache-based side-channel attacks, called Speculative-Aware noninterference (SANI), which is applicable to a variety of attacks and cache models. We also develop SpecSafe to detect the violations of SANI. Unlike other speculation-aware symbolic executors, SpecSafe employs a novel program transformation so that SANI can be soundly checked by speculation-unaware side-channel detectors. SpecSafe is shown to be both scalable and accurate on a set of moderately sized benchmarks, including commonly used cryptography libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Brotzman-Smith</last_name>
          <affiliation>Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>robertbrotzmansmith</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Danfeng</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.psu.edu/~dbz5017/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danfengzhang/6eb87743-0994-4ff3-be1e-dbfb34429946/small.jpg</picture_url>
          <person_id>danfengzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mahmut Taylan</first_name>
          <last_name>Kandemir</last_name>
          <affiliation>Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.psu.edu/~kandemir/</homepage_url>
          <person_id>mahmuttaylankandemir</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gang</first_name>
          <last_name>Tan</last_name>
          <affiliation>Penn State University</affiliation>
          <bio>Dr. Gang Tan is the James F. Will Career Development Associate Professor in Computer Science and Engineering at Pennsylvania State University, PA. He leads the Security of Software (SOS) Lab. His research is at the interface between computer security, programming languages, and formal methods. He received his bachelor’s degree in Computer Science with honors from Tsinghua University in 1999 and his Ph.D. degree from Princeton University in 2005. He has received an NSF CAREER award, two Google Research Awards, and a Francis Upton Graduate Fellowship.</bio>
          <homepage_url>http://www.cse.psu.edu/~gxt29/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gangtan/e101adef-54fb-4fcc-bce0-381da3d1aace/small.jpg</picture_url>
          <person_id>gangtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ae8015d3-5995-42f3-b77f-b6bad7066a37</slot_id>
      <event_id>f767b573-d238-483e-bafc-2f0adec651ed</event_id>
      <title>Not So Fast: Understanding and Mitigating Negative Impacts of Compiler Optimizations on Code Reuse Gadget Sets</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>23:10</end_time>
      <description>Despite extensive testing and correctness certification of their functional semantics, a number of compiler optimizations have been shown to violate security guarantees implemented in source code. While prior work has shed light on how such optimizations may introduce semantic security weaknesses into programs, there remains a significant knowledge gap concerning the impacts of compiler optimizations on non-semantic properties with security implications. In particular, little is currently known about how code generation and optimization decisions made by the compiler affect the availability and utility of reusable code segments called gadgets required for implementing code reuse attack methods such as return-oriented programming. 
In this paper, we bridge this gap through a study of the impacts of compiler optimization on code reuse gadget sets. We analyze and compare 1,187 variants of 20 different benchmark programs built with two production compilers (GCC and Clang) to determine how their optimization behaviors affect the code reuse gadget sets present in program variants with respect to both quantitative and qualitative metrics. Our study exposes an important and unexpected problem; compiler optimizations introduce new gadgets at a high rate and produce code containing gadget sets that are generally more useful to an attacker than those in unoptimized code. Using differential binary analysis, we identify several undesirable behaviors at the root of this phenomenon. In turn, we propose and evaluate several strategies to mitigate these behaviors. In particular, we show that post-production binary recompilation can effectively mitigate these behaviors with negligible performance impacts, resulting in optimized code with significantly smaller and less useful gadget sets.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael D.</first_name>
          <last_name>Brown</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>michaeldbrown</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Pruett</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>matthewpruett</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robert</first_name>
          <last_name>Bigelow</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>robertbigelow</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Girish</first_name>
          <last_name>Mururu</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>girishmururu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Santosh</first_name>
          <last_name>Pande</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>santoshpande1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b73fa9da-fb13-44a5-963e-f07a529d8fb0</slot_id>
      <event_id>d160658e-2c64-4c8e-9ce6-b2048d30d69c</event_id>
      <title>Interpretable Noninterference Measurement and its Application to Processor Designs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>22:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:30</end_time>
      <description>Noninterference measurement quantifies the secret information that might leak to an adversary from what the adversary can observe and influence about the computation. Static and high-fidelity noninterference measurement has been difficult to scale to complex computations, however. This paper scales a recent framework for noninterference measurement to the open-source RISC-V BOOM core as specified in Verilog, through three key innovations: logically characterizing the core’s execution incrementally, applying specific optimizations between each cycle; permitting information to be declassified, to focus leakage measurement to only secret information that cannot be inferred from the declassified information; and interpreting leakage measurements for the analyst in terms of simple rules that characterize when leakage occurs. Case studies on cache-based side channels generally, and on specific instances including Spectre attacks, show that the resulting toolchain, called DINoMe, effectively scales to this modern processor design.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ziqiao</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <person_id>ziqiaozhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael K.</first_name>
          <last_name>Reiter</last_name>
          <affiliation>Duke University</affiliation>
          <bio>undefined</bio>
          <person_id>michaelkreiter</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d69cc666-fbcb-498e-8bfc-094114034313</slot_id>
      <event_id>e1451bd2-8368-4f79-bdf9-aa3a7332f14e</event_id>
      <title>Reconciling Optimization With Secure Compilation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>22:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:50</end_time>
      <description>Software protections against side-channel and physical attacks are essential to the development of secure applications. Such protections are meaningful at machine code or micro-architectural level, but they typically do not carry observable semantics at source level. This renders them susceptible to miscompilation, and security engineers embed input/output side-effects to prevent optimizing compilers from altering them. Yet these side-effects are error-prone and compiler-dependent. The current practice involves analyzing the generated machine code to make sure security or privacy properties are still enforced. These side-effects may also be too expensive in fine-grained protections such as control-flow integrity. We introduce observations of the program state that are intrinsic to the correct execution of security protections, along with means to specify and preserve observations across the compilation flow. Such observations complement the input/output semantics-preservation contract of compilers. We introduce an opacification mechanism to preserve and enforce a partial ordering of observations. This approach is compatible with a production compiler and does not incur any modification to its optimization passes. We validate the effectiveness and performance of our approach on a range of benchmarks, expressing the secure compilation of these applications in terms of observations to be made at specific program points.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Son</first_name>
          <last_name>Tuan Vu</last_name>
          <affiliation>ARM</affiliation>
          <bio>undefined</bio>
          <person_id>sontuanvu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Albert</first_name>
          <last_name>Cohen</last_name>
          <affiliation>Google</affiliation>
          <bio>Albert is a research scientist at Google. He has been a research scientist at Inria from 2000 to 2018. He graduated from École Normale Supérieure de Lyon and received his PhD from the University of Versailles in 1999 (awarded two national prizes). He has been a visiting scholar at the University of Illinois, an invited professor at Philips Research, and a visiting scientist at Facebook Artificial Intelligence Research. Albert Cohen works on parallelizing and optimizing compilers, parallel programming languages and systems and synchronous programming for reactive control systems. He served as the general or program chair of major conferences, including PLDI, PPoPP, HiPEAC, CC, the embedded software track of DAC, and as a member of the editorial board of ACM TACO and IJPP. He coauthored more than 180 peer-reviewed papers and has been the advisor for 26 PhD theses. Several research projects initiated by Albert Cohen resulted in effective transfer to production compilers and programming environments in industry.</bio>
          <homepage_url>https://who.rocq.inria.fr/Albert.Cohen</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/albertcohen/3684aca0-5e45-4ea1-bece-82d71228da32/small.jpg</picture_url>
          <person_id>albertcohen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arnaud</first_name>
          <last_name>de Grandmaison</last_name>
          <affiliation>ARM</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/arnauddegrandmaison/e359aaef-874f-472d-9bbd-01eaef90cd1c/small.jpg</picture_url>
          <person_id>arnauddegrandmaison</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Guillon</last_name>
          <affiliation>STMicroelectronics</affiliation>
          <bio>undefined</bio>
          <person_id>christopheguillon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Karine</first_name>
          <last_name>Heydemann</last_name>
          <affiliation>Sorbonne Université, CNRS, Laboratoire d'Informatique de Paris 6, LIP6</affiliation>
          <bio>undefined</bio>
          <person_id>karineheydemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>09181b8a-0f35-41e7-ba62-4414da49750b</subevent_id>
    <title>SPLASH OOPSLA: Analysis</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>2880b139-fc29-4c7a-a359-98b7aa016846</slot_id>
      <title>Session: SPLASH OOPSLA - Analysis</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0ef55ecb-b8af-4fcf-abe4-824661856f64</slot_id>
      <event_id>9ea1d9f0-04dc-4462-8e51-cc113731d741</event_id>
      <title>JavaDL: Automatically Incrementalizing Java Bug Pattern Detection</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>17:00</end_time>
      <description>Static checker frameworks support software developers by automatically discovering bugs that fit general-purpose bug patterns. These frameworks ship with hundreds of detectors for such patterns and allow developers to add custom detectors for their own projects. However, existing frameworks generally encode detectors in imperative specifications, with extensive details of not only what to detect but also how. These details not only add complexity to maintenance and extensibility, but also interfere with the framework’s ability to change how detection is done, for instance, to make the detectors incremental. 
In this paper, we present JavaDL, a Datalog-based declarative specification language for bug pattern detection in Java code. JavaDL seamlessly supports both exhaustive and incremental evaluation from the same detector specification . The system further allows developers to concisely describe bug detectors via syntactic pattern matching for local AST matching, and via Datalog-style logical rules for nonlocal reasoning. We compare our approach against the well-established SpotBugs and Error Prone tools by re-implementing several of their detectors in JavaDL. We find that our implementations are substantially smaller and similarly effective at detecting bugs on the Defects4J benchmark suite, and run with competitive runtime performance. In our experiments, neither incremental nor exhaustive analysis is able to consistently outperform the other analysis mode, which highlights the value of our ability to transparently switch execution modes. We argue that our approach highlights the potential of clear-box static checker frameworks that constrain the bug detector specification language to enable the framework to adapt and enhance the detectors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexandru</first_name>
          <last_name>Dura</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <person_id>alexandrudura1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Reichenbach</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophreichenbach/04687677-a813-459e-8929-d1e4a32627c6/small.jpg</picture_url>
          <person_id>christophreichenbach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Emma</first_name>
          <last_name>Söderberg</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/emmasoderberg/2edc9865-4e98-41ee-a89e-1568465852e0/small.jpg</picture_url>
          <person_id>emmasoderberg</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>55a84f52-8a15-4248-8698-be9d3ea174c4</slot_id>
      <event_id>15b825cc-d30b-4dc1-97c4-9068619d905b</event_id>
      <title>Making Pointer Analysis More Precise by Unleashing the Power of Selective Context Sensitivity</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:00</end_time>
      <description>Traditional context-sensitive pointer analysis is hard to scale for large and complex Java programs. To address this issue, a series of selective context-sensitivity approaches have been proposed and exhibit promising results. In this work, we move one step further towards producing highly-precise pointer analyses for hard-to-analyze Java programs by presenting the Unity-Relay framework, which takes selective context sensitivity to the next level. Briefly, Unity-Relay is a one-two punch: given a set of different selective context-sensitivity approaches, say $S = {S_1, \ldots, S_n}$, Unity-Relay first provides a mechanism (called Unity) to combine and maximize the precision of all components of $S$. When Unity fails to scale, Unity-Relay offers a scheme (called Relay) to pass and accumulate the precision from one approach $S_i$ in $S$ to the next, $S_{i+1}$, leading to an analysis that is more precise than all approaches in $S$. 
As a proof-of-concept, we instantiate Unity-Relay into a tool called Baton and extensively evaluate it on a set of hard-to-analyze Java programs, using general precision metrics and popular clients. Compared with the state of the art, Baton achieves the best precision for \emph{all} metrics and clients for \emph{all} evaluated programs. The difference in precision is often dramatic—up to 71% of alias pairs reported by previously-best algorithms are found to be spurious and eliminated.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tian</first_name>
          <last_name>Tan</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <person_id>tiantan1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yue</first_name>
          <last_name>Li</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuelee.bitbucket.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yueli/c0b3b5ef-ffac-472c-9a05-5b9c8f165d7d/small.jpg</picture_url>
          <person_id>yueli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xiaoxing</first_name>
          <last_name>Ma</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ics.nju.edu.cn/people/xiaoxingma/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaoxingma1/5add1977-f0a4-458b-b59b-71cf18017400/small.jpg</picture_url>
          <person_id>xiaoxingma1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Chang</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.nju.edu.cn/changxu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/changxu/e28fcdd7-83f6-43c4-9ac8-20a3fa1137d8/small.jpg</picture_url>
          <person_id>changxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b9b0e90a-8319-42ae-b0a9-20f36ca45f0c</slot_id>
      <event_id>6ff2a930-bcaf-47ae-9930-b8baa0788972</event_id>
      <title>Program Analysis via Efficient Symbolic Abstraction</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:40</end_time>
      <description>This paper addresses the scalability challenges of symbolic abstraction: given a formula $\varphi$ in a logic $\mathcal{L}$ and an abstract domain $\mathcal{A}$, find a most precise element in the abstract domain that over-approximates the meaning of $\varphi$. Symbolic abstraction is an important point in the space of abstract interpretation, as it allows for automatically synthesizing the best abstract transformers. However, current techniques for symbolic abstraction can have difficulty delivering on its practical strengths, due to performance issues. 
In this work, we introduce two algorithms for the symbolic abstraction of quantifier-free bit-vector formulas, which apply to the bit-vector interval domain and a certain kind of polyhedral domain, respectively. We implement and evaluate the proposed techniques on two machine code analysis clients, static memory corruption analysis and constrained random fuzzing. Using a suite of 57,933 queries from the clients, we compare our approach against a diverse group of state-of-the-art algorithms. The experiments show that our algorithms achieve a substantial speedup over existing techniques, and illustrate significant precision advantages for the clients. Our work presents strong evidence that symbolic abstraction of numeric domains can be efficient and practical for large and realistic programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Peisen</first_name>
          <last_name>Yao</last_name>
          <affiliation>The Hong Kong University of Science and Technology</affiliation>
          <bio>I am broadly interested in topics related to programming languages, software engineering, formal method, and cybersecurity, with an emphasis on using program reasoning techniques to ensure software reliability.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/yaopeisen/afec483a-bef9-4542-b208-b84c15344696/small.jpg</picture_url>
          <person_id>yaopeisen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Qingkai</first_name>
          <last_name>Shi</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Qingkai Shi is a Postdoc Research Associate in the department of computer science, Purdue University. His major research interest is the use of compiler techniques to ensure software reliability. He has published extensively at premium venues of programming languages (PLDI, OOPSLA), software engineering (ICSE, FSE, TSE, ISSTA), and cybersecurity (S&amp;amp;P). His research received many awards including ACM SIGSOFT Distinguished Paper Award and Hong Kong Ph.D. Fellowship. His research has led to the discovery of over a hundred software vulnerabilities in open-source software and has been successfully commercialized in Sourcebrella Inc, a static analysis tool vendor. Qingkai obtained his Ph.D. and B.S. from Nanjing University and the Hong Kong University of Science and Technology, respectively.</bio>
          <homepage_url>https://qingkaishi.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/qingkaishi/99eef1fd-60de-40bf-888f-38d77b3db376/small.jpg</picture_url>
          <person_id>qingkaishi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Heqing</first_name>
          <last_name>Huang</last_name>
          <affiliation>Hong Kong University of Science and Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://5hadowblad3.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/heqinghuang/726be0ec-989d-4ddd-b27c-6559ebc40835/small.jpg</picture_url>
          <person_id>heqinghuang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charles</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Hong Kong University of Science and Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ust.hk/~charlesz</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/charleszhang/d5404cd7-dca8-4033-b79f-500613a981b9/small.jpg</picture_url>
          <person_id>charleszhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f0a6ce5f-4e88-4231-9eb1-282eb60f0ccb</slot_id>
      <event_id>4f4af528-c989-4120-8b8e-ab1590c33f65</event_id>
      <title>Compacting Points-To Sets Through Object Clustering</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:20</end_time>
      <description>Inclusion-based set constraint solving is the most popular technique for whole-program points-to analysis whereby an analysis is typically formulated as repeatedly resolving constraints between points-to sets of program variables. The set union operation is central to this process. The number and size of points-to sets grow as analyses become more precise and input programs become larger, resulting in more time spent performing unions. Most existing approaches focus on improving scalability of precise points-to analyses from an algorithmic perspective and there has been less research into improving the data structures behind the analyses. 
Bit-vectors as one of the more popular data structures have been used in several mainstream analysis frameworks to represent points-to sets. To store memory objects in bit-vectors, objects need to mapped to integral identifiers. We observe that this object-to-identifier mapping is critical for a compact points-to set representation and the set union operation. If objects in the same points-to sets (co-pointees) are not given numerically close identifiers, points-to resolution can cost significantly more space and time. Without data on the unpredictable points-to relations discovered by the analysis, an ideal mapping is extremely challenging. 
In this paper, we present a new approach to inclusion-based analysis by compacting points-to sets through object clustering. Inspired by recent staged analysis where an auxiliary analysis produces results approximating a more precise main analysis, we formulate points-to set compaction as an optimisation problem solved by integer programming using constraints generated from the auxiliary analysis’s results in order to produce an effective mapping. We then develop a more approximate mapping, yet much more efficiently, using hierarchical clustering to compact bit-vectors. We also develop an improved representation of bit-vectors (called core bit-vectors) to fully take advantage of the newly produced mapping. Our approach requires no algorithmic change to the points-to analysis. We evaluate our object clustering on flow-sensitive points-to analysis using 9 open-source programs (&amp;gt;5.3 millions lines of LLVM instructions) and Our results show that our approach can successfully improve the analysis with an up to 1.75$\times$ speed up and up to 3.25$\times$ reduction in memory usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohamad</first_name>
          <last_name>Barbar</last_name>
          <affiliation>University of Technology Sydney, Australia and CSIRO's Data61, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mbarbar.net</homepage_url>
          <person_id>mohamadbarbar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2a53dbc8-8ad6-4ed9-b1e5-c439d967e7d2</subevent_id>
    <title>SPLASH OOPSLA: Optimization</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>42225286-08fb-4b9a-8764-22c2e94c4aec</slot_id>
      <title>Session: SPLASH OOPSLA - Optimization</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5d2ccc4a-0cdf-46df-88a1-1599ce5b6b77</slot_id>
      <event_id>e78d6285-c5ed-4a96-8242-9315d1c25ef4</event_id>
      <title>VESPA: Static Profiling for Binary Optimization</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>11:16</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:43</end_time>
      <description>Over the past few years, there has been a surge in the popularity of binary optimizers such as BOLT, Propeller, Janus and HALO. These tools use dynamic profiling information to make optimization decisions. Although effective, gathering runtime data presents developers with inconveniences such as unrepresentative inputs, the need to accommodate software modifications, and longer build times. In this paper, we revisit the static profiling technique proposed by Calder et al. in the late 90’s, and investigate its application to drive binary optimizations, in the context of the BOLT binary optimizer, as a replacement for dynamic profiling. A few core modifications to Calder et al.’s original proposal, consisting of new program features and a new regression model, are sufficient to enable some of the gains obtained through runtime profiling. An evaluation of BOLT powered by our static profiler on four large benchmarks (clang, GCC, MySQL and PostgreSQL) yields binaries that are 5.50% faster than the executables produced by clang -O3.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Angelica Aparecida</first_name>
          <last_name>Moreira</last_name>
          <affiliation>Universidade Federal de Minas Gerais</affiliation>
          <bio>Angélica Moreira is a late 3rd year PhD candidate in the Computer Science Department at Federal University of Minas Gerais (UFMG). She is a member of the Compilers Laboratory (LAC), where she is advised by Professor Fernando Magno Quintão Pereira. She holds an M.Sc degree in Computer Science from the Federal University of Ouro Preto (UFOP) and a B.Sc degree in Computer Science from the Pontifical Catholic University of Minas Gerais (PUC Minas). 
Angélica’s research interest lies in pursuing the design and implementation of techniques that reduce program binary size and make them run faster on heterogeneous architectures. Her research focuses on combining machine learning and compilation techniques to achieve her goal. Her dream is to contribute to a better world through the development of science and technology.</bio>
          <homepage_url>https://homepages.dcc.ufmg.br/~angelica.moreira/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/angelicaaparecidamoreira/8e228596-dcff-49ff-9b56-e77a499f89d8/small.jpg</picture_url>
          <person_id>angelicaaparecidamoreira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guilherme</first_name>
          <last_name>Ottoni</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~ottoni</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guilhermeottoni/a60389de-a60b-4624-949a-574fd53ea7ab/small.jpg</picture_url>
          <person_id>guilhermeottoni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>Federal University of Minas Gerais</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an associate professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
          <person_id>fernandomagnoquintaopereira</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5d59cc95-38b3-44e7-90e6-bcc4d0b84f55</slot_id>
      <event_id>a07657bd-7670-4ce9-b59c-c0d4a5733ee1</event_id>
      <title>A Derivative-based Parser Generator for Visibly Pushdown Grammars</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:16</end_time>
      <description>In this paper, we present a derivative-based, functional recognizer and parser generator for visibly pushdown grammars. The generated parser accepts ambiguous grammars and produces a parse forest containing all valid parse trees for an input string in linear time. Each parse tree in the forest can then be extracted also in linear time. Besides the parser generator, to allow more flexible forms of the visibly pushdown grammars, we also present a translator that converts a tagged CFG to a visibly pushdown grammar in a sound way, and the parse trees of the tagged CFG are further produced by running the semantic actions embedded in the parse trees of the translated visibly pushdown grammar. The performance of the parser is compared with a popular parsing tool ANTLR on parsing JSON and HTML files. The correctness of the core parsing algorithm is formally verified in the proof assistant Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaodong</first_name>
          <last_name>Jia</last_name>
          <affiliation>The Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>xiaodongjia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ashish</first_name>
          <last_name>Kumar</last_name>
          <affiliation>The Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>ashishkumar1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gang</first_name>
          <last_name>Tan</last_name>
          <affiliation>Penn State University</affiliation>
          <bio>Dr. Gang Tan is the James F. Will Career Development Associate Professor in Computer Science and Engineering at Pennsylvania State University, PA. He leads the Security of Software (SOS) Lab. His research is at the interface between computer security, programming languages, and formal methods. He received his bachelor’s degree in Computer Science with honors from Tsinghua University in 1999 and his Ph.D. degree from Princeton University in 2005. He has received an NSF CAREER award, two Google Research Awards, and a Francis Upton Graduate Fellowship.</bio>
          <homepage_url>http://www.cse.psu.edu/~gxt29/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gangtan/e101adef-54fb-4fcc-bce0-381da3d1aace/small.jpg</picture_url>
          <person_id>gangtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8376eb9d-b37e-4a1a-9347-7373327cfb97</slot_id>
      <event_id>b07a5fb5-66c7-4797-a121-2c07df02ff9d</event_id>
      <title>Copy-and-Patch Compilation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>11:43</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>12:10</end_time>
      <description>Fast compilation is important when compilation occurs at runtime, such as query compilers in modern database systems and WebAssembly virtual machines in modern browsers. We present copy-and-patch, an extremely fast compilation technique that also produces good quality code. It is capable of lowering both high-level languages and low-level bytecode programs to binary code, by stitching together code from a large library of binary implementation variants. We call these binary implementations stencils because they have holes where missing values must be inserted during code generation. We show how to construct a stencil library and describe the copy-and-patch algorithm that generates optimized binary code. 
We demonstrate two use cases of copy-and-patch: a compiler for a high-level C-like language intended for metaprogramming and a compiler for WebAssembly. Our high-level language compiler has negligible compilation cost: it produces code from an AST in less time than it takes to construct the AST. We have implemented an SQL database query compiler on top of this metaprogramming system and show that on TPC-H database benchmarks, copy-and-patch generates code two orders of magnitude faster than LLVM -O0 and three orders of magnitude faster than higher optimization levels. The generated code runs an order of magnitude faster than interpretation and 15% faster than LLVM -O0. Our WebAssembly compiler generates code 4.9X-6.5X faster than Liftoff, the WebAssembly baseline compiler in Google Chrome. The generated code also outperforms Liftoff’s by 46%-63% on the Coremark and PolyBenchC WebAssembly benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Haoran</first_name>
          <last_name>Xu</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>haoranxu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9e7eea66-f426-41d4-80d4-01bf91dfc8b4</subevent_id>
    <title>SPLASH OOPSLA: Testing</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9012807a-7ef6-4353-bac4-046e2daa2f08</slot_id>
      <title>Session: SPLASH OOPSLA - Testing</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>031a9473-cdc1-4b67-879e-fbb89fd8e10b</slot_id>
      <event_id>033e9d5c-0599-4e16-95be-bf846cf24376</event_id>
      <title>Permchecker: A Toolchain for Debugging Memory Managers with Typestate</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:10</end_time>
      <description>Dynamic memory managers are a crucial component of almost every modern software system. In addition to implementing efficient allocation and reclamation, memory managers provide the essential abstraction of memory as distinct objects, which underpins the properties of memory safety and type safety. Bugs in memory managers, while not common, are extremely hard to diagnose and fix. One reason is that their implementations often involve tricky pointer calculations, raw memory manipulation, and complex memory state invariants. While these properties are often documented, they are not specified in any precise, machine-checkable form. A second reason is that memory manager bugs can break the client application in bizarre ways that do not immediately implicate the memory manager at all. A third reason is that existing tools for debugging memory errors, such as Memcheck, cannot help because they rely on correct allocation and deallocation information to work. 
In this paper we present Permchecker, a tool designed specifically to detect and diagnose bugs in memory managers. The key idea in Permchecker is to make the expected structure of the heap explicit by associating \emph{typestates} with each piece of memory. Typestate captures elements of both type (e.g., page, block, or cell) and state (e.g., allocated, free, or forwarded). Memory manager developers annotate their implementation with information about the expected typestates of memory and how heap operations change those typestates. At runtime, our system tracks the typestates and ensures that each memory access is consistent with the expected typestates. This technique detects errors quickly, before they corrupt the application or the memory manager itself, and it often provides accurate information about the reason for the error. 
The implementation of Permchecker uses a combination of compile-time annotation and instrumentation, and dynamic binary instrumention. Because the overhead of DBI is fairly high, Permchecker is suitable for a testing and debugging setting and not for deployment. It works on a wide variety of existing systems, including explict malloc/free memory managers and garbage collectors, such as those found in JikesRVM and OpenJDK. Since bugs in these systems are not numerous, we developed a testing methodology in which we automatically inject bugs into the code using bug patterns derived from real bugs. This technique allows us to test Permchecker on hundreds or thousands of buggy variants of the code. We find that Permchecker effectively detects and localizes errors in the vast majority of cases; without it, these bugs result in strange, incorrect behaviors usually long after the actual error occurs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Karl</first_name>
          <last_name>Cronburg</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.eecs.tufts.edu/~karl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/karlcronburg/1487b759-23be-47d5-adb2-f6e6b4013d52/small.jpg</picture_url>
          <person_id>karlcronburg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Guyer</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/samguyer/94906fdc-2110-48fb-a0cd-afd1464b9262/small.jpg</picture_url>
          <person_id>samguyer</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>17f14932-3f40-41eb-b324-df1ff158261d</slot_id>
      <event_id>1f6ab670-2e0d-4713-b59c-0e28fbaea895</event_id>
      <title>Programming and Execution Models for Parallel Bounded Exhaustive Testing</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:30</end_time>
      <description>Bounded-exhaustive testing (BET), which exercises a program under test for all inputs up to some bounds, is an effective method for detecting software bugs. Systematic property-based testing is a BET approach where developers write test generation programs that describe properties of test inputs. Hybrid test generation programs offer the most expressive way to write desired properties by freely combining declarative filters and imperative generators. However, exploring hybrid test generation programs, to obtain test inputs, is both computationally demanding and challenging to parallelize. We present the first programming and execution models, dubbed Tempo, for parallel exploration of hybrid test generation programs. We describe two different strategies for mapping the computation to parallel hardware and implement them both for GPUs and CPUs. We evaluated Tempo by generating instances of various data structures commonly used for benchmarking in the BET domain. Additionally, we generated CUDA programs to stress test CUDA compilers, finding four bugs confirmed by the developers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nader</first_name>
          <last_name>Al Awar</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>naderalawar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kush</first_name>
          <last_name>Jain</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>kushjain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chris</first_name>
          <last_name>Rossbach</last_name>
          <affiliation>The University of Texas at Austin and VMware Research Group</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.utexas.edu/~rossbach</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chrisrossbach/d36775ec-4ad9-4010-ae6e-ba41c5f9d61d/small.jpg</picture_url>
          <person_id>chrisrossbach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milos</first_name>
          <last_name>Gligoric</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/milosgligoric/4d0671ae-937e-4f08-b499-092379ff7ad3/small.jpg</picture_url>
          <person_id>milosgligoric</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2abb50ed-5999-400e-810d-f006a599ae35</slot_id>
      <event_id>4e7d7fa2-4fd4-42e1-9e44-961a43dfab85</event_id>
      <title>Fully Automated Functional Fuzzing of Android Apps for Detecting Non-Crashing Logic Bugs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>12:10</end_time>
      <description>Android apps are GUI-based event-driven software and have become ubiquitous in recent years. Obviously, functional correctness is critical for an app’s success. However, in addition to crash bugs, \emph{non-crashing functional bugs} (in short as “non-crashing bugs” in this work) like inadvertent function failures, silent user data lost and incorrect display information are prevalent, even in popular, well-tested apps. These non-crashing functional bugs are usually caused by program logic errors and manifest themselves on the graphic user interfaces (GUIs). In practice, such bugs pose significant challenges in effectively detecting them because (1) current practices heavily rely on expensive, small-scale manual validation (\emph{the lack of automation}); and (2) modern \emph{fully automated} testing has been limited to crash bugs (\emph{the lack of test oracles}). 
This paper fills this gap by introducing \emph{independent view fuzzing}, \emph{a novel, fully automated approach} for detecting non-crashing functional bugs in Android apps. Inspired by metamorphic testing, our key insight is to leverage the commonly-held \emph{independent view property} of Android apps to manufacture property-preserving mutant tests from a set of seed tests that validate certain app properties. The mutated tests help exercise the tested apps under additional, adverse conditions. Any property violations indicate likely functional bugs for further manual confirmation. We have realized our approach as an automated, end-to-end functional fuzzing tool, Genie. Given an app, (1) Genie automatically detects non-crashing bugs without requiring human-provided tests and oracles (thus \emph{fully automated}); and (2) the detected non-crashing bugs are diverse (thus \emph{general and not limited to specific functional properties}), which set Genie apart from prior work. 
We have evaluated Genie on 12 real-world Android apps and successfully uncovered 34 previously unknown non-crashing bugs in their latest releases — all have been confirmed, and 22 have already been fixed. Most of the detected bugs are nontrivial and have escaped developer (and user) testing for at least one year and affected many app releases, thus clearly demonstrating Genie’s effectiveness. These 34 non-crashing bugs could not been detected by prior fully automated GUI testing tools (as our evaluation confirms). Thus, our work complements and enhances existing manual testing and fully automated testing for crash bugs. 
To facilitate reviewing and replication of our work, we have open-sourced Genie and provided additional information (\emph{fully anonymized}) at https://github.com/functional-fuzzing-android-apps/home.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ting</first_name>
          <last_name>Su</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://tingsu.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tingsu/a7bc2f83-b98a-44ba-954c-da631ab86471/small.jpg</picture_url>
          <person_id>tingsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yichen</first_name>
          <last_name>Yan</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>yichenyan1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jue</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/juewang1/989813f5-0a9c-4617-8f83-9690a0e6b253/small.jpg</picture_url>
          <person_id>juewang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Sun</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>jinglingsun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yiheng</first_name>
          <last_name>Xiong</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>yihengxiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Geguang</first_name>
          <last_name>Pu</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>geguangpu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Ke</first_name>
          <last_name>Wang</last_name>
          <affiliation>Visa Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kbwang.bitbucket.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kewang/37ef656e-ca92-475f-8a51-902dbe44fb72/small.jpg</picture_url>
          <person_id>kewang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>73b86ac8-38fa-4453-a7b9-b90b02ab78c4</slot_id>
      <event_id>26e88f75-7306-434e-afa1-624701a72947</event_id>
      <title>Generative Type-Aware Mutation for Testing SMT Solvers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:50</end_time>
      <description>We propose Generative Type-Aware Mutation, an effective approach for testing SMT solvers. The key idea is to realize generation through the mutation of expressions with parametric operators from the SMT-LIB specification. Generative Type-Aware Mutation is a hybrid of mutation-based and grammar-based type-ware mutations and features an unbounded mutation space—overcoming a major limitation of OpFuzz, the state-of-the-art fuzzer for SMT solvers. We have realized Generative Type-Aware Mutation in a practical SMT solver bug hunting tool, TypeFuzz. During three months of testing with TypeFuzz, we reported over 70 bugs in the state-of-the-art SMT solvers Z3 and CVC4. Among these, 48 bugs were confirmed and 35 bugs were fixed. Perhaps most notably, we found 9 soundness bugs in CVC4’s default mode alone. CVC4 has proven to be a very stable SMT solver and has resisted several fuzzing campaigns. A third of the soundness bugs in CVC4 (3/9) are at least 2 years latent and pre-date any previous SMT solver fuzzing campaigns.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jiwon</first_name>
          <last_name>Park</last_name>
          <affiliation>École Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>jiwonpark</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wintered.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a2854896-06d6-4f97-84e7-10c78fff6496</subevent_id>
    <title>SPLASH OOPSLA: Functional Programming - Mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8e0d34df-b3fd-4312-999a-ed7e301bf584</slot_id>
      <title>Session: SPLASH OOPSLA - Functional Programming - Mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1b9393da-cc9d-4307-98e8-03dd6215eb94</slot_id>
      <event_id>c37258b4-1df6-476e-b6e1-b5168f6b0ece</event_id>
      <title>Synbit: Synthesizing Bidirectional Programs using Unidirectional Sketches</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>20:10</end_time>
      <description>We propose a technique for synthesizing bidirectional programs from the corresponding unidirectional code plus a few input/output examples. The core ideas are: (1) \emph{constructing a sketch} using the given unidirectional program as a specification, and (2) \emph{filling the sketch} in a modular fashion by exploiting the properties of bidirectional programs. These ideas are enabled by our choice of programming language, HOBiT, which is specifically designed to maintain the unidirectional program structure in bidirectional programming, and keep the parts that control bidirectional behavior modular. To evaluate our approach, we implemented it in a tool called Synbit and used it to generate bidirectional programs for intricate microbenchmarks, as well as for a few larger, more realistic problems. We also compared Synbit to a state-of-the-art unidirectional synthesis tool on the task of synthesizing backward computations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Masaomi</first_name>
          <last_name>Yamaguchi</last_name>
          <affiliation>Graduate School of Information Sciences, Tohoku University</affiliation>
          <bio>undefined</bio>
          <person_id>masaomiyamaguchi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kazutaka</first_name>
          <last_name>Matsuda</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.sf.ecei.tohoku.ac.jp/~kztk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kazutakamatsuda/2262653d-0d0f-4641-8ac2-7b653c0e3683/small.jpg</picture_url>
          <person_id>kazutakamatsuda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cristina</first_name>
          <last_name>David</last_name>
          <affiliation>University of Bristol</affiliation>
          <bio>undefined</bio>
          <person_id>cristinadavid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Meng</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Bristol, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/mengwang/2aba9176-828a-4227-9392-75f364770330/small.jpg</picture_url>
          <person_id>mengwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>852ee1fb-6de7-4ac3-a96a-e4c69a691d74</slot_id>
      <event_id>7e72ede0-84a8-45df-97b4-f2b728e7a48d</event_id>
      <title>Compiling with Continuations, Correctly</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:10</end_time>
      <description>In this paper we present a novel simulation relation for proving correctness of program transformations that combines syntactic simulations and logical relations. In particular, we establish a new kind of simulation diagram that uses a small-step or big-step semantics in the source language and an untyped, step-indexed logical relation in the target language. Our technique provides a practical solution for proving semantics preservation for transformations that do not preserve reductions in the source language. This is common when transformations generate new binder names, and hence $\alpha$-conversion must be explicitly accounted for, or when transformations introduce administrative redexes. Our technique does not require reductions in the source language to correspond directly to reductions in the target language. Instead, we enforce a weaker notion of semantic preorder, which suffices to show that semantics are preserved for both whole-program and separate compilation. Because our logical relation is transitive, we can transition between intermediate program states in a small-step fashion and hence the shape of the proof resembles that of a simple small-step simulation. 
We use this technique to revisit the semantic correctness of a continuation-passing style (CPS) transformation and we demonstrate how it allows us to overcome well-known complications of this proof related to $\alpha$-conversion and administrative reductions. In addition, by using a logical relation that is indexed by invariants that relate the resource consumption of two programs, we are able show that the transformation preserves diverging behaviors and that our CPS transformation asymptotically preserves the running time of the source program. 
Our results are formalized in the Coq proof assistant. Our continuation-passing style transformation is part of the CertiCoq compiler for Gallina, the specification language of Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zoe</first_name>
          <last_name>Paraskevopoulou</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zoep.github.io/</homepage_url>
          <person_id>zoeparaskevopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anvay</first_name>
          <last_name>Grover</last_name>
          <affiliation>University of Wisconsin–Madison</affiliation>
          <bio>undefined</bio>
          <person_id>anvaygrover</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9935e976-d33e-4b76-a94c-45fa4fe9e891</slot_id>
      <event_id>fc877a4c-cd99-491d-bb86-11c7282681b5</event_id>
      <title>Efficient Compilation of Algebraic Effect Handlers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>19:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:30</end_time>
      <description>The popularity of algebraic effect handlers as a programming language feature for user-defined computational effects is steadily growing. Yet, even though efficient runtime representations have already been studied, most handler-based programs are still much slower than hand-written code. This paper shows that the performance gap can be drastically narrowed (in some cases even closed) by means of type-and-effect directed optimising compilation. Our approach consists of source-to-source transformations in two phases of the compilation pipeline. Firstly, elementary rewrites, aided by judicious function specialisation, exploit the explicit type and effect information of the compiler’s core language to agressively reduce handler applications. Secondly, after erasing the effect information further rewrites in the backend of the compiler emit tight code. This work comes with a practical implementation: an optimizing compiler from Eff, an ML style language with algebraic effect handlers, to OCaml. Experimental evaluation with this implementation demonstrates that in a number of benchmarks, our approach eliminates much of the overhead of handlers, outperforms capability-passing style compilation and yields competitive performance compared to hand-written OCaml code as well Multicore OCaml’s dedicated runtime support.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Karachalias</last_name>
          <affiliation>Tweag</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gkaracha.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/georgekarachalias/cb10a8f5-6b72-4883-aef0-c9978070378a/small.jpg</picture_url>
          <person_id>georgekarachalias</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Filip</first_name>
          <last_name>Koprivec</last_name>
          <affiliation>University of Ljubljana</affiliation>
          <bio>undefined</bio>
          <person_id>filipkoprivec1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matija</first_name>
          <last_name>Pretnar</last_name>
          <affiliation>University of Ljubljana</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://matija.pretnar.info/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/matijapretnar/87fb17f8-8e61-4088-8c8f-88c5c9174485/small.jpg</picture_url>
          <person_id>matijapretnar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e25e936e-96a6-4c05-bbce-1f9b468664e4</slot_id>
      <event_id>f0e509f9-0fba-48ca-8b45-d1c318f1c895</event_id>
      <title>Reachability Types: Tracking Aliasing and Separation in Higher-Order Functional Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>19:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:50</end_time>
      <description>Ownership type systems, based on the idea of enforcing unique access paths, have been primarily focused on objects and top-level classes. However, existing models do not as readily reflect the finer aspects of nested lexical scopes, capturing, or escaping closures in higher-order functional programming patterns, which are increasingly adopted even in mainstream OO languages. We present a new type system, $\lambda^{\ast}$, which enables expressive ownership-style reasoning across higher-order functions. It tracks sharing and separation through reachability sets, and layers additional mechanisms for selectively enforcing uniqueness on top of it. Based on reachability sets, we extend the type system with an expressive flow-sensitive effect system, which enables flavors of move semantics and ownership transfer. In addition, we present several case studies and extensions, including applications to capabilities for algebraic effects, one-shot continuations, and safe parallelization.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuyan</first_name>
          <last_name>Bao</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuyanbao.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuyanbao/29054831-172d-4005-9e61-a5f62bd70c76/small.jpg</picture_url>
          <person_id>yuyanbao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guannan</first_name>
          <last_name>Wei</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://continuation.passing.style</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guannanwei/e1971b4b-ebd3-429b-b28c-0c2cfb0f0289/small.jpg</picture_url>
          <person_id>guannanwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Bračevac</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://bracevac.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/oliverbracevac/17c0ac71-a156-4868-8df9-d4ae4cd669e7/small.jpg</picture_url>
          <person_id>oliverbracevac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yuxuan</first_name>
          <last_name>Jiang</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>yuxuanjiang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Qiyang</first_name>
          <last_name>He</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>qiyanghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c5b15de0-086a-4a9c-8af8-1713ec940e75</subevent_id>
    <title>SPLASH OOPSLA: Analysis - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>322b7dcc-5e03-4dd7-a39e-cafc2a04605e</slot_id>
      <title>Session: SPLASH OOPSLA - Analysis - mirror</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0904489f-d856-46e0-b3fd-727c57b89b5d</slot_id>
      <event_id>15b825cc-d30b-4dc1-97c4-9068619d905b</event_id>
      <title>Making Pointer Analysis More Precise by Unleashing the Power of Selective Context Sensitivity</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:00</end_time>
      <description>Traditional context-sensitive pointer analysis is hard to scale for large and complex Java programs. To address this issue, a series of selective context-sensitivity approaches have been proposed and exhibit promising results. In this work, we move one step further towards producing highly-precise pointer analyses for hard-to-analyze Java programs by presenting the Unity-Relay framework, which takes selective context sensitivity to the next level. Briefly, Unity-Relay is a one-two punch: given a set of different selective context-sensitivity approaches, say $S = {S_1, \ldots, S_n}$, Unity-Relay first provides a mechanism (called Unity) to combine and maximize the precision of all components of $S$. When Unity fails to scale, Unity-Relay offers a scheme (called Relay) to pass and accumulate the precision from one approach $S_i$ in $S$ to the next, $S_{i+1}$, leading to an analysis that is more precise than all approaches in $S$. 
As a proof-of-concept, we instantiate Unity-Relay into a tool called Baton and extensively evaluate it on a set of hard-to-analyze Java programs, using general precision metrics and popular clients. Compared with the state of the art, Baton achieves the best precision for \emph{all} metrics and clients for \emph{all} evaluated programs. The difference in precision is often dramatic—up to 71% of alias pairs reported by previously-best algorithms are found to be spurious and eliminated.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tian</first_name>
          <last_name>Tan</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <person_id>tiantan1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yue</first_name>
          <last_name>Li</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuelee.bitbucket.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yueli/c0b3b5ef-ffac-472c-9a05-5b9c8f165d7d/small.jpg</picture_url>
          <person_id>yueli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xiaoxing</first_name>
          <last_name>Ma</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ics.nju.edu.cn/people/xiaoxingma/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaoxingma1/5add1977-f0a4-458b-b59b-71cf18017400/small.jpg</picture_url>
          <person_id>xiaoxingma1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Chang</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.nju.edu.cn/changxu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/changxu/e28fcdd7-83f6-43c4-9ac8-20a3fa1137d8/small.jpg</picture_url>
          <person_id>changxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>974af04e-bd93-490a-98a8-48009888efad</slot_id>
      <event_id>9ea1d9f0-04dc-4462-8e51-cc113731d741</event_id>
      <title>JavaDL: Automatically Incrementalizing Java Bug Pattern Detection</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>09:00</end_time>
      <description>Static checker frameworks support software developers by automatically discovering bugs that fit general-purpose bug patterns. These frameworks ship with hundreds of detectors for such patterns and allow developers to add custom detectors for their own projects. However, existing frameworks generally encode detectors in imperative specifications, with extensive details of not only what to detect but also how. These details not only add complexity to maintenance and extensibility, but also interfere with the framework’s ability to change how detection is done, for instance, to make the detectors incremental. 
In this paper, we present JavaDL, a Datalog-based declarative specification language for bug pattern detection in Java code. JavaDL seamlessly supports both exhaustive and incremental evaluation from the same detector specification . The system further allows developers to concisely describe bug detectors via syntactic pattern matching for local AST matching, and via Datalog-style logical rules for nonlocal reasoning. We compare our approach against the well-established SpotBugs and Error Prone tools by re-implementing several of their detectors in JavaDL. We find that our implementations are substantially smaller and similarly effective at detecting bugs on the Defects4J benchmark suite, and run with competitive runtime performance. In our experiments, neither incremental nor exhaustive analysis is able to consistently outperform the other analysis mode, which highlights the value of our ability to transparently switch execution modes. We argue that our approach highlights the potential of clear-box static checker frameworks that constrain the bug detector specification language to enable the framework to adapt and enhance the detectors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexandru</first_name>
          <last_name>Dura</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <person_id>alexandrudura1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Reichenbach</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophreichenbach/04687677-a813-459e-8929-d1e4a32627c6/small.jpg</picture_url>
          <person_id>christophreichenbach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Emma</first_name>
          <last_name>Söderberg</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/emmasoderberg/2edc9865-4e98-41ee-a89e-1568465852e0/small.jpg</picture_url>
          <person_id>emmasoderberg</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>da2b371d-80a2-4a22-b409-af9367de5223</slot_id>
      <event_id>6ff2a930-bcaf-47ae-9930-b8baa0788972</event_id>
      <title>Program Analysis via Efficient Symbolic Abstraction</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>08:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:40</end_time>
      <description>This paper addresses the scalability challenges of symbolic abstraction: given a formula $\varphi$ in a logic $\mathcal{L}$ and an abstract domain $\mathcal{A}$, find a most precise element in the abstract domain that over-approximates the meaning of $\varphi$. Symbolic abstraction is an important point in the space of abstract interpretation, as it allows for automatically synthesizing the best abstract transformers. However, current techniques for symbolic abstraction can have difficulty delivering on its practical strengths, due to performance issues. 
In this work, we introduce two algorithms for the symbolic abstraction of quantifier-free bit-vector formulas, which apply to the bit-vector interval domain and a certain kind of polyhedral domain, respectively. We implement and evaluate the proposed techniques on two machine code analysis clients, static memory corruption analysis and constrained random fuzzing. Using a suite of 57,933 queries from the clients, we compare our approach against a diverse group of state-of-the-art algorithms. The experiments show that our algorithms achieve a substantial speedup over existing techniques, and illustrate significant precision advantages for the clients. Our work presents strong evidence that symbolic abstraction of numeric domains can be efficient and practical for large and realistic programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Peisen</first_name>
          <last_name>Yao</last_name>
          <affiliation>The Hong Kong University of Science and Technology</affiliation>
          <bio>I am broadly interested in topics related to programming languages, software engineering, formal method, and cybersecurity, with an emphasis on using program reasoning techniques to ensure software reliability.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/yaopeisen/afec483a-bef9-4542-b208-b84c15344696/small.jpg</picture_url>
          <person_id>yaopeisen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Qingkai</first_name>
          <last_name>Shi</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Qingkai Shi is a Postdoc Research Associate in the department of computer science, Purdue University. His major research interest is the use of compiler techniques to ensure software reliability. He has published extensively at premium venues of programming languages (PLDI, OOPSLA), software engineering (ICSE, FSE, TSE, ISSTA), and cybersecurity (S&amp;amp;P). His research received many awards including ACM SIGSOFT Distinguished Paper Award and Hong Kong Ph.D. Fellowship. His research has led to the discovery of over a hundred software vulnerabilities in open-source software and has been successfully commercialized in Sourcebrella Inc, a static analysis tool vendor. Qingkai obtained his Ph.D. and B.S. from Nanjing University and the Hong Kong University of Science and Technology, respectively.</bio>
          <homepage_url>https://qingkaishi.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/qingkaishi/99eef1fd-60de-40bf-888f-38d77b3db376/small.jpg</picture_url>
          <person_id>qingkaishi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Heqing</first_name>
          <last_name>Huang</last_name>
          <affiliation>Hong Kong University of Science and Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://5hadowblad3.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/heqinghuang/726be0ec-989d-4ddd-b27c-6559ebc40835/small.jpg</picture_url>
          <person_id>heqinghuang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charles</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Hong Kong University of Science and Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ust.hk/~charlesz</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/charleszhang/d5404cd7-dca8-4033-b79f-500613a981b9/small.jpg</picture_url>
          <person_id>charleszhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fda5f4ff-0971-4534-af6f-b53075389529</slot_id>
      <event_id>4f4af528-c989-4120-8b8e-ab1590c33f65</event_id>
      <title>Compacting Points-To Sets Through Object Clustering</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>08:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:20</end_time>
      <description>Inclusion-based set constraint solving is the most popular technique for whole-program points-to analysis whereby an analysis is typically formulated as repeatedly resolving constraints between points-to sets of program variables. The set union operation is central to this process. The number and size of points-to sets grow as analyses become more precise and input programs become larger, resulting in more time spent performing unions. Most existing approaches focus on improving scalability of precise points-to analyses from an algorithmic perspective and there has been less research into improving the data structures behind the analyses. 
Bit-vectors as one of the more popular data structures have been used in several mainstream analysis frameworks to represent points-to sets. To store memory objects in bit-vectors, objects need to mapped to integral identifiers. We observe that this object-to-identifier mapping is critical for a compact points-to set representation and the set union operation. If objects in the same points-to sets (co-pointees) are not given numerically close identifiers, points-to resolution can cost significantly more space and time. Without data on the unpredictable points-to relations discovered by the analysis, an ideal mapping is extremely challenging. 
In this paper, we present a new approach to inclusion-based analysis by compacting points-to sets through object clustering. Inspired by recent staged analysis where an auxiliary analysis produces results approximating a more precise main analysis, we formulate points-to set compaction as an optimisation problem solved by integer programming using constraints generated from the auxiliary analysis’s results in order to produce an effective mapping. We then develop a more approximate mapping, yet much more efficiently, using hierarchical clustering to compact bit-vectors. We also develop an improved representation of bit-vectors (called core bit-vectors) to fully take advantage of the newly produced mapping. Our approach requires no algorithmic change to the points-to analysis. We evaluate our object clustering on flow-sensitive points-to analysis using 9 open-source programs (&amp;gt;5.3 millions lines of LLVM instructions) and Our results show that our approach can successfully improve the analysis with an up to 1.75$\times$ speed up and up to 3.25$\times$ reduction in memory usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohamad</first_name>
          <last_name>Barbar</last_name>
          <affiliation>University of Technology Sydney, Australia and CSIRO's Data61, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mbarbar.net</homepage_url>
          <person_id>mohamadbarbar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>215b386c-5fd8-4a20-bc1f-35e6539e9127</subevent_id>
    <title>SPLASH OOPSLA: Optimization - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>09cc35f9-916b-4d5a-a7cf-eeaafc88fe22</slot_id>
      <title>Session: SPLASH OOPSLA - Optimization - mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>049f1d5e-e9e9-4e81-88b6-e6f54a4c4ba8</slot_id>
      <event_id>e78d6285-c5ed-4a96-8242-9315d1c25ef4</event_id>
      <title>VESPA: Static Profiling for Binary Optimization</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>19:16</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:43</end_time>
      <description>Over the past few years, there has been a surge in the popularity of binary optimizers such as BOLT, Propeller, Janus and HALO. These tools use dynamic profiling information to make optimization decisions. Although effective, gathering runtime data presents developers with inconveniences such as unrepresentative inputs, the need to accommodate software modifications, and longer build times. In this paper, we revisit the static profiling technique proposed by Calder et al. in the late 90’s, and investigate its application to drive binary optimizations, in the context of the BOLT binary optimizer, as a replacement for dynamic profiling. A few core modifications to Calder et al.’s original proposal, consisting of new program features and a new regression model, are sufficient to enable some of the gains obtained through runtime profiling. An evaluation of BOLT powered by our static profiler on four large benchmarks (clang, GCC, MySQL and PostgreSQL) yields binaries that are 5.50% faster than the executables produced by clang -O3.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Angelica Aparecida</first_name>
          <last_name>Moreira</last_name>
          <affiliation>Universidade Federal de Minas Gerais</affiliation>
          <bio>Angélica Moreira is a late 3rd year PhD candidate in the Computer Science Department at Federal University of Minas Gerais (UFMG). She is a member of the Compilers Laboratory (LAC), where she is advised by Professor Fernando Magno Quintão Pereira. She holds an M.Sc degree in Computer Science from the Federal University of Ouro Preto (UFOP) and a B.Sc degree in Computer Science from the Pontifical Catholic University of Minas Gerais (PUC Minas). 
Angélica’s research interest lies in pursuing the design and implementation of techniques that reduce program binary size and make them run faster on heterogeneous architectures. Her research focuses on combining machine learning and compilation techniques to achieve her goal. Her dream is to contribute to a better world through the development of science and technology.</bio>
          <homepage_url>https://homepages.dcc.ufmg.br/~angelica.moreira/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/angelicaaparecidamoreira/8e228596-dcff-49ff-9b56-e77a499f89d8/small.jpg</picture_url>
          <person_id>angelicaaparecidamoreira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guilherme</first_name>
          <last_name>Ottoni</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~ottoni</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guilhermeottoni/a60389de-a60b-4624-949a-574fd53ea7ab/small.jpg</picture_url>
          <person_id>guilhermeottoni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>Federal University of Minas Gerais</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an associate professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
          <person_id>fernandomagnoquintaopereira</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2144a809-1527-48fc-8350-8bd99954c786</slot_id>
      <event_id>a07657bd-7670-4ce9-b59c-c0d4a5733ee1</event_id>
      <title>A Derivative-based Parser Generator for Visibly Pushdown Grammars</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:16</end_time>
      <description>In this paper, we present a derivative-based, functional recognizer and parser generator for visibly pushdown grammars. The generated parser accepts ambiguous grammars and produces a parse forest containing all valid parse trees for an input string in linear time. Each parse tree in the forest can then be extracted also in linear time. Besides the parser generator, to allow more flexible forms of the visibly pushdown grammars, we also present a translator that converts a tagged CFG to a visibly pushdown grammar in a sound way, and the parse trees of the tagged CFG are further produced by running the semantic actions embedded in the parse trees of the translated visibly pushdown grammar. The performance of the parser is compared with a popular parsing tool ANTLR on parsing JSON and HTML files. The correctness of the core parsing algorithm is formally verified in the proof assistant Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaodong</first_name>
          <last_name>Jia</last_name>
          <affiliation>The Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>xiaodongjia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ashish</first_name>
          <last_name>Kumar</last_name>
          <affiliation>The Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>ashishkumar1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gang</first_name>
          <last_name>Tan</last_name>
          <affiliation>Penn State University</affiliation>
          <bio>Dr. Gang Tan is the James F. Will Career Development Associate Professor in Computer Science and Engineering at Pennsylvania State University, PA. He leads the Security of Software (SOS) Lab. His research is at the interface between computer security, programming languages, and formal methods. He received his bachelor’s degree in Computer Science with honors from Tsinghua University in 1999 and his Ph.D. degree from Princeton University in 2005. He has received an NSF CAREER award, two Google Research Awards, and a Francis Upton Graduate Fellowship.</bio>
          <homepage_url>http://www.cse.psu.edu/~gxt29/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gangtan/e101adef-54fb-4fcc-bce0-381da3d1aace/small.jpg</picture_url>
          <person_id>gangtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>51182649-061d-4ca9-8070-fde2edd8a989</slot_id>
      <event_id>b07a5fb5-66c7-4797-a121-2c07df02ff9d</event_id>
      <title>Copy-and-Patch Compilation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>19:43</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>20:10</end_time>
      <description>Fast compilation is important when compilation occurs at runtime, such as query compilers in modern database systems and WebAssembly virtual machines in modern browsers. We present copy-and-patch, an extremely fast compilation technique that also produces good quality code. It is capable of lowering both high-level languages and low-level bytecode programs to binary code, by stitching together code from a large library of binary implementation variants. We call these binary implementations stencils because they have holes where missing values must be inserted during code generation. We show how to construct a stencil library and describe the copy-and-patch algorithm that generates optimized binary code. 
We demonstrate two use cases of copy-and-patch: a compiler for a high-level C-like language intended for metaprogramming and a compiler for WebAssembly. Our high-level language compiler has negligible compilation cost: it produces code from an AST in less time than it takes to construct the AST. We have implemented an SQL database query compiler on top of this metaprogramming system and show that on TPC-H database benchmarks, copy-and-patch generates code two orders of magnitude faster than LLVM -O0 and three orders of magnitude faster than higher optimization levels. The generated code runs an order of magnitude faster than interpretation and 15% faster than LLVM -O0. Our WebAssembly compiler generates code 4.9X-6.5X faster than Liftoff, the WebAssembly baseline compiler in Google Chrome. The generated code also outperforms Liftoff’s by 46%-63% on the Coremark and PolyBenchC WebAssembly benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Haoran</first_name>
          <last_name>Xu</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>haoranxu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>169af1b0-2e2e-4ad1-ad71-97a921d38142</subevent_id>
    <title>SPLASH OOPSLA: Types</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>3b5a71fa-a93b-4849-8955-4c631c0461ec</slot_id>
      <title>Session: SPLASH OOPSLA - Types</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6af725b8-1750-4a30-9eb3-099b5aaabcc1</subevent_id>
    <title>SPLASH OOPSLA: Synthesis of models, tools and programs -- mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>b5d1f561-5a97-4653-98b7-180431dac4d1</slot_id>
      <title>Session: SPLASH OOPSLA - Synthesis of models, tools and programs -- mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3e9f1b8e-df42-4ca7-8717-8bd888eefe33</slot_id>
      <event_id>44632a19-da24-4769-9abf-fb6b1a1b8dab</event_id>
      <title>Multi-modal Program Inference: a Marriage of Pre-trained Language Models and Component-based Synthesis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>20:10</end_time>
      <description>Multi-modal program synthesis refers to the task of synthesizing programs (code) from their specification given in different forms, such as a combination of natural language and examples. Examples provide a precise but incomplete specification, and natural language provides an ambiguous but more “complete” task description. Machine-learned pre-trained models (PTMs) are adept at handling ambiguous natural language, but struggle with generating syntactically and semantically precise code. Program synthesis techniques can generate correct code, often even from incomplete but precise specifications, such as examples, but they are unable to work with the ambiguity of natural languages. We present an approach that combines PTMs with component-based synthesis (CBS): PTMs are used to generate candidate programs from the natural language description of the task, which are then used to guide the CBS procedure to find the program that matches the precise examples-based specification. We use our combination approach to instantiate multi-modal synthesis systems for two programming domains: the domain of regular expressions and the domain of CSS selectors. Our evaluation demonstrates the effectiveness of our domain-agnostic approach in comparison to a state-of-the-art specialized system, and the generality of our approach in providing multi-modal program synthesis from natural language and examples in different programming domains.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kia</first_name>
          <last_name>Rahmani</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am a PhD candidate of computer science at Purdue University. I am a member of the programming languages group, working under the supervision of Professor Suresh Jagannathan and Professor Benjamin Delaware. 
My PhD thesis is focused around compilation, synthesis, and testing of modern database-backed programs. More broadly, I am interested in all formal methods for modeling and analysis of (classical or quantum) computer programs. 
I was previously a research intern at Microsoft, working on a new program synthesis technique based on pre-trained language models. My work was supervised by Dr. Mohammad Raza and Dr. Sumit Gulwani.</bio>
          <homepage_url>https://kiarahmani.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kiarahmani/745190a9-35f0-49e9-b5a9-f8831bce9162/small.jpg</picture_url>
          <person_id>kiarahmani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mohammad</first_name>
          <last_name>Raza</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>mohammadraza</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Vu</first_name>
          <last_name>Le</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>I am a Researcher at Microsoft, working on the Microsoft Program Synthesis using Examples (PROSE) framework. I obtained my PhD in 2015 at UC Davis, advised by Zhendong Su and Sumit Gulwani. My research is about developing novel and practical techniques to help improve the quality of critical software (e.g., compilers and database engines) and make programming accessible for end users. My work has led to the discovery of hundreds of bugs in GCC and LLVM, most of which have been fixed, and shipped in various Microsoft products.</bio>
          <homepage_url>http://vuminhle.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vule/8674b9d0-747d-4a80-b8f0-3c7a435cd9b7/small.jpg</picture_url>
          <person_id>vule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Morris</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>danielmorris</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Soares</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/gsoares/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gustavosoares/fc1e5a17-f939-4c3d-ab30-85467cb2610b/small.jpg</picture_url>
          <person_id>gustavosoares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Ashish</first_name>
          <last_name>Tiwari</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csl.sri.com/users/tiwari/</homepage_url>
          <person_id>ashishtiwari</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>85290b7b-4c12-4b6c-a3a7-e5f54050e9ea</subevent_id>
    <title>SPLASH OOPSLA: Test and Verification</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>74d84ace-0c1f-4647-81e9-4b68b1ceb8ce</slot_id>
      <title>Session: SPLASH OOPSLA - Test and Verification</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7c9de42f-6994-48a9-9141-c0ac163053fb</slot_id>
      <event_id>7776cd20-1ef0-46d3-ba4d-606e81ee96fe</event_id>
      <title>Scalability and Precision by Combining Expressive Type Systems and Deductive Verification</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:16</end_time>
      <description>Type systems and modern type checkers can be used very successfully to obtain formal correctness guarantees with little specification overhead. However, type systems in practical scenarios have to trade precision for decidability and scalability. Tools for deductive verification, on the other hand, can prove general properties in more cases than a typical type checker can, but they do not scale well. We present a method to complement the scalability of expressive type systems with the precision of deductive program verification approaches. Our novel approach is introduced both conceptually by a proven formalization and practically by a concrete implementation for the Java programming language. The usefulness and power of our approach has been evaluated by discharging known false positives from a real-world program and by a small case study.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Lanzinger</last_name>
          <affiliation>Karlsruhe Institute of Technology (KIT)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://formal.iti.kit.edu/~lanzinger/</homepage_url>
          <person_id>florianlanzinger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Weigl</last_name>
          <affiliation>Karlsruhe Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>alexanderweigl</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mattias</first_name>
          <last_name>Ulbrich</last_name>
          <affiliation>Karlsruhe Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://formal.iti.kit.edu/~ulbrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mattiasulbrich/93c421cd-7529-43d3-8968-366d6ba1753d/small.jpg</picture_url>
          <person_id>mattiasulbrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Werner</first_name>
          <last_name>Dietl</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ece.uwaterloo.ca/~wdietl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wernerdietl/f6ddc3ef-7134-4260-a182-a71ed88842cb/small.jpg</picture_url>
          <person_id>wernerdietl</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e7da96db-48d7-4442-bfbc-35c3340b5c94</slot_id>
      <event_id>b5f75101-c8be-4cba-88b6-888ea6deaadc</event_id>
      <title>MonkeyDB: Effectively Testing Correctness under Weak Isolation Levels</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>14:16</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:43</end_time>
      <description>Modern applications, such as social networking systems and e-commerce platforms are centered around using large-scale storage systems for storing and retrieving data. In the presence of concurrent accesses, these storage systems trade off isolation for performance. The weaker the isolation level, the more behaviors a storage system is allowed to exhibit and it is up to the developer to ensure that their application can tolerate those behaviors. However, these weak behaviors only occur rarely in practice, that too outside the control of the application, making it difficult for developers to test the robustness of their code against weak isolation levels. 
This paper presents MonkeyDB, a mock storage system for testing storage-backed applications. MonkeyDB supports a Key-Value interface as well as SQL queries under multiple isolation levels. It uses a logical specification of the isolation level to compute, on a read operation, the set of all possible return values. MonkeyDB then returns a value randomly from this set. We show that MonkeyDB provides good coverage of weak behaviors, which is complete in the limit. We test a variety of applications for assertions that fail only under weak isolation. MonkeyDB is able to break each of those assertions in a small number of attempts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ranadeep</first_name>
          <last_name>Biswas</last_name>
          <affiliation>Informal Systems</affiliation>
          <bio>undefined</bio>
          <person_id>ranadeepbiswas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Diptanshu</first_name>
          <last_name>Kakwani</last_name>
          <affiliation>Microsoft, India</affiliation>
          <bio>undefined</bio>
          <person_id>diptanshukakwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jyothi</first_name>
          <last_name>Vedurada</last_name>
          <affiliation>IIT Hyderabad</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jyothivedurada.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jyothivedurada/669c2067-2bb1-4cfd-9ecd-ad4dc7772314/small.jpg</picture_url>
          <person_id>jyothivedurada</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>University of Paris / IRIF / CNRS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
          <person_id>constantinenea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Akash</first_name>
          <last_name>Lal</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/akashl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/akashlal/96032ffc-99b4-4b90-b99d-01b1f833751a/small.jpg</picture_url>
          <person_id>akashlal</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fe186d8e-a13f-4ed7-85f5-a8be6e5d2535</slot_id>
      <event_id>ffbfc4af-f8a6-43e6-9e8b-c1c5253ab739</event_id>
      <title>Specifying and Testing GPU Workgroup Progress Models</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>14:43</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>15:10</end_time>
      <description>As GPU availability has increased and programming support has matured, a wider variety of applications are being ported to these platforms. Many parallel applications contain fine-grained synchronization idioms; as such, their correct execution depends on a degree of relative forward progress between threads (or thread groups). Unfortunately, many GPU programming specifications (e.g. Vulkan and Metal) say almost nothing about relative forward progress guarantees between workgroups. Although prior work has proposed a spectrum of plausible progress models for GPUs, cross-vendor specifications have yet to commit to any model. 
This work is a collection of tools experimental data to aid specification designers when considering forward progress guarantees in programming frameworks. As a foundation, we formalize a small parallel programming language that captures the essence of fine-grained synchronization. We then provide a means of formally specifying a progress model, and develop a termination oracle that decides whether a given program is guaranteed to eventually terminate with respect to a given progress model. Next, we formalize a constraint for concurrent programs that require relative forward progress to terminate. Using this constraint, we synthesize a large set of 483 progress litmus tests. Combined with the termination oracle, this allows us to determine the expected status of each litmus test – i.e. whether it is guaranteed eventual termination – under various progress models. We present a large experimental campaign running the litmus tests across 8 GPUs from 5 different vendors. Our results highlight that GPUs have significantly different termination behaviors under our test suite. Most notably, we find that Apple and ARM GPUs do not support the linear occupancy-bound model, an intuitive progress model defined by prior work and hypothesized to describe the workgroup schedulers of existing GPUs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>University of California at Santa Cruz</affiliation>
          <bio>I am a Post Doc researcher at Princeton University working in Margaret Martonosi’s group. My research interests are in concurrency: programming, modeling, testing, and architecture. In particular, I am interested in exploring new heterogeneous architectures and how programming models can enable development of secure and efficient applications. 
I received my PhD from the Multicore Programming Group at Imperial College London supervised by Alastair Donaldson. Previously, I worked with Ganesh Gopalakrishnan and Zvonimir Rakamaric at University of Utah.</bio>
          <homepage_url>https://www.cs.princeton.edu/~ts20/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tylersorensen1/e6c9c5cc-65e1-4a42-87c2-5e4a7d347b0d/small.jpg</picture_url>
          <person_id>tylersorensen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lucas Fernan</first_name>
          <last_name>Salvador</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>I am a software engineer at the Xbox Platform team, and used to be a Master’s student at Princeton University (having graduated in May 2021). My main area of interest is parallel computing in its multiple facets (algorithms, architecture and verification).</bio>
          <homepage_url>https://www.cs.princeton.edu/~ls24/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lucasfernansalvador/b45303b8-06e1-4f08-be26-369bff1b5628/small.jpg</picture_url>
          <person_id>lucasfernansalvador</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Harmit</first_name>
          <last_name>Raval</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>harmitraval</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hugues</first_name>
          <last_name>Evrard</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <person_id>huguesevrard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Margaret</first_name>
          <last_name>Martonosi</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>margaretrmartonosi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Alastair F.</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8b220a19-ec5d-4e9a-b89b-8a85fe4f4703</subevent_id>
    <title>SPLASH OOPSLA: Testing - Mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>c093c87f-86aa-4979-895b-b373efc4b6c3</slot_id>
      <title>Session: SPLASH OOPSLA - Testing - Mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4c0fe2d1-2284-463c-9a5e-f4f01384e61f</slot_id>
      <event_id>033e9d5c-0599-4e16-95be-bf846cf24376</event_id>
      <title>Permchecker: A Toolchain for Debugging Memory Managers with Typestate</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:10</end_time>
      <description>Dynamic memory managers are a crucial component of almost every modern software system. In addition to implementing efficient allocation and reclamation, memory managers provide the essential abstraction of memory as distinct objects, which underpins the properties of memory safety and type safety. Bugs in memory managers, while not common, are extremely hard to diagnose and fix. One reason is that their implementations often involve tricky pointer calculations, raw memory manipulation, and complex memory state invariants. While these properties are often documented, they are not specified in any precise, machine-checkable form. A second reason is that memory manager bugs can break the client application in bizarre ways that do not immediately implicate the memory manager at all. A third reason is that existing tools for debugging memory errors, such as Memcheck, cannot help because they rely on correct allocation and deallocation information to work. 
In this paper we present Permchecker, a tool designed specifically to detect and diagnose bugs in memory managers. The key idea in Permchecker is to make the expected structure of the heap explicit by associating \emph{typestates} with each piece of memory. Typestate captures elements of both type (e.g., page, block, or cell) and state (e.g., allocated, free, or forwarded). Memory manager developers annotate their implementation with information about the expected typestates of memory and how heap operations change those typestates. At runtime, our system tracks the typestates and ensures that each memory access is consistent with the expected typestates. This technique detects errors quickly, before they corrupt the application or the memory manager itself, and it often provides accurate information about the reason for the error. 
The implementation of Permchecker uses a combination of compile-time annotation and instrumentation, and dynamic binary instrumention. Because the overhead of DBI is fairly high, Permchecker is suitable for a testing and debugging setting and not for deployment. It works on a wide variety of existing systems, including explict malloc/free memory managers and garbage collectors, such as those found in JikesRVM and OpenJDK. Since bugs in these systems are not numerous, we developed a testing methodology in which we automatically inject bugs into the code using bug patterns derived from real bugs. This technique allows us to test Permchecker on hundreds or thousands of buggy variants of the code. We find that Permchecker effectively detects and localizes errors in the vast majority of cases; without it, these bugs result in strange, incorrect behaviors usually long after the actual error occurs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Karl</first_name>
          <last_name>Cronburg</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.eecs.tufts.edu/~karl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/karlcronburg/1487b759-23be-47d5-adb2-f6e6b4013d52/small.jpg</picture_url>
          <person_id>karlcronburg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Guyer</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/samguyer/94906fdc-2110-48fb-a0cd-afd1464b9262/small.jpg</picture_url>
          <person_id>samguyer</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4ea871ed-1fcd-4551-a4e6-15343850a166</slot_id>
      <event_id>26e88f75-7306-434e-afa1-624701a72947</event_id>
      <title>Generative Type-Aware Mutation for Testing SMT Solvers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>19:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:50</end_time>
      <description>We propose Generative Type-Aware Mutation, an effective approach for testing SMT solvers. The key idea is to realize generation through the mutation of expressions with parametric operators from the SMT-LIB specification. Generative Type-Aware Mutation is a hybrid of mutation-based and grammar-based type-ware mutations and features an unbounded mutation space—overcoming a major limitation of OpFuzz, the state-of-the-art fuzzer for SMT solvers. We have realized Generative Type-Aware Mutation in a practical SMT solver bug hunting tool, TypeFuzz. During three months of testing with TypeFuzz, we reported over 70 bugs in the state-of-the-art SMT solvers Z3 and CVC4. Among these, 48 bugs were confirmed and 35 bugs were fixed. Perhaps most notably, we found 9 soundness bugs in CVC4’s default mode alone. CVC4 has proven to be a very stable SMT solver and has resisted several fuzzing campaigns. A third of the soundness bugs in CVC4 (3/9) are at least 2 years latent and pre-date any previous SMT solver fuzzing campaigns.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jiwon</first_name>
          <last_name>Park</last_name>
          <affiliation>École Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>jiwonpark</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wintered.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>90f1cdc0-4cc5-40a1-9d1a-7e420c8ea00b</slot_id>
      <event_id>4e7d7fa2-4fd4-42e1-9e44-961a43dfab85</event_id>
      <title>Fully Automated Functional Fuzzing of Android Apps for Detecting Non-Crashing Logic Bugs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>20:10</end_time>
      <description>Android apps are GUI-based event-driven software and have become ubiquitous in recent years. Obviously, functional correctness is critical for an app’s success. However, in addition to crash bugs, \emph{non-crashing functional bugs} (in short as “non-crashing bugs” in this work) like inadvertent function failures, silent user data lost and incorrect display information are prevalent, even in popular, well-tested apps. These non-crashing functional bugs are usually caused by program logic errors and manifest themselves on the graphic user interfaces (GUIs). In practice, such bugs pose significant challenges in effectively detecting them because (1) current practices heavily rely on expensive, small-scale manual validation (\emph{the lack of automation}); and (2) modern \emph{fully automated} testing has been limited to crash bugs (\emph{the lack of test oracles}). 
This paper fills this gap by introducing \emph{independent view fuzzing}, \emph{a novel, fully automated approach} for detecting non-crashing functional bugs in Android apps. Inspired by metamorphic testing, our key insight is to leverage the commonly-held \emph{independent view property} of Android apps to manufacture property-preserving mutant tests from a set of seed tests that validate certain app properties. The mutated tests help exercise the tested apps under additional, adverse conditions. Any property violations indicate likely functional bugs for further manual confirmation. We have realized our approach as an automated, end-to-end functional fuzzing tool, Genie. Given an app, (1) Genie automatically detects non-crashing bugs without requiring human-provided tests and oracles (thus \emph{fully automated}); and (2) the detected non-crashing bugs are diverse (thus \emph{general and not limited to specific functional properties}), which set Genie apart from prior work. 
We have evaluated Genie on 12 real-world Android apps and successfully uncovered 34 previously unknown non-crashing bugs in their latest releases — all have been confirmed, and 22 have already been fixed. Most of the detected bugs are nontrivial and have escaped developer (and user) testing for at least one year and affected many app releases, thus clearly demonstrating Genie’s effectiveness. These 34 non-crashing bugs could not been detected by prior fully automated GUI testing tools (as our evaluation confirms). Thus, our work complements and enhances existing manual testing and fully automated testing for crash bugs. 
To facilitate reviewing and replication of our work, we have open-sourced Genie and provided additional information (\emph{fully anonymized}) at https://github.com/functional-fuzzing-android-apps/home.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ting</first_name>
          <last_name>Su</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://tingsu.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tingsu/a7bc2f83-b98a-44ba-954c-da631ab86471/small.jpg</picture_url>
          <person_id>tingsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yichen</first_name>
          <last_name>Yan</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>yichenyan1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jue</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/juewang1/989813f5-0a9c-4617-8f83-9690a0e6b253/small.jpg</picture_url>
          <person_id>juewang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Sun</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>jinglingsun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yiheng</first_name>
          <last_name>Xiong</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>yihengxiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Geguang</first_name>
          <last_name>Pu</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>geguangpu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Ke</first_name>
          <last_name>Wang</last_name>
          <affiliation>Visa Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kbwang.bitbucket.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kewang/37ef656e-ca92-475f-8a51-902dbe44fb72/small.jpg</picture_url>
          <person_id>kewang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e027fdab-5784-440d-bbd5-27f8e0a06be2</slot_id>
      <event_id>1f6ab670-2e0d-4713-b59c-0e28fbaea895</event_id>
      <title>Programming and Execution Models for Parallel Bounded Exhaustive Testing</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>19:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:30</end_time>
      <description>Bounded-exhaustive testing (BET), which exercises a program under test for all inputs up to some bounds, is an effective method for detecting software bugs. Systematic property-based testing is a BET approach where developers write test generation programs that describe properties of test inputs. Hybrid test generation programs offer the most expressive way to write desired properties by freely combining declarative filters and imperative generators. However, exploring hybrid test generation programs, to obtain test inputs, is both computationally demanding and challenging to parallelize. We present the first programming and execution models, dubbed Tempo, for parallel exploration of hybrid test generation programs. We describe two different strategies for mapping the computation to parallel hardware and implement them both for GPUs and CPUs. We evaluated Tempo by generating instances of various data structures commonly used for benchmarking in the BET domain. Additionally, we generated CUDA programs to stress test CUDA compilers, finding four bugs confirmed by the developers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nader</first_name>
          <last_name>Al Awar</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>naderalawar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kush</first_name>
          <last_name>Jain</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>kushjain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chris</first_name>
          <last_name>Rossbach</last_name>
          <affiliation>The University of Texas at Austin and VMware Research Group</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.utexas.edu/~rossbach</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chrisrossbach/d36775ec-4ad9-4010-ae6e-ba41c5f9d61d/small.jpg</picture_url>
          <person_id>chrisrossbach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milos</first_name>
          <last_name>Gligoric</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/milosgligoric/4d0671ae-937e-4f08-b499-092379ff7ad3/small.jpg</picture_url>
          <person_id>milosgligoric</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a1dc5cbc-2fd9-446b-8687-b52c4f2f7107</subevent_id>
    <title>SPLASH OOPSLA: Shared Memory - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>e720dc2a-c28f-409b-b845-195b7acbd998</slot_id>
      <title>Session: SPLASH OOPSLA - Shared Memory - mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3209b2e0-55ce-4dbd-80d8-d2f73c09a4ac</slot_id>
      <event_id>6aa106ca-9202-4ee8-904b-b032fcb07a70</event_id>
      <title>The Semantics of Shared Memory in Intel CPU/FPGA Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>09:00</end_time>
      <description>Heterogeneous CPU/FPGA devices, in which a CPU and an FPGA can execute together while sharing memory, are becoming popular in several computing sectors. In this paper, we study the shared-memory semantics of these devices, with a view to providing a firm foundation for reasoning about the programs that run on them. We focus on Intel platforms that combine an Intel FPGA with a multicore Xeon CPU. We describe the weak-memory behaviours that are allowed (and observable) on these devices when CPU threads and an FPGA thread access common memory locations in a fine-grained manner through multiple channels. Some of these behaviours are familiar from well-studied CPU and GPU concurrency; others are weaker still. We encode these behaviours in two formal memory models: one operational, one axiomatic. We develop executable implementations of both models, using the CBMC bounded model-checking tool for our operational model and the Alloy modelling language for our axiomatic model. Using these, we cross-check our models against each other via a translator that converts Alloy-generated executions into queries for the CBMC model. We also validate our models against actual hardware by translating 477 Alloy-generated executions into litmus tests that we run on CPU/FPGA devices; when doing this, we avoid the prohibitive cost of synthesising a hardware design per litmus test by creating our own ‘litmus-test processor’ in hardware. We expect that our models, one of which has been deemed ‘definitive’ by a Senior Principal Engineer at Intel, will be useful for low-level programmers, compiler writers, and designers of analysis tools. Indeed, as a demonstration of the utility of our work, we use our operational model to reason about a producer/consumer buffer implemented across the CPU and the FPGA. When the buffer uses insufficient synchronisation – a situation that our model is able to detect – we observe that its performance improves at the cost of occasional data corruption.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dan</first_name>
          <last_name>Iorga</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~di13/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/daniorga/dac1a236-b8e7-462e-a2c3-2713314bf843/small.jpg</picture_url>
          <person_id>daniorga</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alastair F.</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I’m a PhD student at Imperial College London supervised by Alastair Donaldson. I study testing and modeling of many-core systems, with an emphasis on fine-grained communication idioms.</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~trs15/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tylersorensen/a5910621-6b59-4729-be27-e5dfae22a495/small.jpg</picture_url>
          <person_id>tylersorensen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5a4de905-cb76-4b10-986c-bc0902fb6620</slot_id>
      <event_id>14c40490-ef1d-49cd-9483-5f093e37fb06</event_id>
      <title>The Reads-From Equivalence for the TSO and PSO Memory Models</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>08:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:40</end_time>
      <description>The verification of concurrent programs remains an open challenge due to the non-determinism in inter-process communication. One recurring algorithmic problem in this challenge is the consistency verification of concurrent executions. In particular, consistency verification under a reads-from map allows to compute the \emph{reads-from (RF) equivalence} between concurrent traces, with direct applications to areas such as Stateless Model Checking (SMC). Importantly, the RF equivalence was recently shown to be coarser than the standard Mazurkiewicz equivalence, leading to impressive scalability improvements for SMC under SC (sequential consistency). However, for the \emph{relaxed memory} models of TSO and PSO (total/partial store order), the algorithmic problem of deciding the RF equivalence, as well as its impact on SMC, has been elusive. 
In this work we solve the algorithmic problem of consistency verification for the TSO and PSO memory models given a reads-from map, denoted $\operatorname{VTSO-rf}$ and $\operatorname{VPSO-rf}$, respectively. For an execution of $n$ events over $k$ threads and $d$ variables, we establish novel bounds that scale as $n^{k+1}$ for TSO and as $n^{k+1}\cdot \min(n^{k^2}, 2^{k\cdot d})$ for PSO. Moreover, based on our solution to these problems, we develop an SMC algorithm under TSO and PSO that uses the RF equivalence. The algorithm is \emph{exploration-optimal}, in the sense that it is guaranteed to explore each class of the RF partitioning exactly once, and spends polynomial time per class when $k$ is bounded. Finally, we implement all our algorithms in the SMC tool Nidhugg, and perform a large number of experiments over benchmarks from existing literature. Our experimental results show that our algorithms for $\operatorname{VTSO-rf}$ and $\operatorname{VPSO-rf}$ provide significant scalability improvements over standard alternatives. Moreover, when used for SMC, the RF partitioning is often much coarser than the standard Shasha-Snir partitioning for TSO/PSO, which yields a significant speedup in the model checking task.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Truc Lam</first_name>
          <last_name>Bui</last_name>
          <affiliation>Comenius University Bratislava</affiliation>
          <bio>undefined</bio>
          <person_id>truclambui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Krishnendu</first_name>
          <last_name>Chatterjee</last_name>
          <affiliation>IST Austria, Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pub.ist.ac.at/~kchatterjee/</homepage_url>
          <person_id>krishnenduchatterjee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tushar</first_name>
          <last_name>Gautam</last_name>
          <affiliation>IIT Bombay</affiliation>
          <bio>undefined</bio>
          <person_id>tushargautam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Pavlogiannis</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.au.dk/~pavlogiannis/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/andreaspavlogiannis1/e756b107-52cb-4474-b2a4-c5d3174d8d5c/small.jpg</picture_url>
          <person_id>andreaspavlogiannis1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Toman</last_name>
          <affiliation>IST Austria (Institute of Science and Technology Austria)</affiliation>
          <bio>undefined</bio>
          <person_id>viktortoman</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>776c452b-6fcd-4408-8dc6-ee1d69175c45</slot_id>
      <event_id>ebe80fc8-3b07-494a-a4ca-22e80b3c5b6e</event_id>
      <title>SecRSL: Security Separation Logic for C11 Release-Acquire Concurrency</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>08:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:20</end_time>
      <description>We present Security Relaxed Separation Logic (SecRSL), a separation logic for proving information-flow security of C11 programs in the Release-Acquire fragment with relaxed accesses. SecRSL is the first security logic that (1)~supports weak-memory reasoning about programs in a high-level language; (2)~inherits separation logic’s virtues of compositional, local reasoning about (3)~expressive security policies like value-dependent classification. 
SecRSL is also, to our knowledge, the first security logic developed over an axiomatic memory model. Thus we also present the first definitions of information-flow security for an axiomatic weak memory model, against which we prove SecRSL sound. SecRSL ensures that programs satisfy a constant-time security guarantee, while being free of undefined behaviour. 
We apply SecRSL to implement and verify the functional correctness and constant-time security of a range of concurrency primitives, including a spinlock module, a mixed-sensitivity mutex, and multiple synchronous channel implementations. Empirical performance evaluations of the latter demonstrate SecRSL’s power to support the development of secure and performant concurrent C programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pengbo</first_name>
          <last_name>Yan</last_name>
          <affiliation>University of Melbourne</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/pengboyan1/e18d6038-3acb-4c3d-8c02-3c0448477791/small.jpg</picture_url>
          <person_id>pengboyan1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Toby</first_name>
          <last_name>Murray</last_name>
          <affiliation>University of Melbourne, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.eng.unimelb.edu.au/tobym</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobymurray/b22e1351-c7fc-420a-acef-492aadfce115/small.jpg</picture_url>
          <person_id>tobymurray</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>def6104e-37f0-49fc-82c1-0adc8685e623</slot_id>
      <event_id>ad86ee65-6cc2-442d-97e9-4761304ac507</event_id>
      <title>Making Weak Memory Models Fair</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:00</end_time>
      <description>Liveness properties, such as termination, of even the simplest shared-memory concurrent programs under sequential consistency typically require some fairness assumptions about the scheduler. Under weak memory models we observe that the standard notions of thread fairness are insufficient, and, an additional fairness property, which we call memory fairness, is needed. 
In this paper, we propose a uniform definition for memory fairness that can be integrated in any declarative memory model enforcing porf-acyclicity. For models, such as SC, TSO, RA, and StrongCOH, with equivalent operational and declarative presentations, we show that our declarative memory fairness condition is equivalent to an intuitive model-specific operational notion of memory fairness, which requires the memory system to fairly execute its internal propagation steps. Our fairness condition preserves the correctness of local transformations and the compilation scheme from RC11 to x86-TSO, and also enables the first formal proofs of termination of mutual exclusion lock implementations under declarative weak memory models.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Egor</first_name>
          <last_name>Namakonov</last_name>
          <affiliation>JetBrains Research, St Petersburg University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/egornamakonov/441c64d6-cf63-4751-9ba9-a8ae7d54216c/small.jpg</picture_url>
          <person_id>egornamakonov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonas</first_name>
          <last_name>Oberhauser</last_name>
          <affiliation>Huawei Dresden Research Center, Huawei OS Kernel Lab</affiliation>
          <bio>undefined</bio>
          <person_id>jonasoberhauser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anton</first_name>
          <last_name>Podkopaev</last_name>
          <affiliation>HSE University, JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://podkopaev.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/antonpodkopaev/b00dceb2-5b55-4c0b-afe0-17581b19dfee/small.jpg</picture_url>
          <person_id>antonpodkopaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>Viktor Vafeiadis is a tenured researcher at the Max Planck Institute for Software Systems (MPI-SWS), working on weak memory consistency and persistency. He has made numerous contributions on the semantics of weak memory consistency as well as on verification of concurrent programs with program logics and/or model checking, having published over 60 articles at top-tier venues. He got his PhD from the University of Cambridge in 2008 on concurrent program logics, for which he received the ACM SIGPLAN distinguished dissertation award. After postdoc positions at Microsoft Research and at the University of Cambridge, he joined the MPI-SWS in 2010 and got tenure in 2016.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
          <person_id>viktorvafeiadis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9d46868a-717c-44c0-8d62-55f627fa3181</subevent_id>
    <title>SPLASH OOPSLA: Security</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>ddc4477d-0047-4bdc-b940-1207905f966c</slot_id>
      <title>Session: SPLASH OOPSLA - Security</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>48bc5cd0-a20c-4590-98d1-9fe51ed2ffdf</slot_id>
      <event_id>d160658e-2c64-4c8e-9ce6-b2048d30d69c</event_id>
      <title>Interpretable Noninterference Measurement and its Application to Processor Designs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:30</end_time>
      <description>Noninterference measurement quantifies the secret information that might leak to an adversary from what the adversary can observe and influence about the computation. Static and high-fidelity noninterference measurement has been difficult to scale to complex computations, however. This paper scales a recent framework for noninterference measurement to the open-source RISC-V BOOM core as specified in Verilog, through three key innovations: logically characterizing the core’s execution incrementally, applying specific optimizations between each cycle; permitting information to be declassified, to focus leakage measurement to only secret information that cannot be inferred from the declassified information; and interpreting leakage measurements for the analyst in terms of simple rules that characterize when leakage occurs. Case studies on cache-based side channels generally, and on specific instances including Spectre attacks, show that the resulting toolchain, called DINoMe, effectively scales to this modern processor design.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ziqiao</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <person_id>ziqiaozhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael K.</first_name>
          <last_name>Reiter</last_name>
          <affiliation>Duke University</affiliation>
          <bio>undefined</bio>
          <person_id>michaelkreiter</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9437f010-3597-4b99-9f1e-bf7850d52bf8</slot_id>
      <event_id>e1451bd2-8368-4f79-bdf9-aa3a7332f14e</event_id>
      <title>Reconciling Optimization With Secure Compilation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:50</end_time>
      <description>Software protections against side-channel and physical attacks are essential to the development of secure applications. Such protections are meaningful at machine code or micro-architectural level, but they typically do not carry observable semantics at source level. This renders them susceptible to miscompilation, and security engineers embed input/output side-effects to prevent optimizing compilers from altering them. Yet these side-effects are error-prone and compiler-dependent. The current practice involves analyzing the generated machine code to make sure security or privacy properties are still enforced. These side-effects may also be too expensive in fine-grained protections such as control-flow integrity. We introduce observations of the program state that are intrinsic to the correct execution of security protections, along with means to specify and preserve observations across the compilation flow. Such observations complement the input/output semantics-preservation contract of compilers. We introduce an opacification mechanism to preserve and enforce a partial ordering of observations. This approach is compatible with a production compiler and does not incur any modification to its optimization passes. We validate the effectiveness and performance of our approach on a range of benchmarks, expressing the secure compilation of these applications in terms of observations to be made at specific program points.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Son</first_name>
          <last_name>Tuan Vu</last_name>
          <affiliation>ARM</affiliation>
          <bio>undefined</bio>
          <person_id>sontuanvu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Albert</first_name>
          <last_name>Cohen</last_name>
          <affiliation>Google</affiliation>
          <bio>Albert is a research scientist at Google. He has been a research scientist at Inria from 2000 to 2018. He graduated from École Normale Supérieure de Lyon and received his PhD from the University of Versailles in 1999 (awarded two national prizes). He has been a visiting scholar at the University of Illinois, an invited professor at Philips Research, and a visiting scientist at Facebook Artificial Intelligence Research. Albert Cohen works on parallelizing and optimizing compilers, parallel programming languages and systems and synchronous programming for reactive control systems. He served as the general or program chair of major conferences, including PLDI, PPoPP, HiPEAC, CC, the embedded software track of DAC, and as a member of the editorial board of ACM TACO and IJPP. He coauthored more than 180 peer-reviewed papers and has been the advisor for 26 PhD theses. Several research projects initiated by Albert Cohen resulted in effective transfer to production compilers and programming environments in industry.</bio>
          <homepage_url>https://who.rocq.inria.fr/Albert.Cohen</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/albertcohen/3684aca0-5e45-4ea1-bece-82d71228da32/small.jpg</picture_url>
          <person_id>albertcohen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arnaud</first_name>
          <last_name>de Grandmaison</last_name>
          <affiliation>ARM</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/arnauddegrandmaison/e359aaef-874f-472d-9bbd-01eaef90cd1c/small.jpg</picture_url>
          <person_id>arnauddegrandmaison</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Guillon</last_name>
          <affiliation>STMicroelectronics</affiliation>
          <bio>undefined</bio>
          <person_id>christopheguillon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Karine</first_name>
          <last_name>Heydemann</last_name>
          <affiliation>Sorbonne Université, CNRS, Laboratoire d'Informatique de Paris 6, LIP6</affiliation>
          <bio>undefined</bio>
          <person_id>karineheydemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b8b9b365-2144-451c-9572-8459f7d1640d</slot_id>
      <event_id>b8e58c10-44b0-4c96-94ba-19e9d23a0e86</event_id>
      <title>SpecSafe: Detecting Cache Side Channels in a Speculative World</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:10</end_time>
      <description>The high-profile Spectre attack and its variants have revealed that speculative execution may leave secret-dependent footprints in the cache, allowing an attacker to learn confidential data. However, existing static side-channel detectors either ignore speculative execution, leading to false negatives, or lack a precise cache model, leading to false positives. In this paper, somewhat surprisingly, we show that it is challenging to develop a speculation-aware static analysis with precise cache models: a combination of existing works does not necessarily catch all cache side channels. Motivated by this observation, we present a new semantic definition of security against cache-based side-channel attacks, called Speculative-Aware noninterference (SANI), which is applicable to a variety of attacks and cache models. We also develop SpecSafe to detect the violations of SANI. Unlike other speculation-aware symbolic executors, SpecSafe employs a novel program transformation so that SANI can be soundly checked by speculation-unaware side-channel detectors. SpecSafe is shown to be both scalable and accurate on a set of moderately sized benchmarks, including commonly used cryptography libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Brotzman-Smith</last_name>
          <affiliation>Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>robertbrotzmansmith</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Danfeng</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.psu.edu/~dbz5017/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danfengzhang/6eb87743-0994-4ff3-be1e-dbfb34429946/small.jpg</picture_url>
          <person_id>danfengzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mahmut Taylan</first_name>
          <last_name>Kandemir</last_name>
          <affiliation>Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.psu.edu/~kandemir/</homepage_url>
          <person_id>mahmuttaylankandemir</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gang</first_name>
          <last_name>Tan</last_name>
          <affiliation>Penn State University</affiliation>
          <bio>Dr. Gang Tan is the James F. Will Career Development Associate Professor in Computer Science and Engineering at Pennsylvania State University, PA. He leads the Security of Software (SOS) Lab. His research is at the interface between computer security, programming languages, and formal methods. He received his bachelor’s degree in Computer Science with honors from Tsinghua University in 1999 and his Ph.D. degree from Princeton University in 2005. He has received an NSF CAREER award, two Google Research Awards, and a Francis Upton Graduate Fellowship.</bio>
          <homepage_url>http://www.cse.psu.edu/~gxt29/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gangtan/e101adef-54fb-4fcc-bce0-381da3d1aace/small.jpg</picture_url>
          <person_id>gangtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fde29dbd-5aae-45f8-8d09-413180af5530</slot_id>
      <event_id>f767b573-d238-483e-bafc-2f0adec651ed</event_id>
      <title>Not So Fast: Understanding and Mitigating Negative Impacts of Compiler Optimizations on Code Reuse Gadget Sets</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:10</end_time>
      <description>Despite extensive testing and correctness certification of their functional semantics, a number of compiler optimizations have been shown to violate security guarantees implemented in source code. While prior work has shed light on how such optimizations may introduce semantic security weaknesses into programs, there remains a significant knowledge gap concerning the impacts of compiler optimizations on non-semantic properties with security implications. In particular, little is currently known about how code generation and optimization decisions made by the compiler affect the availability and utility of reusable code segments called gadgets required for implementing code reuse attack methods such as return-oriented programming. 
In this paper, we bridge this gap through a study of the impacts of compiler optimization on code reuse gadget sets. We analyze and compare 1,187 variants of 20 different benchmark programs built with two production compilers (GCC and Clang) to determine how their optimization behaviors affect the code reuse gadget sets present in program variants with respect to both quantitative and qualitative metrics. Our study exposes an important and unexpected problem; compiler optimizations introduce new gadgets at a high rate and produce code containing gadget sets that are generally more useful to an attacker than those in unoptimized code. Using differential binary analysis, we identify several undesirable behaviors at the root of this phenomenon. In turn, we propose and evaluate several strategies to mitigate these behaviors. In particular, we show that post-production binary recompilation can effectively mitigate these behaviors with negligible performance impacts, resulting in optimized code with significantly smaller and less useful gadget sets.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael D.</first_name>
          <last_name>Brown</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>michaeldbrown</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Pruett</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>matthewpruett</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robert</first_name>
          <last_name>Bigelow</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>robertbigelow</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Girish</first_name>
          <last_name>Mururu</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>girishmururu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Santosh</first_name>
          <last_name>Pande</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>santoshpande1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c15f1b97-c675-427b-86cb-80b09a9f03e5</subevent_id>
    <title>SPLASH OOPSLA: Smart Contracts and Distributed Programming</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>d6b893e4-4379-493d-a976-07255b29e178</slot_id>
      <title>Session: SPLASH OOPSLA - Smart Contracts and Distributed Programming</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3e290c5f-f0e5-4b67-b931-c8bf727342dd</subevent_id>
    <title>SPLASH OOPSLA: Program Synthesis</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>f32d5c03-62a4-4adb-90f4-e8a16544e41a</slot_id>
      <title>Session: SPLASH OOPSLA - Program Synthesis</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>68ddb3af-b6fd-40a2-9040-7c9cbdc19d72</slot_id>
      <event_id>43ca20c2-56eb-45a4-ba22-83f5f26257c4</event_id>
      <title>Generalizable Synthesis Through Unification</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:50</end_time>
      <description>The generalizability of PBE solvers is the key to the empirical synthesis performance. Despite the importance of generalizability, related studies on PBE solvers are still limited. In theory, few existing solvers provide theoretical guarantees on generalizability, and in practice, there is a lack of PBE solvers with satisfactory generalizability on important domains such as conditional linear integer arithmetic (CLIA). In this paper, we adopt a concept from the computational learning theory, Occam learning, and perform a comprehensive study on the framework of synthesis through unification (STUN), a state-of-the-art framework for synthesizing programs with nested if-then-else operators. We prove that Eusolver, a state-of-the-art STUN solver, does not satisfy the condition of Occam learning, and then we design a novel STUN solver, PolyGen, of which the generalizability is theoretically guaranteed by Occam learning. We evaluate PolyGen on the domains of CLIA and demonstrate that PolyGen significantly outperforms two state-of-the-art PBE solvers on CLIA, Eusolver and Euphony, on both generalizability and efficiency.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruyi</first_name>
          <last_name>Ji</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>ruyiji</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jingtao</first_name>
          <last_name>Xia</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>jingtaoxia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhenjiang</first_name>
          <last_name>Hu</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~hu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhenjianghu/5d426480-5589-46be-b4f6-f98cf2acc80e/small.jpg</picture_url>
          <person_id>zhenjianghu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b01bb567-84a8-4917-9b85-2b96a9f90096</slot_id>
      <event_id>25bb8503-88a2-4ba4-b253-0fc9a52e05dc</event_id>
      <title>Gauss: Program Synthesis by Reasoning Over Graphs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:30</end_time>
      <description>While input-output examples are a natural form of specification for program synthesis engines, they can be imprecise. In this paper, we investigate how extracting readily-available information about the user intent \emph{behind} these input-output examples helps speed up synthesis and reduce overfitting. We present Gauss, a synthesis algorithm that accepts partial input-output examples, along with \emph{user intent graphs}. Gauss includes a novel conflict-resolution reasoning algorithm over graphs that enables it to learn from mistakes made during the search and use that knowledge to explore the space of programs even faster. It also ensures the final program is consistent with the user intent specification, reducing overfitting. We implement Gauss for the domain of table transformations (supporting Pandas and R), and compare it to two state-of-the-art synthesizers accepting only input-output examples. We find that it is able to reduce the search space by 56$\times$, 73$\times$ and 664$\times$ on average, resulting in 7$\times$, 26$\times$ and 7$\times$ speedups in synthesis times on average, respectively.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rohan</first_name>
          <last_name>Bavishi</last_name>
          <affiliation>UC Berkeley</affiliation>
          <bio>I am a 3rd Year PhD student advised by Prof. Koushik Sen.</bio>
          <homepage_url>https://rbavishi.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rohanbavishi/9512af7a-f463-4f18-9edd-f4634cd69487/small.jpg</picture_url>
          <person_id>rohanbavishi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Caroline</first_name>
          <last_name>Lemieux</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Caroline Lemieux is a postdoctoral researcher at Microsoft Research, and will be starting as an Assistant Professor at UBC in Fall 2022. Her research interests center around improving the correctness and reliability of software systems by developing automated methods for engineering tasks such as testing, debugging, and comprehension. Her work on fuzz testing has been awarded an ACM SIGSOFT Distinguished Paper Award, Distinguished Artifact Award, Tool Demonstration Award, and Best Paper Award (Industry Track). She completed her PhD at UC Berkeley, advised by Koushik Sen; there, she was the recipient of a Berkeley Fellowship for Graduate Study, and a Google PhD Fellowship in Programming Technologies and Software Engineering. She received her B.Sc. in Computer Science and Mathematics at the University of British Columbia, where she won the Governor General’s Silver Medal in Science, awarded to the undergraduate student with highest standing in the Faculty of Science.</bio>
          <homepage_url>https://www.carolemieux.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/carolinelemieux/e43ab970-fd4b-43bd-83fe-eada347d47c9/small.jpg</picture_url>
          <person_id>carolinelemieux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Koushik</first_name>
          <last_name>Sen</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>Koushik Sen is a professor in the Department of Electrical Engineering and Computer Sciences at the University of California, Berkeley. His research interest lies in Software Engineering, Programming Languages, and Formal methods. He is interested in developing software tools and methodologies that improve programmer productivity and software quality. He holds a B.Tech from Indian Institute of Technology, Kanpur, and M.S. and Ph.D. in CS from University of Illinois at Urbana-Champaign.</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~ksen/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/koushiksen/9f417f8a-40b9-40a7-866c-9c44cd81859a/small.jpg</picture_url>
          <person_id>koushiksen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ion</first_name>
          <last_name>Stoica</last_name>
          <affiliation>UC Berkeley</affiliation>
          <bio>undefined</bio>
          <person_id>ionstoica</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c82e9b18-f2b0-4fec-bf11-c9a7794cfdef</slot_id>
      <event_id>d4737a93-8cd6-4e8c-833c-7ed194f21b7a</event_id>
      <title>LooPy: Interactive Program Synthesis with Control Structures</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:10</end_time>
      <description>One vision for program synthesis, and specifically for Programming by Example (PBE), is an interactive programmer’s assistant, integrated into the development environment. To make program synthesis practical for interactive use, prior work on Small-Step Live PBE has proposed to limit the scope of synthesis to small code snippets, and enable the users to provide local specifications for those snippets. This paradigm, however, does not work well in the presence of loops. We present LooPy, a synthesizer integrated into a Live Programming environment, which extends Small-Step Live PBE to work inside loops and scales it up to synthesize larger code snippets, while remaining fast enough for interactive use. To allow users to effectively provide examples at various loop iterations, even when the loop body is incomplete, LooPy makes use of live execution, a technique that leverages the programmer as an oracle to step over incomplete parts of the loop. To enable synthesis of loop bodies at interactive speeds, LooPy introduces Intermediate State Graph, a new data structure, which compactly represents a large space of code snippets composed of multiple assignment statements and conditionals. We evaluate LooPy empirically using benchmarks from competitive programming and previous synthesizers, and show that it can solve a wide variety of synthesis tasks at interactive speeds. We also performed a small qualitative user study which shows that LooPy’s block-level specifications are easy for programmers to provide.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kasra</first_name>
          <last_name>Ferdowsifard</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <person_id>kasraferdowsifard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/shraddhabarke1/4e11ed13-0f46-4d77-8a6d-dd4c07b7fd4b/small.jpg</picture_url>
          <person_id>shraddhabarke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.technion.ac.il/~hilap</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sorin</first_name>
          <last_name>Lerner</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/users/lerner/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sorinlerner/3d3b1a70-e2f8-4d3a-a1bc-9c4e17dad80b/small.jpg</picture_url>
          <person_id>sorinlerner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of 2020 Intel Rising Stars Award and the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e673ae02-9d71-4390-bd07-58bc57185f6c</slot_id>
      <event_id>24dd1202-bb64-4cef-86c5-251fda3fcd93</event_id>
      <title>APIfix: Output-Oriented Program Synthesis for Combating Breaking Changes in Libraries</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:10</end_time>
      <description>Use of third-party libraries is extremely common in application software. The libraries evolve to accommodate new features or mitigate security vulnerabilities, thereby breaking the Application Programming Interface (API) used by the software. Such breaking changes in the libraries may discourage client code from using the new library versions thereby keeping the application vulnerable and not up-to-date. We propose a novel output-oriented program synthesis algorithm to automate API usage adaptations via program transformation. Our aim is not only to rely on the few example human adaptations of the clients from the old library to the new library, since this can lead to over-fitting transformation rules. Instead, we also rely on example usages of the new updated library in clients, which provide valuable context for synthesizing and applying the transformation rules. Our tool APIFix provides an automated mechanism to transform application code using the old library versions to code using the new library versions - thereby achieving automated API usage adaptation to fix the effect of breaking changes. Our evaluation shows that the transformation rules inferred by APIFix achieve 98.7% precision and 91.5% recall. By comparing our approach to state-of-the-art program synthesis approaches, we show that our approach significantly reduces over-fitting while synthesizing transformation rules for API usage adaptations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiang</first_name>
          <last_name>Gao</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.comp.nus.edu.sg/~gaoxiang/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xianggao/482ff4c5-f003-40e7-90cc-d888adbd1e2f/small.jpg</picture_url>
          <person_id>xianggao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Soares</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/gsoares/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gustavosoares/fc1e5a17-f939-4c3d-ab30-85467cb2610b/small.jpg</picture_url>
          <person_id>gustavosoares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ridwan Salihin</first_name>
          <last_name>Shariffdeen</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>I am a fourth-year PhD student in Department of Computer Science at School of Computing, National University of Singapore, where I am advised by Abhik Roychoudhury. The current focus of my research is on automated program repair, software security and software engineering automation.</bio>
          <homepage_url>https://rshariffdeen.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ridwansalihinshariffdeen/4ac6e84f-a4cb-4547-b8d7-026e9e142f00/small.jpg</picture_url>
          <person_id>ridwansalihinshariffdeen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Abhik</first_name>
          <last_name>Roychoudhury</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>Abhik Roychoudhury is a Professor of Computer Science at National University of Singapore. His research focuses on software testing and analysis, software security and trust-worthy software construction. His research group has built scalable techniques for testing, debugging and repair of programs using systematic semantic analysis. The capability to automatically repair programs at a large scale contributes to the vision of self-healing software. He is currently directing the National Satellite of Excellence in Trustworthy Software Systems in Singapore. He is also the Lead Principal Investigator of the Singapore Cyber-security Consortium, which is a consortium of 25 companies in the cyber-security space engaging with academia for research and collaboration.</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~abhik</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/abhikroychoudhury/7017e73b-76d1-4dd4-a4b4-def2881fc2c9/small.jpg</picture_url>
          <person_id>abhikroychoudhury</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9acec159-f093-4b84-8791-dda108158926</subevent_id>
    <title>SPLASH OOPSLA: Shared Memory</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>fb1ca30b-1dc7-4f39-8e7e-b95bc2e607c8</slot_id>
      <title>Session: SPLASH OOPSLA - Shared Memory</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>061ee6ea-d630-4c99-a98a-a657425dd84b</slot_id>
      <event_id>ebe80fc8-3b07-494a-a4ca-22e80b3c5b6e</event_id>
      <title>SecRSL: Security Separation Logic for C11 Release-Acquire Concurrency</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:20</end_time>
      <description>We present Security Relaxed Separation Logic (SecRSL), a separation logic for proving information-flow security of C11 programs in the Release-Acquire fragment with relaxed accesses. SecRSL is the first security logic that (1)~supports weak-memory reasoning about programs in a high-level language; (2)~inherits separation logic’s virtues of compositional, local reasoning about (3)~expressive security policies like value-dependent classification. 
SecRSL is also, to our knowledge, the first security logic developed over an axiomatic memory model. Thus we also present the first definitions of information-flow security for an axiomatic weak memory model, against which we prove SecRSL sound. SecRSL ensures that programs satisfy a constant-time security guarantee, while being free of undefined behaviour. 
We apply SecRSL to implement and verify the functional correctness and constant-time security of a range of concurrency primitives, including a spinlock module, a mixed-sensitivity mutex, and multiple synchronous channel implementations. Empirical performance evaluations of the latter demonstrate SecRSL’s power to support the development of secure and performant concurrent C programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pengbo</first_name>
          <last_name>Yan</last_name>
          <affiliation>University of Melbourne</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/pengboyan1/e18d6038-3acb-4c3d-8c02-3c0448477791/small.jpg</picture_url>
          <person_id>pengboyan1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Toby</first_name>
          <last_name>Murray</last_name>
          <affiliation>University of Melbourne, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.eng.unimelb.edu.au/tobym</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobymurray/b22e1351-c7fc-420a-acef-492aadfce115/small.jpg</picture_url>
          <person_id>tobymurray</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>13ccc3f1-ca7c-40b5-a00f-e5c1c110d394</slot_id>
      <event_id>14c40490-ef1d-49cd-9483-5f093e37fb06</event_id>
      <title>The Reads-From Equivalence for the TSO and PSO Memory Models</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:40</end_time>
      <description>The verification of concurrent programs remains an open challenge due to the non-determinism in inter-process communication. One recurring algorithmic problem in this challenge is the consistency verification of concurrent executions. In particular, consistency verification under a reads-from map allows to compute the \emph{reads-from (RF) equivalence} between concurrent traces, with direct applications to areas such as Stateless Model Checking (SMC). Importantly, the RF equivalence was recently shown to be coarser than the standard Mazurkiewicz equivalence, leading to impressive scalability improvements for SMC under SC (sequential consistency). However, for the \emph{relaxed memory} models of TSO and PSO (total/partial store order), the algorithmic problem of deciding the RF equivalence, as well as its impact on SMC, has been elusive. 
In this work we solve the algorithmic problem of consistency verification for the TSO and PSO memory models given a reads-from map, denoted $\operatorname{VTSO-rf}$ and $\operatorname{VPSO-rf}$, respectively. For an execution of $n$ events over $k$ threads and $d$ variables, we establish novel bounds that scale as $n^{k+1}$ for TSO and as $n^{k+1}\cdot \min(n^{k^2}, 2^{k\cdot d})$ for PSO. Moreover, based on our solution to these problems, we develop an SMC algorithm under TSO and PSO that uses the RF equivalence. The algorithm is \emph{exploration-optimal}, in the sense that it is guaranteed to explore each class of the RF partitioning exactly once, and spends polynomial time per class when $k$ is bounded. Finally, we implement all our algorithms in the SMC tool Nidhugg, and perform a large number of experiments over benchmarks from existing literature. Our experimental results show that our algorithms for $\operatorname{VTSO-rf}$ and $\operatorname{VPSO-rf}$ provide significant scalability improvements over standard alternatives. Moreover, when used for SMC, the RF partitioning is often much coarser than the standard Shasha-Snir partitioning for TSO/PSO, which yields a significant speedup in the model checking task.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Truc Lam</first_name>
          <last_name>Bui</last_name>
          <affiliation>Comenius University Bratislava</affiliation>
          <bio>undefined</bio>
          <person_id>truclambui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Krishnendu</first_name>
          <last_name>Chatterjee</last_name>
          <affiliation>IST Austria, Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pub.ist.ac.at/~kchatterjee/</homepage_url>
          <person_id>krishnenduchatterjee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tushar</first_name>
          <last_name>Gautam</last_name>
          <affiliation>IIT Bombay</affiliation>
          <bio>undefined</bio>
          <person_id>tushargautam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Pavlogiannis</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.au.dk/~pavlogiannis/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/andreaspavlogiannis1/e756b107-52cb-4474-b2a4-c5d3174d8d5c/small.jpg</picture_url>
          <person_id>andreaspavlogiannis1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Toman</last_name>
          <affiliation>IST Austria (Institute of Science and Technology Austria)</affiliation>
          <bio>undefined</bio>
          <person_id>viktortoman</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1f01d3d2-864d-477e-90f8-917f115f876e</slot_id>
      <event_id>6aa106ca-9202-4ee8-904b-b032fcb07a70</event_id>
      <title>The Semantics of Shared Memory in Intel CPU/FPGA Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>17:00</end_time>
      <description>Heterogeneous CPU/FPGA devices, in which a CPU and an FPGA can execute together while sharing memory, are becoming popular in several computing sectors. In this paper, we study the shared-memory semantics of these devices, with a view to providing a firm foundation for reasoning about the programs that run on them. We focus on Intel platforms that combine an Intel FPGA with a multicore Xeon CPU. We describe the weak-memory behaviours that are allowed (and observable) on these devices when CPU threads and an FPGA thread access common memory locations in a fine-grained manner through multiple channels. Some of these behaviours are familiar from well-studied CPU and GPU concurrency; others are weaker still. We encode these behaviours in two formal memory models: one operational, one axiomatic. We develop executable implementations of both models, using the CBMC bounded model-checking tool for our operational model and the Alloy modelling language for our axiomatic model. Using these, we cross-check our models against each other via a translator that converts Alloy-generated executions into queries for the CBMC model. We also validate our models against actual hardware by translating 477 Alloy-generated executions into litmus tests that we run on CPU/FPGA devices; when doing this, we avoid the prohibitive cost of synthesising a hardware design per litmus test by creating our own ‘litmus-test processor’ in hardware. We expect that our models, one of which has been deemed ‘definitive’ by a Senior Principal Engineer at Intel, will be useful for low-level programmers, compiler writers, and designers of analysis tools. Indeed, as a demonstration of the utility of our work, we use our operational model to reason about a producer/consumer buffer implemented across the CPU and the FPGA. When the buffer uses insufficient synchronisation – a situation that our model is able to detect – we observe that its performance improves at the cost of occasional data corruption.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dan</first_name>
          <last_name>Iorga</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~di13/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/daniorga/dac1a236-b8e7-462e-a2c3-2713314bf843/small.jpg</picture_url>
          <person_id>daniorga</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alastair F.</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I’m a PhD student at Imperial College London supervised by Alastair Donaldson. I study testing and modeling of many-core systems, with an emphasis on fine-grained communication idioms.</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~trs15/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tylersorensen/a5910621-6b59-4729-be27-e5dfae22a495/small.jpg</picture_url>
          <person_id>tylersorensen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f0e1e423-1f73-44ee-b7f8-144248fbfb45</slot_id>
      <event_id>ad86ee65-6cc2-442d-97e9-4761304ac507</event_id>
      <title>Making Weak Memory Models Fair</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:00</end_time>
      <description>Liveness properties, such as termination, of even the simplest shared-memory concurrent programs under sequential consistency typically require some fairness assumptions about the scheduler. Under weak memory models we observe that the standard notions of thread fairness are insufficient, and, an additional fairness property, which we call memory fairness, is needed. 
In this paper, we propose a uniform definition for memory fairness that can be integrated in any declarative memory model enforcing porf-acyclicity. For models, such as SC, TSO, RA, and StrongCOH, with equivalent operational and declarative presentations, we show that our declarative memory fairness condition is equivalent to an intuitive model-specific operational notion of memory fairness, which requires the memory system to fairly execute its internal propagation steps. Our fairness condition preserves the correctness of local transformations and the compilation scheme from RC11 to x86-TSO, and also enables the first formal proofs of termination of mutual exclusion lock implementations under declarative weak memory models.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Egor</first_name>
          <last_name>Namakonov</last_name>
          <affiliation>JetBrains Research, St Petersburg University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/egornamakonov/441c64d6-cf63-4751-9ba9-a8ae7d54216c/small.jpg</picture_url>
          <person_id>egornamakonov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonas</first_name>
          <last_name>Oberhauser</last_name>
          <affiliation>Huawei Dresden Research Center, Huawei OS Kernel Lab</affiliation>
          <bio>undefined</bio>
          <person_id>jonasoberhauser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anton</first_name>
          <last_name>Podkopaev</last_name>
          <affiliation>HSE University, JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://podkopaev.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/antonpodkopaev/b00dceb2-5b55-4c0b-afe0-17581b19dfee/small.jpg</picture_url>
          <person_id>antonpodkopaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>Viktor Vafeiadis is a tenured researcher at the Max Planck Institute for Software Systems (MPI-SWS), working on weak memory consistency and persistency. He has made numerous contributions on the semantics of weak memory consistency as well as on verification of concurrent programs with program logics and/or model checking, having published over 60 articles at top-tier venues. He got his PhD from the University of Cambridge in 2008 on concurrent program logics, for which he received the ACM SIGPLAN distinguished dissertation award. After postdoc positions at Microsoft Research and at the University of Cambridge, he joined the MPI-SWS in 2010 and got tenure in 2016.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
          <person_id>viktorvafeiadis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0077f585-0c74-4d9d-91eb-ffbca7321026</subevent_id>
    <title>SPLASH OOPSLA: Dynamic Languages</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8181d564-03ea-4023-8229-135ee1e55a1a</slot_id>
      <title>Session: SPLASH OOPSLA - Dynamic Languages</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3a36c8d0-e603-4151-a0ba-6d5abc8a1b9f</slot_id>
      <event_id>4a141d82-81f5-4f25-b5aa-659e52e64f49</event_id>
      <title>Solver-based Gradual Type Migration</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>12:10</end_time>
      <description>Gradually typed languages allow programmers to mix statically and dynamically typed code, enabling them to incrementally reap the benefits of static typing as they add type annotations to their code. However, this type migration process is typically a manual effort with limited tool support. This paper examines the problem of automated type migration: given a dynamic program, infer additional or improved type annotations. 
Existing type migration algorithms prioritize different goals, such as maximizing type precision, maintaining compatibility with unmigrated code, and preserving the semantics of the original program. We argue that the type migration problem involves fundamental compromises: optimizing for a single goal often comes at the expense of others. Ideally, a type migration tool would flexibly accommodate a range of user priorities. 
We present TypeWhich, a new approach to automated type migration for an extension of the gradually-typed lambda calculus. Unlike prior work, which relies on custom solvers, TypeWhich produces constraints that can be solved by an off-the-shelf MaxSMT solver. This allows us to easily express objectives, such as minimizing the number of necessary syntactic coercions, and constraining the type of the migration to be compatible with unmigrated code. 
We present the first comprehensive evaluation of GTLC type migration algorithms, and compare TypeWhich to four other tools from the literature. Our evaluation uses prior benchmarks, and a new set of ``challenge problems''. Moreover, we design a new evaluation methodology that highlights the subtleties of gradual type migration. In addition, we apply TypeWhich to a suite of benchmarks for Grift, a programming language based on the GTLC. TypeWhich is able to reconstruct all human-written annotations on all but one program.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luna</first_name>
          <last_name>Phipps-Costin</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>undefined</bio>
          <person_id>lunaphippscostin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carolyn</first_name>
          <last_name>Anderson</last_name>
          <affiliation>Wellesley College</affiliation>
          <bio>undefined</bio>
          <person_id>carolynanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mgree.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>79ba39ce-1153-4406-abf8-bc688920cf2c</slot_id>
      <event_id>499d1ade-0a8a-4045-884c-ebba85519ad6</event_id>
      <title>Gradually Structured Data</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:50</end_time>
      <description>Dynamically-typed languages offer easy interaction with ad hoc data such as JSON and S-expressions; statically-typed languages offer powerful tools for working with structured data, notably \emph{algebraic datatypes}, which are a core feature of typed functional languages such as OCaml and Haskell, or otherwise such as Scala and Rust. Gradual typing aims to reconcile dynamic and static typing smoothly. The gradual typing literature has extensively focused on the computational aspect of types, such as type safety, effects, noninterference, or parametricity, but the application of graduality to data structuring mechanisms has been much less explored. While row polymorphism and set-theoretic types have been studied in the context of gradual typing, algebraic datatypes in particular have not, which is surprising considering their wide use in practice. We develop, formalize and prototype a novel approach to gradually structured data with algebraic datatypes. Gradually structured data bridges the gap between traditional algebraic datatypes and flexible data management mechanisms such as tagged data in dynamic languages, or polymorphic variants in OCaml. We illustrate the key ideas of gradual algebraic datatypes through the evolution of a small server application from dynamic to progressively more static checking, formalize a core functional language with gradually structured data, and establish its metatheory, including the gradual guarantees.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Malewski</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefanmalewski/cb42d4d7-af16-4e9d-b2a4-b8ce774834d7/small.jpg</picture_url>
          <person_id>stefanmalewski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mgree.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a8e677b6-02b1-41e2-93b0-038a4a78dc69</slot_id>
      <event_id>05e9115b-0577-4202-ab11-ae1224cdc112</event_id>
      <title>Promises Are Made to be Broken</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:10</end_time>
      <description>Function calls in the R language do not evaluate their arguments; these are passed to the callee as suspended computations and only evaluated if needed. After 25 years of experience with the language, there are very few cases where programmers leverage delayed evaluation intentionally. Yet, being lazy comes at a price in performance and complexity. This paper explores how to evolve the semantics of the language towards strictness by default and laziness on demand. To provide a migration path, it is necessary to change the semantics of the language and provide tooling for developers to migrate libraries and user code without introducing errors. This paper reports on a dynamic analysis that infers strictness signatures for functions to capture both intentional and accidental laziness. To assess the robustness of the inferred signatures we tested them on 2,000 R packages and found that inference was wrong in only 0.56% of the client programs. Finally, we report on the potential for performance improvements due to strictness. By modifying a just-in-time compiler to remove promises, we achieved an average speedup of 1.17X.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Ječmen</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <person_id>janjecmen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sebastián</first_name>
          <last_name>Krynski</last_name>
          <affiliation>Czech Technical University in Prague</affiliation>
          <bio>undefined</bio>
          <person_id>sebastiankrynski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c62bca9d-0b47-42f5-a45e-d86bce2d8687</slot_id>
      <event_id>27a5d755-7c49-43c3-aea7-317ade9e584c</event_id>
      <title>SimTyper: Sound Type Inference for Ruby using Type Equality Prediction</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:30</end_time>
      <description>Many researchers have explored type inference for dynamic languages. However, traditional type inference computes most general types which, for complex type systems—which are often needed to type dynamic languages—can be verbose, complex, and difficult to understand. In this paper, we introduce SimTyper, a Ruby type inference system that aims to infer \emph{usable} types—specifically, nominal and generic types—that match the types programmers write. SimTyper builds on InferDL, a recent Ruby type inference system that soundly combines standard type inference with heuristics. The key novelty of SimTyper is \emph{type equality prediction}, a new, machine learning-based technique that predicts when method arguments or returns are likely to have the same type. SimTyper finds pairs of positions that are predicted to have the same type yet one has a verbose, overly general solution and the other has a usable solution. It then guesses the two types are equal, keeping the guess if it is consistent with the rest of the program, and discarding it if not. In this way, types inferred by SimTyper are guaranteed to be sound. Type equality prediction is performed by a \emph{deep similarity} (DeepSim) neural network, which follows the Siamese network architecture, and uses CodeBERT, a pre-trained model, to embed source tokens into vectors that capture tokens and their contexts. DeepSim is trained on 100,000 pairs labeled with type similarity information extracted from 371 Ruby programs with manually documented, but not checked, types. We evaluated SimTyper on eight Ruby programs and found that, compared to standard type inference, SimTyper finds 71% more types that match programmer-written type information. Moreover, DeepSim can predict rare types that appear neither in the Ruby standard library nor in the training data. Our results show that type equality prediction can help type inference systems effectively produce more usable types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milod</first_name>
          <last_name>Kazerounian</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>undefined</bio>
          <person_id>milodkazerounian1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeffrey S.</first_name>
          <last_name>Foster</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.tufts.edu/~jfoster/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeffreysfoster/b22ce952-32b0-48bd-be56-12fd87bf3469/small.jpg</picture_url>
          <person_id>jeffreysfoster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bonan</first_name>
          <last_name>Min</last_name>
          <affiliation>Raytheon BBN Technologies</affiliation>
          <bio>undefined</bio>
          <person_id>bonanmin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fcde6341-62c0-4164-b5e5-a72a1b25551b</subevent_id>
    <title>SPLASH OOPSLA: Distributed Programming - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>00e194c2-4376-4112-89f3-73af0ec946b7</slot_id>
      <title>Session: SPLASH OOPSLA - Distributed Programming - mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>586543b5-9114-4bdd-82a0-d2f26acf6ad1</slot_id>
      <event_id>2c375f32-8c80-4300-b328-20661ab229e4</event_id>
      <title>Much ADO about Failures: A Fault-Aware Model for Compositional Verification of Strongly Consistent Distributed Systems</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:00</end_time>
      <description>Despite recent advances, guaranteeing the correctness of large-scale distributed applications without compromising performance remains a challenging problem. Network and node failures are inevitable and, for some applications, careful control over how they are handled is essential. Unfortunately, existing approaches either completely hide these failures behind an atomic state machine replication (SMR) interface, or expose all of the network-level details, sacrificing atomicity. We propose a novel, compositional, atomic distributed object (ADO) model for strongly consistent distributed systems that combines the best of both options. The object-oriented API abstracts over protocol-specific details and decouples high-level correctness reasoning from implementation choices. At the same time, it intentionally exposes an abstract view of certain key distributed failure cases, thus allowing for more fine-grained control over them than SMR-like models. We demonstrate that proving properties even of composite distributed systems can be straightforward with our Coq verification framework, Advert, thanks to the ADO model. We also show that a variety of common protocols including multi-Paxos and Chain Replication refine the ADO semantics, which allows one to freely choose among them for an application’s implementation without modifying ADO-level correctness proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wolf</first_name>
          <last_name>Honore</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <person_id>wolfhonore</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jieung</first_name>
          <last_name>Kim</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/jkim</homepage_url>
          <person_id>jieungkim</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ji-Yong</first_name>
          <last_name>Shin</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.jiyongshin.info</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jiyongshin/887e7089-7e73-4b28-8c02-9dc79624fe5d/small.jpg</picture_url>
          <person_id>jiyongshin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
          <person_id>zhongshao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>772724d3-77d3-4d05-86cd-2e56674d1986</slot_id>
      <event_id>62c941e0-1d73-41ab-b192-9220506f2589</event_id>
      <title>A Multiparty Session Typing Discipline for Fault-tolerant Event-driven Distributed Programming</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>08:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:20</end_time>
      <description>Correctly designing and implementing distributed systems software is notoriously difficult. Multiparty session types (MPSTs) is a typing discipline for concurrent processes that statically ensures properties such as freedom from message reception errors and deadlocks. The existing approaches in MPSTs cannot, however, be applied to a significant class of real-world distributed systems because they do not support practical specification and verification of protocols that handle and recover from partial failures. 
This paper presents the first formulation of MPSTs for practical fault-tolerant distributed programming. We tackle the long-standing challenges faced by session types in this context: bringing structure to communication patterns involving asynchronous and concurrent partial failures, and integrating the range of features required to express fault-tolerant protocols in practice, that involve dynamic replacement of failed parties and retrying failed protocol segments in the presence of imperfect failure detection. Key to our approach is that we develop the first model of event-driven concurrency for multiparty sessions, to unify the session-typed handling of failures and regular I/O events. Moreover, the characteristics of our model allow us to prove a global progress property for well-typed processes engaged in multiple concurrent sessions, which does not hold in traditional MPST systems. To demonstrate its practicality, we implement our approach as a toolchain for Scala, and use it to specify and implement a session-typed version of the cluster manager (CM) system of the widely employed Apache Spark data analytics engine. Our session-typed CM integrates with the other vanilla Spark components to give a functioning Spark runtime; e.g., it can execute existing third-party Spark applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Malte</first_name>
          <last_name>Viering</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>malteviering</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>University of Hertfordshire</affiliation>
          <bio>undefined</bio>
          <person_id>raymondhu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Eugster</last_name>
          <affiliation>USI Lugano &amp; Purdue University</affiliation>
          <bio>Patrick Eugster joined USI as a Full Professor of Computer Science in 2017, where he leads the SWYSTEMS (Software Systems) group, and co-founded the Computer Systems Institute in 2020. Prior to that he was a regular faculty member at TU Darmstadt (2014-2017) and Purdue University (2005-2016) where he remains an adjunct faculty member. Patrick holds M.S. (1998) and Ph.D. (2001) degrees from EPFL. 
Patrick is interested in software systems, with a particular focus on distributed systems and programming models/languages, and the intersection between the two. He has co-authored over 150 scientific articles on these topics. His research has been awarded by various funding agencies (e.g., NSF CAREER 2007, DARPA Computer Science Study Group 2011, ERC Consolidator 2014) and companies (e.g., Google Research Award 2003, NetApp Faculty Fellowship 2014, Facebook Research Award 2020). Patrick had the privilege to act as program chair of ACM OOPSLA 2015 and is currently serving as associate editor for IEEE Transactions on Software Engineering.</bio>
          <homepage_url>https://www.inf.usi.ch/faculty/eugstp/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/patrickeugster/bf8c955c-8902-4678-8c57-4b75cbd4f3c0/small.jpg</picture_url>
          <person_id>patrickeugster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lukasz</first_name>
          <last_name>Ziarek</last_name>
          <affiliation>SUNY Buffalo, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.buffalo.edu/~lziarek/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lukaszziarek/78ff4fd0-ef3b-4aed-ba86-2d6e66f85f65/small.jpg</picture_url>
          <person_id>lukaszziarek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>92630439-b4ac-446f-98fd-88929dcd3cae</slot_id>
      <event_id>cdc5b0cb-32bc-47df-a54d-5dd5e4516932</event_id>
      <title>QuickSilver: Modeling and Parameterized Verification for Distributed Agreement-Based Systems</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>09:00</end_time>
      <description>The last decade has sparked several valiant efforts in deductive verification of distributed agreement protocols such as consensus and leader election. Oddly, there have been far fewer verification efforts that go beyond the core protocols and target applications that are built on top of agreement protocols. This is unfortunate, as agreement-based distributed services such as data stores, locks, and ledgers are ubiquitous and potentially permit modular, scalable verification approaches that mimic their modular design. 
We address this need for verification of distributed agreement-based systems through our novel modeling and verification framework, QuickSilver, that is not only modular, but also fully automated. The key enabling feature of QuickSilver is our encoding of abstractions of verified agreement protocols that facilitates modular, decidable, and scalable automated verification. We demonstrate the potential of QuickSilver by modeling and efficiently verifying a series of tricky case studies, adapted from real-world applications, such as a data store, a lock service, a surveillance system, a pathfinding algorithm for mobile robots, and more.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nouraldin</first_name>
          <last_name>Jaber</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/nouraldinjaber/0aeeca1f-ae9b-4220-85ef-02510d406a10/small.jpg</picture_url>
          <person_id>nouraldinjaber</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christopher</first_name>
          <last_name>Wagner</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>christopherwagner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Swen</first_name>
          <last_name>Jacobs</last_name>
          <affiliation>CISPA Helmholtz Center for Information Security</affiliation>
          <bio>undefined</bio>
          <person_id>swenjacobs1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University. 
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures. 
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University. I received an NSF CAREER Award in 2012, a Department of Energy Early Career Research Award in 2013, and the Presidential Early Career Award for Scientists and Engineers in 2016.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
          <person_id>milindkulkarni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Roopsha</first_name>
          <last_name>Samanta</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/roopsha/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/roopshasamanta/3d74f41a-6adb-447b-8426-4a7fd9079dd4/small.jpg</picture_url>
          <person_id>roopshasamanta</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cf1308fe-6daf-4b53-8c7b-f10bb6a67ada</slot_id>
      <event_id>740c257f-f41f-4619-8c89-49e2da972d1d</event_id>
      <title>Automatic Migration from Synchronous to Asynchronous JavaScript APIs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>08:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:40</end_time>
      <description>The JavaScript ecosystem provides equivalent synchronous and asynchronous Application Programming Interfaces (APIs) for many commonly used I/O operations. Synchronous APIs involve straightforward sequential control flow that makes them easy to use and understand, but their “blocking” behavior may result in poor responsiveness or performance. Asynchronous APIs impose a higher syntactic burden that relies on callbacks, promises, and higher-order functions. On the other hand, their nonblocking behavior enables applications to scale better and remain responsive while I/O requests are being processed. While it is generally understood that asynchronous APIs have better performance characteristics, many applications still rely on synchronous APIs. In this paper, we present a refactoring technique for assisting programmers with the migration from synchronous to asynchronous APIs. The technique relies on static analysis to determine where calls to synchronous API functions can be replaced with their asynchronous counterparts, relying on JavaScript’s async/await feature to minimize disruption to the source code. Since the static analysis is potentially unsound, the proposed refactorings are presented as suggestions that must be reviewed and confirmed by the programmer. The technique was implemented in a tool named Desynchronizer. In an empirical evaluation on 12 subject applications containing 316 synchronous API calls, Desynchronizer identified 256 of these as candidates for refactoring. Of these candidates, 244 were transformed successfully, and only 12 resulted in behavioral changes. Further inspection of these cases revealed that the majority of these issues can be attributed to unsoundness in the call graph.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Satyajit</first_name>
          <last_name>Gokhale</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <person_id>satyajitgokhale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexi</first_name>
          <last_name>Turcotte</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://reallytg.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexiturcotte/6881a0a0-5145-40cb-aab4-ff41754a0640/small.jpg</picture_url>
          <person_id>alexiturcotte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Tip</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Frank Tip is a Professor and Associate Dean for Graduate Programs at Northeastern University. Previously, he was a Senior Principal Engineer at Samsung Research America in Mountain View, California (2014-2016), a Professor and Cheriton Research Chair in the David R. Cheriton School of Computer Science at the University of Waterloo (2012-2014), and a Research Staff Member and Manager at the Software Technology Department at the IBM T.J. Watson Research Center (1995-2012). He received his PhD in 1995 from the University of Amsterdam.</bio>
          <homepage_url>http://www.franktip.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/franktip/b4b4c804-cf32-45fa-afc8-3058f718b160/small.jpg</picture_url>
          <person_id>franktip</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8d0693c5-0cfe-436d-8e56-02a8877a467c</subevent_id>
    <title>SPLASH OOPSLA: Corpus and User Studies</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8153f459-3cfe-49cd-8d4e-9d4e71696db5</slot_id>
      <title>Session: SPLASH OOPSLA - Corpus and User Studies</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a1951cbd-47b6-4312-a4ab-916543ab6e32</subevent_id>
    <title>SPLASH OOPSLA: Specification Synthesis</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>b0ba1f76-cf50-425a-b721-72baa428a293</slot_id>
      <title>Session: SPLASH OOPSLA - Specification Synthesis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3ae5447c-3b96-47da-a249-dea254923827</slot_id>
      <event_id>b1cf329e-5f00-41ab-a8ac-2a2f2ba72e9f</event_id>
      <title>Data-Driven Abductive Inference of Library Specifications</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:50</end_time>
      <description>Programmers often leverage data structure libraries that provide useful and reusable abstractions. Modular verification of programs that make use of these libraries naturally rely on specifications that capture important properties about how the library expects these data structures to be accessed and manipulated. However, these specifications are often missing or incomplete, making it hard for clients to be confident they are using the library safely. When library source code is also unavailable, as is often the case, the challenge to infer meaningful specifications is further exacerbated. In this paper, we present a novel data-driven abductive inference mechanism that infers specifications for library methods sufficient to enable verification of the library’s clients. Our technique combines a data-driven learning-based framework to postulate candidate specifications, along with SMT-provided counterexamples to refine these candidates, taking special care to prevent generating specifications that overfit to sampled tests. The resulting specifications form a minimal set of requirements on the behavior of library implementations that ensures safety of a particular client program. Our solution thus provides a new multi-abduction procedure for precise specification inference of data structure libraries guided by client-side verification tasks. Experimental results on a wide range of realistic OCaml data structure programs demonstrate the effectiveness of the approach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhe</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhezhou/278a17cb-759b-46f2-98ca-6cb67f839b0b/small.jpg</picture_url>
          <person_id>zhezhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robert</first_name>
          <last_name>Dickerson</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://robd.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/robertdickerson/e65391dc-1815-4ecc-b58f-6afd1e1ac81d/small.jpg</picture_url>
          <person_id>robertdickerson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Delaware</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/bendy/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benjamindelaware/39bbf6b3-d145-435c-8956-8acf8cfcaffa/small.jpg</picture_url>
          <person_id>benjamindelaware</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Suresh</first_name>
          <last_name>Jagannathan</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/suresh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sureshjagannathan/70e51299-573f-4211-a895-b2028c19c585/small.jpg</picture_url>
          <person_id>sureshjagannathan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>54d87c19-1e53-4160-84a9-2e61cd78510a</slot_id>
      <event_id>f48451af-33ee-4d30-9177-5142a5caec22</event_id>
      <title>Synthesizing Contracts Correct Modulo a Test Generator</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>12:10</end_time>
      <description>We present an approach that learns contracts for object-oriented programs where guarantees of correctness of the contracts are made with respect to a test generator. Our contract synthesis approach is based on a novel notion of tight contracts and an online learning algorithm (for tight contracts) that works in tandem with a test generator. We implement our approach and evaluate it on a suite of programs written in C#, studying the safety and strength of the synthesized contracts, and compare them to those synthesized by Daikon.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Angello</first_name>
          <last_name>Astorga</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>angelloastorga1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shambwaditya</first_name>
          <last_name>Saha</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <person_id>shambwadityasaha2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ahmad</first_name>
          <last_name>Dinkins</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>ahmaddinkins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Felicia</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>feliciawang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>P.</first_name>
          <last_name>Madhusudan</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://madhu.cs.illinois.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/pmadhusudan/3775a90b-eb5d-4825-86d8-2a91a1e68fdf/small.jpg</picture_url>
          <person_id>pmadhusudan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tao</first_name>
          <last_name>Xie</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://taoxiease.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/taoxie/14ae8022-1dd6-4455-a54f-157c86bc406d/small.jpg</picture_url>
          <person_id>taoxie</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b5f1fdff-ff31-47e1-ae15-3585eef991b5</slot_id>
      <event_id>63e652b6-5919-48e6-b8bb-c7ed0009804e</event_id>
      <title>Static Detection of Silent Misconfigurations with Deep Interaction Analysis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:30</end_time>
      <description>The behavior of large systems is guided by their configurations: users set parameters in the configuration file to dictate which corresponding part of the system code is executed. However, it is often the case that, although some parameters are set in the configuration file, they do not influence the system runtime behavior, thus failing to meet the user’s intent. Moreover, such misconfigurations rarely lead to an error message or raising an exception. We introduce the notion of silent misconfigurations which are prohibitively hard to identify due to (1) lack of feedback and (2) complex interactions between configurations and code. 
This paper presents ConfigX, the first tool for the detection of silent configurations. The main challenge is to understand complex interactions between configuration and the code that is affected by them. Our goal is to derive a specification describing non-trivial dependencies between the configuration parameters that lead to silent misconfigurations. To this end, ConfigX uses static analysis to determine which parts of the system code are associated with configuration parameters. ConfigX then infers the connections between configuration parameters by analyzing their associated code blocks. We design customized control- and data-flow analysis to derive a specification of configurations. Additionally, we conduct reachability analysis to eliminate spurious rules to reduce false positives. Upon evaluation on five real-world datasets across three widely-used systems, Apache, vsftpd, and PostgreSQL, ConfigX detected more than 2200 silent misconfigurations. We additionally conducted a user study where we ran ConfigX on misconfigurations reported on user forums by real-world users. ConfigX easily detected issues and suggested a repair for those misconfigurations. Our solutions were accepted and confirmed in the interaction with the users, who originally posted the problems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jialu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jialuzhang/7427a686-f97e-42da-9f0b-4b94122d30f3/small.jpg</picture_url>
          <person_id>jialuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ruzica</first_name>
          <last_name>Piskac</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/~piskac/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ruzicapiskac/5643c034-322b-49cb-9686-ebb925bd37ed/small.jpg</picture_url>
          <person_id>ruzicapiskac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ennan</first_name>
          <last_name>Zhai</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ennanzhai.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ennanzhai/4ab41fb7-50ce-4cde-b173-2b1b7d957b82/small.jpg</picture_url>
          <person_id>ennanzhai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tianyin</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://tianyin.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tianyinxu1/e97e4373-f937-4b16-b4e0-4eec79f5eb77/small.jpg</picture_url>
          <person_id>tianyinxu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dd6ab95d-8b36-48c9-96d4-faedc40bbc87</slot_id>
      <event_id>42d71fb3-b56f-4be5-89c7-9df2b25795da</event_id>
      <title>Dynaplex: Analyzing Program Complexity using Dynamically Inferred Recurrence Relations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:10</end_time>
      <description>Being able to detect program runtime complexity is useful in many tasks (e.g., checking expected performance and identifying potential security vulnerabilities such as DoS attacks and information leakage). In this work, we introduce a new dynamic approach for inferring the asymptotic complexity bounds of recursive programs. From program execution traces, we learn \emph{recurrence relations} and solve them using pattern matching to obtain closed-form solutions representing asymptotic complexity bounds. This approach allows us to efficiently infer simple recurrence relations that represent nontrivial, potentially nonlinear polynomial and non-polynomial, complexity bounds. 
We present Dynaplex, a tool that implements these ideas to automatically generate recurrence relations from execution traces. Our preliminary results on popular and challenging recursive programs show that Dynaplex can learn precise relations capturing worst-case complexity bounds (e.g., $\mathtt{O(n \lg n)}$ for mergesort, $\mathtt{O(2^n)}$ for Tower of Hanoi and $\mathtt{O(n^{1.58})}$ for Karatsuba’s multiplication algorithm).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Didier</first_name>
          <last_name>Ishimwe</last_name>
          <affiliation>University of Nebraska-Lincoln</affiliation>
          <bio>undefined</bio>
          <person_id>didierishimwe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>KimHao</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>University of Nebraska-Lincoln</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ndkimhao.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kimhaonguyen/6a6755d8-13f3-4b86-b4aa-068f378b1ff2/small.jpg</picture_url>
          <person_id>kimhaonguyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>ThanhVu</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>George Mason University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nguyenthanhvuh.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thanhvunguyen/db337089-c863-4086-ad33-88d7dbfeb025/small.jpg</picture_url>
          <person_id>thanhvunguyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>236943f2-f2a7-4e8a-962c-5c1e7c6f70fb</subevent_id>
    <title>SPLASH OOPSLA: Specification Synthesis - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>52220131-aaac-43d0-a6aa-8542c265e505</slot_id>
      <title>Session: SPLASH OOPSLA - Specification Synthesis - mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>194ba4f6-a685-4b76-976e-491813473d1d</slot_id>
      <event_id>42d71fb3-b56f-4be5-89c7-9df2b25795da</event_id>
      <title>Dynaplex: Analyzing Program Complexity using Dynamically Inferred Recurrence Relations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:10</end_time>
      <description>Being able to detect program runtime complexity is useful in many tasks (e.g., checking expected performance and identifying potential security vulnerabilities such as DoS attacks and information leakage). In this work, we introduce a new dynamic approach for inferring the asymptotic complexity bounds of recursive programs. From program execution traces, we learn \emph{recurrence relations} and solve them using pattern matching to obtain closed-form solutions representing asymptotic complexity bounds. This approach allows us to efficiently infer simple recurrence relations that represent nontrivial, potentially nonlinear polynomial and non-polynomial, complexity bounds. 
We present Dynaplex, a tool that implements these ideas to automatically generate recurrence relations from execution traces. Our preliminary results on popular and challenging recursive programs show that Dynaplex can learn precise relations capturing worst-case complexity bounds (e.g., $\mathtt{O(n \lg n)}$ for mergesort, $\mathtt{O(2^n)}$ for Tower of Hanoi and $\mathtt{O(n^{1.58})}$ for Karatsuba’s multiplication algorithm).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Didier</first_name>
          <last_name>Ishimwe</last_name>
          <affiliation>University of Nebraska-Lincoln</affiliation>
          <bio>undefined</bio>
          <person_id>didierishimwe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>KimHao</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>University of Nebraska-Lincoln</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ndkimhao.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kimhaonguyen/6a6755d8-13f3-4b86-b4aa-068f378b1ff2/small.jpg</picture_url>
          <person_id>kimhaonguyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>ThanhVu</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>George Mason University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nguyenthanhvuh.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thanhvunguyen/db337089-c863-4086-ad33-88d7dbfeb025/small.jpg</picture_url>
          <person_id>thanhvunguyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2ef425a3-651d-4aea-bc46-765ba83af2e2</slot_id>
      <event_id>b1cf329e-5f00-41ab-a8ac-2a2f2ba72e9f</event_id>
      <title>Data-Driven Abductive Inference of Library Specifications</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>19:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:50</end_time>
      <description>Programmers often leverage data structure libraries that provide useful and reusable abstractions. Modular verification of programs that make use of these libraries naturally rely on specifications that capture important properties about how the library expects these data structures to be accessed and manipulated. However, these specifications are often missing or incomplete, making it hard for clients to be confident they are using the library safely. When library source code is also unavailable, as is often the case, the challenge to infer meaningful specifications is further exacerbated. In this paper, we present a novel data-driven abductive inference mechanism that infers specifications for library methods sufficient to enable verification of the library’s clients. Our technique combines a data-driven learning-based framework to postulate candidate specifications, along with SMT-provided counterexamples to refine these candidates, taking special care to prevent generating specifications that overfit to sampled tests. The resulting specifications form a minimal set of requirements on the behavior of library implementations that ensures safety of a particular client program. Our solution thus provides a new multi-abduction procedure for precise specification inference of data structure libraries guided by client-side verification tasks. Experimental results on a wide range of realistic OCaml data structure programs demonstrate the effectiveness of the approach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhe</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhezhou/278a17cb-759b-46f2-98ca-6cb67f839b0b/small.jpg</picture_url>
          <person_id>zhezhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robert</first_name>
          <last_name>Dickerson</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://robd.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/robertdickerson/e65391dc-1815-4ecc-b58f-6afd1e1ac81d/small.jpg</picture_url>
          <person_id>robertdickerson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Delaware</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/bendy/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benjamindelaware/39bbf6b3-d145-435c-8956-8acf8cfcaffa/small.jpg</picture_url>
          <person_id>benjamindelaware</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Suresh</first_name>
          <last_name>Jagannathan</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/suresh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sureshjagannathan/70e51299-573f-4211-a895-b2028c19c585/small.jpg</picture_url>
          <person_id>sureshjagannathan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5064775f-2f20-4d96-882f-35009d1c7cfd</slot_id>
      <event_id>63e652b6-5919-48e6-b8bb-c7ed0009804e</event_id>
      <title>Static Detection of Silent Misconfigurations with Deep Interaction Analysis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>19:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:30</end_time>
      <description>The behavior of large systems is guided by their configurations: users set parameters in the configuration file to dictate which corresponding part of the system code is executed. However, it is often the case that, although some parameters are set in the configuration file, they do not influence the system runtime behavior, thus failing to meet the user’s intent. Moreover, such misconfigurations rarely lead to an error message or raising an exception. We introduce the notion of silent misconfigurations which are prohibitively hard to identify due to (1) lack of feedback and (2) complex interactions between configurations and code. 
This paper presents ConfigX, the first tool for the detection of silent configurations. The main challenge is to understand complex interactions between configuration and the code that is affected by them. Our goal is to derive a specification describing non-trivial dependencies between the configuration parameters that lead to silent misconfigurations. To this end, ConfigX uses static analysis to determine which parts of the system code are associated with configuration parameters. ConfigX then infers the connections between configuration parameters by analyzing their associated code blocks. We design customized control- and data-flow analysis to derive a specification of configurations. Additionally, we conduct reachability analysis to eliminate spurious rules to reduce false positives. Upon evaluation on five real-world datasets across three widely-used systems, Apache, vsftpd, and PostgreSQL, ConfigX detected more than 2200 silent misconfigurations. We additionally conducted a user study where we ran ConfigX on misconfigurations reported on user forums by real-world users. ConfigX easily detected issues and suggested a repair for those misconfigurations. Our solutions were accepted and confirmed in the interaction with the users, who originally posted the problems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jialu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jialuzhang/7427a686-f97e-42da-9f0b-4b94122d30f3/small.jpg</picture_url>
          <person_id>jialuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ruzica</first_name>
          <last_name>Piskac</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/~piskac/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ruzicapiskac/5643c034-322b-49cb-9686-ebb925bd37ed/small.jpg</picture_url>
          <person_id>ruzicapiskac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ennan</first_name>
          <last_name>Zhai</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ennanzhai.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ennanzhai/4ab41fb7-50ce-4cde-b173-2b1b7d957b82/small.jpg</picture_url>
          <person_id>ennanzhai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tianyin</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://tianyin.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tianyinxu1/e97e4373-f937-4b16-b4e0-4eec79f5eb77/small.jpg</picture_url>
          <person_id>tianyinxu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d218b998-8b89-4171-8f8b-defb0b966c5a</slot_id>
      <event_id>f48451af-33ee-4d30-9177-5142a5caec22</event_id>
      <title>Synthesizing Contracts Correct Modulo a Test Generator</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>20:10</end_time>
      <description>We present an approach that learns contracts for object-oriented programs where guarantees of correctness of the contracts are made with respect to a test generator. Our contract synthesis approach is based on a novel notion of tight contracts and an online learning algorithm (for tight contracts) that works in tandem with a test generator. We implement our approach and evaluate it on a suite of programs written in C#, studying the safety and strength of the synthesized contracts, and compare them to those synthesized by Daikon.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Angello</first_name>
          <last_name>Astorga</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>angelloastorga1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shambwaditya</first_name>
          <last_name>Saha</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <person_id>shambwadityasaha2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ahmad</first_name>
          <last_name>Dinkins</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>ahmaddinkins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Felicia</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>feliciawang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>P.</first_name>
          <last_name>Madhusudan</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://madhu.cs.illinois.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/pmadhusudan/3775a90b-eb5d-4825-86d8-2a91a1e68fdf/small.jpg</picture_url>
          <person_id>pmadhusudan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tao</first_name>
          <last_name>Xie</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://taoxiease.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/taoxie/14ae8022-1dd6-4455-a54f-157c86bc406d/small.jpg</picture_url>
          <person_id>taoxie</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>78c4f22f-a120-458a-b749-ea736ff4baac</subevent_id>
    <title>SPLASH OOPSLA: Rust - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>4426a3c5-f277-4432-a3f8-6e68112cefb0</slot_id>
      <title>Session: SPLASH OOPSLA - Rust - mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2b10682a-4fbd-4356-b979-f252f2242b78</slot_id>
      <event_id>9c148540-5a2f-4370-b1e1-f409b281e5e6</event_id>
      <title>Modular Specification and Verification of Closures in Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>22:16</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:43</end_time>
      <description>Closures are a language feature supported by many mainstream languages, combining the ability to package up references to code blocks with the possibility of capturing state from the environment of the closure’s declaration. Closures are powerful, but complicate understanding and formal reasoning, especially when closure invocations may mutate objects reachable from the captured state or from closure arguments. This paper presents a novel technique for the modular specification and verification of closure-manipulating code in Rust. Our technique combines Rust’s type system guarantees and novel specification features to enable formal verification of rich functional properties. It encodes higher-order concerns into a first-order logic, which enables automation via SMT solvers. Our technique is implemented as an extension of the deductive verifier Prusti, with which we have successfully verified many common idioms of closure usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabian</first_name>
          <last_name>Wolff</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>fabianwolff</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aurel</first_name>
          <last_name>Bílý</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>aurelbily</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Matheja</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christophmatheja1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alexander J.</first_name>
          <last_name>Summers</last_name>
          <affiliation>University of British Columbia (UBC)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.ubc.ca/~alexsumm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexanderjsummers/f97b84a8-d46a-4e76-aa73-cc4b38c4ec41/small.jpg</picture_url>
          <person_id>alexanderjsummers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ce87d881-8816-4528-b38c-8bde1cff7227</slot_id>
      <event_id>d6067c7f-9230-454c-9672-66c980a2da21</event_id>
      <title>Safer at Any Speed: Automatic Context-Aware Safety Enhancement for Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>22:43</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>23:10</end_time>
      <description>Type-safe languages improve application safety by eliminating whole classes of vulnerabilities, such as buffer overflows, by construction. But safety sometimes comes at a cost. As a result, modern type-safe languages often provide escape hatches that allow developers to manually bypass dynamic safety checks in hopes of improving performance. However, this requires applications to implicitly inherit whatever performance vs. safety trade-offs are made in libraries they depend on. Without knowing the importance of safety to each application, their performance requirements, the compiler used, or the hardware upon which applications will run, library developers have no hope of navigating such trade-offs appropriately for all cases. We find that in the Rust ecosystem, library developers have given up type safety in at least 10% of the 500 most downloaded packages in exchange for very little or no performance gains in many contexts. We present NADER, a Rust development tool that makes applications safer by automatically transforming unsafe code into equivalent safe code according to developer preferences and application context. In an end-to-end system evaluation, NADER automatically reintroduces dozens of bounds checks with no performance loss.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Natalie</first_name>
          <last_name>Popescu</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.princeton.edu/~npopescu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nataliepopescu1/7e11a54e-61c9-49bc-bc69-07f19db73a1b/small.jpg</picture_url>
          <person_id>nataliepopescu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ziyang</first_name>
          <last_name>Xu</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.princeton.edu/~ziyangx/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ziyangxu/4d095217-b7d0-4159-9508-7cae73aa6bf5/small.jpg</picture_url>
          <person_id>ziyangxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sotiris</first_name>
          <last_name>Apostolakis</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sapostolakis.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sotirisapostolakis/538416ca-ec5a-4441-b330-832a65a0bac2/small.jpg</picture_url>
          <person_id>sotirisapostolakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>David I.</first_name>
          <last_name>August</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>davidiaugust</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Amit</first_name>
          <last_name>Levy</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>amitlevy</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f71c2a8a-9b05-4dfa-9700-93468edaebca</slot_id>
      <event_id>66f57c5c-e9da-44bf-9914-726337159123</event_id>
      <title>Translating C to Safer Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:16</end_time>
      <description>Rust is a relatively new programming language that targets efficient and safe systems-level applications. It includes a sophisticated type system that allows for provable memory- and thread-safety, and is explicitly designed to take the place of unsafe languages such as C and C++ in the coding ecosystem. There is a large existing C and C++ codebase (many of which have been affected by bugs and security vulnerabilities due to unsafety) that would benefit from being rewritten in Rust to remove an entire class of potential bugs. However, porting these applications to Rust manually is a daunting task. 
In this paper we investigate the problem of automatically translating C programs into safer Rust programs—that is, Rust programs that improve on the safety guarantees of the original C programs. We conduct an in-depth study into the underlying causes of unsafety in translated programs and the relative impact of fixing each cause. We also describe a novel technique for automatically removing a particular cause of unsafety and evaluate its effectiveness and impact. This paper presents the first empirical study of unsafety in translated Rust programs (as opposed to programs originally written in Rust) and also the first technique for automatically removing causes of unsafety in translated Rust programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mehmet</first_name>
          <last_name>Emre</last_name>
          <affiliation>University of California, Santa Barbara</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.ucsb.edu/~emre</homepage_url>
          <person_id>mehmetemre</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Schroeder</last_name>
          <affiliation>University of California, Santa Barbara</affiliation>
          <bio>undefined</bio>
          <person_id>ryanschroeder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kyle</first_name>
          <last_name>Dewey</last_name>
          <affiliation>California State University, Northridge</affiliation>
          <bio>undefined</bio>
          <person_id>kyledewey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ben</first_name>
          <last_name>Hardekopf</last_name>
          <affiliation>UC Santa Barbara</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.cs.ucsb.edu/~benh</homepage_url>
          <person_id>benhardekopf</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3a487e5d-273f-4588-aaf2-e29980f4aae3</subevent_id>
    <title>SPLASH OOPSLA: Dynamic Languages - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9c1678ac-f9f3-4394-bb5f-dcf6d2c8a157</slot_id>
      <title>Session: SPLASH OOPSLA - Dynamic Languages - mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0e5a6053-2b81-491c-bebf-6cf3542912bc</slot_id>
      <event_id>27a5d755-7c49-43c3-aea7-317ade9e584c</event_id>
      <title>SimTyper: Sound Type Inference for Ruby using Type Equality Prediction</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>19:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:30</end_time>
      <description>Many researchers have explored type inference for dynamic languages. However, traditional type inference computes most general types which, for complex type systems—which are often needed to type dynamic languages—can be verbose, complex, and difficult to understand. In this paper, we introduce SimTyper, a Ruby type inference system that aims to infer \emph{usable} types—specifically, nominal and generic types—that match the types programmers write. SimTyper builds on InferDL, a recent Ruby type inference system that soundly combines standard type inference with heuristics. The key novelty of SimTyper is \emph{type equality prediction}, a new, machine learning-based technique that predicts when method arguments or returns are likely to have the same type. SimTyper finds pairs of positions that are predicted to have the same type yet one has a verbose, overly general solution and the other has a usable solution. It then guesses the two types are equal, keeping the guess if it is consistent with the rest of the program, and discarding it if not. In this way, types inferred by SimTyper are guaranteed to be sound. Type equality prediction is performed by a \emph{deep similarity} (DeepSim) neural network, which follows the Siamese network architecture, and uses CodeBERT, a pre-trained model, to embed source tokens into vectors that capture tokens and their contexts. DeepSim is trained on 100,000 pairs labeled with type similarity information extracted from 371 Ruby programs with manually documented, but not checked, types. We evaluated SimTyper on eight Ruby programs and found that, compared to standard type inference, SimTyper finds 71% more types that match programmer-written type information. Moreover, DeepSim can predict rare types that appear neither in the Ruby standard library nor in the training data. Our results show that type equality prediction can help type inference systems effectively produce more usable types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milod</first_name>
          <last_name>Kazerounian</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>undefined</bio>
          <person_id>milodkazerounian1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeffrey S.</first_name>
          <last_name>Foster</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.tufts.edu/~jfoster/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeffreysfoster/b22ce952-32b0-48bd-be56-12fd87bf3469/small.jpg</picture_url>
          <person_id>jeffreysfoster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bonan</first_name>
          <last_name>Min</last_name>
          <affiliation>Raytheon BBN Technologies</affiliation>
          <bio>undefined</bio>
          <person_id>bonanmin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2a85541-d295-44d6-b217-beb5eeb3602a</slot_id>
      <event_id>4a141d82-81f5-4f25-b5aa-659e52e64f49</event_id>
      <title>Solver-based Gradual Type Migration</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>20:10</end_time>
      <description>Gradually typed languages allow programmers to mix statically and dynamically typed code, enabling them to incrementally reap the benefits of static typing as they add type annotations to their code. However, this type migration process is typically a manual effort with limited tool support. This paper examines the problem of automated type migration: given a dynamic program, infer additional or improved type annotations. 
Existing type migration algorithms prioritize different goals, such as maximizing type precision, maintaining compatibility with unmigrated code, and preserving the semantics of the original program. We argue that the type migration problem involves fundamental compromises: optimizing for a single goal often comes at the expense of others. Ideally, a type migration tool would flexibly accommodate a range of user priorities. 
We present TypeWhich, a new approach to automated type migration for an extension of the gradually-typed lambda calculus. Unlike prior work, which relies on custom solvers, TypeWhich produces constraints that can be solved by an off-the-shelf MaxSMT solver. This allows us to easily express objectives, such as minimizing the number of necessary syntactic coercions, and constraining the type of the migration to be compatible with unmigrated code. 
We present the first comprehensive evaluation of GTLC type migration algorithms, and compare TypeWhich to four other tools from the literature. Our evaluation uses prior benchmarks, and a new set of ``challenge problems''. Moreover, we design a new evaluation methodology that highlights the subtleties of gradual type migration. In addition, we apply TypeWhich to a suite of benchmarks for Grift, a programming language based on the GTLC. TypeWhich is able to reconstruct all human-written annotations on all but one program.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luna</first_name>
          <last_name>Phipps-Costin</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>undefined</bio>
          <person_id>lunaphippscostin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carolyn</first_name>
          <last_name>Anderson</last_name>
          <affiliation>Wellesley College</affiliation>
          <bio>undefined</bio>
          <person_id>carolynanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mgree.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d2b4b59b-5211-49b6-b6ad-d13a77487cbc</slot_id>
      <event_id>499d1ade-0a8a-4045-884c-ebba85519ad6</event_id>
      <title>Gradually Structured Data</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>19:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:50</end_time>
      <description>Dynamically-typed languages offer easy interaction with ad hoc data such as JSON and S-expressions; statically-typed languages offer powerful tools for working with structured data, notably \emph{algebraic datatypes}, which are a core feature of typed functional languages such as OCaml and Haskell, or otherwise such as Scala and Rust. Gradual typing aims to reconcile dynamic and static typing smoothly. The gradual typing literature has extensively focused on the computational aspect of types, such as type safety, effects, noninterference, or parametricity, but the application of graduality to data structuring mechanisms has been much less explored. While row polymorphism and set-theoretic types have been studied in the context of gradual typing, algebraic datatypes in particular have not, which is surprising considering their wide use in practice. We develop, formalize and prototype a novel approach to gradually structured data with algebraic datatypes. Gradually structured data bridges the gap between traditional algebraic datatypes and flexible data management mechanisms such as tagged data in dynamic languages, or polymorphic variants in OCaml. We illustrate the key ideas of gradual algebraic datatypes through the evolution of a small server application from dynamic to progressively more static checking, formalize a core functional language with gradually structured data, and establish its metatheory, including the gradual guarantees.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Malewski</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefanmalewski/cb42d4d7-af16-4e9d-b2a4-b8ce774834d7/small.jpg</picture_url>
          <person_id>stefanmalewski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mgree.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f40d4a27-a7fc-4db3-95b9-eb1d27be708f</slot_id>
      <event_id>05e9115b-0577-4202-ab11-ae1224cdc112</event_id>
      <title>Promises Are Made to be Broken</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:10</end_time>
      <description>Function calls in the R language do not evaluate their arguments; these are passed to the callee as suspended computations and only evaluated if needed. After 25 years of experience with the language, there are very few cases where programmers leverage delayed evaluation intentionally. Yet, being lazy comes at a price in performance and complexity. This paper explores how to evolve the semantics of the language towards strictness by default and laziness on demand. To provide a migration path, it is necessary to change the semantics of the language and provide tooling for developers to migrate libraries and user code without introducing errors. This paper reports on a dynamic analysis that infers strictness signatures for functions to capture both intentional and accidental laziness. To assess the robustness of the inferred signatures we tested them on 2,000 R packages and found that inference was wrong in only 0.56% of the client programs. Finally, we report on the potential for performance improvements due to strictness. By modifying a just-in-time compiler to remove promises, we achieved an average speedup of 1.17X.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Ječmen</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <person_id>janjecmen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sebastián</first_name>
          <last_name>Krynski</last_name>
          <affiliation>Czech Technical University in Prague</affiliation>
          <bio>undefined</bio>
          <person_id>sebastiankrynski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>768261ce-817a-4a1c-abcb-a4523fbe5a6e</subevent_id>
    <title>SPLASH OOPSLA: Distributed Programming</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>7a9afbef-474e-461c-b42b-1cd532310a47</slot_id>
      <title>Session: SPLASH OOPSLA - Distributed Programming</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>02f67968-297b-443a-92e4-76b442960122</slot_id>
      <event_id>740c257f-f41f-4619-8c89-49e2da972d1d</event_id>
      <title>Automatic Migration from Synchronous to Asynchronous JavaScript APIs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:40</end_time>
      <description>The JavaScript ecosystem provides equivalent synchronous and asynchronous Application Programming Interfaces (APIs) for many commonly used I/O operations. Synchronous APIs involve straightforward sequential control flow that makes them easy to use and understand, but their “blocking” behavior may result in poor responsiveness or performance. Asynchronous APIs impose a higher syntactic burden that relies on callbacks, promises, and higher-order functions. On the other hand, their nonblocking behavior enables applications to scale better and remain responsive while I/O requests are being processed. While it is generally understood that asynchronous APIs have better performance characteristics, many applications still rely on synchronous APIs. In this paper, we present a refactoring technique for assisting programmers with the migration from synchronous to asynchronous APIs. The technique relies on static analysis to determine where calls to synchronous API functions can be replaced with their asynchronous counterparts, relying on JavaScript’s async/await feature to minimize disruption to the source code. Since the static analysis is potentially unsound, the proposed refactorings are presented as suggestions that must be reviewed and confirmed by the programmer. The technique was implemented in a tool named Desynchronizer. In an empirical evaluation on 12 subject applications containing 316 synchronous API calls, Desynchronizer identified 256 of these as candidates for refactoring. Of these candidates, 244 were transformed successfully, and only 12 resulted in behavioral changes. Further inspection of these cases revealed that the majority of these issues can be attributed to unsoundness in the call graph.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Satyajit</first_name>
          <last_name>Gokhale</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <person_id>satyajitgokhale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexi</first_name>
          <last_name>Turcotte</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://reallytg.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexiturcotte/6881a0a0-5145-40cb-aab4-ff41754a0640/small.jpg</picture_url>
          <person_id>alexiturcotte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Tip</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Frank Tip is a Professor and Associate Dean for Graduate Programs at Northeastern University. Previously, he was a Senior Principal Engineer at Samsung Research America in Mountain View, California (2014-2016), a Professor and Cheriton Research Chair in the David R. Cheriton School of Computer Science at the University of Waterloo (2012-2014), and a Research Staff Member and Manager at the Software Technology Department at the IBM T.J. Watson Research Center (1995-2012). He received his PhD in 1995 from the University of Amsterdam.</bio>
          <homepage_url>http://www.franktip.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/franktip/b4b4c804-cf32-45fa-afc8-3058f718b160/small.jpg</picture_url>
          <person_id>franktip</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>13e72224-47cf-4644-a43c-ac7678d02864</slot_id>
      <event_id>2c375f32-8c80-4300-b328-20661ab229e4</event_id>
      <title>Much ADO about Failures: A Fault-Aware Model for Compositional Verification of Strongly Consistent Distributed Systems</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:00</end_time>
      <description>Despite recent advances, guaranteeing the correctness of large-scale distributed applications without compromising performance remains a challenging problem. Network and node failures are inevitable and, for some applications, careful control over how they are handled is essential. Unfortunately, existing approaches either completely hide these failures behind an atomic state machine replication (SMR) interface, or expose all of the network-level details, sacrificing atomicity. We propose a novel, compositional, atomic distributed object (ADO) model for strongly consistent distributed systems that combines the best of both options. The object-oriented API abstracts over protocol-specific details and decouples high-level correctness reasoning from implementation choices. At the same time, it intentionally exposes an abstract view of certain key distributed failure cases, thus allowing for more fine-grained control over them than SMR-like models. We demonstrate that proving properties even of composite distributed systems can be straightforward with our Coq verification framework, Advert, thanks to the ADO model. We also show that a variety of common protocols including multi-Paxos and Chain Replication refine the ADO semantics, which allows one to freely choose among them for an application’s implementation without modifying ADO-level correctness proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wolf</first_name>
          <last_name>Honore</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <person_id>wolfhonore</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jieung</first_name>
          <last_name>Kim</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/jkim</homepage_url>
          <person_id>jieungkim</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ji-Yong</first_name>
          <last_name>Shin</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.jiyongshin.info</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jiyongshin/887e7089-7e73-4b28-8c02-9dc79624fe5d/small.jpg</picture_url>
          <person_id>jiyongshin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
          <person_id>zhongshao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6fd1f1cf-d08b-4cf8-802c-ea32e99eb5c8</slot_id>
      <event_id>cdc5b0cb-32bc-47df-a54d-5dd5e4516932</event_id>
      <title>QuickSilver: Modeling and Parameterized Verification for Distributed Agreement-Based Systems</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>17:00</end_time>
      <description>The last decade has sparked several valiant efforts in deductive verification of distributed agreement protocols such as consensus and leader election. Oddly, there have been far fewer verification efforts that go beyond the core protocols and target applications that are built on top of agreement protocols. This is unfortunate, as agreement-based distributed services such as data stores, locks, and ledgers are ubiquitous and potentially permit modular, scalable verification approaches that mimic their modular design. 
We address this need for verification of distributed agreement-based systems through our novel modeling and verification framework, QuickSilver, that is not only modular, but also fully automated. The key enabling feature of QuickSilver is our encoding of abstractions of verified agreement protocols that facilitates modular, decidable, and scalable automated verification. We demonstrate the potential of QuickSilver by modeling and efficiently verifying a series of tricky case studies, adapted from real-world applications, such as a data store, a lock service, a surveillance system, a pathfinding algorithm for mobile robots, and more.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nouraldin</first_name>
          <last_name>Jaber</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/nouraldinjaber/0aeeca1f-ae9b-4220-85ef-02510d406a10/small.jpg</picture_url>
          <person_id>nouraldinjaber</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christopher</first_name>
          <last_name>Wagner</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>christopherwagner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Swen</first_name>
          <last_name>Jacobs</last_name>
          <affiliation>CISPA Helmholtz Center for Information Security</affiliation>
          <bio>undefined</bio>
          <person_id>swenjacobs1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University. 
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures. 
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University. I received an NSF CAREER Award in 2012, a Department of Energy Early Career Research Award in 2013, and the Presidential Early Career Award for Scientists and Engineers in 2016.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
          <person_id>milindkulkarni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Roopsha</first_name>
          <last_name>Samanta</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/roopsha/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/roopshasamanta/3d74f41a-6adb-447b-8426-4a7fd9079dd4/small.jpg</picture_url>
          <person_id>roopshasamanta</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>de4d210a-6a98-4e20-bc06-f4e4ee9b0023</slot_id>
      <event_id>62c941e0-1d73-41ab-b192-9220506f2589</event_id>
      <title>A Multiparty Session Typing Discipline for Fault-tolerant Event-driven Distributed Programming</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:20</end_time>
      <description>Correctly designing and implementing distributed systems software is notoriously difficult. Multiparty session types (MPSTs) is a typing discipline for concurrent processes that statically ensures properties such as freedom from message reception errors and deadlocks. The existing approaches in MPSTs cannot, however, be applied to a significant class of real-world distributed systems because they do not support practical specification and verification of protocols that handle and recover from partial failures. 
This paper presents the first formulation of MPSTs for practical fault-tolerant distributed programming. We tackle the long-standing challenges faced by session types in this context: bringing structure to communication patterns involving asynchronous and concurrent partial failures, and integrating the range of features required to express fault-tolerant protocols in practice, that involve dynamic replacement of failed parties and retrying failed protocol segments in the presence of imperfect failure detection. Key to our approach is that we develop the first model of event-driven concurrency for multiparty sessions, to unify the session-typed handling of failures and regular I/O events. Moreover, the characteristics of our model allow us to prove a global progress property for well-typed processes engaged in multiple concurrent sessions, which does not hold in traditional MPST systems. To demonstrate its practicality, we implement our approach as a toolchain for Scala, and use it to specify and implement a session-typed version of the cluster manager (CM) system of the widely employed Apache Spark data analytics engine. Our session-typed CM integrates with the other vanilla Spark components to give a functioning Spark runtime; e.g., it can execute existing third-party Spark applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Malte</first_name>
          <last_name>Viering</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>malteviering</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>University of Hertfordshire</affiliation>
          <bio>undefined</bio>
          <person_id>raymondhu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Eugster</last_name>
          <affiliation>USI Lugano &amp; Purdue University</affiliation>
          <bio>Patrick Eugster joined USI as a Full Professor of Computer Science in 2017, where he leads the SWYSTEMS (Software Systems) group, and co-founded the Computer Systems Institute in 2020. Prior to that he was a regular faculty member at TU Darmstadt (2014-2017) and Purdue University (2005-2016) where he remains an adjunct faculty member. Patrick holds M.S. (1998) and Ph.D. (2001) degrees from EPFL. 
Patrick is interested in software systems, with a particular focus on distributed systems and programming models/languages, and the intersection between the two. He has co-authored over 150 scientific articles on these topics. His research has been awarded by various funding agencies (e.g., NSF CAREER 2007, DARPA Computer Science Study Group 2011, ERC Consolidator 2014) and companies (e.g., Google Research Award 2003, NetApp Faculty Fellowship 2014, Facebook Research Award 2020). Patrick had the privilege to act as program chair of ACM OOPSLA 2015 and is currently serving as associate editor for IEEE Transactions on Software Engineering.</bio>
          <homepage_url>https://www.inf.usi.ch/faculty/eugstp/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/patrickeugster/bf8c955c-8902-4678-8c57-4b75cbd4f3c0/small.jpg</picture_url>
          <person_id>patrickeugster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lukasz</first_name>
          <last_name>Ziarek</last_name>
          <affiliation>SUNY Buffalo, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.buffalo.edu/~lziarek/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lukaszziarek/78ff4fd0-ef3b-4aed-ba86-2d6e66f85f65/small.jpg</picture_url>
          <person_id>lukaszziarek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>14e681a9-7ea3-49fa-b190-74aec050364c</subevent_id>
    <title>SPLASH OOPSLA: Implementation of special Paradigms - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>688199a3-e3ee-4326-b3c9-f8e197a9aada</slot_id>
      <title>Session: SPLASH OOPSLA - Implementation of special Paradigms - mirror</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>38e4c8a6-c3a6-4e90-a9ea-b56666cc0809</slot_id>
      <event_id>a9b6a816-8bad-42e4-8254-5769ef450530</event_id>
      <title>Statically Bounded-Memory Delayed Sampling for Probabilistic Streams</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>22:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:30</end_time>
      <description>\emph{Probabilistic programming languages} aid developers performing Bayesian inference. These languages provide programming constructs and tools for probabilistic modeling and automating the process of developing a probabilistic inference procedure. Prior work introduced a probabilistic programming language, ProbZelus, to extend probabilistic programming functionality to unbounded streams of data. A key innovation of ProbZelus was to demonstrate that the \emph{delayed sampling} inference algorithm could be extended to work in a streaming context. ProbZelus showed that while delayed sampling could be effectively deployed on some programs, depending on the probabilistic model under consideration, delayed sampling is not guaranteed to use a bounded amount of memory over the course of the execution of the program. 
In this paper, we the present conditions on a probabilistic program’s execution under which delayed sampling will execute in bounded memory. The two conditions are dataflow properties of the core operations of delayed sampling: the \emph{$m$-consumed property} and \emph{the unseparated path property}. A program executes in bounded memory under delayed sampling if, and only if, it satisfies the $m$-consumed and unseparated path properties. We propose a static analysis that abstracts over these properties to soundly ensure that any program that passes the analysis satisfies these properties, and thus executes in bounded memory under delayed sampling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Baudart</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <person_id>guillaumebaudart1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM T.J. Watson Research Center</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charles</first_name>
          <last_name>Yuan</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>charlesyuan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3b47ca11-e388-42ab-87b1-98d7ab5f96b5</slot_id>
      <event_id>dfc8e21a-b4fb-4095-9b67-790f96f35c7b</event_id>
      <title>Coarsening Optimization for Differentiable Programming</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>23:10</end_time>
      <description>This paper presents a novel optimization for differentiable programming named coarsening optimization. It offers a systematic way to synergize symbolic differentiation and algorithmic differentiation (AD). Through it, the granularity of the computations differentiated by each step in AD can become much larger than a single operation, and hence lead to much reduced runtime computations and data allocations in AD. To circumvent the difficulties that control flow creates to symbolic differentiation in coarsening, this work introduces $\phi$-calculus, a novel method to allow symbolic reasoning and differentiation of computations that involve branches and loops. It further avoids “expression swell” in symbolic differentiation and balance reuse and coarsening through the design of reuse-centric segment of interest(SOI) identification. Experiments on a collection of real-world applications show that coarsening optimization is effective in speeding up AD, producing several times to an order of magnitude speedups.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xipeng</first_name>
          <last_name>Shen</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>Xipeng Shen is an associate professor at the Computer Science Department, North Carolina State University (NCSU). He is a receipt of NSF CAREER Award, DOE Early Career Award, and Google Faculty Research Award. He is an ACM Distinguished Speaker, and a senior member of IEEE. Prior to joining NC State in 2014, Shen was the Adina Allen Term Distinguished Associate Professor at The College of William and Mary. He had served as a consultant to Intel Labs and Cisco, and a Visiting Researcher at MIT and Microsoft Research. He received his Ph.D. in Computer Science from University of Rochester in 2006.</bio>
          <homepage_url>http://people.engr.ncsu.edu/xshen5/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xipengshen/7ba54e69-f90a-4cf7-90d2-19fdd5f42e87/small.jpg</picture_url>
          <person_id>xipengshen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guoqiang</first_name>
          <last_name>Zhang</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
          <person_id>guoqiangzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Irene</first_name>
          <last_name>Dea</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>irenedea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Samantha</first_name>
          <last_name>Andow</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>samanthaandow</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Emilio</first_name>
          <last_name>Arroyo-Fang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>emilioarroyofang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ac1321ed-36d1-47cd-9645-d9ac353482cd</slot_id>
      <event_id>2a3bd10f-d88a-4ac7-b023-0ee9946d5e84</event_id>
      <title>Compilation of Sparse Array Programming Models</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:10</end_time>
      <description>This paper shows how to compile sparse array programming languages. A sparse array programming language is an array programming language that supports element-wise application, reduction, and broadcasting of arbitrary functions over dense and sparse arrays with any fill value. Such a language has great expressive power and can express sparse and dense linear and tensor algebra, functions over images, exclusion and inclusion filters, and even graph algorithms. 
Our compiler strategy generalizes prior work in the literature on sparse tensor algebra compilation to support any function applied to sparse arrays, instead of only addition and multiplication. To achieve this, we generalize the notion of sparse iteration spaces beyond intersections and unions. These iteration spaces are automatically derived by considering how algebraic properties annotated onto functions interact with the fill values of the arrays. We then show how to compile these iteration spaces to efficient code. 
When compared with two widely-used Python sparse array packages, our evaluation shows that we generate built-in sparse array library features with a performance of 1.4$\times$ to 53.7$\times$ when measured against PyData/Sparse for user-defined functions and between 0.98$\times$ and 5.53$\times$ when measured against SciPy/Sparse for array slicing. Our technique outperforms PyData/Sparse by 6.58$\times$ to 70.3$\times$, and (where applicable) performs between 0.96$\times$ and 28.9$\times$ that of a dense NumPy implementation, on end-to-end sparse array applications. We also implement graph linear algebra kernels in our system with a performance of between 0.56$\times$ and 3.50$\times$ compared to that of the hand-optimized SuiteSparse:GraphBLAS library.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rawn</first_name>
          <last_name>Henry</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>rawnhenry</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivia</first_name>
          <last_name>Hsu</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>oliviahsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rohan</first_name>
          <last_name>Yadav</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>rohanyadav1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Kunle</first_name>
          <last_name>Olukotun</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arsenalfc.stanford.edu/kunle</homepage_url>
          <person_id>kunleolukotun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>samanamarsinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>baf51c60-e0c3-49fb-addd-8f62acf90a5a</slot_id>
      <event_id>aac8ee13-0cef-4d91-b60c-f029b7f08587</event_id>
      <title>Efficient Automatic Scheduling of Imaging &amp; Vision Pipelines for the GPU</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>22:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:50</end_time>
      <description>We present a new algorithm to quickly generate high-performance GPU implementations of complex imaging and vision pipelines, directly from high-level Halide algorithm code. It is fully automatic, requiring no schedule templates or hand-optimized kernels. We address the scalability challenge of extending search-based automatic scheduling to map large real-world programs to the deep hierarchies of memory and parallelism on GPU architectures in reasonable compile time. We achieve this using (1) a two-phase search algorithm that first ‘freezes’ decisions for the lowest cost sections of a program, allowing relatively more time to be spent on the important stages, (2) a hierarchical sampling strategy that groups schedules based on their structural similarity, then samples representatives to be evaluated, allowing us to explore a large space with few samples, and (3) memoization of repeated partial schedules, amortizing their cost over all their occurrences. We guide the process with an efficient cost model combining machine learning, program analysis, and GPU architecture knowledge. We evaluate our method’s performance on a diverse suite of real-world imaging and vision pipelines. Our scalability optimizations lead to average compile time speedups of 49x (up to 530x). We find schedules that are on average 1.7x faster than existing automatic solutions (up to 5x), and competitive with what the best human experts were able to achieve in an active effort to beat our automatic results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luke</first_name>
          <last_name>Anderson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>lukeanderson1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Adams</last_name>
          <affiliation>Adobe</affiliation>
          <bio>undefined</bio>
          <person_id>andrewadams</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Karima</first_name>
          <last_name>Ma</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>karimama1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tzu-Mao</first_name>
          <last_name>Li</last_name>
          <affiliation>UC San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~tzli/</homepage_url>
          <person_id>tzumaoli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tian</first_name>
          <last_name>Jin</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>tianjin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Ragan-Kelley</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>Assistant Professor of Computer Science</bio>
          <homepage_url>https://people.csail.mit.edu/jrk</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanragankelley/1b837cf9-1002-4ab3-8bfc-fdf6708db7e1/small.jpg</picture_url>
          <person_id>jonathanragankelley</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f27d91c7-6da9-4bd9-b07d-9b61b11e532c</subevent_id>
    <title>SPLASH OOPSLA: Functional Programming</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>05e4b6e7-b27b-4575-97a3-f1c007c5a29a</slot_id>
      <title>Session: SPLASH OOPSLA - Functional Programming</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0c00b2be-ccdc-48f6-be5a-d8a2a3a8c0f4</slot_id>
      <event_id>7e72ede0-84a8-45df-97b4-f2b728e7a48d</event_id>
      <title>Compiling with Continuations, Correctly</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:10</end_time>
      <description>In this paper we present a novel simulation relation for proving correctness of program transformations that combines syntactic simulations and logical relations. In particular, we establish a new kind of simulation diagram that uses a small-step or big-step semantics in the source language and an untyped, step-indexed logical relation in the target language. Our technique provides a practical solution for proving semantics preservation for transformations that do not preserve reductions in the source language. This is common when transformations generate new binder names, and hence $\alpha$-conversion must be explicitly accounted for, or when transformations introduce administrative redexes. Our technique does not require reductions in the source language to correspond directly to reductions in the target language. Instead, we enforce a weaker notion of semantic preorder, which suffices to show that semantics are preserved for both whole-program and separate compilation. Because our logical relation is transitive, we can transition between intermediate program states in a small-step fashion and hence the shape of the proof resembles that of a simple small-step simulation. 
We use this technique to revisit the semantic correctness of a continuation-passing style (CPS) transformation and we demonstrate how it allows us to overcome well-known complications of this proof related to $\alpha$-conversion and administrative reductions. In addition, by using a logical relation that is indexed by invariants that relate the resource consumption of two programs, we are able show that the transformation preserves diverging behaviors and that our CPS transformation asymptotically preserves the running time of the source program. 
Our results are formalized in the Coq proof assistant. Our continuation-passing style transformation is part of the CertiCoq compiler for Gallina, the specification language of Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zoe</first_name>
          <last_name>Paraskevopoulou</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zoep.github.io/</homepage_url>
          <person_id>zoeparaskevopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anvay</first_name>
          <last_name>Grover</last_name>
          <affiliation>University of Wisconsin–Madison</affiliation>
          <bio>undefined</bio>
          <person_id>anvaygrover</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>15bbe8cb-08f4-4c63-a3f6-ce9ae9f29b37</slot_id>
      <event_id>f0e509f9-0fba-48ca-8b45-d1c318f1c895</event_id>
      <title>Reachability Types: Tracking Aliasing and Separation in Higher-Order Functional Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:50</end_time>
      <description>Ownership type systems, based on the idea of enforcing unique access paths, have been primarily focused on objects and top-level classes. However, existing models do not as readily reflect the finer aspects of nested lexical scopes, capturing, or escaping closures in higher-order functional programming patterns, which are increasingly adopted even in mainstream OO languages. We present a new type system, $\lambda^{\ast}$, which enables expressive ownership-style reasoning across higher-order functions. It tracks sharing and separation through reachability sets, and layers additional mechanisms for selectively enforcing uniqueness on top of it. Based on reachability sets, we extend the type system with an expressive flow-sensitive effect system, which enables flavors of move semantics and ownership transfer. In addition, we present several case studies and extensions, including applications to capabilities for algebraic effects, one-shot continuations, and safe parallelization.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuyan</first_name>
          <last_name>Bao</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuyanbao.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuyanbao/29054831-172d-4005-9e61-a5f62bd70c76/small.jpg</picture_url>
          <person_id>yuyanbao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guannan</first_name>
          <last_name>Wei</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://continuation.passing.style</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guannanwei/e1971b4b-ebd3-429b-b28c-0c2cfb0f0289/small.jpg</picture_url>
          <person_id>guannanwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Bračevac</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://bracevac.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/oliverbracevac/17c0ac71-a156-4868-8df9-d4ae4cd669e7/small.jpg</picture_url>
          <person_id>oliverbracevac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yuxuan</first_name>
          <last_name>Jiang</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>yuxuanjiang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Qiyang</first_name>
          <last_name>He</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>qiyanghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b92d6597-9025-471b-a543-359ea439fada</slot_id>
      <event_id>c37258b4-1df6-476e-b6e1-b5168f6b0ece</event_id>
      <title>Synbit: Synthesizing Bidirectional Programs using Unidirectional Sketches</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>12:10</end_time>
      <description>We propose a technique for synthesizing bidirectional programs from the corresponding unidirectional code plus a few input/output examples. The core ideas are: (1) \emph{constructing a sketch} using the given unidirectional program as a specification, and (2) \emph{filling the sketch} in a modular fashion by exploiting the properties of bidirectional programs. These ideas are enabled by our choice of programming language, HOBiT, which is specifically designed to maintain the unidirectional program structure in bidirectional programming, and keep the parts that control bidirectional behavior modular. To evaluate our approach, we implemented it in a tool called Synbit and used it to generate bidirectional programs for intricate microbenchmarks, as well as for a few larger, more realistic problems. We also compared Synbit to a state-of-the-art unidirectional synthesis tool on the task of synthesizing backward computations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Masaomi</first_name>
          <last_name>Yamaguchi</last_name>
          <affiliation>Graduate School of Information Sciences, Tohoku University</affiliation>
          <bio>undefined</bio>
          <person_id>masaomiyamaguchi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kazutaka</first_name>
          <last_name>Matsuda</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.sf.ecei.tohoku.ac.jp/~kztk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kazutakamatsuda/2262653d-0d0f-4641-8ac2-7b653c0e3683/small.jpg</picture_url>
          <person_id>kazutakamatsuda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cristina</first_name>
          <last_name>David</last_name>
          <affiliation>University of Bristol</affiliation>
          <bio>undefined</bio>
          <person_id>cristinadavid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Meng</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Bristol, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/mengwang/2aba9176-828a-4227-9392-75f364770330/small.jpg</picture_url>
          <person_id>mengwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d1959753-ad03-4810-b070-8c6b6a7cf071</slot_id>
      <event_id>fc877a4c-cd99-491d-bb86-11c7282681b5</event_id>
      <title>Efficient Compilation of Algebraic Effect Handlers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:30</end_time>
      <description>The popularity of algebraic effect handlers as a programming language feature for user-defined computational effects is steadily growing. Yet, even though efficient runtime representations have already been studied, most handler-based programs are still much slower than hand-written code. This paper shows that the performance gap can be drastically narrowed (in some cases even closed) by means of type-and-effect directed optimising compilation. Our approach consists of source-to-source transformations in two phases of the compilation pipeline. Firstly, elementary rewrites, aided by judicious function specialisation, exploit the explicit type and effect information of the compiler’s core language to agressively reduce handler applications. Secondly, after erasing the effect information further rewrites in the backend of the compiler emit tight code. This work comes with a practical implementation: an optimizing compiler from Eff, an ML style language with algebraic effect handlers, to OCaml. Experimental evaluation with this implementation demonstrates that in a number of benchmarks, our approach eliminates much of the overhead of handlers, outperforms capability-passing style compilation and yields competitive performance compared to hand-written OCaml code as well Multicore OCaml’s dedicated runtime support.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Karachalias</last_name>
          <affiliation>Tweag</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gkaracha.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/georgekarachalias/cb10a8f5-6b72-4883-aef0-c9978070378a/small.jpg</picture_url>
          <person_id>georgekarachalias</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Filip</first_name>
          <last_name>Koprivec</last_name>
          <affiliation>University of Ljubljana</affiliation>
          <bio>undefined</bio>
          <person_id>filipkoprivec1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matija</first_name>
          <last_name>Pretnar</last_name>
          <affiliation>University of Ljubljana</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://matija.pretnar.info/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/matijapretnar/87fb17f8-8e61-4088-8c8f-88c5c9174485/small.jpg</picture_url>
          <person_id>matijapretnar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>af0c6941-3b7f-4e4c-9875-79e315238790</subevent_id>
    <title>SPLASH OOPSLA: Test and Verification</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>c8d659a5-dfbb-4bfd-b77a-99d196decdb2</slot_id>
      <title>Session: SPLASH OOPSLA - Test and Verification</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9daeb789-ba31-4abf-9aba-5b7d5ec343bc</subevent_id>
    <title>SPLASH OOPSLA: Smart Contracts and Distributed Programming</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>a06c9a13-291e-416e-ab8b-0a1738403aa1</slot_id>
      <title>Session: SPLASH OOPSLA - Smart Contracts and Distributed Programming</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2071aa56-1d3b-4d08-b639-82fe941b482e</slot_id>
      <event_id>1d8597cd-3c9f-4c45-b22a-ec533b6faaba</event_id>
      <title>Rich Specifications for Ethereum Smart Contract Verification</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:00</end_time>
      <description>Smart contracts are programs that execute inside blockchains such as Ethereum to manipulate digital assets. Since bugs in smart contracts may lead to substantial financial losses, there is considerable interest in formally proving their correctness. However, the specification and verification of smart contracts faces challenges that do not arise in other application domains. Smart contracts frequently interact with unverified, potentially adversarial outside code, which substantially weakens the assumptions that formal analyses can (soundly) make. Moreover, the core functionality of smart contracts is to manipulate and transfer resources; describing this functionality concisely requires dedicated specification support. Current reasoning techniques do not fully address these challenges, being restricted in their scope or expressiveness (in particular, in the presence of re-entrant calls), and offering limited means of expressing the resource transfers a contract performs. 
In this paper, we present a novel specification methodology tailored to the domain of smart contracts. Our specification constructs and associated reasoning technique are the first to enable: (1) sound and precise reasoning in the presence of unverified code and arbitrary re-entrancy, (2) modular reasoning about collaborating smart contracts, and (3) domain-specific specifications based on resources and resource transfers, which allow expressing a contract’s behavior in intuitive and concise ways and exclude typical errors by default. We have implemented our approach in 2vyper, an SMT-based automated verification tool for Ethereum smart contracts written in the Vyper language, and demonstrated its effectiveness in succinctly capturing and verifying strong correctness guarantees for real-world contracts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Braem</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christianbraem</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marco</first_name>
          <last_name>Eilers</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch/people/personal/meilers-pers.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marcoeilers/fbfa4a0a-c277-440b-af64-20c5dbf19d0c/small.jpg</picture_url>
          <person_id>marcoeilers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robin</first_name>
          <last_name>Sierra</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>robinsierra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Alexander J.</first_name>
          <last_name>Summers</last_name>
          <affiliation>University of British Columbia (UBC)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.ubc.ca/~alexsumm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexanderjsummers/f97b84a8-d46a-4e76-aa73-cc4b38c4ec41/small.jpg</picture_url>
          <person_id>alexanderjsummers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6a711623-b03c-4a9e-b8bd-98e209e99ba2</slot_id>
      <event_id>70fddf0a-a865-4d6d-a00e-3c602d4f2336</event_id>
      <title>ECROs: Building Global Scale Systems from Sequential Code</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:40</end_time>
      <description>To ease the development of geo-distributed applications, replicated data types (RDTs) offer a familiar programming interface while ensuring state convergence, low latency, and high availability. However, RDTs are still designed exclusively by experts using ad-hoc solutions that are error-prone and result in brittle systems. Recent works statically detect conflicting operations on existing data types and coordinate those at runtime to guarantee convergence and preserve application invariants. However, these approaches are too conservative, imposing coordination on a large number of operations. In this work, we propose a principled approach to design and implement efficient RDTs taking into account application invariants. Developers extend sequential data types with a distributed specification, which together form a RDT. We statically analyze the specification to detect conflicts and unravel their cause. This information is then used at runtime to serialize concurrent operations safely and efficiently. Our approach derives a correct RDT from any sequential data type without changes to the data type’s implementation and with minimal coordination. We implement our approach in Scala and develop an extensive portfolio of RDTs. The evaluation shows that our approach provides performance similar to conflict-free replicated data types for commutative operations, and considerably improves the performance of non-commutative operations, compared to existing solutions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kevin</first_name>
          <last_name>De Porre</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>kevindeporre1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carla</first_name>
          <last_name>Ferreira</last_name>
          <affiliation>Universidade Nova Lisboa</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/carlaferreira/84cdc5a2-f01b-44cd-b28f-73ae8baed899/small.jpg</picture_url>
          <person_id>carlaferreira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nuno</first_name>
          <last_name>Preguica</last_name>
          <affiliation>Universidade Nova Lisboa</affiliation>
          <bio>undefined</bio>
          <person_id>nunopreguica</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Gonzalez Boix</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/elisagonzalezboix/51a3d0ba-7330-40d4-ad16-4568d31fe2e4/small.jpg</picture_url>
          <person_id>elisagonzalezboix</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca88cf46-5d91-4a04-9093-b4a203616eb4</slot_id>
      <event_id>3864f6b3-a74b-4f39-89f7-b15e107b4a2a</event_id>
      <title>Symbolic Value-Flow Static Analysis: Deep, Precise, Complete Modeling of Ethereum Smart Contracts</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:20</end_time>
      <description>We present a static analysis approach that combines concrete values and symbolic expressions. This symbolic value-flow (“symvalic”) analysis models program behavior with high precision, e.g., full path sensitivity. To achieve deep modeling of program semantics, the analysis relies on a symbiotic relationship between a traditional static analysis fixpoint computation and a symbolic solver: the solver does not merely receive a complex “path condition” to solve, but is instead invoked repeatedly (often tens or hundreds of thousands of times), in close cooperation with the flow computation of the analysis. 
The result of the symvalic analysis architecture is a static modeling of program behavior that is much more complete than symbolic execution, much more precise than conventional static analysis, and domain-agnostic: no special-purpose definition of anti-patterns is necessary in order to compute violations of safety conditions with high precision. 
We apply the analysis to the domain of Ethereum smart contracts. This domain represents a fundamental challenge for program analysis approaches: despite numerous publications, research work has not been effective at uncovering vulnerabilities of high real-world value. 
In systematic comparison of symvalic analysis with past tools, we find significantly increased completeness (shown as 83-96% statement coverage and more true error reports) combined with much higher precision, as measured by rate of true positive reports. In terms of real-world impact, since the beginning of 2021, the analysis has resulted in the discovery and disclosure of several critical vulnerabilities, over funds in the many millions of dollars. Six separate bug bounties totaling over $350K have been awarded for these disclosures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neville</first_name>
          <last_name>Grech</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>My expertise is focused on program analysis, mostly applied to security applications. My work in this area has been recently highlighted by ACM SIGPLAN and Communications of the ACM. I am also interested in the areas of energy efficient systems, smart contracts, semantics and generative programming. Some popular tools I have codeveloped include decompilers and security analyzers for the Ethereum platform (MadMax and Gigahorse) and Java pointer and taint analysis frameworks (Doop, P/Taint and HeapDL). Previously, I was Reach High Fellow at the University of Athens, a Senior Research Associate at the University of Bristol, and have worked in industry as a Data Scientist and Software Engineer. I hold a PhD from the University of Southampton.</bio>
          <homepage_url>http://www.nevillegrech.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
          <person_id>nevillegrech</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sifis</first_name>
          <last_name>Lagouvardos</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/sifislagouvardos/7bff730b-e719-4f0c-935c-245291f18d9d/small.jpg</picture_url>
          <person_id>sifislagouvardos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Triantafyllou</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <person_id>konstantinostriantafyllou1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ilias</first_name>
          <last_name>Tsatiris</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/iliastsatiris/b33fd835-f771-4b76-b5e8-00452e460cf7/small.jpg</picture_url>
          <person_id>iliastsatiris</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e43c8207-2a0f-4c35-a8c3-6503bbc7f849</slot_id>
      <event_id>f2687be1-d8a0-434b-942c-242aef9f826d</event_id>
      <title>Durable Functions: Semantics for Stateful Serverless</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>17:00</end_time>
      <description>Serverless, or Functions-as-a-Service (FaaS), is an increasingly popular paradigm for application development, as it provides implicit elastic scaling and load based billing. However, the weak execution guarantees and intrinsic compute-storage separation of FaaS create serious challenges when developing applications that require persistent state, reliable progress, or synchronization. This has motivated a new generation of serverless frameworks that provide stateful abstractions. For instance, Azure’s Durable Functions (DF) programming model enhances FaaS with actors, workflows, and critical sections. As a programming model, DF is interesting because it combines task and actor parallelism, which makes it suitable for a wide range of serverless applications. We describe DF both informally, using examples, and formally, using an idealized high-level model based on the untyped lambda calculus. Next, we demystify how the DF runtime can (1) execute in a distributed unreliable serverless environment with compute-storage separation, yet still conform to the fault-free high-level model, and (2) persist execution progress without requiring checkpointing support by the language runtime. To this end we define two progressively more complex execution models, which contain the compute-storage separation and the record-replay, and prove that they are equivalent to the high-level model.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Burckhardt</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Sebastian Burckhardt was born and raised in Basel, Switzerland, where he studied Mathematics at the local University. During an exchange year at Brandeis University, he discovered his affinity to Computer Science and immigrated to the United States. After a few years of industry experience at IBM, he returned to academia and earned his PhD in Computer Science at the University of Pennsylvania. Since then, he has worked as a researcher at Microsoft Research in Redmond. His general research interest is the study of programming models for of concurrent, parallel, and distributed systems. More specific interests include consistency models, concurrency testing, self-adjusting computation, and the concurrent revisions programming model.</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/sburckha/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sebastianburckhardt/726ac702-681a-40f8-94d6-c0465e108867/small.jpg</picture_url>
          <person_id>sebastianburckhardt</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chris</first_name>
          <last_name>Gillum</last_name>
          <affiliation>Microsoft Azure</affiliation>
          <bio>undefined</bio>
          <person_id>chrisgillum</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Justo</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>David Justo is a Software Engineer at Microsoft, working on programming models for distributed systems and developer tooling more broadly. Previously, he was an MS student at UC San Diego working on program synthesis and polyglot programming. He’s interested in programming languages, programming environments, database theory, and formal methods.</bio>
          <homepage_url>https://davidmrdavid.github.io/about.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidjusto/1f7a0dc6-330d-47c6-9738-4e120b9e56bb/small.jpg</picture_url>
          <person_id>davidjusto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Kallas</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://angelhof.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/konstantinoskallas/532ec21f-35f9-482a-afc9-d7c8b7118a65/small.jpg</picture_url>
          <person_id>konstantinoskallas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Connor</first_name>
          <last_name>McMahon</last_name>
          <affiliation>Microsoft Azure</affiliation>
          <bio>undefined</bio>
          <person_id>connormcmahon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Christopher S.</first_name>
          <last_name>Meiklejohn</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>christophersmeiklejohn</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2daf5026-e857-4e32-a9e0-c5c28cd539d7</subevent_id>
    <title>SPLASH OOPSLA: Type &amp; Verification</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>6661d152-d406-464e-b9eb-fa286e69c3e2</slot_id>
      <title>Session: SPLASH OOPSLA - Type &amp; Verification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1575053d-50a0-4ad8-ada1-801b339644c7</slot_id>
      <event_id>dec21536-5710-4cea-9e64-3c18c13c7578</event_id>
      <title>Formal Verification of High-Level Synthesis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>14:43</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>15:10</end_time>
      <description>High-level synthesis (HLS), which refers to the automatic compilation of software into hardware, is rapidly gaining popularity. In a world increasingly reliant on application-specific hardware accelerators, HLS promises hardware designs of comparable performance and energy efficiency to those coded by hand in a hardware description language such as Verilog, while maintaining the convenience and the rich ecosystem of software development. However, current HLS tools cannot always guarantee that the hardware designs they produce are equivalent to the software they were given, thus undermining any reasoning conducted at the software level. Furthermore, there is mounting evidence that existing HLS tools are quite unreliable, sometimes generating wrong hardware or crashing when given valid inputs. 
To address this problem, we present the first HLS tool that is mechanically verified to preserve the behaviour of its input software. Our tool, called HLSCert, extends the CompCert verified C compiler with a new hardware-oriented intermediate language and a Verilog back end, and has been proven correct in Coq. HLSCert supports most C constructs, including all integer operations, function calls, local arrays, structs, unions and general control-flow statements. An evaluation on the PolyBench/C benchmark suite indicates that HLSCert generates hardware that is around an order of magnitude slower (only around 2$\times$ slower in the absence of division) and about the same size as hardware generated by an existing, optimising (but unverified) HLS tool.</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>870d0a92-458a-482f-bf95-222c4c503cca</slot_id>
      <event_id>c535117f-4286-427b-a999-ec9db64e4b2c</event_id>
      <title>A Type System for Extracting Functional Specifications from Memory-Safe Imperative Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>14:16</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:43</end_time>
      <description>Verifying imperative programs is hard. A key difficulty is that the specification of what an imperative program does is often intertwined with details about pointers and imperative state. Although there are a number of powerful separation logics that allow the details of imperative state to be captured and managed, these details are complicated and reasoning about them requires significant time and expertise. In this paper, we take a different approach: a memory-safe type system that, as part of type-checking, extracts functional specifications from imperative programs. This disentangles imperative state, which is handled by the type system, from functional specifications, which can be verified without reference to pointers. A key difficulty is that sometimes memory safety depends crucially on the functional specification of a program; e.g., an array index is only memory-safe if the index is in bounds. To handle this case, our specification extraction inserts dynamic checks into the specification. Verification then requires the additional proof that none of these checks fail. However, these checks are in a purely functional language, and so this proof also requires no reasoning about pointers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paul</first_name>
          <last_name>He</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>I am a PhD student at the University of Pennsylvania.</bio>
          <homepage_url>https://paulhe.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/paulhe/0d514283-c73f-4e42-aca3-b62e5080b1b8/small.jpg</picture_url>
          <person_id>paulhe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Westbrook</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>edwinwestbrook</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brent</first_name>
          <last_name>Carmer</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>brentcarmer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Chris</first_name>
          <last_name>Phifer</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>chrisphifer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Valentin</first_name>
          <last_name>Robert</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>valentinrobert2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Karl</first_name>
          <last_name>Smeltzer</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>karlsmeltzer1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Andrei</first_name>
          <last_name>Stefanescu</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>andreistefanescu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Tomb</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://galois.com/team/aaron-tomb/</homepage_url>
          <person_id>aarontomb</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Adam</first_name>
          <last_name>Wick</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>adamwick</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Yacavone</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>matthewyacavone</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Steve</first_name>
          <last_name>Zdancewic</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~stevez</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stevezdancewic/41b883c6-4689-4ae3-b6f1-6b7a24622e99/small.jpg</picture_url>
          <person_id>stevezdancewic</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b25b2443-1253-4342-b457-5709328b81b8</slot_id>
      <event_id>1d37dffb-2929-4565-b632-7873f6a12ea7</event_id>
      <title>Transitioning from Structural to Nominal Code with Efficient Gradual Typing</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:16</end_time>
      <description>Gradual typing is a principled means for mixing typed and untyped code. But typed and untyped code often exhibit different programming patterns. Significant research has investigated gradually giving types to code exhibiting typical untyped patterns, while some research has investigated gradually removing types from code exhibiting typical typed patterns. This paper investigates how to extend established gradual-typing concepts so that one can give formal guarantees not only about how types can change as code evolves but also about how such patterns can change as well. 
In particular, we explore mixing untyped structural code with typed nominal code in an object-oriented language. But whereas previous work only allowed nominal values to be treated as structural values, we also allow structural values to dynamically acquire certain nominal types, namely interfaces. We demonstrate that this choice to support structures as nominal interfaces, but not nominal classes, can still be implemented efficiently despite the fact that not all values have concrete types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabian</first_name>
          <last_name>Muehlboeck</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ist.ac.at/~fmuehlbo</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fabianmuehlboeck/4fb2ec06-e164-4813-bb8b-499adc17c869/small.jpg</picture_url>
          <person_id>fabianmuehlboeck</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ross</first_name>
          <last_name>Tate</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~ross/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rosstate/cbcbd066-943d-46a2-a301-1f4084076400/small.jpg</picture_url>
          <person_id>rosstate</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a23929a7-e348-4414-841c-06716b1f3a1d</subevent_id>
    <title>SPLASH OOPSLA: Program Synthesis - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>4b1b228a-e73a-44d1-be09-d3d0b8750ca0</slot_id>
      <title>Session: SPLASH OOPSLA - Program Synthesis - mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>30c0b480-c68a-4baa-af4b-ab656d6b19d4</slot_id>
      <event_id>25bb8503-88a2-4ba4-b253-0fc9a52e05dc</event_id>
      <title>Gauss: Program Synthesis by Reasoning Over Graphs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>22:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:30</end_time>
      <description>While input-output examples are a natural form of specification for program synthesis engines, they can be imprecise. In this paper, we investigate how extracting readily-available information about the user intent \emph{behind} these input-output examples helps speed up synthesis and reduce overfitting. We present Gauss, a synthesis algorithm that accepts partial input-output examples, along with \emph{user intent graphs}. Gauss includes a novel conflict-resolution reasoning algorithm over graphs that enables it to learn from mistakes made during the search and use that knowledge to explore the space of programs even faster. It also ensures the final program is consistent with the user intent specification, reducing overfitting. We implement Gauss for the domain of table transformations (supporting Pandas and R), and compare it to two state-of-the-art synthesizers accepting only input-output examples. We find that it is able to reduce the search space by 56$\times$, 73$\times$ and 664$\times$ on average, resulting in 7$\times$, 26$\times$ and 7$\times$ speedups in synthesis times on average, respectively.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rohan</first_name>
          <last_name>Bavishi</last_name>
          <affiliation>UC Berkeley</affiliation>
          <bio>I am a 3rd Year PhD student advised by Prof. Koushik Sen.</bio>
          <homepage_url>https://rbavishi.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rohanbavishi/9512af7a-f463-4f18-9edd-f4634cd69487/small.jpg</picture_url>
          <person_id>rohanbavishi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Caroline</first_name>
          <last_name>Lemieux</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Caroline Lemieux is a postdoctoral researcher at Microsoft Research, and will be starting as an Assistant Professor at UBC in Fall 2022. Her research interests center around improving the correctness and reliability of software systems by developing automated methods for engineering tasks such as testing, debugging, and comprehension. Her work on fuzz testing has been awarded an ACM SIGSOFT Distinguished Paper Award, Distinguished Artifact Award, Tool Demonstration Award, and Best Paper Award (Industry Track). She completed her PhD at UC Berkeley, advised by Koushik Sen; there, she was the recipient of a Berkeley Fellowship for Graduate Study, and a Google PhD Fellowship in Programming Technologies and Software Engineering. She received her B.Sc. in Computer Science and Mathematics at the University of British Columbia, where she won the Governor General’s Silver Medal in Science, awarded to the undergraduate student with highest standing in the Faculty of Science.</bio>
          <homepage_url>https://www.carolemieux.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/carolinelemieux/e43ab970-fd4b-43bd-83fe-eada347d47c9/small.jpg</picture_url>
          <person_id>carolinelemieux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Koushik</first_name>
          <last_name>Sen</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>Koushik Sen is a professor in the Department of Electrical Engineering and Computer Sciences at the University of California, Berkeley. His research interest lies in Software Engineering, Programming Languages, and Formal methods. He is interested in developing software tools and methodologies that improve programmer productivity and software quality. He holds a B.Tech from Indian Institute of Technology, Kanpur, and M.S. and Ph.D. in CS from University of Illinois at Urbana-Champaign.</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~ksen/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/koushiksen/9f417f8a-40b9-40a7-866c-9c44cd81859a/small.jpg</picture_url>
          <person_id>koushiksen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ion</first_name>
          <last_name>Stoica</last_name>
          <affiliation>UC Berkeley</affiliation>
          <bio>undefined</bio>
          <person_id>ionstoica</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>61a648b7-624b-42f7-95bd-5faeebc1197d</slot_id>
      <event_id>24dd1202-bb64-4cef-86c5-251fda3fcd93</event_id>
      <title>APIfix: Output-Oriented Program Synthesis for Combating Breaking Changes in Libraries</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:10</end_time>
      <description>Use of third-party libraries is extremely common in application software. The libraries evolve to accommodate new features or mitigate security vulnerabilities, thereby breaking the Application Programming Interface (API) used by the software. Such breaking changes in the libraries may discourage client code from using the new library versions thereby keeping the application vulnerable and not up-to-date. We propose a novel output-oriented program synthesis algorithm to automate API usage adaptations via program transformation. Our aim is not only to rely on the few example human adaptations of the clients from the old library to the new library, since this can lead to over-fitting transformation rules. Instead, we also rely on example usages of the new updated library in clients, which provide valuable context for synthesizing and applying the transformation rules. Our tool APIFix provides an automated mechanism to transform application code using the old library versions to code using the new library versions - thereby achieving automated API usage adaptation to fix the effect of breaking changes. Our evaluation shows that the transformation rules inferred by APIFix achieve 98.7% precision and 91.5% recall. By comparing our approach to state-of-the-art program synthesis approaches, we show that our approach significantly reduces over-fitting while synthesizing transformation rules for API usage adaptations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiang</first_name>
          <last_name>Gao</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.comp.nus.edu.sg/~gaoxiang/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xianggao/482ff4c5-f003-40e7-90cc-d888adbd1e2f/small.jpg</picture_url>
          <person_id>xianggao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Soares</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/gsoares/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gustavosoares/fc1e5a17-f939-4c3d-ab30-85467cb2610b/small.jpg</picture_url>
          <person_id>gustavosoares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ridwan Salihin</first_name>
          <last_name>Shariffdeen</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>I am a fourth-year PhD student in Department of Computer Science at School of Computing, National University of Singapore, where I am advised by Abhik Roychoudhury. The current focus of my research is on automated program repair, software security and software engineering automation.</bio>
          <homepage_url>https://rshariffdeen.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ridwansalihinshariffdeen/4ac6e84f-a4cb-4547-b8d7-026e9e142f00/small.jpg</picture_url>
          <person_id>ridwansalihinshariffdeen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Abhik</first_name>
          <last_name>Roychoudhury</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>Abhik Roychoudhury is a Professor of Computer Science at National University of Singapore. His research focuses on software testing and analysis, software security and trust-worthy software construction. His research group has built scalable techniques for testing, debugging and repair of programs using systematic semantic analysis. The capability to automatically repair programs at a large scale contributes to the vision of self-healing software. He is currently directing the National Satellite of Excellence in Trustworthy Software Systems in Singapore. He is also the Lead Principal Investigator of the Singapore Cyber-security Consortium, which is a consortium of 25 companies in the cyber-security space engaging with academia for research and collaboration.</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~abhik</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/abhikroychoudhury/7017e73b-76d1-4dd4-a4b4-def2881fc2c9/small.jpg</picture_url>
          <person_id>abhikroychoudhury</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bd442b59-fb41-4205-9876-b13f56738347</slot_id>
      <event_id>43ca20c2-56eb-45a4-ba22-83f5f26257c4</event_id>
      <title>Generalizable Synthesis Through Unification</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>22:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:50</end_time>
      <description>The generalizability of PBE solvers is the key to the empirical synthesis performance. Despite the importance of generalizability, related studies on PBE solvers are still limited. In theory, few existing solvers provide theoretical guarantees on generalizability, and in practice, there is a lack of PBE solvers with satisfactory generalizability on important domains such as conditional linear integer arithmetic (CLIA). In this paper, we adopt a concept from the computational learning theory, Occam learning, and perform a comprehensive study on the framework of synthesis through unification (STUN), a state-of-the-art framework for synthesizing programs with nested if-then-else operators. We prove that Eusolver, a state-of-the-art STUN solver, does not satisfy the condition of Occam learning, and then we design a novel STUN solver, PolyGen, of which the generalizability is theoretically guaranteed by Occam learning. We evaluate PolyGen on the domains of CLIA and demonstrate that PolyGen significantly outperforms two state-of-the-art PBE solvers on CLIA, Eusolver and Euphony, on both generalizability and efficiency.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruyi</first_name>
          <last_name>Ji</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>ruyiji</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jingtao</first_name>
          <last_name>Xia</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>jingtaoxia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhenjiang</first_name>
          <last_name>Hu</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~hu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhenjianghu/5d426480-5589-46be-b4f6-f98cf2acc80e/small.jpg</picture_url>
          <person_id>zhenjianghu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>edb5dd9c-419e-42e8-bf0b-b39545d73b77</slot_id>
      <event_id>d4737a93-8cd6-4e8c-833c-7ed194f21b7a</event_id>
      <title>LooPy: Interactive Program Synthesis with Control Structures</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>23:10</end_time>
      <description>One vision for program synthesis, and specifically for Programming by Example (PBE), is an interactive programmer’s assistant, integrated into the development environment. To make program synthesis practical for interactive use, prior work on Small-Step Live PBE has proposed to limit the scope of synthesis to small code snippets, and enable the users to provide local specifications for those snippets. This paradigm, however, does not work well in the presence of loops. We present LooPy, a synthesizer integrated into a Live Programming environment, which extends Small-Step Live PBE to work inside loops and scales it up to synthesize larger code snippets, while remaining fast enough for interactive use. To allow users to effectively provide examples at various loop iterations, even when the loop body is incomplete, LooPy makes use of live execution, a technique that leverages the programmer as an oracle to step over incomplete parts of the loop. To enable synthesis of loop bodies at interactive speeds, LooPy introduces Intermediate State Graph, a new data structure, which compactly represents a large space of code snippets composed of multiple assignment statements and conditionals. We evaluate LooPy empirically using benchmarks from competitive programming and previous synthesizers, and show that it can solve a wide variety of synthesis tasks at interactive speeds. We also performed a small qualitative user study which shows that LooPy’s block-level specifications are easy for programmers to provide.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kasra</first_name>
          <last_name>Ferdowsifard</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <person_id>kasraferdowsifard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/shraddhabarke1/4e11ed13-0f46-4d77-8a6d-dd4c07b7fd4b/small.jpg</picture_url>
          <person_id>shraddhabarke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.technion.ac.il/~hilap</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sorin</first_name>
          <last_name>Lerner</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/users/lerner/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sorinlerner/3d3b1a70-e2f8-4d3a-a1bc-9c4e17dad80b/small.jpg</picture_url>
          <person_id>sorinlerner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of 2020 Intel Rising Stars Award and the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b189e22e-f983-46fe-bbfd-1d0b2ee308c7</subevent_id>
    <title>SPLASH OOPSLA: Implementation of special Paradigms</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>cf4f853f-ea30-4422-99f7-d9933b7f6e8f</slot_id>
      <title>Session: SPLASH OOPSLA - Implementation of special Paradigms</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>06d47352-20f8-47a7-ae2e-3d3dc3174c14</slot_id>
      <event_id>dfc8e21a-b4fb-4095-9b67-790f96f35c7b</event_id>
      <title>Coarsening Optimization for Differentiable Programming</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:10</end_time>
      <description>This paper presents a novel optimization for differentiable programming named coarsening optimization. It offers a systematic way to synergize symbolic differentiation and algorithmic differentiation (AD). Through it, the granularity of the computations differentiated by each step in AD can become much larger than a single operation, and hence lead to much reduced runtime computations and data allocations in AD. To circumvent the difficulties that control flow creates to symbolic differentiation in coarsening, this work introduces $\phi$-calculus, a novel method to allow symbolic reasoning and differentiation of computations that involve branches and loops. It further avoids “expression swell” in symbolic differentiation and balance reuse and coarsening through the design of reuse-centric segment of interest(SOI) identification. Experiments on a collection of real-world applications show that coarsening optimization is effective in speeding up AD, producing several times to an order of magnitude speedups.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xipeng</first_name>
          <last_name>Shen</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>Xipeng Shen is an associate professor at the Computer Science Department, North Carolina State University (NCSU). He is a receipt of NSF CAREER Award, DOE Early Career Award, and Google Faculty Research Award. He is an ACM Distinguished Speaker, and a senior member of IEEE. Prior to joining NC State in 2014, Shen was the Adina Allen Term Distinguished Associate Professor at The College of William and Mary. He had served as a consultant to Intel Labs and Cisco, and a Visiting Researcher at MIT and Microsoft Research. He received his Ph.D. in Computer Science from University of Rochester in 2006.</bio>
          <homepage_url>http://people.engr.ncsu.edu/xshen5/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xipengshen/7ba54e69-f90a-4cf7-90d2-19fdd5f42e87/small.jpg</picture_url>
          <person_id>xipengshen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guoqiang</first_name>
          <last_name>Zhang</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
          <person_id>guoqiangzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Irene</first_name>
          <last_name>Dea</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>irenedea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Samantha</first_name>
          <last_name>Andow</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>samanthaandow</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Emilio</first_name>
          <last_name>Arroyo-Fang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>emilioarroyofang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d8fe5a64-0f97-4c0a-be4c-9b51852de1fd</slot_id>
      <event_id>2a3bd10f-d88a-4ac7-b023-0ee9946d5e84</event_id>
      <title>Compilation of Sparse Array Programming Models</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:10</end_time>
      <description>This paper shows how to compile sparse array programming languages. A sparse array programming language is an array programming language that supports element-wise application, reduction, and broadcasting of arbitrary functions over dense and sparse arrays with any fill value. Such a language has great expressive power and can express sparse and dense linear and tensor algebra, functions over images, exclusion and inclusion filters, and even graph algorithms. 
Our compiler strategy generalizes prior work in the literature on sparse tensor algebra compilation to support any function applied to sparse arrays, instead of only addition and multiplication. To achieve this, we generalize the notion of sparse iteration spaces beyond intersections and unions. These iteration spaces are automatically derived by considering how algebraic properties annotated onto functions interact with the fill values of the arrays. We then show how to compile these iteration spaces to efficient code. 
When compared with two widely-used Python sparse array packages, our evaluation shows that we generate built-in sparse array library features with a performance of 1.4$\times$ to 53.7$\times$ when measured against PyData/Sparse for user-defined functions and between 0.98$\times$ and 5.53$\times$ when measured against SciPy/Sparse for array slicing. Our technique outperforms PyData/Sparse by 6.58$\times$ to 70.3$\times$, and (where applicable) performs between 0.96$\times$ and 28.9$\times$ that of a dense NumPy implementation, on end-to-end sparse array applications. We also implement graph linear algebra kernels in our system with a performance of between 0.56$\times$ and 3.50$\times$ compared to that of the hand-optimized SuiteSparse:GraphBLAS library.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rawn</first_name>
          <last_name>Henry</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>rawnhenry</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivia</first_name>
          <last_name>Hsu</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>oliviahsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rohan</first_name>
          <last_name>Yadav</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>rohanyadav1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Kunle</first_name>
          <last_name>Olukotun</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arsenalfc.stanford.edu/kunle</homepage_url>
          <person_id>kunleolukotun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>samanamarsinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e1a0dd77-238f-48d0-942b-0556f8dbfa6a</slot_id>
      <event_id>a9b6a816-8bad-42e4-8254-5769ef450530</event_id>
      <title>Statically Bounded-Memory Delayed Sampling for Probabilistic Streams</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:30</end_time>
      <description>\emph{Probabilistic programming languages} aid developers performing Bayesian inference. These languages provide programming constructs and tools for probabilistic modeling and automating the process of developing a probabilistic inference procedure. Prior work introduced a probabilistic programming language, ProbZelus, to extend probabilistic programming functionality to unbounded streams of data. A key innovation of ProbZelus was to demonstrate that the \emph{delayed sampling} inference algorithm could be extended to work in a streaming context. ProbZelus showed that while delayed sampling could be effectively deployed on some programs, depending on the probabilistic model under consideration, delayed sampling is not guaranteed to use a bounded amount of memory over the course of the execution of the program. 
In this paper, we the present conditions on a probabilistic program’s execution under which delayed sampling will execute in bounded memory. The two conditions are dataflow properties of the core operations of delayed sampling: the \emph{$m$-consumed property} and \emph{the unseparated path property}. A program executes in bounded memory under delayed sampling if, and only if, it satisfies the $m$-consumed and unseparated path properties. We propose a static analysis that abstracts over these properties to soundly ensure that any program that passes the analysis satisfies these properties, and thus executes in bounded memory under delayed sampling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Baudart</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <person_id>guillaumebaudart1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM T.J. Watson Research Center</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charles</first_name>
          <last_name>Yuan</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>charlesyuan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fea00bff-719d-42fb-a42c-9b40fe95f750</slot_id>
      <event_id>aac8ee13-0cef-4d91-b60c-f029b7f08587</event_id>
      <title>Efficient Automatic Scheduling of Imaging &amp; Vision Pipelines for the GPU</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:50</end_time>
      <description>We present a new algorithm to quickly generate high-performance GPU implementations of complex imaging and vision pipelines, directly from high-level Halide algorithm code. It is fully automatic, requiring no schedule templates or hand-optimized kernels. We address the scalability challenge of extending search-based automatic scheduling to map large real-world programs to the deep hierarchies of memory and parallelism on GPU architectures in reasonable compile time. We achieve this using (1) a two-phase search algorithm that first ‘freezes’ decisions for the lowest cost sections of a program, allowing relatively more time to be spent on the important stages, (2) a hierarchical sampling strategy that groups schedules based on their structural similarity, then samples representatives to be evaluated, allowing us to explore a large space with few samples, and (3) memoization of repeated partial schedules, amortizing their cost over all their occurrences. We guide the process with an efficient cost model combining machine learning, program analysis, and GPU architecture knowledge. We evaluate our method’s performance on a diverse suite of real-world imaging and vision pipelines. Our scalability optimizations lead to average compile time speedups of 49x (up to 530x). We find schedules that are on average 1.7x faster than existing automatic solutions (up to 5x), and competitive with what the best human experts were able to achieve in an active effort to beat our automatic results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luke</first_name>
          <last_name>Anderson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>lukeanderson1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Adams</last_name>
          <affiliation>Adobe</affiliation>
          <bio>undefined</bio>
          <person_id>andrewadams</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Karima</first_name>
          <last_name>Ma</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>karimama1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tzu-Mao</first_name>
          <last_name>Li</last_name>
          <affiliation>UC San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~tzli/</homepage_url>
          <person_id>tzumaoli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tian</first_name>
          <last_name>Jin</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>tianjin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Ragan-Kelley</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>Assistant Professor of Computer Science</bio>
          <homepage_url>https://people.csail.mit.edu/jrk</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanragankelley/1b837cf9-1002-4ab3-8bfc-fdf6708db7e1/small.jpg</picture_url>
          <person_id>jonathanragankelley</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e79353d8-e431-48ba-9094-ce8ad7c8f57b</subevent_id>
    <title>SPLASH OOPSLA: Algorithms, Libraries and Databases</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>fb99d429-0fe8-478c-8d57-7d29870da0d0</slot_id>
      <title>Session: SPLASH OOPSLA - Algorithms, Libraries and Databases</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>004778be-df5e-4a2b-9ed7-7a9507b4a6dd</slot_id>
      <event_id>e41ff4b0-ba00-4e8f-ba86-28ea4d9821ae</event_id>
      <title>UDF to SQL Translation through Compositional Lazy Inductive Synthesis</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>12:10</end_time>
      <description>Many data processing systems allow SQL queries that call user-defined functions (UDFs)written in conventional programming languages. While such SQL extensions provide convenience and flexibility to users, queries involving UDFs are not as efficient as their pure SQL counterparts that invoke SQL’s highly-optimized built-in functions. Motivated by this problem, we propose a new technique for translating SQL queries with UDFs to pure SQL expressions. Unlike prior work in this space (Ramachandra et al., 2017a), our method is not based on syntactic rewrite rules and can handle a much more general class of UDFs. At a high-level, our method is based on counterexample-guided inductive synthesis (CEGIS) but employs a novel compositional strategy that decomposes the synthesis task into simpler sub-problems. However, because there is no universal decomposition strategy that works for all UDFs, we propose a novel lazy inductive synthesis approach that generates a sequence of decompositions that correspond to increasingly harder inductive synthesis problems. Because most realistic UDF-to-SQL translation tasks are amenable to a fine-grained decomposition strategy, our lazy inductive synthesis method scales significantly better than traditional CEGIS. 
We have implemented our proposed technique in a tool called CLIS for optimizing Spark SQL programs containing Scala UDFs. To evaluate CLIS, we manually study 100 randomly selected UDFs and find that 63 of them can be expressed in pure SQL. Our evaluation on these 63 UDFs shows that CLIS can automatically synthesize equivalent SQL expressions in 92% of the cases and that it can solve 2.4× more benchmarks compared to a baseline that does not use our compositional approach. We also show that CLIS yields an average speed-up of 4.6× for individual UDFs and 1.3× to 3.1× in terms of end-to-end application performance.</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>323cafd7-89a0-46db-a176-acec80c9fcf5</slot_id>
      <event_id>7a1731c9-53d0-4f27-90c8-227f5a3a717e</event_id>
      <title>Verifying Concurrent Multicopy Search Structures</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:10</end_time>
      <description>Multicopy data structures such as log-structured merge (LSM) trees are optimized for high insert/update/delete (collectively known as upsert) performance. In such search structures, an upsert on key $k$, which adds $(k,v)$ where $v$ can be a value or a tombstone, is added to the root node even if $k$ is already present in other nodes. Thus there may be multiple copies of $k$ in the search structure. A search on $k$ aims to return the value associated with the most recent upsert. We present a general framework for verifying linearizability of concurrent multicopy structures that abstracts from the underlying representation of the data structure in memory, enabling proof-reuse across diverse implementations. Based on our framework, we propose template algorithms for LSM structures forming arbitrary directed acyclic graphs, and formally verify these templates in the concurrent separation logic Iris. We instantiate this template to obtain the first verified concurrent in-memory LSM tree implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nisarg</first_name>
          <last_name>Patel</last_name>
          <affiliation>New York University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>nisargpatel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Siddharth</first_name>
          <last_name>Krishna</last_name>
          <affiliation>Microsoft Research, Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.nyu.edu/~siddharth/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/siddharthkrishna/fb064b85-b50f-4fba-9626-67ed7a75b358/small.jpg</picture_url>
          <person_id>siddharthkrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dennis</first_name>
          <last_name>Shasha</last_name>
          <affiliation>New York University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dennisshasha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Wies</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.nyu.edu/wies/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thomaswies/e43dd6b5-97dc-433f-9708-836bd6364a01/small.jpg</picture_url>
          <person_id>thomaswies</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>58024535-f431-46a0-90fa-7321bb44a1b0</slot_id>
      <event_id>c7fcb53f-6c45-46d6-9e4c-be51477a0bbb</event_id>
      <title>FPL: Fast Presburger Arithmetic through Transprecision</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:50</end_time>
      <description>Presburger arithmetic provides the mathematical core for the polyhedral compilation techniques that drive analytical cache models, loop optimization for ML and HPC, formal verification, and even hardware design. Polyhedral compilation is widely regarded as being slow due to the potentially high computational cost of the underlying Presburger libraries. Researchers typically use these libraries as powerful black-box tools, but a lack of internal documentation and decade-old C implementations hold back broader performance-optimization efforts. With FPL, we introduce a new library for Presburger arithmetic built from the ground up in modern C++. We carefully document its internal algorithmic foundations, use lightweight C++ data structures to minimize memory management costs, and deploy transprecision computing across the entire library to effectively exploit machine integers and vector instructions. On a newly-developed comprehensive benchmark suite for Presburger arithmetic, we show a 5.25x speedup in total runtime over the state-of-the-art library isl in its default configuration and 3.14x when over a variant of isl optimized with element-wise transprecision computing. We expect that the availability of a well-documented and fast Presburger library will accelerate the adoption of polyhedral compilation techniques in production compilers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Pitchanathan</last_name>
          <affiliation>IIIT Hyderabad</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunpitchanathan/ad5b4feb-d93b-4bc7-b90b-7250f26856fa/small.jpg</picture_url>
          <person_id>arjunpitchanathan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christian</first_name>
          <last_name>Ulmann</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christianulmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michel</first_name>
          <last_name>Weber</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>michelweber</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Torsten</first_name>
          <last_name>Hoefler</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>torstenhoefler1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Grosser</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.grosser.es</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobiasgrosser/1ee43044-14e9-497e-a230-90f96a8da867/small.jpg</picture_url>
          <person_id>tobiasgrosser</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e61274ce-6a71-41ca-a9c1-a500f6f9d93e</slot_id>
      <event_id>bbd115c1-8ed3-4aed-a963-aa15387946b3</event_id>
      <title>LXM: Better Splittable Pseudorandom Number Generators (and Almost as Fast)</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:30</end_time>
      <description>In 2014, Steele, Lea, and Flood presented SplitMix, an object-oriented pseudorandom number generator (PRNG) that is quite fast (9 64-bit arithmetic/logical operations per 64 bits generated) and also \emph{splittable}. A conventional PRNG object provides a \emph{generate} method that returns one pseudorandom value and updates the state of the PRNG; a splittable PRNG object also has a second operation, \emph{split}, that replaces the original PRNG object with two (seemingly) independent PRNG objects, by creating and returning a new such object and updating the state of the original object. Splittable PRNG objects make it easy to organize the use of pseudorandom numbers in multithreaded programs structured using fork-join parallelism. This overall strategy still appears to be sound, but the specific arithmetic calculation used for \emph{generate} in the SplitMix algorithm has some detectable weaknesses, and the period of any one generator is limited to $2^{64}$. 
Here we present the LXM \emph{family} of PRNG algorithms. The idea is an old one: combine the outputs of two independent PRNG algorithms, then (optionally) feed the result to a mixing function. An LXM algorithm uses a linear congruential subgenerator and an $\mathbf{F}_2$-linear subgenerator; the examples studied in this paper use an LCG of period $2^{16}$, $2^{32}$, $2^{64}$, or $2^{128}$ with one of the multipliers recommended by L’Ecuyer or by Steele and Vigna, and an $\mathbf{F}_2$-linear generator of the xoshiro family or xoroshiro family as described by Blackman and Vigna. Mixing functions studied in this paper include the MurmurHash3 finalizer function, David Stafford’s variants, Doug Lea’s variants, and the null (identity) mixing function. 
Like SplitMix, LXM provides both a \emph{generate} operation and a \emph{split} operation. Also like SplitMix, LXM requires no locking or other synchronization (other than the usual memory fence after instance initialization), and is suitable for use with SIMD instruction sets because it has no branches or loops. 
We analyze the period and equidistribution properties of LXM generators, and present the results of thorough testing of specific members of this family, using the TestU01 and PractRand test suites, not only on single instances of the algorithm but also for collections of instances, used in parallel, ranging in size from $2$ to $2^{24}$. Single instances of LXM that include a strong mixing function appear to have no major weaknesses, and LXM is significantly more robust than SplitMix against accidental correlation in a multithreaded setting. We believe that LXM is suitable for the same sorts of applications as SplitMix, that is, “everyday” scientific and machine-learning applications (but not cryptographic applications), especially when concurrent threads or distributed processes are involved.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guy L.</first_name>
          <last_name>Steele Jr.</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Guy L. Steele Jr. (A.B., 1975, Harvard College; S.M., 1977, and Ph.D., 1980, MIT) is a Software Architect at Oracle Labs. He has taught at Carnegie-Mellon University, and worked for Tartan Laboratories, Thinking Machines Corporation, and Sun Microsystems. 
He is author or co-author of five books: Common Lisp: The Language, C: A Reference Manual, The Hacker’s Dictionary, The High Performance Fortran Handbook, and The Java Language Specification. He has published more than two dozen papers on the subject of the Lisp language and Lisp implementation, including a series with Gerald Jay Sussman that defined the Scheme dialect of Lisp. His paper “Data Parallel Algorithms” with W. Daniel Hillis (December 1986) has been cited more than 1100 times. 
He has been given the Grace Murray Hopper Award (1988), the ACM SIGPLAN Programming Languages Achievement Award (1996), and the Harry H. Goode Memorial Award (2007). He is an ACM Fellow, IEEE Fellow, Fellow of the American Academy of Arts and Sciences, and a Member of the National Academy of Engineering of the United States of America. 
He has served on accredited standards committees X3J11 (C language) and X3J3 (Fortran), and served as chairman of X3J13 (Common Lisp). He was also a member of the IEEE committee that produced the IEEE Standard for the Scheme Programming Language, IEEE Std 1178-1990. At Thinking Machines Corporation he co-developed the languages Connection Machine Lisp, C*, and Connection Machine Fortran. At Sun Microsystems (and now at Oracle) he has advised the evolution of the Java programming language; he also led the design of Fortress, an object-oriented mathematical language intended to support high-performance computing. He designed the original EMACS command set and was the first person to port TeX. 
He is a member of Tech Squares, the Plus-level Modern Western Square Dance club at MIT, and a square dance caller (currently Mainstream through C3A). At SPLASH 2011 he gave a presentation and demonstration on the structure of square-dance singing calls. 
At Oracle labs, he is responsible for research in language design and implementation strategies, and architectural and software support for programming languages.</bio>
          <homepage_url>https://labs.oracle.com/pls/apex/f?p=labs:bio:0:120</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guylsteelejr/9c36bdda-9de1-43c9-a239-3143cf32ae57/small.jpg</picture_url>
          <person_id>guylsteelejr</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastiano</first_name>
          <last_name>Vigna</last_name>
          <affiliation>Università degli Studi di Milano</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/sebastianovigna/8cd65f59-c0bc-4d72-bd2c-c8f746296fbb/small.jpg</picture_url>
          <person_id>sebastianovigna</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>98d3b139-8908-41ec-859f-f81d1f2f42a8</subevent_id>
    <title>SPLASH OOPSLA: Types</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>c7234353-bb35-4b83-97fe-a3710677c304</slot_id>
      <title>Session: SPLASH OOPSLA - Types</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>268b4ba2-16c3-4ae7-a4f7-95ce5e6a73e6</slot_id>
      <event_id>41174c70-3ab0-4594-8b81-6dea9b1c3735</event_id>
      <title>Relational Nullable Types with Boolean Unification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:50</end_time>
      <description>We present a simple, practical, and expressive relational nullable type system. A relational nullable type system captures whether an expression may evaluate to null based on its type, but also based on the type of other related expressions. The type system extends the Hindley-Milner type system with Boolean constraints, supports parametric polymorphism, and preserves principal types modulo Boolean equivalence. We show how to support full Hindley-Milner style type inference with an extension of Algorithm W. 
We conduct a preliminary study of open source projects showing that there is a need for relational nullable type systems across a wide range of programming languages. The most important findings from the study are: (i) programmers use programming patterns where the nullability of one expression depends on the nullability of other related expressions, (ii) such invariants are commonly enforced with run-time exceptions, and (iii) reasoning about these programming patterns requires not only knowledge of when an expression may evaluate to null, but also when it may evaluate to a non-null value. We incorporate these observations in the design of the proposed relational nullable type system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jaco</first_name>
          <last_name>van de Pol</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Jaco van de Pol did his PhD research in Utrecht University on rewrite systems, in particular termination of higher-order rewrite systems. At CWI Amsterdam, he published several papers on theorem proving and model checking for concurrent systems in process algebra and contributed to the µCRL toolset. In Twente, he started a new research line on parallel model checking algorithms. This resulted in the LTSmin toolset for high-performance model checking. He worked on applications in embedded systems, safety &amp;amp; security and systems biology. 
Jaco van de Pol is now professor of Computer Science at Aarhus University, working on automated verification and synthesis. Publications at Google Scholar and DBLP. 
Affiliations: 
 
 MSc Utrecht University (supervisor Hans Zantema) 
 PhD Utrecht University (supervisor Jan Bergstra) 
 Research Assistant LMU Mathematisches Institute Munich (with Helmut Schwichtenberg) 
 Postdoc Technical University of Eindhoven (with Jozef Hooman) 
 Senior Researcher CWI (1999-2007) 
 Associate Professor Technical University of Eindhoven (2004-2007, 20%) 
 Professor Formal Methods and Tools at University of Twente (2007-2018; from Nov 2018 10%) 
 Professor Computer Science at Aarhus University (from Nov 2018) 
</bio>
          <homepage_url>https://www.cs.au.dk/~jaco</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jacovandepol/b053e08d-fe52-46a9-b4cd-b863ea6c9c07/small.jpg</picture_url>
          <person_id>jacovandepol</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3ce90a8d-bd20-482e-9f78-d65cb3aefda5</slot_id>
      <event_id>3d8946fe-98b1-4684-8c3c-05faf136ee3f</event_id>
      <title>Label Dependent Lambda Calculus and Gradual Typing</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:30</end_time>
      <description>Dependently-typed programming languages are gaining importance, because they can guarantee a wide range of properties at compile time. Their use in practice is often hampered because programmers have to provide very precise types. Gradual typing is a means to vary the level of typing precision between program fragments and to transition smoothly towards more precisely typed programs. The combination of gradual typing and dependent types seems promising to promote the widespread use of dependent types. 
We investigate a gradual version of a minimalist value-dependent lambda calculus. Compile-time calculations and thus dependencies are restricted to labels, drawn from a generic enumeration type. The calculus supports the usual Pi and Sigma types as well as singleton types and subtyping. It is sufficiently powerful to provide flexible encodings of variant and record types with first-class labels. 
We provide type checking algorithms for the underlying label-dependent lambda calculus and its gradual extension. The gradual type checker drives the translation into a cast calculus, which extends the original language. The cast calculus comes with several innovations: refined typing for casts in the presence of singletons, type reduction in casts, and fully dependent Sigma types. Besides standard metatheoretical results, we establish the gradual guarantee for the gradual language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Weili</first_name>
          <last_name>Fu</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>weilifu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fabian</first_name>
          <last_name>Krause</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <person_id>fabiankrause</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Thiemann</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/peterthiemann/43fc0175-1745-4b3a-b626-86e10da76b86/small.jpg</picture_url>
          <person_id>peterthiemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5ef3e14b-448a-4aa2-8904-f6ae7a969898</slot_id>
      <event_id>3aad0c8c-c620-4cea-b83f-3ef19cdf6d5f</event_id>
      <title>Type Stability in Julia: Avoiding Performance Pathologies in JIT Compilation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:10</end_time>
      <description>As a scientific programming language, Julia strives for performance but also provides high-level productivity features. To avoid performance pathologies, Julia users are expected to adhere to a coding discipline that enables so-called type stability. Informally, a function is type stable if the type of the output depends only on the types of the inputs, not their values. This paper provides a formal definition of type stability as well as a stronger property of type groundedness, shows that groundedness enables compiler optimizations, and proves the compiler correct. We also perform a corpus analysis to uncover how these type-related properties manifest in practice.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Artem</first_name>
          <last_name>Pelenitsyn</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mmcs.sfedu.ru/~ulysses/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/artempelenitsyn/747a7a15-5a78-4871-857b-53cbbe5f6e1e/small.jpg</picture_url>
          <person_id>artempelenitsyn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julia</first_name>
          <last_name>Belyakova</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Sep 2018 – present: PhD Student, Northeastern University, USA. Sep 2017 – Jul 2018: Researcher, Czech Technical University in Prague, Czech Republic. Jan 2017 – Jun 2017: Research Scientist, Northeastern University, USA. 2014–2016: teaching assistant/lecturer at Southern Federal University, Russia. Received MS in Computer Science from Southern Federal University, Russia in 2014.</bio>
          <homepage_url>https://julbinb.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juliabelyakova/b35236df-c22a-44f1-8048-aecfeba8ac2e/small.jpg</picture_url>
          <person_id>juliabelyakova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin W</first_name>
          <last_name>Chung</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <person_id>benjaminwchung</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ross</first_name>
          <last_name>Tate</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~ross/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rosstate/cbcbd066-943d-46a2-a301-1f4084076400/small.jpg</picture_url>
          <person_id>rosstate</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a35b0137-4a12-4ad1-b4d0-fc30fce8582d</slot_id>
      <event_id>ca540410-cf87-4a60-a719-2ad9b0f97620</event_id>
      <title>Study of the Subtyping Machine of Nominal Subtyping with Variance</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:10</end_time>
      <description>This is a study of the computing power of the subtyping machine behind Kennedy and Pierce’s nominal subtyping with variance. We depict the lattice of fragments of Kennedy and Pierce’s type system and characterize their computing power in terms of regular, context-free, deterministic, and non-deterministic tree languages. Based on the theory, we present Treetop—a generator of C# implementations of subtyping machines. The software artifact constitutes the first feasible (yet POC) fluent API generator to support context-free API protocols in a decidable type system fragment.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ori</first_name>
          <last_name>Roth</last_name>
          <affiliation>Technion</affiliation>
          <bio>Ori Roth is a PhD student at the Technion—Israel Institute of Technology. His research interests include programming languages, software engineering, and automata theory.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/oriroth/f303c081-564f-4bb5-8037-c59de38bd235/small.jpg</picture_url>
          <person_id>oriroth</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>505c7019-b9d3-49b4-a29e-02bdec1b65cd</subevent_id>
    <title>SPLASH OOPSLA: Synthesis of models, tools and programs</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>bae1691a-1dde-41bd-9e3d-46e02287b378</slot_id>
      <title>Session: SPLASH OOPSLA - Synthesis of models, tools and programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18fb8fc7-0642-4e69-baaf-f2bfe56a8609</slot_id>
      <event_id>44632a19-da24-4769-9abf-fb6b1a1b8dab</event_id>
      <title>Multi-modal Program Inference: a Marriage of Pre-trained Language Models and Component-based Synthesis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>12:10</end_time>
      <description>Multi-modal program synthesis refers to the task of synthesizing programs (code) from their specification given in different forms, such as a combination of natural language and examples. Examples provide a precise but incomplete specification, and natural language provides an ambiguous but more “complete” task description. Machine-learned pre-trained models (PTMs) are adept at handling ambiguous natural language, but struggle with generating syntactically and semantically precise code. Program synthesis techniques can generate correct code, often even from incomplete but precise specifications, such as examples, but they are unable to work with the ambiguity of natural languages. We present an approach that combines PTMs with component-based synthesis (CBS): PTMs are used to generate candidate programs from the natural language description of the task, which are then used to guide the CBS procedure to find the program that matches the precise examples-based specification. We use our combination approach to instantiate multi-modal synthesis systems for two programming domains: the domain of regular expressions and the domain of CSS selectors. Our evaluation demonstrates the effectiveness of our domain-agnostic approach in comparison to a state-of-the-art specialized system, and the generality of our approach in providing multi-modal program synthesis from natural language and examples in different programming domains.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kia</first_name>
          <last_name>Rahmani</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am a PhD candidate of computer science at Purdue University. I am a member of the programming languages group, working under the supervision of Professor Suresh Jagannathan and Professor Benjamin Delaware. 
My PhD thesis is focused around compilation, synthesis, and testing of modern database-backed programs. More broadly, I am interested in all formal methods for modeling and analysis of (classical or quantum) computer programs. 
I was previously a research intern at Microsoft, working on a new program synthesis technique based on pre-trained language models. My work was supervised by Dr. Mohammad Raza and Dr. Sumit Gulwani.</bio>
          <homepage_url>https://kiarahmani.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kiarahmani/745190a9-35f0-49e9-b5a9-f8831bce9162/small.jpg</picture_url>
          <person_id>kiarahmani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mohammad</first_name>
          <last_name>Raza</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>mohammadraza</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Vu</first_name>
          <last_name>Le</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>I am a Researcher at Microsoft, working on the Microsoft Program Synthesis using Examples (PROSE) framework. I obtained my PhD in 2015 at UC Davis, advised by Zhendong Su and Sumit Gulwani. My research is about developing novel and practical techniques to help improve the quality of critical software (e.g., compilers and database engines) and make programming accessible for end users. My work has led to the discovery of hundreds of bugs in GCC and LLVM, most of which have been fixed, and shipped in various Microsoft products.</bio>
          <homepage_url>http://vuminhle.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vule/8674b9d0-747d-4a80-b8f0-3c7a435cd9b7/small.jpg</picture_url>
          <person_id>vule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Morris</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>danielmorris</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Soares</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/gsoares/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gustavosoares/fc1e5a17-f939-4c3d-ab30-85467cb2610b/small.jpg</picture_url>
          <person_id>gustavosoares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Ashish</first_name>
          <last_name>Tiwari</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csl.sri.com/users/tiwari/</homepage_url>
          <person_id>ashishtiwari</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7c497d6a-686e-4d73-91da-19de32e324f2</slot_id>
      <event_id>5a37cd42-11e4-4df2-a92f-376c879a05e3</event_id>
      <title>Rewrite Rule Inference Using Equality Saturation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:10</end_time>
      <description>Many compilers, synthesizers, and theorem provers rely on rewrite rules to simplify expressions or prove equivalences. Developing rewrite rules can be difficult: rules may be subtly incorrect, profitable rules are easy to miss, and rulesets must be rechecked or extended whenever semantics are tweaked. Large rulesets can also be challenging to apply: redundant rules can slow down rule-based search and frustrate debugging. 
This paper explores how equality saturation, a promising technique that uses e-graphs to apply rewrite rules, can also be used to infer rewrite rules. E-graphs can compactly represent the exponentially large sets of enumerated terms and potential rewrite rules. We show that equality saturation efficiently shrinks both sets,leading to faster synthesis of smaller, more general rulesets. 
We prototyped these strategies in a tool dubbed Ruler. Compared to a similar tool built on CVC4, Ruler synthesizes 5.8× smaller rulesets 25× faster without compromising on proving power. In an end-to-end case study, we show Ruler-synthesized rules which perform as well as those crafted by domain experts, addressing a longstanding issue in a popular open source tool.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chandrakana</first_name>
          <last_name>Nandi</last_name>
          <affiliation>Certora, inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cnandi.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chandrakananandi/a90ad233-62bb-4a90-8e9d-9afd969ef245/small.jpg</picture_url>
          <person_id>chandrakananandi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Max</first_name>
          <last_name>Willsey</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.mwillsey.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/maxwillsey/ff552459-e263-42a5-b17b-1301d482943d/small.jpg</picture_url>
          <person_id>maxwillsey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Amy</first_name>
          <last_name>Zhu</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <person_id>amyzhu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Brett</first_name>
          <last_name>Saiki</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <person_id>brettsaiki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yisu Remy</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>PhD student at University of Washington.</bio>
          <homepage_url>https://remy.wang</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yisuremywang1/5aec4d9a-13a9-460e-8154-fc72a368b4f9/small.jpg</picture_url>
          <person_id>yisuremywang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Adam</first_name>
          <last_name>Anderson</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <person_id>adamanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Adriana</first_name>
          <last_name>Schulz</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <person_id>adrianaschulz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Dan</first_name>
          <last_name>Grossman</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~djg/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dangrossman/941e0321-e962-4f03-9027-ba9f0448e7df/small.jpg</picture_url>
          <person_id>dangrossman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Tatlock</last_name>
          <affiliation>University of Washington, Seattle</affiliation>
          <bio>Associate Professor at the University of Washington</bio>
          <homepage_url>https://ztatlock.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zacharytatlock/87af1196-2d8d-4bd5-a692-018d3939a00f/small.jpg</picture_url>
          <person_id>zacharytatlock</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>99674ca7-7721-4eb9-b5bf-1fcb49d4ff96</slot_id>
      <event_id>c534281c-22ac-4d12-b79c-ef3db26a300f</event_id>
      <title>Semantic programming by example with pre-trained models</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:50</end_time>
      <description>The ability to learn programs from few examples is a powerful technology with disruptive applications in many domains, as it allows users to automate repetitive tasks in an intuitive way. Existing frameworks on inductive synthesis only perform syntactic manipulations, where they rely on the syntactic structure of the given examples and not their meaning. Any semantic manipulations, such as transforming dates, have to be manually encoded by the designer of the inductive programming framework. Recent advances in large language models have shown these models to be very adept at performing semantic transformations of its input by simply providing a few examples of the task at hand. When it comes to syntactic transformations, however, these models are limited in their expressive power. In this paper, we propose a novel framework for integrating inductive synthesis with few-shot learning language models to combine the strength of these two popular technologies. In particular, the inductive synthesis is tasked with breaking down the problem in smaller subproblems, among which those that cannot be solved syntactically are passed to the language model. We formalise three semantic operators that can be integrated with inductive synthesizers. To minimize invoking expensive semantic operators during learning, we introduce a novel deferred query execution algorithm that considers the operators to be oracles during learning. We evaluate our approach in the domain of string transformations: the combination methodology can automate tasks that cannot be handled using either technologies by themselves. Finally, we demonstrate the generality of our approach via a case study in the domain of string profiling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gust</first_name>
          <last_name>Verbruggen</last_name>
          <affiliation>Department of Computer Science, KU Leuven</affiliation>
          <bio>undefined</bio>
          <person_id>gustverbruggen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vu</first_name>
          <last_name>Le</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>I am a Researcher at Microsoft, working on the Microsoft Program Synthesis using Examples (PROSE) framework. I obtained my PhD in 2015 at UC Davis, advised by Zhendong Su and Sumit Gulwani. My research is about developing novel and practical techniques to help improve the quality of critical software (e.g., compilers and database engines) and make programming accessible for end users. My work has led to the discovery of hundreds of bugs in GCC and LLVM, most of which have been fixed, and shipped in various Microsoft products.</bio>
          <homepage_url>http://vuminhle.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vule/8674b9d0-747d-4a80-b8f0-3c7a435cd9b7/small.jpg</picture_url>
          <person_id>vule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d954d87e-9377-4e79-8439-a42f37856d1b</slot_id>
      <event_id>984afe45-291b-4657-9b18-5d36553b8fcb</event_id>
      <title>One Down, 699 to Go: or, synthesising compositional desugarings</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:30</end_time>
      <description>Programming or scripting languages used in real-world systems are seldom designed with a formal semantics in mind from the outset. Therefore, developing well-founded analysis tools for these systems requires reverse-engineering a formal semantics as a first step. This can take months or years of effort. 
Can we (at least partially) automate this process? Though desirable, automatically reverse-engineering semantics rules from an implementation is very challenging, as found by Krishnamurthi et al. [2019]. In this paper, we highlight that scaling methods with the size of the language is very difficult due to state space explosion, so we propose to learn semantics incrementally, in smaller parts. We give a formalisation of Krishnamurthi et al's desugaring learning framework in order to clarify the assumptions necessary for an incremental learning algorithm to be feasible.

We show that this reformulation allows us to extend the search space and express rules that Krishnamurthi et al. described as challenging, while still retaining feasibility. We evaluate enumerative synthesis as a baseline algorithm, and demonstrate that, with our reformulation of the problem, it is possible to learn correct  desugaring rules for the example source and core languages proposed by Krishnamurthi et al., in most cases identical to the intended rules.
</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sándor</first_name>
          <last_name>Bartha</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>sandorbartha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>Cheney</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/jcheney/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamescheney/fad2c5e0-4605-4bd7-a0bb-aa02ec0b60ba/small.jpg</picture_url>
          <person_id>jamescheney</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vaishak</first_name>
          <last_name>Belle</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>vaishakbelle</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c8ba9b31-4faa-4f9b-bc7d-84a007267d47</subevent_id>
    <title>SPLASH OOPSLA: Type &amp; Verification</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>375e13b1-a4ff-4a0b-83a1-8c4345bbb63e</slot_id>
      <title>Session: SPLASH OOPSLA - Type &amp; Verification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7077477a-48ac-47b5-9afd-07cd438582ca</subevent_id>
    <title>SPLASH OOPSLA: Algorithms, Libraries and Databases</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>c5427d6f-d455-4a9c-864c-832c78628b9a</slot_id>
      <title>Session: SPLASH OOPSLA - Algorithms, Libraries and Databases</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a465fd04-171d-4b17-b5fe-87639ad89a49</subevent_id>
    <title>SPLASH OOPSLA: Corpus and User Studies</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8ff7ea6c-f67b-4823-a981-57063982013b</slot_id>
      <title>Session: SPLASH OOPSLA - Corpus and User Studies</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0ed7a3d2-ed91-4410-8c2d-765a5fda2e15</slot_id>
      <event_id>da83cec0-6c60-4185-8177-b65b19357468</event_id>
      <title>How Statically-Typed Functional Programmers Write Code</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>16:33</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>17:00</end_time>
      <description>How working statically-typed functional programmers write code is largely understudied. And yet, a better understanding of developer practices could pave the way for the design of more useful and usable tooling, more ergonomic languages, and more effective on-ramps into programming communities. The goal of this work is to address this knowledge gap: to better understand the high-level authoring patterns that statically-typed functional programmers employ. We conducted a grounded theory analysis of 30 programming sessions of practicing statically-typed functional programmers, 15 of which also included a semi-structured interview. The theory we developed gives insight into how the specific affordances of statically-typed functional programming affect domain modeling, type construction, focusing techniques, exploratory and reasoning strategies, and expressions of intent. We conducted a set of quantitative lab experiments to validate our findings, including that statically-typed functional programmers often iterate between editing types and expressions, that they often run their compiler on code they fully believed will not successfully compile, and that they often make textual program edits that reliably signal future edits that they intend to make. Lastly, we outline the implications of our findings for language and tool design. The success of this approach in revealing program authorship patterns suggests that the same methodology could be used to study other understudied programmer populations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Justin</first_name>
          <last_name>Lubin</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jlubin.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/justinlubin1/20ea84ad-9355-48d7-924c-af6d84fdb568/small.jpg</picture_url>
          <person_id>justinlubin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sarah E.</first_name>
          <last_name>Chasins</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~schasins/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sarahchasins/11334835-84ec-45c0-8ba1-2b87910eb7f7/small.jpg</picture_url>
          <person_id>sarahchasins</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4c1fdf43-3d85-4426-91b8-35dd7251488b</slot_id>
      <event_id>24a8f69d-0191-4166-b3f5-353579f8fe38</event_id>
      <title>What we Eval in the Shadows</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:06</end_time>
      <description>Most dynamic languages allow users to turn text into code using various functions, often named eval, with language-dependent semantics. The widespread use of these reflective functions hinders static analysis and prevents compilers from performing optimizations. This paper aims to provide a better sense of why programmers use eval. Understanding why eval is used in practice is key to finding ways to mitigate its negative impact. We have reasons to believe that reflective feature usage is language and application domain specific; we focus on data science code written in R, and compare our results to previous work that analyzed web programming in JavaScript. This paper studied 240,327 scripts extracted from 15,401 R packages, for a total of 49,296,059 calls to eval. We find that eval is indeed in widespread use; R’s eval is more pervasive and arguably dangerous than what was previously reported for JavaScript.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Donat-Bouillud</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.pdonatbouillud.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/pierredonatbouillud/3887f7f4-a8bf-4d04-af05-af6cd45e2423/small.jpg</picture_url>
          <person_id>pierredonatbouillud</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Filip</first_name>
          <last_name>Křikava</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fikovnik.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/filipkrikava/12cc1e57-732c-4b7e-880e-ca7b51a07d77/small.jpg</picture_url>
          <person_id>filipkrikava</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Kirsch</last_name>
          <affiliation>University of Salzburg</affiliation>
          <bio>Christoph Kirsch is Professor at the Department of Computer Sciences of the University of Salzburg, Austria. He received his Dr.Ing. degree from Saarland University in 1999 while at the Max Planck Institute for Computer Science in Saarbrücken, Germany. From 1999 to 2004 he worked as Postdoctoral Researcher at the Department of Electrical Engineering and Computer Sciences of the University of California, Berkeley. He later returned to Berkeley as Visiting Scholar (2008-2013) and Visiting Professor (2014) at the Department of Civil and Environmental Engineering. His research interests are in concurrent programming, memory management, virtualization, and formal verification. Dr. Kirsch co-invented embedded programming languages and systems such as Giotto, HTL, and the Embedded Machine, and more recently co-designed high-performance, multicore-scalable concurrent data structures and memory management systems. He co-founded the International Conference on Embedded Software (EMSOFT) in 2001 and served as ACM SIGBED chair from 2011 until 2013. He has been IEEE TCAD and ACM TODAES associate editor, and is ACM Distinguished Speaker since 2017.</bio>
          <homepage_url>http://cs.uni-salzburg.at/~ck</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophkirsch/2adc8995-a32a-49c9-b820-8427e5a1f25a/small.jpg</picture_url>
          <person_id>christophkirsch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>599a87fd-d2ee-4acc-a1af-ee71f0d4c090</slot_id>
      <event_id>75978bcc-89d2-43d2-9ca9-77bb20edeb87</event_id>
      <title>Well-Typed Programs Can Go Wrong: A Study of Typing-Related Bugs in JVM Compilers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>16:06</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:33</end_time>
      <description>Despite the substantial progress in compiler testing, the research endeavors have mainly focused on detecting compiler crashes and subtle miscompilations caused by bugs in the implementation of compiler optimizations. Surprisingly, this growing body of work neglects other compiler components, most notably the front-end. In statically-typed programming languages with rich and expressive type systems and modern features, such as type inference or a mix of object-oriented with functional programming features, the process of static typing in compiler front-ends is complicated by a high-density of bugs. Such bugs can lead to the acceptance of incorrect programs (breaking code portability or the type system’s soundness), the rejection of correct (e.g. well-typed) programs, and the reporting of misleading errors and warnings. 
We conduct, what is to the best of our knowledge, the first empirical study for understanding and characterizing typing-related compiler bugs. To do so, we manually study 320 typing-related bugs (along with their fixes and test cases) that are randomly sampled from four mainstream JVM languages, namely Java, Scala, Kotlin, and Groovy. We evaluate each bug in terms of several aspects, including their symptom, root cause, bug fix’s size, and the characteristics of the bug-revealing test cases. Some representative observations indicate that: 1) more than a half of the typing-related bugs manifest as unexpected compile-time errors: the buggy compiler wrongly rejects semantically correct programs, 2) the majority of typing-related bugs lie in the implementations of the underlying type systems and in other core components related to operations on types, 3) parametric polymorphism is the most pervasive feature in the corresponding test cases, 4) one third of typing-related bugs are triggered by non-compilable programs. 
We believe that our study opens up a new research direction by driving future researchers to build appropriate methods and techniques for a more holistic testing of compilers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefanos</first_name>
          <last_name>Chaliasos</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Stefanos Chaliasos is a PhD candidate advised by Dr Ben Livshits and Dr Arthur Gervais at Imperial College London. He holds an MSc in Computer Science from the National and Kapodistrian University of Athens and a BSc in Management Science and Technology from the Athens University of Economics and Business. He has previously worked in the industry as a software engineer at Greek Research and Technology Network (GRNET) and as a researcher in the FASTEN project. His main research interests involve Computer Security, Software Testing, Program Analysis, and Programming Languages.</bio>
          <homepage_url>https://stefanoschaliasos.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefanoschaliasos/abb30586-5ab6-4e4e-9363-d2604af831ec/small.jpg</picture_url>
          <person_id>stefanoschaliasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thodoris</first_name>
          <last_name>Sotiropoulos</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>Thodoris Sotiropoulos is a PhD candidate at the Department of Management Science and Technology. He holds an MSc with distinction in Advanced Computing from Imperial College London, and a BSc in Management Science and Technology from the Athens University of Economics and Business. He has previously worked in industry as a software engineer at the Greek Research and Technology Network (GRNET).</bio>
          <homepage_url>https://theosotr.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thodorissotiropoulos/9e48a9b1-ba8a-4565-97da-0ed90ead2047/small.jpg</picture_url>
          <person_id>thodorissotiropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Georgios-Petros</first_name>
          <last_name>Drosos</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/georgiospetrosdrosos/94bab4c6-9f9f-4a22-b4f7-b111515d1936/small.jpg</picture_url>
          <person_id>georgiospetrosdrosos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charalambos Ioannis</first_name>
          <last_name>Mitropoulos</last_name>
          <affiliation>Technical University of Crete</affiliation>
          <bio>undefined</bio>
          <person_id>charalambosioannismitropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Mitropoulos</last_name>
          <affiliation>National and Kapodistrian University of Athens</affiliation>
          <bio>Dimitris Mitropoulos is an Assistant Professor at the National and Kapodistrian University of Athens and the Head of Reliability Engineering at the Greek National Infrastructures for Research and Technology (GRNET). Previously, he has been a Postdoctoral Researcher at the Network Security Laboratory (NSL) of Columbia University in the City of New York. Dimitris holds a PhD in Computer Security from the Athens University of Economics and Business and has been involved in several EU and US funded R&amp;amp;D projects. His research interests include software engineering, computer security and software reliability. He is a member of ACM, IEEE, SysSec, and an official writer for the ACM Computing Reviews journal.</bio>
          <homepage_url>https://dimitro.gr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dimitrismitropoulos/a0d64ae8-d979-4ed9-a834-b808d3cc40d2/small.jpg</picture_url>
          <person_id>dimitrismitropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Diomidis</first_name>
          <last_name>Spinellis</last_name>
          <affiliation>Athens University of Economics and Business  &amp; TU Delft</affiliation>
          <bio>Diomidis Spinellis is Professor of Software Engineering in the Department of Management Science and Technology heading the Business Analytics Laboratory (BALab) at the Athens University of Economics and Business, Greece and Professor of Software Analytics in the Department of Software Technology at the Delft University of Technology. His research interests include software engineering, IT security, and computing systems. He has written two award-winning, widely-translated books: Code Reading and Code Quality: The Open Source Perspective. In 2016 he published the book Effective Debugging: 66 Specific Ways to Debug Software and Systems. Dr. Spinellis has also published more than 300 technical papers in journals and refereed conference proceedings, which have received more than 10500 citations. He served for a decade as a member of the IEEE Software editorial board, authoring the regular “Tools of the Trade” column and for four years at the magazine’s Editor in Chief. He has contributed code that ships with Apple’s macOS and BSD Unix and is the developer of CScout, UMLGraph, dgsh, and other open-source software packages, libraries, and tools. He holds an MEng in Software Engineering and a PhD in Computer Science, both from Imperial College London. Dr. Spinellis has served as an elected member of the IEEE Computer Society Board of Governors (2013–2015), and is a senior member of the ACM and the IEEE.</bio>
          <homepage_url>https://www.dmst.aueb.gr/dds</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/diomidisspinellis/a7f21db5-04c0-4282-85ab-614b4394c90a/small.jpg</picture_url>
          <person_id>diomidisspinellis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <timezone_id>America/Chicago</timezone_id>
</event>
