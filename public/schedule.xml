<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE event [<!ELEMENT zip_code (#PCDATA)><!ELEMENT url_link_display (#PCDATA)><!ELEMENT url (#PCDATA)><!ELEMENT tracks (track+)><!ELEMENT track (#PCDATA)><!ELEMENT title (#PCDATA)><!ELEMENT timeslot (slot_id?, event_id?, submission_id?, title, room, date, start_time, end_date?, end_time, description?, acm_doi?, persons?, tracks?, tags?, badges?)><!ATTLIST timeslot is_mirror CDATA #IMPLIED><!ELEMENT event_id (#PCDATA)><!ELEMENT submission_id (#PCDATA)><!ELEMENT tags (tag+)><!ELEMENT tag (#PCDATA)><!ELEMENT badges (badge+)><!ELEMENT badge (#PCDATA)><!ATTLIST badge property CDATA #IMPLIED><!ELEMENT suffix (#PCDATA)><!ELEMENT subevent_logo_url (#PCDATA)><!ELEMENT subevent_id (#PCDATA)><!ELEMENT subevent (subevent_id?, title, acronym?, subevent_type, description?, room, date, url?, url_link_display?, subevent_logo_url?, acm_doi?, persons?, tracks?, tags?, sponsor?, timeslot*)><!ELEMENT state (#PCDATA)><!ELEMENT start_time (#PCDATA)><!ELEMENT start_date (#PCDATA)><!ELEMENT sponsor (#PCDATA)><!ELEMENT sort_key (#PCDATA)><!ELEMENT slot_id (#PCDATA)><!ELEMENT subevent_type EMPTY><!ATTLIST subevent_type	type (case_study | demonstration | poster | regular | tutorial | workshop) #IMPLIED><!ELEMENT room (#PCDATA)><!ELEMENT role (#PCDATA)><!ELEMENT picture_url (#PCDATA)><!ELEMENT persons (person+)><!ELEMENT person (role, sort_key, first_name, middle_name?, last_name, suffix?, affiliation, acm_profile_id?, email?, bio?, homepage_url?, picture_url?, person_id?)><!ELEMENT person_id (#PCDATA)><!ELEMENT middle_name (#PCDATA)><!ELEMENT location (facility_name, facility_map_url?, address, city, state?, country, zip_code?)><!ELEMENT last_name (#PCDATA)><!ELEMENT homepage_url (#PCDATA)><!ELEMENT first_name (#PCDATA)><!ELEMENT facility_name (#PCDATA)><!ELEMENT facility_map_url (#PCDATA)><!ELEMENT event_type EMPTY><!ATTLIST event_type	type (conference|workshop|symposium) #IMPLIED><!ELEMENT event (event_details, subevent*, timeslot*, timezone_id?)><!ELEMENT timezone_id (#PCDATA)><!ELEMENT event_logo_url (#PCDATA)><!ELEMENT event_details (title, acronym, event_type, start_date, end_date, location, description, url?, url_link_display?, event_logo_url?, persons?)><!ELEMENT end_time (#PCDATA)><!ELEMENT end_date (#PCDATA)><!ELEMENT email (#PCDATA)><!ELEMENT description (#PCDATA)><!ELEMENT date (#PCDATA)><!ELEMENT country (#PCDATA)><!ELEMENT city (#PCDATA)><!ELEMENT bio (#PCDATA)><!ELEMENT affiliation (#PCDATA)><!ELEMENT address (#PCDATA)><!ELEMENT acronym (#PCDATA)><!ELEMENT acm_profile_id (#PCDATA)><!ELEMENT acm_doi (#PCDATA)>]>
<event>
  <event_details>
    <title>SPLASH 2021</title>
    <acronym>SPLASH 2021</acronym>
    <event_type type="conference"/>
    <start_date>2021/10/17</start_date>
    <end_date>2021/10/22</end_date>
    <location>
      <facility_name>Swissotel Chicago</facility_name>
      <address>323 East Wacker Drive</address>
      <city>Chicago</city>
      <state>Illinois</state>
      <country>United States</country>
    </location>
    <description>Welcome 
Welcome to SPLASH 2021, the ACM SIGPLAN conference on Systems, Programming, Languages, and Applications: Software for Humanity. SPLASH embraces all aspects of software construction and delivery, to make it the premier conference on the applications of programming languages—at the intersection of programming languages and software engineering. SPLASH takes place Sunday October 17th to Friday 22th. 
SPLASH 2021 registration is now open. Please register using this online registration form. If you are planning to attend SPLASH 2021 in Chicago please register NOW. COVID-19 vaccination verification can take up to 24 hours. In person attendees will not be admitted until their vaccination is verified. 
SPLASH 2021 will require in-person attendees to be fully vaccinated, as defined by the Center for Disease Control (CDC). According to the CDC, attendees “are considered fully vaccinated (a) 2 weeks after their second dose in a 2-dose series, such as the Pfizer or Moderna vaccines, or (b) 2 weeks after a single-dose vaccine, such as Johnson &amp;amp; Johnson’s Janssen vaccine. If you don’t meet these requirements, regardless of your age, you are NOT fully vaccinated.” SPLASH 2021 will offer virtual attendance options for those individuals who are not fully vaccinated. Vaccination validation will be conducted by a vendor contracted by the ACM to perform this validation for the SPLASH 2021 conference. Masks are required at SPLASH 2021. 
The virtual attendance option is available to unvaccinated attendees. 
SPLASH 2021 will be held at the Swissotel Chicago. We have arranged for a room rate of $209+ per night. The conference rate applies from October 14th to October 24th. Outside of those dates, you will have to make a separate booking. To book use the following link: Reservations for Splash 2021</description>
    <url>https://2021.splashcon.org</url>
    <url_link_display>SPLASH 2021</url_link_display>
    <persons>
      <person>
        <role>Committee Member in Steering Committee, General Chair in Organizing Committee</role>
        <sort_key>1</sort_key>
        <first_name>Hridesh</first_name>
        <last_name>Rajan</last_name>
        <affiliation>Iowa State University</affiliation>
        <bio>Hridesh Rajan is a Professor and Chair of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the department chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a AAAS fellow, a distinguished member of the ACM, and a member of IEEE. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
        <homepage_url>https://hridesh.github.io</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
        <person_id>hrideshrajan</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee, OOPSLA Review Committee Chair in Organizing Committee</role>
        <sort_key>2</sort_key>
        <first_name>Sophia</first_name>
        <last_name>Drossopoulou</last_name>
        <affiliation>Facebook and Imperial College London</affiliation>
        <bio>I am leading the London Probable team at Facebook, and a Professor of Programming Languages at the Department of Computing, Imperial College, London, UK.</bio>
        <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
        <person_id>sophiadrossopoulou</person_id>
      </person>
      <person>
        <role>Chair in Steering Committee, SLE General Chair in Organizing Committee</role>
        <sort_key>3</sort_key>
        <first_name>Eelco</first_name>
        <last_name>Visser</last_name>
        <affiliation>Delft University of Technology</affiliation>
        <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science and chair of the Programming Languages Group at Delft University of Technology. His current research is on the foundation and implementation of declarative specification of programming languages. He studied at the University of Amsterdam (master 1993; doctorate 1997), and worked at the Oregon Graduate Institute (postdoc 1997-1998), Utrecht University (assistant professor 1998-2006), and TU Delft (associate professor 2006-2013, full professor since 2013). 
His research interests include (domain-specific) programming languages, language engineering, program transformation, and declarative language definition. With his students he has designed and implemented the Spoofax language workbench, as well as several domain-specific languages, including DSLs for syntax definition (SDF3), program transformation (Stratego), static semantics (Statix), software deployment (Nix), and web application development (WebDSL). Applications of WebDSL include the researchr conference hosting site and the WebLab learning management system.</bio>
        <homepage_url>http://eelcovisser.org</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
        <person_id>eelcovisser</person_id>
      </person>
      <person>
        <role>Hybridization Co-Chair in Organizing Committee</role>
        <sort_key>4</sort_key>
        <first_name>Jonathan</first_name>
        <last_name>Aldrich</last_name>
        <affiliation>Carnegie Mellon University</affiliation>
        <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
        <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
        <person_id>jonathanaldrich</person_id>
      </person>
      <person>
        <role>Hybridization Co-Chair in Organizing Committee</role>
        <sort_key>5</sort_key>
        <first_name>Steve</first_name>
        <last_name>Blackburn</last_name>
        <affiliation>Australian National University</affiliation>
        <bio>My research interests are centered on the challenge of making software run faster and more power-efficiently on modern hardware. My primary interests include: microarchitectural support for managed languages, fast and efficient garbage collection, and the design and implementation of virtual machines. As a backdrop to this I have a longstanding interest in role of sound methodology and infrastructure in successful research innovation.</bio>
        <homepage_url>http://users.cecs.anu.edu.au/~steveb/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/steveblackburn/1deee732-405d-4403-a974-a418751399c2/small.jpg</picture_url>
        <person_id>steveblackburn</person_id>
      </person>
      <person>
        <role>Hybridization and Video Co-Chair in Organizing Committee</role>
        <sort_key>6</sort_key>
        <first_name>Benjamin</first_name>
        <last_name>Chung</last_name>
        <affiliation>Northeastern University</affiliation>
        <bio>undefined</bio>
        <picture_url>https://2021.splashcon.org/getProfileImage/benjaminchung/30978af0-bcee-4c1e-9dd1-f2588ea14f38/small.jpg</picture_url>
        <person_id>benjaminchung</person_id>
      </person>
      <person>
        <role>Hybridization Co-Chair in Organizing Committee</role>
        <sort_key>7</sort_key>
        <first_name>Youyou</first_name>
        <last_name>Cong</last_name>
        <affiliation>Tokyo Institute of Technology</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://prg.is.titech.ac.jp/people/cong/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/youyoucong/55f54fd9-cac5-44ae-93c1-921409269efc/small.jpg</picture_url>
        <person_id>youyoucong</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee, Hybridization Co-Chair in Organizing Committee</role>
        <sort_key>8</sort_key>
        <first_name>Alex</first_name>
        <last_name>Potanin</last_name>
        <affiliation>Victoria University of Wellington</affiliation>
        <bio>I am an Associate Professor in the School of Engineering and Computer Science at Victoria University of Wellington, New Zealand. 
I am originally from Moscow, Russia with a background in Mathematics. I have completed my PhD in programming languages in 2006 and took up a job as a Lecturer in Software Engineering at Victoria University of Wellington. During my studies, I took short breaks to work as a Visiting Researcher at Purdue University, and Software Engineer at two Wellington start-ups. I spent 2013 on sabbatical at Carnegie Mellon University in Pittsburgh, PA, USA. I spent winter 2019/2020 on sabbatical at Kyoto University in Japan.</bio>
        <homepage_url>http://homepages.ecs.vuw.ac.nz/~alex/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/alexpotanin/614f887b-90a3-4626-b67d-fa63309b44c8/small.jpg</picture_url>
        <person_id>alexpotanin</person_id>
      </person>
      <person>
        <role>Hybridization Co-Chair in Organizing Committee</role>
        <sort_key>9</sort_key>
        <first_name>Talia</first_name>
        <last_name>Ringer</last_name>
        <affiliation>University of Illinois at Urbana-Champaign</affiliation>
        <bio>I am an incoming assistant professor at University of Illinois at Urbana-Champaign. My main interest is in making program verification using interactive theorem provers more accessible through better proof engineering tools and practices, especially when it comes to maintaining proofs as programs change over time. My vision is a future of verification that is accessible to all programmers, not just to experts. I got my Ph.D. from University of Washington in June 2021, where I was an NSF GRFP fellow and a P.E.O fellow. Prior to graduate school, I earned my bachelor’s in mathematics and computer science from University of Maryland, then worked at Amazon as a software engineer for three years. I am the founder and chair of the SIGPLAN-M mentoring program, and a contributor to the Coq interactive theorem prover. 
Oh, and I am currently looking for students! Please apply!</bio>
        <homepage_url>https://dependenttyp.es</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/taliaringer/1a95a492-cf5a-4225-8efb-ac834a36fa16/small.jpg</picture_url>
        <person_id>taliaringer</person_id>
      </person>
      <person>
        <role>Onward! Essays Chair in Organizing Committee</role>
        <sort_key>10</sort_key>
        <first_name>Elisa</first_name>
        <last_name>Baniassad</last_name>
        <affiliation>University of British Columbia</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.ubc.ca/~ebani</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/elisabaniassad/ebb453ca-88ce-4678-823e-82b113c14751/small.jpg</picture_url>
        <person_id>elisabaniassad</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee, Onward! Papers Chair in Organizing Committee</role>
        <sort_key>11</sort_key>
        <first_name>Wolfgang</first_name>
        <last_name>De Meuter</last_name>
        <affiliation>Vrije Universiteit Brussel</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/wolfgangdemeuter/cb721b79-a1aa-4583-8ba0-b1a96f896900/small.jpg</picture_url>
        <person_id>wolfgangdemeuter</person_id>
      </person>
      <person>
        <role>DLS Chair in Organizing Committee</role>
        <sort_key>12</sort_key>
        <first_name>Arjun</first_name>
        <last_name>Guha</last_name>
        <affiliation>Northeastern University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
        <person_id>arjunguha</person_id>
      </person>
      <person>
        <role>SPLASH-E Co-Chair in Organizing Committee</role>
        <sort_key>13</sort_key>
        <first_name>Charlie</first_name>
        <last_name>Curtsinger</last_name>
        <affiliation>Grinnell College</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://ccurtsinger.net</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/charliecurtsinger/e779a4c9-ade3-4073-b660-866046d6c953/small.jpg</picture_url>
        <person_id>charliecurtsinger</person_id>
      </person>
      <person>
        <role>SPLASH-E Co-Chair in Organizing Committee</role>
        <sort_key>14</sort_key>
        <first_name>Tien N.</first_name>
        <last_name>Nguyen</last_name>
        <affiliation>University of Texas at Dallas</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.utdallas.edu/~tien.n.nguyen/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/tiennguyen/10e4533a-6059-499a-aa1c-a76131caeae5/small.jpg</picture_url>
        <person_id>tiennguyen</person_id>
      </person>
      <person>
        <role>Doctoral Symposium Chair in Organizing Committee</role>
        <sort_key>15</sort_key>
        <first_name>Robert</first_name>
        <last_name>Dyer</last_name>
        <affiliation>University of Nebraska-Lincoln</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://go.unl.edu/rdyer</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/robertdyer/774d6fd8-9a08-4c37-9113-f0bc0c5fb833/small.jpg</picture_url>
        <person_id>robertdyer</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee, Rebase Chair in Organizing Committee</role>
        <sort_key>16</sort_key>
        <first_name>Jan</first_name>
        <last_name>Vitek</last_name>
        <affiliation>Northeastern University / Czech Technical University</affiliation>
        <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
        <homepage_url>http://janvitek.org</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
        <person_id>janvitek</person_id>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>17</sort_key>
        <first_name>Mehdi</first_name>
        <last_name>Bagherzadeh</last_name>
        <affiliation>Oakland University</affiliation>
        <bio>Assistant Professor, Department of Computer Science and Engineering</bio>
        <homepage_url>https://mbagherz.bitbucket.io/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/mehdibagherzadeh/95dc6f53-51a0-4bf1-b822-7bbe8c4d223a/small.jpg</picture_url>
        <person_id>mehdibagherzadeh</person_id>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>18</sort_key>
        <first_name>Raffi</first_name>
        <last_name>Khatchadourian</last_name>
        <affiliation>CUNY Hunter College</affiliation>
        <bio>I am an Assistant Professor in the Department of Computer Science at Hunter College and the Graduate Center of the City University of New York (CUNY). My research is centered on techniques for automated software evolution, particularly those related to automated refactoring and source code recommendation systems. My goal is to ease the burden associated with correctly and efficiently evolving large and complex software by providing automated tools that can be easily used by developers. I am also interested in the automated analysis of Object-Oriented programs. 
I received my MS and Ph.D. degrees in Computer Science from Ohio State University and my BS degree in Computer Science from Monmouth University in New Jersey. Prior to joining CUNY, I was a Software Engineer at Apple, Inc. in Cupertino, California, where I worked on Digital Rights Management (DRM) for iTunes, iBooks, and the App Store. I also developed distributed software that tested various features of iPhones, iPads, and iPods. You may also find more information about me by visiting my CUNY Academic Commons profile, my vita, GitHub, and my blog (you can subscribe for updates here).</bio>
        <homepage_url>http://cs.hunter.cuny.edu/~Raffi.Khatchadourian99</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/raffikhatchadourian/5c884f46-e4aa-4dc5-b581-2e37f77d320a/small.jpg</picture_url>
        <person_id>raffikhatchadourian</person_id>
      </person>
      <person>
        <role>Student Research Competition Co-Chair in Organizing Committee</role>
        <sort_key>19</sort_key>
        <first_name>Julia</first_name>
        <last_name>Rubin</last_name>
        <affiliation>University of British Columbia</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.ece.ubc.ca/~mjulia/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/juliarubin/5846079d-0c90-4d9a-8f16-eef07002e37d/small.jpg</picture_url>
        <person_id>juliarubin</person_id>
      </person>
      <person>
        <role>Student Research Competition Co-Chair in Organizing Committee</role>
        <sort_key>20</sort_key>
        <first_name>Caterina</first_name>
        <last_name>Urban</last_name>
        <affiliation>INRIA &amp; École Normale Supérieure | Université PSL</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://caterinaurban.github.io</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/caterinaurban1/a945f9bd-bc13-4fe2-945a-59528d7d7e2a/small.jpg</picture_url>
        <person_id>caterinaurban1</person_id>
      </person>
      <person>
        <role>Publicity Chair in Organizing Committee</role>
        <sort_key>21</sort_key>
        <first_name>Juan</first_name>
        <last_name>Fumero</last_name>
        <affiliation>University of Manchester, UK</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://jjfumero.github.io</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/juanfumero/e76896d1-7e40-4e77-859f-dc51392013a2/small.jpg</picture_url>
        <person_id>juanfumero</person_id>
      </person>
      <person>
        <role>Web Chair in Organizing Committee</role>
        <sort_key>22</sort_key>
        <first_name>Rangeet</first_name>
        <last_name>Pan</last_name>
        <affiliation>Iowa State University, USA</affiliation>
        <bio>Rangeet Pan is a Ph.D. candidate at Iowa State University. His research interests include program analysis, machine learning, and software engineering. He has published works at ESEC/FSE and ICSE.</bio>
        <homepage_url>https://rangeetpan.github.io/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/rangeetpan/3f0551cd-7e73-4053-bb36-66f8d05daae5/small.jpg</picture_url>
        <person_id>rangeetpan</person_id>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>23</sort_key>
        <first_name>Breno</first_name>
        <last_name>Dantas Cruz</last_name>
        <affiliation>Iowa State University, USA</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://people.cs.vt.edu/~bdantasc/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/brenodantascruz/7407f1b4-cf3d-4a2e-8c5e-3a49f0405e8f/small.jpg</picture_url>
        <person_id>brenodantascruz</person_id>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>24</sort_key>
        <first_name>Samantha Syeda</first_name>
        <last_name>Khairunnesa</last_name>
        <affiliation>Florida Gulf Coast University</affiliation>
        <bio>Samantha Syeda Khairunnesa, Ph.D., is the Assistant Professor in the Department of Software Engineering at Florida Gulf Coast University, where she has been since August 2021. She earned her Ph.D. in Computer Science from Iowa State University in August 2021. She specializes in software engineering, programming languages, and machine learning.</bio>
        <homepage_url>https://www.linkedin.com/in/samantha-syeda/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/samanthasyedakhairunnesa/23aa8334-ebf0-4967-b8ab-6d4cbf1509c5/small.jpg</picture_url>
        <person_id>samanthasyedakhairunnesa</person_id>
      </person>
      <person>
        <role>Sponsorship Co-Chair in Organizing Committee</role>
        <sort_key>25</sort_key>
        <first_name>Ganesha</first_name>
        <last_name>Upadhyaya</last_name>
        <affiliation>Harmony.one</affiliation>
        <bio>I am currently a Research Engineer at Harmony.one, Mountain View, CA. I work on blockchain network, protocol, and smart contract verification. Previously, I was a Senior Staff Researcher at Futurewei Technologies (Huawei R&amp;amp;D), Champaign, IL, where I worked on researching and developing compiler, runtime, and frameworks for Huawei’s mobile, cloud, and IoT solutions. In addition, impactful software engineering research has always been my passion.</bio>
        <homepage_url>http://web.cs.iastate.edu/~ganeshau/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/ganeshaupadhyaya/e4cda76a-77e7-4064-a67e-a85da0616702/small.jpg</picture_url>
        <person_id>ganeshaupadhyaya</person_id>
      </person>
      <person>
        <role>Poster Co-Chair in Organizing Committee</role>
        <sort_key>26</sort_key>
        <first_name>Christos</first_name>
        <last_name>Dimoulas</last_name>
        <affiliation>PLT @ Northwestern University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://users.eecs.northwestern.edu/~chrdimo/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/christosdimoulas1/b0a0a408-c992-49cf-99f4-39e30fe9ce1d/small.jpg</picture_url>
        <person_id>christosdimoulas1</person_id>
      </person>
      <person>
        <role>Poster Co-Chair in Organizing Committee</role>
        <sort_key>27</sort_key>
        <first_name>Murali</first_name>
        <last_name>Krishna Ramanathan</last_name>
        <affiliation>Uber Technologies Inc.</affiliation>
        <bio>Murali Krishna Ramanathan is a Staff Software Engineer at Uber Technologies Inc. Previously, he was affiliated with IISc, Bangalore and Coverity Inc. He has designed and implemented several novel program analysis tools for detecting software bugs. He received his PhD in Computer Science from Purdue University.</bio>
        <homepage_url>https://sites.google.com/view/mkramanathan/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/muralikrishnaramanathan/52304999-046a-4d35-a2ed-9eb9ca2db709/small.jpg</picture_url>
        <person_id>muralikrishnaramanathan</person_id>
      </person>
      <person>
        <role>Publications Chair in Organizing Committee</role>
        <sort_key>28</sort_key>
        <first_name>Saba</first_name>
        <last_name>Alimadadi</last_name>
        <affiliation>Simon Fraser University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://ece.ubc.ca/~saba/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/sabaalimadadi/fb15cf5f-b2f9-4ff5-84d1-1b5aa9be2378/small.jpg</picture_url>
        <person_id>sabaalimadadi</person_id>
      </person>
      <person>
        <role>Artifact Evaluation Co-Chair in Organizing Committee</role>
        <sort_key>29</sort_key>
        <first_name>Colin</first_name>
        <last_name>Gordon</last_name>
        <affiliation>Drexel University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
        <person_id>colingordon</person_id>
      </person>
      <person>
        <role>Artifact Evaluation Co-Chair in Organizing Committee</role>
        <sort_key>30</sort_key>
        <first_name>Ana</first_name>
        <last_name>Milanova</last_name>
        <affiliation>Rensselaer Polytechnic Institute</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.rpi.edu/~milanova/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/anamilanova/4fa9038c-d0e6-44ca-b1b7-2420329714f4/small.jpg</picture_url>
        <person_id>anamilanova</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee, Artifact Evaluation Co-Chair in Organizing Committee</role>
        <sort_key>31</sort_key>
        <first_name>Anders</first_name>
        <last_name>Møller</last_name>
        <affiliation>Aarhus University</affiliation>
        <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
        <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
        <person_id>andersmoller</person_id>
      </person>
      <person>
        <role>Accessibility Chair in Organizing Committee</role>
        <sort_key>32</sort_key>
        <first_name>Sumon</first_name>
        <last_name>Biswas</last_name>
        <affiliation>Iowa State University, USA</affiliation>
        <bio>I am a computer science Ph.D. candidate at Iowa State University and Research Assistant at Laboratory of Software Design at ISU under the supervision of Hridesh Rajan. My research interests are in the intersection of Software Engineering, Programming languages, and Artificial Intelligence. I worked on large-scale program analysis using the Boa framework. I also worked on building Python language support for Boa to analyze machine learning (ML) programs.&amp;nbsp;Currently, I am&amp;nbsp;working in the&amp;nbsp;D4 (Dependable Data-Driven Discovery) project and focusing on increasing the dependability of data-driven software. Specifically, I am conducting research on improving the fairness of machine learning models.</bio>
        <homepage_url>https://sumonbis.github.io/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/sumonbiswas/7a793cc7-0e7e-4dca-8729-e35e8f495ff8/small.jpg</picture_url>
        <person_id>sumonbiswas</person_id>
      </person>
      <person>
        <role>Video Co-Chair in Organizing Committee</role>
        <sort_key>33</sort_key>
        <first_name>Leif</first_name>
        <last_name>Andersen</last_name>
        <affiliation>Northeastern University</affiliation>
        <bio>undefined</bio>
        <picture_url>https://2021.splashcon.org/getProfileImage/leifandersen/022e7f05-2a9a-4e3d-8be9-418b798e00c0/small.jpg</picture_url>
        <person_id>leifandersen</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>34</sort_key>
        <first_name>Jeffrey S.</first_name>
        <last_name>Foster</last_name>
        <affiliation>Tufts University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.cs.tufts.edu/~jfoster/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/jeffreysfoster/b22ce952-32b0-48bd-be56-12fd87bf3469/small.jpg</picture_url>
        <person_id>jeffreysfoster</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>35</sort_key>
        <first_name>Elisa</first_name>
        <last_name>Gonzalez Boix</last_name>
        <affiliation>Vrije Universiteit Brussel</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/elisagonzalezboix/51a3d0ba-7330-40d4-ad16-4568d31fe2e4/small.jpg</picture_url>
        <person_id>elisagonzalezboix</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>36</sort_key>
        <first_name>David</first_name>
        <last_name>Grove</last_name>
        <affiliation>IBM Research</affiliation>
        <bio>I am a Distinguished Research Staff Member at the IBM T.J. Watson Research Center. I joined IBM Research in 1998 after completing my PhD at the University of Washington. I am a software systems researcher, working primarily on problems in programming language implementation and scalable runtime systems. 
I have contributed to a number of technical topics in programming language design and implementation including the analysis and optimization of object-oriented languages, virtual machine design and implementation, scalable runtime systems, Just-In-Time compilation, online feedback-directed optimization, and garbage collection.</bio>
        <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-groved</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/davidgrove/5524049e-7d0a-4799-ad8c-93e1e76a77ec/small.jpg</picture_url>
        <person_id>davidgrove</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>37</sort_key>
        <first_name>Tony</first_name>
        <last_name>Hosking</last_name>
        <affiliation>Australian National University</affiliation>
        <bio>I am Professor and Director of the School of Computing at the Australian National University. I previously spent 22 years on the faculty at Purdue University. I studied computer science at the University of Adelaide, the University of Waikato, and the University of Massachusetts at Amherst, receiving BSc, MSc, and PhD degrees, respectively. My research interests lie in the area of programming language implementation, and I work on problems arising in object persistence, object databases, distribution, memory management (garbage collection), managed language runtimes, language virtual machines, optimizing compilers, and architectural support for programming languages and applications. 
I am a Life Member of the Association for Computing Machinery and a Member of the IEEE. I was named a Distinguished Scientist of the ACM in 2012.</bio>
        <homepage_url>https://hosking.github.io</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/tonyhosking/6d43d7a0-6e7b-47fe-8081-e4ae5207cda1/small.jpg</picture_url>
        <person_id>tonyhosking</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>38</sort_key>
        <first_name>Stephen</first_name>
        <last_name>Kell</last_name>
        <affiliation>King's College London</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cl.cam.ac.uk/users/srk31</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/stephenkell/53088184-3e8c-4a2c-b34f-b2a290cff411/small.jpg</picture_url>
        <person_id>stephenkell</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>39</sort_key>
        <first_name>Hidehiko</first_name>
        <last_name>Masuhara</last_name>
        <affiliation>Tokyo Institute of Technology</affiliation>
        <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
        <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
        <person_id>hidehikomasuhara</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>40</sort_key>
        <first_name>Yannis</first_name>
        <last_name>Smaragdakis</last_name>
        <affiliation>University of Athens</affiliation>
        <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
        <homepage_url>http://smaragd.org/</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
        <person_id>yannissmaragdakis</person_id>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>41</sort_key>
        <first_name>Manu</first_name>
        <last_name>Sridharan</last_name>
        <affiliation>University of California at Riverside</affiliation>
        <bio>I’m an associate professor at the University of California, Riverside. Previously I worked at IBM Research, Samsung Research, and Uber. My research focuses on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
        <homepage_url>http://manu.sridharan.net</homepage_url>
        <picture_url>https://2021.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
        <person_id>manusridharan</person_id>
      </person>
      <person>
        <role>SIGPLAN Conference Manager in Organizing Committee</role>
        <sort_key>42</sort_key>
        <first_name>Neringa</first_name>
        <last_name>Young</last_name>
        <affiliation>undefined</affiliation>
        <bio>undefined</bio>
        <picture_url>https://2021.splashcon.org/getProfileImage/neringayoung/76e430ed-594f-431f-83fe-5bc632116ade/small.jpg</picture_url>
        <person_id>neringayoung</person_id>
      </person>
    </persons>
  </event_details>
  <subevent>
    <subevent_id>f9ef8e04-130e-4ecd-9317-4548cc16e943</subevent_id>
    <title>SPLASH Closing: Closing Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-closing</url>
    <url_link_display>Closing</url_link_display>
    <tracks>
      <track>Closing</track>
    </tracks>
    <timeslot>
      <slot_id>39bf9ca7-fac1-405a-bddf-d3075d3c2070</slot_id>
      <title>Session: SPLASH Closing - Closing Session</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>15:10</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Closing</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8acee41e-5de3-49aa-b741-83d4e938b8cf</slot_id>
      <event_id>6a7aa849-d624-401f-89d1-bcd47a266aaf</event_id>
      <title>Ice Cream Social</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>15:10</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hridesh</first_name>
          <last_name>Rajan</last_name>
          <affiliation>Iowa State University</affiliation>
          <bio>Hridesh Rajan is a Professor and Chair of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the department chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a AAAS fellow, a distinguished member of the ACM, and a member of IEEE. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
          <homepage_url>https://hridesh.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
          <person_id>hrideshrajan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Closing</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>45c119d9-22f4-4958-92de-4a8c4c79d2cc</subevent_id>
    <title>SPLASH Faculty Mentorship Roundtable: Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-faculty-mentorship-roundtable</url>
    <url_link_display>Faculty Mentorship Roundtable</url_link_display>
    <tracks>
      <track>Faculty Mentorship Roundtable</track>
    </tracks>
    <timeslot>
      <slot_id>215e3d43-9a66-479b-a581-8b1e8090dfb7</slot_id>
      <title>Session: SPLASH Faculty Mentorship Roundtable - Session 1</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>12:10</start_time>
      <end_time>13:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Danny</first_name>
          <last_name>Dig</last_name>
          <affiliation>University of Colorado Boulder, USA</affiliation>
          <bio>Danny Dig is an associate professor of computer science at the University of Colorado, and an adjunct professor at University of Illinois and Oregon State. He enjoys doing research in Software Engineering, with a focus on interactive program transformations that improve programmer productivity and software quality. He successfully pioneered interactive program transformations by opening the field of refactoring in cutting-edge domains including mobile, concurrency and parallelism, component-based, testing, and end-user programming. He earned his Ph.D. from the University of Illinois at Urbana-Champaign where his research won the best Ph.D. dissertation award, and the First Prize at the ACM Student Research Competition Grand Finals. He did a postdoc at MIT. 
He (co-)authored 50+ journal and conference papers that appeared in top places in SE/PL. According to Google Scholar his publications have been cited 4200+ times. His research was recognized with 8 best paper awards at the flagship and top conferences in SE (FSE’17, ICSME’17, FSE’16, ICSE’14, ISSTA’13, ICST’13, ICSME’15), 4 award runner-ups, and 1 most influential paper award (N-10 years) at ICSME’15. He received the NSF CAREER award, the Google Faculty Research Award (twice), and the Microsoft Software Engineering Innovation Award (twice). He released 9 software systems, among them the world’s first open-source refactoring tool. Some of the techniques he developed are shipping with the official release of the popular Eclipse, NetBeans, and Visual Studio development environments (of which Eclipse alone had more than 14M downloads in 2014). He has started two popular workshops: Workshop on Refactoring Tools, and Hot Topics On Software Upgrades, both had at least five instances. He chaired or co-organized 14 workshops and 1 conference (MobileSoft’15), and served as a member of 35 program committees for all top conferences in his area. His research is funded by NSF, Boeing, IBM, Intel, Google, and Microsoft.</bio>
          <homepage_url>https://danny.cs.colorado.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dannydig/7a07eb43-bd7e-4d6b-89b6-8e63f48a1245/small.jpg</picture_url>
          <person_id>dannydig</person_id>
        </person>
      </persons>
      <tracks>
        <track>Faculty Mentorship Roundtable</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9c8f92db-322b-4ef1-a7ca-99b7ddbda0f5</slot_id>
      <event_id>c8f61496-eff5-49ae-bc48-295360d4799b</event_id>
      <title>Faculty Mentoring Roundtable</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>12:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>13:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>Faculty Mentorship Roundtable</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5fa938e0-94a7-4ec9-852b-e5202e155260</subevent_id>
    <title>SPLASH CARES: CARES</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-cares</url>
    <url_link_display>CARES</url_link_display>
    <tracks>
      <track>CARES</track>
    </tracks>
    <timeslot>
      <slot_id>c1275a32-6861-4e3a-a081-fc1be0b5940c</slot_id>
      <title>Session: SPLASH CARES - CARES</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Michelle</first_name>
          <last_name>Strout</last_name>
          <affiliation>University of Arizona</affiliation>
          <bio>Michelle has been a professor in the Department of Computer Science at the University of Arizona since August 2015. Prof. Strout’s main research area is high performance computing and her research interests include compilers and run-time systems, scientific computing, and software engineering. She earned her Ph.D. at the University of California, San Diego in 2003 with Jeanne Ferrante and Larry Carter as co-advisors. In 2008, Michelle received a CAREER Award from the National Science Foundation for her research in parallelization techniques for irregular applications, such as molecular dynamics simulations. In 2010, she received a DOE Early Career award to fund her research in separating the specification of scientific computing applications from the specification of implementation details such as how to parallelize such computations. Some of Prof. Strout’s research contributions include the Universal Occupancy Vector (UOV) for determining storage mappings for any legal schedule in a stencil computation, the Sparse Polyhedral Framework (SPF) for specifying inspector-executor loop transformations, dataflow analysis for MPI programs, parameterized and full versus partial tiling with the outset and insets, and loop chaining for scheduling across stencil loops.</bio>
          <homepage_url>http://www.cs.arizona.edu/~mstrout</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michellestrout/c14a9580-04a0-4c82-8380-bb666b61acf2/small.jpg</picture_url>
          <person_id>michellestrout</person_id>
        </person>
      </persons>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88544cf7-e3ca-4147-9fa0-e6cc2e041416</slot_id>
      <event_id>8c7c4f57-9211-4101-9ca3-a911bb1691df</event_id>
      <title>CARES Session</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>CARES</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>80ee839a-be36-4bc7-b409-d4421a727a4d</subevent_id>
    <title>SPLASH Student Research Competition: Posters</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>838483d2-4d30-40b4-965c-e2bf63232760</slot_id>
      <title>Session: SPLASH Student Research Competition - Posters</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2b32721e-1c4c-4e71-8e8e-d9db3466a025</slot_id>
      <event_id>85c599e1-d96a-411f-a451-b415c2a66022</event_id>
      <title>Implementation of an End-to-End Gradual Verification System</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>Static verification is used to ensure the correctness of programs. While useful in critical applications, the high overhead associated with writing specifications limits its general applicability. Similarly, the run-time costs introduced by dynamic verification limit its practicality. Gradual verification validates partially-specified code statically where possible and dynamically where necessary. As a result, software developers gain granular control over the trade-offs between static and dynamic verification. This paper contains an end-to-end presentation of gradual verification in action, with a focus on implementing the required dynamic verification and applying it to C0, a safe subset of C.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hemant</first_name>
          <last_name>Gouni</last_name>
          <affiliation>University of Minnesota, Twin Cities</affiliation>
          <bio>undefined</bio>
          <person_id>hemantgouni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Conrad</first_name>
          <last_name>Zimmerman</last_name>
          <affiliation>Brown University</affiliation>
          <bio>undefined</bio>
          <person_id>conradzimmerman</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>406d7711-ca24-4a8d-81d9-beb408639ee8</slot_id>
      <event_id>4110f3c6-8b43-4fd9-be43-e418a341f9f8</event_id>
      <title>Towards Decidable and Expressive DOT</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>Dependent Object Types (DOT) allows mostly object oriented languages to bring in functional features and the higher expressivity of bounds on types. However, this increase in expressivity leads to DOT systems being undecidable. While decidability may be a reasonable sacrifice to make in exchange for greatly increased expressivity, having a type checker that is guaranteed to terminate while maintaining a high degree of expressivity can be beneficial. Over the last few years there have been several papers and theses written describing decidable variants of DOT. Julian Mackay et al. present one such decidable variant in their 2020 paper. Yu Xiang Zhu presents another variant in his 2019 masters thesis describing Nominal Wyvern, a variant of the DOT based programming language Wyvern. Most practical languages use nominality for recursive types which comes with benefits such as more local error messages. Due to this, we chose to focus on increasing the expressivity of Zhu’s variant for this paper. However, both Zhu’s and Mackay’s variants present the same challenges in limitations on expressivity.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Roshal</last_name>
          <affiliation>Cornell University, Carnegie Mellon University (Institute for Software Research)</affiliation>
          <bio>undefined</bio>
          <person_id>sophiaroshal</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>55b5ee6b-e8eb-4616-9c07-34ef958ee644</slot_id>
      <event_id>5306e012-55f6-46a1-9f31-2383635e4404</event_id>
      <title>Programming-By-Example by Programming-By-Example: Synthesis of Looping Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shmuel</first_name>
          <last_name>Berman</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>shmuelberman</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5a2ab465-ae05-48a0-bb60-4b3ce8303b97</slot_id>
      <event_id>13cee821-35d0-46ba-9ddb-745a1cc31c4f</event_id>
      <title>Avoiding Monomorphization Bottlenecks with Phase-based Splitting</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>State-of-the-art managed runtimes apply aggressive optimizations often based on the speculative assumption that programs have low variability. However, the behaviour of programs may evolve over time and literature shows that programs are likely to experience different execution “phases”, i.e. intervals of time displaying an homogeneous behaviour. Taking such phases into account may further improve performance when applied to phase-sensitive optimizations such as lookup caches, that may contain entries that are phase-specific. In this paper, we introduce Phase-based splitting, an experimental compiler optimization that utilizes phase insight to guide monomorphization based on splitting. Preliminary results show speedups ranging from 10 to 20% on average, peaking up to 47.6% at phase granularity.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sophie</first_name>
          <last_name>Kaleba</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/sophiekaleba/83d4bbee-60e2-41f8-a354-707df6642dc8/small.jpg</picture_url>
          <person_id>sophiekaleba</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>66f03b4a-6dc9-4ed9-b7ec-d8b551c8fdba</slot_id>
      <event_id>5fc3df79-877d-49fa-92b9-8769711d1edd</event_id>
      <title>A Study of Call Graph Effectiveness for Framework-Based Web Applications</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>The world of modern web applications is continuously evolving and getting increasingly reliant on web frameworks to support their ever-changing fast-paced needs. This necessitates the realization of efficient static analysis methodologies for the purpose of bug finding and security auditing of such applications. Moreover, the majority of these frameworks are written in JavaScript, which itself is difficult to analyze due to its extremely dynamic nature. The primary goal of this work is to study the effectiveness of the present state-of-the-art call graph approaches for JavaScript and propose techniques to enhance them such that they discover more of the crucial functions and call edges in modern, framework-based JavaScript applications. Ideally, these new techniques must enhance function and call edge discovery without much impact on precision and scalability.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Madhurima</first_name>
          <last_name>Chakraborty</last_name>
          <affiliation>University of California, Riverside</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://madhunimmo.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/madhurimachakraborty/6a31660c-02b2-4256-94df-762aeabdba7f/small.jpg</picture_url>
          <person_id>madhurimachakraborty</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>98481755-1bf2-40c0-ac31-c5dc01990efe</slot_id>
      <event_id>38f57d62-8fe7-4f69-9ae2-b60fe02f0ad1</event_id>
      <title>Run-time Data Analysis to Drive Compiler Optimizations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>Throughout program execution, types may stabilize, variables may become constant, and code sections may turn out to be redundant - all information that is used by just-in-time (JIT) compilers to achieve peak performance. Yet, since JIT compilation is done on demand for individual code parts, global observations cannot be made. Global data analysis, however, is an inherently expensive process, that collects information over large data sets. Thus, it is infeasible in dynamic compilers. With this project, we propose integrating data analysis into a state-of-the-art runtime. The goal is to gather detailed run-time information for compiler optimizations to improve performance of data-heavy applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Kloibhofer</last_name>
          <affiliation>Johannes Kepler Universität Linz</affiliation>
          <bio>undefined</bio>
          <person_id>sebastiankloibhofer</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9c57926a-dbfd-4f2d-b370-6bd0cde7f69a</slot_id>
      <event_id>998d65ae-c201-476d-b518-fa20289ff193</event_id>
      <title>Edgeworth: Authoring Diagrammatic Math Problems Using Program Mutation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>Building connections between mathematical expressions and their visual representations increases conceptual understanding and flexibility. However, students rarely practice visualizing abstract mathematical relationships because developing diagrammatic problems is challenging, especially at scale. To address this issue, we introduce Edgeworth, a system that automatically generates correct and incorrect diagrams for a given question prompt. It does so by mutating declarative mathematical statements with visual semantics. We evaluated the system by recreating diagrammatic problems in a widely used geometry textbook.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hwei-Shin</first_name>
          <last_name>Harriman</last_name>
          <affiliation>Olin College of Engineering</affiliation>
          <bio>undefined</bio>
          <person_id>hweishinharriman</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4af227a-3025-4b38-a96c-103982c56bab</slot_id>
      <event_id>6f1bf3e5-2648-40c9-bf8a-ecb1e8f88b89</event_id>
      <title>Source code authorship attribution using file embeddings</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>The problem of source code authorship attribution is crucial nowadays for a few reasons. Security and legal issues are the most popular ones. However, this domain could also help to understand the nature of the personal code style. This type of information could be used, for instance, by IDEs to improve the developer’s experience of writing the code. The goal of this study is to construct an interpretable model for source code embeddings generation. Such embeddings should represent the correspondence of the source code to its author.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alina</first_name>
          <last_name>Bogdanova</last_name>
          <affiliation>Innopolis University</affiliation>
          <bio>undefined</bio>
          <person_id>alinabogdanova</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d485d4ce-7d4d-4b72-a2fc-fa7a24049e03</slot_id>
      <event_id>15828cbf-e1ac-4b4b-b10a-bee0b57e8722</event_id>
      <title>Run-Time Data Analysis in Dynamic Runtimes</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>Databases are typically faster in processing huge amounts of data than applications with hand-coded data access. Even though modern dynamic runtimes optimize applications intensively, they cannot perform certain optimizations that are traditionally used by database systems as they lack the required information. Thus, we propose to extend the capabilities of dynamic runtimes to allow them to collect fine-grained information of the processed data at run time and use it to perform database-like optimizations. By doing so, we want to enable dynamic runtimes to significantly boost the performance of data-processing workloads. Ideally, applications should be as fast as databases in data-processing workloads by detecting the data schema at run time. To show the feasibility of our approach, we are implementing it in a polyglot dynamic runtime.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Makor</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>undefined</bio>
          <person_id>lukasmakor</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dc581899-3e64-4567-a79a-a5e4f7a55e99</slot_id>
      <event_id>6aeadcaa-c6a6-49e9-8e8e-c953e4b1b001</event_id>
      <title>Can Reactive Synthesis and Syntax-Guided Synthesis Be Friends?</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wonhyuk</first_name>
          <last_name>Choi</last_name>
          <affiliation>Columbia University</affiliation>
          <bio>undefined</bio>
          <person_id>wonhyukchoi</person_id>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>15b76470-f5a6-45ac-b819-a8df0f380722</subevent_id>
    <title>SPLASH Faculty Mentorship Roundtable: Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-faculty-mentorship-roundtable</url>
    <url_link_display>Faculty Mentorship Roundtable</url_link_display>
    <tracks>
      <track>Faculty Mentorship Roundtable</track>
    </tracks>
    <timeslot>
      <slot_id>c7e6756e-35bb-4fda-9162-a27ca3731eb1</slot_id>
      <title>Session: SPLASH Faculty Mentorship Roundtable - Session 2</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>12:10</start_time>
      <end_time>13:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Danny</first_name>
          <last_name>Dig</last_name>
          <affiliation>University of Colorado Boulder, USA</affiliation>
          <bio>Danny Dig is an associate professor of computer science at the University of Colorado, and an adjunct professor at University of Illinois and Oregon State. He enjoys doing research in Software Engineering, with a focus on interactive program transformations that improve programmer productivity and software quality. He successfully pioneered interactive program transformations by opening the field of refactoring in cutting-edge domains including mobile, concurrency and parallelism, component-based, testing, and end-user programming. He earned his Ph.D. from the University of Illinois at Urbana-Champaign where his research won the best Ph.D. dissertation award, and the First Prize at the ACM Student Research Competition Grand Finals. He did a postdoc at MIT. 
He (co-)authored 50+ journal and conference papers that appeared in top places in SE/PL. According to Google Scholar his publications have been cited 4200+ times. His research was recognized with 8 best paper awards at the flagship and top conferences in SE (FSE’17, ICSME’17, FSE’16, ICSE’14, ISSTA’13, ICST’13, ICSME’15), 4 award runner-ups, and 1 most influential paper award (N-10 years) at ICSME’15. He received the NSF CAREER award, the Google Faculty Research Award (twice), and the Microsoft Software Engineering Innovation Award (twice). He released 9 software systems, among them the world’s first open-source refactoring tool. Some of the techniques he developed are shipping with the official release of the popular Eclipse, NetBeans, and Visual Studio development environments (of which Eclipse alone had more than 14M downloads in 2014). He has started two popular workshops: Workshop on Refactoring Tools, and Hot Topics On Software Upgrades, both had at least five instances. He chaired or co-organized 14 workshops and 1 conference (MobileSoft’15), and served as a member of 35 program committees for all top conferences in his area. His research is funded by NSF, Boeing, IBM, Intel, Google, and Microsoft.</bio>
          <homepage_url>https://danny.cs.colorado.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dannydig/7a07eb43-bd7e-4d6b-89b6-8e63f48a1245/small.jpg</picture_url>
          <person_id>dannydig</person_id>
        </person>
      </persons>
      <tracks>
        <track>Faculty Mentorship Roundtable</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8883eb23-a89c-4268-b859-acefe1d663fe</slot_id>
      <event_id>c8f61496-eff5-49ae-bc48-295360d4799b</event_id>
      <title>Faculty Mentoring Roundtable</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>12:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>13:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>Faculty Mentorship Roundtable</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5ca0c6bf-0d55-4256-8c55-8087370e0718</subevent_id>
    <title>SPLASH CARES: CARES</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-cares</url>
    <url_link_display>CARES</url_link_display>
    <tracks>
      <track>CARES</track>
    </tracks>
    <timeslot>
      <slot_id>315f90ca-ee7d-4b70-9660-139ae9d7ea11</slot_id>
      <title>Session: SPLASH CARES - CARES</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Kathryn S</first_name>
          <last_name>McKinley</last_name>
          <affiliation>Google</affiliation>
          <bio>Kathryn S. McKinley is a Research Scientist at Google and an Adjunct Professor at the University of Texas at Austin. She was previously a Principal Researcher at Microsoft, held an Endowed Professorship at The University of Texas, and was a Professor at the University of Massachusetts, Amherst. She is interested in making programming easy and the resulting programs correct and efficient. Her research interests span programming languages, compilers, runtime systems, operating systems, and architecture. She and her collaborators have produced several widely used tools: the DaCapo Java Benchmarks (30,000+ downloads), the TRIPS Compiler, the Hoard memory manager, the MMTk memory management toolkit, and the Immix garbage collector. Her awards include the ACM SIGPLAN Programming Languages Software Award and the ACM SIGPLAN Distinguished Service Award. Her research has received test-of-time awards from OOPSLA (2), ICS, and SIGMETRICS, and best paper awards from ASPLOS, IEEE Micro Top Picks (4), SIGPLAN Research Highlights, and CACM Research Highlights (2). She served as program chair for ASPLOS, PACT, PLDI, ISMM, and CGO. She currently serves on the CRA Board, the CRA-W Board, and SIGPLAN EC. She previously served as co-chair of CRA-W, a member of DARPA ISAT, and on two National Academies studies. Dr. McKinley was honored to testify to the House Science Committee (Feb. 14, 2013). She is an IEEE Fellow and ACM Fellow, has graduated 22 PhD students, and is the mother of three sons.</bio>
          <homepage_url>https://www.cs.utexas.edu/users/mckinley/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kathrynsmckinley/26a6ae47-1d5b-4adb-9444-aeff3e99b5fa/small.jpg</picture_url>
          <person_id>kathrynsmckinley</person_id>
        </person>
      </persons>
      <tracks>
        <track>CARES</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>54616aa3-367c-4775-ab06-8c1b8f8c783d</slot_id>
      <event_id>8c7c4f57-9211-4101-9ca3-a911bb1691df</event_id>
      <title>CARES Session</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>CARES</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ffeff4fb-27ad-43d0-ad2f-7459bc63f9d2</subevent_id>
    <title>SPLASH Student Research Competition: Talks</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-SRC</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>01e77226-c057-4ed6-8faf-03a8abc3985a</slot_id>
      <title>Session: SPLASH Student Research Competition - Talks</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b0ec864e-2e32-44f7-9c15-c5f5e0c79565</subevent_id>
    <title>SPLASH SIGPLAN Business: Future of Conferences</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-sigplan-business</url>
    <url_link_display>SIGPLAN Business</url_link_display>
    <tracks>
      <track>SIGPLAN Business</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>433abd40-8649-43c5-8ed2-e04aab7f021a</slot_id>
      <title>Session: SPLASH SIGPLAN Business - Future of Conferences</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>SIGPLAN Business</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>f6696639-1a27-4530-bc49-9ae0a3728df9</slot_id>
      <event_id>b41962fe-f7e6-43cf-a9b7-e0d1ee39e8d9</event_id>
      <title>Future of Conferences</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>20:10</end_time>
      <description>Covid has turned all conferences into online events. SPLASH 2021 is a hybrid event, but all but Americans have to attend it online due to travel bans. (The lifting of the travel ban per November is coming just too late.) While many are craving a return to normal, it is unclear when or even whether we will get there. Even when the pandemic subsides, we will have to face the climate crisis. So it is high time we consider the future of conferences. In this panel discussion with the SPLASH community we will explore possible scenarios. Some possible ideas: 
 
 online conferences 
 regional events 
 one international SIGPLAN event 
 hybrid events 
 
or a combination of these or other ideas.​ We want to find a way for people in the community to meet and get to know each other; a feat not easily accomplished in (our current) online conferences. In the meantime we can perhaps address some of the downsides of the physical conferences (of the recent past) such as limited time for discussion. An important question is how to build an academic career in the absence of the ability to travel frequently.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science and chair of the Programming Languages Group at Delft University of Technology. His current research is on the foundation and implementation of declarative specification of programming languages. He studied at the University of Amsterdam (master 1993; doctorate 1997), and worked at the Oregon Graduate Institute (postdoc 1997-1998), Utrecht University (assistant professor 1998-2006), and TU Delft (associate professor 2006-2013, full professor since 2013). 
His research interests include (domain-specific) programming languages, language engineering, program transformation, and declarative language definition. With his students he has designed and implemented the Spoofax language workbench, as well as several domain-specific languages, including DSLs for syntax definition (SDF3), program transformation (Stratego), static semantics (Statix), software deployment (Nix), and web application development (WebDSL). Applications of WebDSL include the researchr conference hosting site and the WebLab learning management system.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Amal</first_name>
          <last_name>Ahmed</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/amal/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/amalahmed/301fd92b-d4ae-4998-8f6b-82cf081da653/small.jpg</picture_url>
          <person_id>amalahmed</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Drossopoulou</last_name>
          <affiliation>Facebook and Imperial College London</affiliation>
          <bio>I am leading the London Probable team at Facebook, and a Professor of Programming Languages at the Department of Computing, Imperial College, London, UK.</bio>
          <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
          <person_id>sophiadrossopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>David</first_name>
          <last_name>Grove</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <person_id>davidgrove1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Gorel</first_name>
          <last_name>Hedin</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/gorelhedin/67d62586-c12d-48bb-85df-fca7764d0332/small.jpg</picture_url>
          <person_id>gorelhedin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Tony</first_name>
          <last_name>Hosking</last_name>
          <affiliation>Australian National University</affiliation>
          <bio>I am Professor and Director of the School of Computing at the Australian National University. I previously spent 22 years on the faculty at Purdue University. I studied computer science at the University of Adelaide, the University of Waikato, and the University of Massachusetts at Amherst, receiving BSc, MSc, and PhD degrees, respectively. My research interests lie in the area of programming language implementation, and I work on problems arising in object persistence, object databases, distribution, memory management (garbage collection), managed language runtimes, language virtual machines, optimizing compilers, and architectural support for programming languages and applications. 
I am a Life Member of the Association for Computing Machinery and a Member of the IEEE. I was named a Distinguished Scientist of the ACM in 2012.</bio>
          <homepage_url>https://hosking.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tonyhosking/6d43d7a0-6e7b-47fe-8081-e4ae5207cda1/small.jpg</picture_url>
          <person_id>tonyhosking</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Kell</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/users/srk31</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stephenkell/53088184-3e8c-4a2c-b34f-b2a290cff411/small.jpg</picture_url>
          <person_id>stephenkell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Shriram</first_name>
          <last_name>Krishnamurthi</last_name>
          <affiliation>Brown University, United States</affiliation>
          <bio>I am the Vice President for Programming Languages at Brown University in Providence, RI, USA. I’m not, really, but that’s what it says on my business card. 
I believe tropical fruit are superior to all other kinds. I’d probably rather be out riding a bike up a mountain (slowly). I am terrified of success, because I may be forced to buy a suit. You can learn other things about me from my very serious Web site. 
I am also known to interrogate my audiences to ensure they’re paying attention. So, be alert. You can read email later.</bio>
          <homepage_url>https://cs.brown.edu/~sk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shriramkrishnamurthi/fffeeaab-a8ce-432c-b0ea-0b960163abe3/small.jpg</picture_url>
          <person_id>shriramkrishnamurthi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Alex</first_name>
          <last_name>Potanin</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>I am an Associate Professor in the School of Engineering and Computer Science at Victoria University of Wellington, New Zealand. 
I am originally from Moscow, Russia with a background in Mathematics. I have completed my PhD in programming languages in 2006 and took up a job as a Lecturer in Software Engineering at Victoria University of Wellington. During my studies, I took short breaks to work as a Visiting Researcher at Purdue University, and Software Engineer at two Wellington start-ups. I spent 2013 on sabbatical at Carnegie Mellon University in Pittsburgh, PA, USA. I spent winter 2019/2020 on sabbatical at Kyoto University in Japan.</bio>
          <homepage_url>http://homepages.ecs.vuw.ac.nz/~alex/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexpotanin/614f887b-90a3-4626-b67d-fa63309b44c8/small.jpg</picture_url>
          <person_id>alexpotanin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>12</sort_key>
          <first_name>Manu</first_name>
          <last_name>Sridharan</last_name>
          <affiliation>University of California at Riverside</affiliation>
          <bio>I’m an associate professor at the University of California, Riverside. Previously I worked at IBM Research, Samsung Research, and Uber. My research focuses on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
          <homepage_url>http://manu.sridharan.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
          <person_id>manusridharan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SIGPLAN Business</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1b4a065b-946d-43ec-b123-bb51f68c2d00</subevent_id>
    <title>SPLASH -E: Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-SPLASH-E</url>
    <url_link_display>SPLASH-E</url_link_display>
    <tracks>
      <track>SPLASH-E</track>
    </tracks>
    <timeslot>
      <slot_id>b2c07f0f-4d05-48c4-a171-1fc03357bd6b</slot_id>
      <title>Session: SPLASH -E - Session 1</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>318ad5b7-2849-4d96-abc6-e7961cb403b8</slot_id>
      <event_id>72e989fc-ba9f-45b1-8ce5-f2201a2027ee</event_id>
      <submission_id>13</submission_id>
      <title>Reframing the Liskov Substitution Principle Through the Lens of Testing</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>11:45</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>12:05</end_time>
      <description>In this essay we explore a new pedagogical framing of the LiskovSubstitution Principle (LSP). In addition to, or perhaps even in place of, teaching the specifics of the rule itself, we advocate an operationalised version of the rule: that a subtype must pass its supertype’sblack box tests for each of its overriding methods. We leverage the fact that black box tests should be written to capture conformance to a specification without overfitting or checking im-plementation internals (as would be checked by glassbox tests). We show that a type that violates the rules of substitutability, will also fail the corresponding black box tests for the supertype. Additionally, we argue that the over-strict nature of the classical LSP Postcondition Rule (which has been improved in subsequent work) can be a source of confusion for both instructors and for students learning this crucial concept for the first time. Pleasingly, many of the technical subtleties of this nuanced but important concept drop out naturally when thinking of substitutability via black box tests. Thus we put forward that this test-oriented means of teaching substitutability is a valuable alternative to the classical sense of checking the LSP, with the benefit of being intuitively accessible to students.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Baniassad</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ubc.ca/~ebani</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/elisabaniassad/ebb453ca-88ce-4678-823e-82b113c14751/small.jpg</picture_url>
          <person_id>elisabaniassad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alex</first_name>
          <last_name>Summers</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <person_id>alexsummers</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5edebd04-c2f7-4dff-a62d-d04a7561e86e</slot_id>
      <event_id>8660d78a-7fc2-4b45-a459-6ae48901b2aa</event_id>
      <submission_id>18</submission_id>
      <title>Ruggedizing CS1 Robotics: Tools and Approaches for Online Teaching</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>11:15</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:30</end_time>
      <description>First-year students benefit from robotics-based programming exercises by learning how to use sensors to gain information on the (changing) world surrounding the robot, how to model this information using data structures, and how to design algorithms for performing meaningful activities. Robotics-based exercises are naturally experiential and team-based and provide among the most memorable teachable moments of first-year programming courses. We summarize the pedagogical challenges that robotics-based exercises face, even under ideal circumstances, and how a university responded to these challenges over 15 consecutive years. We report on the additional challenges faced in late 2020 at the same university as a result of the COVID pandemic, and how the course staff addressed these challenges using programming language implementation and network tools. The crucial components were (1) a custom-built web-based development environment with collaborative features including a built-in compiler, (2) a portable virtual machine, (3) collaborative editing, (4) open source protocols, and (5) peer-to-peer teleconferencing software. We report on the lessons learnt and how to further improve the resilience of robotics-based programming exercises.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Boyd</first_name>
          <last_name>Anderson</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>boydanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Henz</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>The guiding motivation for Martin’s work is the scalability of experiential learning. He has led the flagship programming course CS1101S for first-year students of the School of Computing at the National University of Singapore (NUS) since 2012, founded the experiential course CS4215 Programming Language Implementation, and extensively subscribes to SoC’s project-based course CP3108 for experiential learning. 
The work on CS1101S culminated in the textbook Structure and Interpretation of Computer Programs, JavaScript Edition, by Harold Abelson and Gerald J. Sussman, adapted to JavaScript by Martin Henz and Tobias Wrigstad with Julie Sussman, to be published by MIT Press in 2022. Martin is the initiator of the Source Academy, an immersive online experiential environment for learning programming used in CS1101S and at the University of San Francisco. He designs and develops open-source software on GitHub, co-founded the software company Workforce Optimizer Pte Ltd with Alan Sevugan, and supervised Rahul Singhal’s PhD, which led to the formation of the education-A.I. company Cerebry. 
Martin founded the multidisciplinary initiatives NUS Seafarers, a programme for maritime exploration that was active 2017-2020, FrogWorks, a prototyping studio at the iDP in the NUS Faculty of Engineering that was active 2011-2016, and The Physics of Sailing, a collaboration with NUS physics professors that was active 2011-2017.</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~henz</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinhenz/ced23f33-d573-4549-afc7-b640154aa027/small.jpg</picture_url>
          <person_id>martinhenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hao-Wei</first_name>
          <last_name>Tee</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>haoweitee</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>949fd9e6-8884-4327-882a-4ab3583fd77f</slot_id>
      <event_id>5ddbed06-4d61-4930-9042-e2a65ccce42a</event_id>
      <submission_id>8</submission_id>
      <title>Teaching DevOps: A Tale of Two Universities</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>11:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:15</end_time>
      <description>DevOps is a set of practices in software engineering that is in high demand by industry. It is a dynamic field which constantly adds new methods and tools. Teaching DevOps prepares today’s computer science students for best-practices in a working environment but challenges university lecturers to provide central concepts while staying up-to-date with current trends. In this paper we reflect on our experiences teaching DevOps at two universities (in the USA and Germany) in an inverted classroom format. We describe how we set-up the courses, provide a brief analysis of data we collected, and share our lessons learned.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Richard</first_name>
          <last_name>Hobeck</last_name>
          <affiliation>TU Berlin</affiliation>
          <bio>undefined</bio>
          <person_id>richardhobeck</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ingo</first_name>
          <last_name>Weber</last_name>
          <affiliation>TU Berlin</affiliation>
          <bio>undefined</bio>
          <person_id>ingoweber</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Len</first_name>
          <last_name>Bass</last_name>
          <affiliation>CMU</affiliation>
          <bio>undefined</bio>
          <person_id>lenbass</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hasan</first_name>
          <last_name>Yasar</last_name>
          <affiliation>SEI | CMU</affiliation>
          <bio>Hasan Yasar is the Technical Director of Continuous Deployment of Capability group in Software Engineering Institute, CMU. Hasan leads an engineering group to enable, accelerate and assure Transformation at the speed of relevance by leveraging, DevSecOps, Agile, Lean AI/ML and other emerging technologies to create a Smart Software Platform/Pipeline. Hasan has more than 25 years’ experience as senior security engineer, software engineer, software architect and manager in all phases of secure software development and information modeling processes. He is also Adjunct Faculty member in CMU Heinz Collage and Institute of Software Research where he currently teaches “Software and Security” and “DevOps: Engineering for Deployment and Operations ”</bio>
          <homepage_url>https://resources.sei.cmu.edu/library/author.cfm?authorID=42641</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hasanyasar/7a93bc29-4dfe-40bd-8ebb-1b5224d85ebc/small.jpg</picture_url>
          <person_id>hasanyasar</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a5fed540-4c01-4f1e-ae26-f3b22e4f54cf</slot_id>
      <event_id>c68d0cc5-c46b-4b33-9557-b8fff7bcf3d3</event_id>
      <title>Chairs' Welcome</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Co-chair</role>
          <sort_key>1</sort_key>
          <first_name>Charlie</first_name>
          <last_name>Curtsinger</last_name>
          <affiliation>Grinnell College</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ccurtsinger.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/charliecurtsinger/e779a4c9-ade3-4073-b660-866046d6c953/small.jpg</picture_url>
          <person_id>charliecurtsinger</person_id>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>2</sort_key>
          <first_name>Tien N.</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>University of Texas at Dallas</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.utdallas.edu/~tien.n.nguyen/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiennguyen/10e4533a-6059-499a-aa1c-a76131caeae5/small.jpg</picture_url>
          <person_id>tiennguyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cf50fdbe-bea3-4c91-8c73-15c0ef892226</slot_id>
      <event_id>51b6dfb3-ad80-43c1-9df2-cfa1c86d4051</event_id>
      <submission_id>5</submission_id>
      <title>“You Have Said Too Much”: Java-Like Verbosity Anti-Patterns in Python Codebases</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:45</end_time>
      <description>As a popular language for teaching introductory programming, Java can profoundly influence beginner programmers with its coding style and idioms. Despite its many advantages, the paradigmatic coding style in Java is often described as verbose. As a result, when writing code in more concise languages, such programmers tend to emulate the familiar Java coding idioms, thus neglecting to take advantage of the more succinct counterparts in those languages. As a result of such verbosity, not only the overall code quality suffers, but the verbose non-idiomatic patterns also render code hard to understand and maintain. In this paper, we study the incidences of Java-like verbosity as they occur in Python codebases. We present a collection of Java-Like Verbosity Anti-Patterns and our pilot study of their presence in representative open-source Python codebases. We discuss our findings as a call for action to computing educators, particularly those who work with introductory students. We need novel pedagogical interventions that encourage budding programmers to write concise idiomatic code in any language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuzhi</first_name>
          <last_name>Ma</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <person_id>yuzhima</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eli</first_name>
          <last_name>Tilevich</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.vt.edu/~tilevich</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/elitilevich/10b9c85c-8a75-4acb-a0fe-e00c91dd0bb6/small.jpg</picture_url>
          <person_id>elitilevich</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f9cb69de-0723-4331-9ca4-57a43ffd7308</subevent_id>
    <title>SPLASH -E: Session 3</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-SPLASH-E</url>
    <url_link_display>SPLASH-E</url_link_display>
    <tracks>
      <track>SPLASH-E</track>
    </tracks>
    <timeslot>
      <slot_id>2883a079-2b39-4261-8924-0af28e41cd05</slot_id>
      <title>Session: SPLASH -E - Session 3</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>14e6c024-09bd-4e2a-a3bc-95d99dd9dcb0</slot_id>
      <event_id>087a332d-3caa-4696-989c-3c985c6335c5</event_id>
      <submission_id>1</submission_id>
      <title>The Common Coder's Scratch Programming Idioms and their Impact on Project Remixing</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:00</end_time>
      <description>As Scratch has become one of the most popular educational programming languages, understanding its common programming idioms can benefit both computing educators and learners. This understanding can fine-tune the curricular development to help learners master the fundamentals of writing idiomatic code in their programming pursuits. Unfortunately, the research community’s understanding of what constitutes idiomatic Scratch code has been limited. To help bridge this knowledge gap, we systematically identified idioms as based on canonical source code, presented in widely available educational materials. We implemented a tool that automatically detects these idioms to assess their prevalence within a large dataset of over 70K Scratch projects in different experience backgrounds and project categories. Since communal learning and the practice of remixing are one of the cornerstones of the Scratch programming community, we studied the relationship between common programming idioms and remixes. Having analyzed the original projects and their remixes, we observed that different idioms may associate with dissimilar types of code changes. Code changes in remixes are desirable, as they require a meaningful programming effort that spurs the learning process. The ability to substantially change a project in its remixes hinges on the project’s code being easy to understand and modify. Our findings suggest that the presence of certain common idioms can indeed positively impact the degree of code changes in remixes. Our findings can help form a foundation of what comprises common Scratch programming idioms, thus benefiting both introductory computing education and Scratch programming tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xingyu</first_name>
          <last_name>Long</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/xingyulong/91407c09-3a38-43c5-ad29-5e76ced13e1a/small.jpg</picture_url>
          <person_id>xingyulong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Peeratham</first_name>
          <last_name>Techapalokul</last_name>
          <affiliation>Rajamangala University of Technology Lanna</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/peerathamtechapalokul/334982bf-6974-47bb-9a3e-890322a7693f/small.jpg</picture_url>
          <person_id>peerathamtechapalokul</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eli</first_name>
          <last_name>Tilevich</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.vt.edu/~tilevich</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/elitilevich/10b9c85c-8a75-4acb-a0fe-e00c91dd0bb6/small.jpg</picture_url>
          <person_id>elitilevich</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e42363d-b569-460f-b507-92b9bcc97767</slot_id>
      <event_id>adbacabc-00a0-4af7-94e7-7ba7f6c36128</event_id>
      <submission_id>15</submission_id>
      <title>The Efficacy of Online Office Hours: An Experience Report</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>16:15</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:30</end_time>
      <description>To facilitate assisting students while online during the COVID 19 pandemic, we implemented an online office hours queue which kept track of who was waiting in office hours, and for how long. We also have students’ project commit and grade history. These data afforded us a unique look at the efficacy of office hours that the usual, casual drop-in style office hours, had not. In this paper we report on our observations about online office hours and comment on what we can learn going forward for office hours generally.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Braxton</first_name>
          <last_name>Hall</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <person_id>braxtonhall1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Noa</first_name>
          <last_name>Heyl</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <person_id>noaheyl</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Baniassad</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ubc.ca/~ebani</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/elisabaniassad/ebb453ca-88ce-4678-823e-82b113c14751/small.jpg</picture_url>
          <person_id>elisabaniassad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Meghan</first_name>
          <last_name>Allen</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/meghanallen/2b97f305-1781-431a-ab03-901f91b1fa9a/small.jpg</picture_url>
          <person_id>meghanallen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Reid</first_name>
          <last_name>Holmes</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.ubc.ca/~rtholmes</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/reidholmes/62072024-51a4-412c-9a05-af7a560429f1/small.jpg</picture_url>
          <person_id>reidholmes</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8955ef5d-cd05-46c5-a9e8-382a67b3e079</slot_id>
      <event_id>2f95b493-3742-4dff-96ef-ed08f564ace6</event_id>
      <submission_id>16</submission_id>
      <title>Teachable Moments in Functional Audio Processing</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>16:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:45</end_time>
      <description>The atomic entity of digital audio processing systems is a digital audio signal, i.e. a sequence of sound samples that represent the amplitude of a sound wave at discrete time intervals. Such signals are transformed additively, by combining them into more complex signals, and subtractively, by subjecting them to digital filters. In order to cover digital audio processing in a classroom from first principles, we need to form collections of samples in streams or arrays, and define operations on these collections in accordance with the constraints of digitization. In this work, we pursue an alternative approach, where the atomic entity is a continuous wave function. We present additive synthesis operations, including wave envelopes and musical abstractions in a purely functional setting. The final continuous wave function is digitized in order to make the sound audible. We report our experiences with what we call functional audio processing as an example domain for teaching functional programming to first-year students, where simplicity and conceptual elegance outweighs the inherent limitation to additive synthesis. We describe a sequence of teachable moments that highlight the potential of functional audio processing at an early stage in the learning process, before streams or arrays are introduced.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Henz</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>The guiding motivation for Martin’s work is the scalability of experiential learning. He has led the flagship programming course CS1101S for first-year students of the School of Computing at the National University of Singapore (NUS) since 2012, founded the experiential course CS4215 Programming Language Implementation, and extensively subscribes to SoC’s project-based course CP3108 for experiential learning. 
The work on CS1101S culminated in the textbook Structure and Interpretation of Computer Programs, JavaScript Edition, by Harold Abelson and Gerald J. Sussman, adapted to JavaScript by Martin Henz and Tobias Wrigstad with Julie Sussman, to be published by MIT Press in 2022. Martin is the initiator of the Source Academy, an immersive online experiential environment for learning programming used in CS1101S and at the University of San Francisco. He designs and develops open-source software on GitHub, co-founded the software company Workforce Optimizer Pte Ltd with Alan Sevugan, and supervised Rahul Singhal’s PhD, which led to the formation of the education-A.I. company Cerebry. 
Martin founded the multidisciplinary initiatives NUS Seafarers, a programme for maritime exploration that was active 2017-2020, FrogWorks, a prototyping studio at the iDP in the NUS Faculty of Engineering that was active 2011-2016, and The Physics of Sailing, a collaboration with NUS physics professors that was active 2011-2017.</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~henz</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinhenz/ced23f33-d573-4549-afc7-b640154aa027/small.jpg</picture_url>
          <person_id>martinhenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shang-Hui</first_name>
          <last_name>Koh</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>shanghuikoh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Samyukta</first_name>
          <last_name>Sounderraman</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>samyuktasounderraman</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c6c15a94-c26f-4bcd-bcd9-90e353b05514</slot_id>
      <event_id>bec22816-7156-4acb-95fb-37f6b9a659cc</event_id>
      <submission_id>12</submission_id>
      <title>Machine Learning Pedagogy to Support the Research Community</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:15</end_time>
      <description>Machine learning methods are increasingly leveraged in disparate domains of research. Herein, we describe our curriculum design to introduce undergraduate students to research applications through a series of course assignments and a competition among peers to inspire other educators. For the selected course-long problem of predicting which drugs might interact with specific proteins, we leveraged state-of-the-art tools for representing drug and protein sequences and challenged students to develop unique solutions competitive with a current state-of-the-art model with the expectation that top-ranking solutions would be used to predict novel drugable targets within the SARS-CoV-2 proteome to possibly treat COVID19 patients. We motivate this curriculum design based on related competition frameworks that have led to notable research advancements and contributed to machine learning pedagogy. We describe the overall course structure and detail how the assignments were tailored to a selected open research question while developing student understanding of machine learning. We outline the lessons learned from this new undergraduate curriculum design and describe how it may be adapted to similar courses. From our experience, the top student solutions were ultimately combined using a stacked classifier to create a publishable solution representing an actual research contribution. We highly recommended introducing undergraduate students to open research applications early in their program to encourage them to consider pursuing a career in research.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Dick</last_name>
          <affiliation>Carleton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kevindick.ai</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kevindick/bc1d7661-8e90-4ebf-acc5-ba1e00e55691/small.jpg</picture_url>
          <person_id>kevindick</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel G.</first_name>
          <last_name>Kyrollos</last_name>
          <affiliation>Carleton University</affiliation>
          <bio>undefined</bio>
          <person_id>danielgkyrollos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James R.</first_name>
          <last_name>Green</last_name>
          <affiliation>Carleton University</affiliation>
          <bio>undefined</bio>
          <person_id>jamesrgreen</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b6e25e7c-8f98-4904-a1f8-a72d90981cbd</subevent_id>
    <title>SPLASH SIGPLAN Business: Future of Conferences</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-sigplan-business</url>
    <url_link_display>SIGPLAN Business</url_link_display>
    <tracks>
      <track>SIGPLAN Business</track>
    </tracks>
    <timeslot>
      <slot_id>27a87465-9bc5-4346-894e-96798b8f95ee</slot_id>
      <title>Session: SPLASH SIGPLAN Business - Future of Conferences</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science and chair of the Programming Languages Group at Delft University of Technology. His current research is on the foundation and implementation of declarative specification of programming languages. He studied at the University of Amsterdam (master 1993; doctorate 1997), and worked at the Oregon Graduate Institute (postdoc 1997-1998), Utrecht University (assistant professor 1998-2006), and TU Delft (associate professor 2006-2013, full professor since 2013). 
His research interests include (domain-specific) programming languages, language engineering, program transformation, and declarative language definition. With his students he has designed and implemented the Spoofax language workbench, as well as several domain-specific languages, including DSLs for syntax definition (SDF3), program transformation (Stratego), static semantics (Statix), software deployment (Nix), and web application development (WebDSL). Applications of WebDSL include the researchr conference hosting site and the WebLab learning management system.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>SIGPLAN Business</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88113db7-9f3c-4deb-b395-e61763db694f</slot_id>
      <event_id>b41962fe-f7e6-43cf-a9b7-e0d1ee39e8d9</event_id>
      <title>Future of Conferences</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>12:10</end_time>
      <description>Covid has turned all conferences into online events. SPLASH 2021 is a hybrid event, but all but Americans have to attend it online due to travel bans. (The lifting of the travel ban per November is coming just too late.) While many are craving a return to normal, it is unclear when or even whether we will get there. Even when the pandemic subsides, we will have to face the climate crisis. So it is high time we consider the future of conferences. In this panel discussion with the SPLASH community we will explore possible scenarios. Some possible ideas: 
 
 online conferences 
 regional events 
 one international SIGPLAN event 
 hybrid events 
 
or a combination of these or other ideas.​ We want to find a way for people in the community to meet and get to know each other; a feat not easily accomplished in (our current) online conferences. In the meantime we can perhaps address some of the downsides of the physical conferences (of the recent past) such as limited time for discussion. An important question is how to build an academic career in the absence of the ability to travel frequently.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science and chair of the Programming Languages Group at Delft University of Technology. His current research is on the foundation and implementation of declarative specification of programming languages. He studied at the University of Amsterdam (master 1993; doctorate 1997), and worked at the Oregon Graduate Institute (postdoc 1997-1998), Utrecht University (assistant professor 1998-2006), and TU Delft (associate professor 2006-2013, full professor since 2013). 
His research interests include (domain-specific) programming languages, language engineering, program transformation, and declarative language definition. With his students he has designed and implemented the Spoofax language workbench, as well as several domain-specific languages, including DSLs for syntax definition (SDF3), program transformation (Stratego), static semantics (Statix), software deployment (Nix), and web application development (WebDSL). Applications of WebDSL include the researchr conference hosting site and the WebLab learning management system.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Amal</first_name>
          <last_name>Ahmed</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/amal/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/amalahmed/301fd92b-d4ae-4998-8f6b-82cf081da653/small.jpg</picture_url>
          <person_id>amalahmed</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Drossopoulou</last_name>
          <affiliation>Facebook and Imperial College London</affiliation>
          <bio>I am leading the London Probable team at Facebook, and a Professor of Programming Languages at the Department of Computing, Imperial College, London, UK.</bio>
          <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
          <person_id>sophiadrossopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>David</first_name>
          <last_name>Grove</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <person_id>davidgrove1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Gorel</first_name>
          <last_name>Hedin</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/gorelhedin/67d62586-c12d-48bb-85df-fca7764d0332/small.jpg</picture_url>
          <person_id>gorelhedin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Tony</first_name>
          <last_name>Hosking</last_name>
          <affiliation>Australian National University</affiliation>
          <bio>I am Professor and Director of the School of Computing at the Australian National University. I previously spent 22 years on the faculty at Purdue University. I studied computer science at the University of Adelaide, the University of Waikato, and the University of Massachusetts at Amherst, receiving BSc, MSc, and PhD degrees, respectively. My research interests lie in the area of programming language implementation, and I work on problems arising in object persistence, object databases, distribution, memory management (garbage collection), managed language runtimes, language virtual machines, optimizing compilers, and architectural support for programming languages and applications. 
I am a Life Member of the Association for Computing Machinery and a Member of the IEEE. I was named a Distinguished Scientist of the ACM in 2012.</bio>
          <homepage_url>https://hosking.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tonyhosking/6d43d7a0-6e7b-47fe-8081-e4ae5207cda1/small.jpg</picture_url>
          <person_id>tonyhosking</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Kell</last_name>
          <affiliation>King's College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/users/srk31</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stephenkell/53088184-3e8c-4a2c-b34f-b2a290cff411/small.jpg</picture_url>
          <person_id>stephenkell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Shriram</first_name>
          <last_name>Krishnamurthi</last_name>
          <affiliation>Brown University, United States</affiliation>
          <bio>I am the Vice President for Programming Languages at Brown University in Providence, RI, USA. I’m not, really, but that’s what it says on my business card. 
I believe tropical fruit are superior to all other kinds. I’d probably rather be out riding a bike up a mountain (slowly). I am terrified of success, because I may be forced to buy a suit. You can learn other things about me from my very serious Web site. 
I am also known to interrogate my audiences to ensure they’re paying attention. So, be alert. You can read email later.</bio>
          <homepage_url>https://cs.brown.edu/~sk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shriramkrishnamurthi/fffeeaab-a8ce-432c-b0ea-0b960163abe3/small.jpg</picture_url>
          <person_id>shriramkrishnamurthi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Alex</first_name>
          <last_name>Potanin</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>I am an Associate Professor in the School of Engineering and Computer Science at Victoria University of Wellington, New Zealand. 
I am originally from Moscow, Russia with a background in Mathematics. I have completed my PhD in programming languages in 2006 and took up a job as a Lecturer in Software Engineering at Victoria University of Wellington. During my studies, I took short breaks to work as a Visiting Researcher at Purdue University, and Software Engineer at two Wellington start-ups. I spent 2013 on sabbatical at Carnegie Mellon University in Pittsburgh, PA, USA. I spent winter 2019/2020 on sabbatical at Kyoto University in Japan.</bio>
          <homepage_url>http://homepages.ecs.vuw.ac.nz/~alex/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexpotanin/614f887b-90a3-4626-b67d-fa63309b44c8/small.jpg</picture_url>
          <person_id>alexpotanin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>12</sort_key>
          <first_name>Manu</first_name>
          <last_name>Sridharan</last_name>
          <affiliation>University of California at Riverside</affiliation>
          <bio>I’m an associate professor at the University of California, Riverside. Previously I worked at IBM Research, Samsung Research, and Uber. My research focuses on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
          <homepage_url>http://manu.sridharan.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
          <person_id>manusridharan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SIGPLAN Business</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dc2c9c25-f5a4-4796-a319-135ab85141fd</subevent_id>
    <title>SPLASH -E: Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-SPLASH-E</url>
    <url_link_display>SPLASH-E</url_link_display>
    <tracks>
      <track>SPLASH-E</track>
    </tracks>
    <timeslot>
      <slot_id>a44b984a-6920-4172-925f-64c7103589eb</slot_id>
      <title>Session: SPLASH -E - Session 2</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>129b529a-e657-4238-afcf-66bdb7c49ac6</slot_id>
      <event_id>3a0e4fc6-6cf4-445b-8bdd-c4a1aca9081d</event_id>
      <submission_id>17</submission_id>
      <title>A Stepper for a Functional JavaScript Sublanguage</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:50</end_time>
      <description>The first two chapters of the introductory computer science textbook \emph{Structure and Interpretation of Computer Programs, JavaScript Adaptation (SICP JS)}, use a subset of JavaScript called \emph{Source §2}. The book introduces the reduction-based ‘‘substitution model’’ as a first mental model for the evaluation of Source §2 programs. To support the learner in adopting this mental model, we built an \emph{algebraic stepper}—a tool for visualizing the evaluation of Source §2 programs according to the model. As a sublanguage of JavaScript, Source §2 differs from other purely functional programming languages by using a statement-oriented syntax, with statement sequences, return statements, and block-scoped declarations. For the purpose of this tool description, we distill these distinguishing features—along with explicit recursion—into a Source §2 sublanguage that we call \emph{Source §0}, and focus on a stepper for this language. We formalize the substitution model of Source §0 as a lambda-calculus-style reduction semantics that handles explicit recursion by term graph rewriting and faithfully implements the JavaScript specification, when restricted to that language. Our implementation of the stepper represents term graphs by persistent data structures that maximize sharing and enable random access to all steps. This work presents the first reduction-based semantics for a JavaScript sublanguage and the first algebraic stepper for a language with return statements and block-scoped declarations. The tool supports the learner with step-level explanations, redex highlighting, and function-level skipping and can also be used for teaching the applicative-order-reduction lambda calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Henz</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>The guiding motivation for Martin’s work is the scalability of experiential learning. He has led the flagship programming course CS1101S for first-year students of the School of Computing at the National University of Singapore (NUS) since 2012, founded the experiential course CS4215 Programming Language Implementation, and extensively subscribes to SoC’s project-based course CP3108 for experiential learning. 
The work on CS1101S culminated in the textbook Structure and Interpretation of Computer Programs, JavaScript Edition, by Harold Abelson and Gerald J. Sussman, adapted to JavaScript by Martin Henz and Tobias Wrigstad with Julie Sussman, to be published by MIT Press in 2022. Martin is the initiator of the Source Academy, an immersive online experiential environment for learning programming used in CS1101S and at the University of San Francisco. He designs and develops open-source software on GitHub, co-founded the software company Workforce Optimizer Pte Ltd with Alan Sevugan, and supervised Rahul Singhal’s PhD, which led to the formation of the education-A.I. company Cerebry. 
Martin founded the multidisciplinary initiatives NUS Seafarers, a programme for maritime exploration that was active 2017-2020, FrogWorks, a prototyping studio at the iDP in the NUS Faculty of Engineering that was active 2011-2016, and The Physics of Sailing, a collaboration with NUS physics professors that was active 2011-2017.</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~henz</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinhenz/ced23f33-d573-4549-afc7-b640154aa027/small.jpg</picture_url>
          <person_id>martinhenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Tan</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>thomastan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Chua</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>zacharychua</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Peter</first_name>
          <last_name>Jung</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>peterjung</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yee-Jian</first_name>
          <last_name>Tan</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>yeejiantan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Xinyi</first_name>
          <last_name>Zhang</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>xinyizhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Jingjing</first_name>
          <last_name>Zhao</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>jingjingzhao</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c8ee1a43-0204-487a-b82a-050aef9481e4</slot_id>
      <event_id>81bc0ac5-26e3-4b3d-985f-8f1d82e6c82b</event_id>
      <submission_id>11</submission_id>
      <title>PaCon: A Symbolic Analysis Approach for Tactic-oriented Clustering of Programming Submissions</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:10</end_time>
      <description>Enrollment in programming courses increasingly surges. To maintain the quality of education in programming courses, instructors need ways to understand student performance and give feedback accordingly at scale. For example, it is important for instructors to identify different problem-solving ways (named as tactics by us in the paper) used in student submissions. However, because there exist many different abstraction levels for problem-solving ways and syntactic diversity of code implementations that adopt the same problem-solving way, it is challenging to tackle the task of tactic identification. Toward addressing this task, in this paper, we propose PaCon, a symbolic analysis approach for tactic-oriented clustering of functionally correct programming submissions. PaCon distinguishes tactics according to path conditions, a semantic feature of programs. PaCon focuses on the semantics of submissions so it does not struggle with an excessive number of clusters caused by subtle syntactic differences across the submissions. Our experimental results on realworld student submissions show that PaCon can produce a reasonable number of clusters that effectively reflect the diversity of tactics in student submissions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yingjie</first_name>
          <last_name>Fu</last_name>
          <affiliation>Peking University, China</affiliation>
          <bio>undefined</bio>
          <person_id>yingjiefu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Osei-Owusu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>jonathanoseiowusu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Angello</first_name>
          <last_name>Astorga</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>angelloastorga1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zirui Neil</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>ziruineilzhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Wei</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>weizhang2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tao</first_name>
          <last_name>Xie</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://taoxiease.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/taoxie/14ae8022-1dd6-4455-a54f-157c86bc406d/small.jpg</picture_url>
          <person_id>taoxie</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>db8b5df5-3fb7-4c2e-8b12-ffcc3d9f822a</slot_id>
      <event_id>7a8be73b-7aab-45cd-96d0-396d92e5579b</event_id>
      <submission_id>6</submission_id>
      <title>Course Experience Report: Full-class Compiler Collaboration</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:05</end_time>
      <description>Compilers are large software systems. In course projects it is often a challenge for students to build a significant compiler on their own with features like memory management, closures, inheritance, and more. We report on our experience splitting a relatively large compiler, with several of these advanced features, among project groups in a graduate compilers course. In addition to allowing students to engage with a larger system than groups would have been able to build on their own, we also believe based on anecdotal feedback that this had positive effects on student morale and community. There were several concrete logistics and content decisions we made that were effective, along with other recommendations and refinements for when we run the course again.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joe Gibbs</first_name>
          <last_name>Politz</last_name>
          <affiliation>University of California San Diego, United States</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jpolitz.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/joepolitz/0eb9487a-3208-43ea-94ea-faed95a525f7/small.jpg</picture_url>
          <person_id>joepolitz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yousef</first_name>
          <last_name>Alhessi</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <person_id>yousefalhessi</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ddbf95d6-64c8-4a0a-837d-fe2c56b345d7</slot_id>
      <event_id>55b44c1e-7213-42d4-b153-f523c8bd05f6</event_id>
      <submission_id>19</submission_id>
      <title>Shrinking JavaScript for CS1</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/20</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:30</end_time>
      <description>In teaching and learning programming at first-year-university level, simple languages with small feature sets are preferable over industry-strength languages with extensive feature sets, to reduce the learners’ cognitive load. At the same time, there is increasing pressure to familiarise students with mainstream languages early in their learning journey, and these languages accumulate features as years go by. In response to these competing requirements, we developed Source, a collection of JavaScript sublanguages with feature sets just expressive enough to introduce first-year computer science students to the elements of computation. These languages are supported by a web-based programming environment custom-built for learning at beginner’s level, which provides transpiler, interpreter, virtual machine, and algebraic-stepper-based implementations of the languages, and includes tracing, debugging, visualization, type-inference, and smart-editor features. This paper motivates the choice of JavaScript as starting point and describes the syntax and semantics of the Source languages compared to their parent language, and their implementations in the system. We report our experiences in developing and improving the languages and implementations over a period of three years, teaching a total of 1561 computer science first-year students at a university.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Boyd</first_name>
          <last_name>Anderson</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>boydanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Henz</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>The guiding motivation for Martin’s work is the scalability of experiential learning. He has led the flagship programming course CS1101S for first-year students of the School of Computing at the National University of Singapore (NUS) since 2012, founded the experiential course CS4215 Programming Language Implementation, and extensively subscribes to SoC’s project-based course CP3108 for experiential learning. 
The work on CS1101S culminated in the textbook Structure and Interpretation of Computer Programs, JavaScript Edition, by Harold Abelson and Gerald J. Sussman, adapted to JavaScript by Martin Henz and Tobias Wrigstad with Julie Sussman, to be published by MIT Press in 2022. Martin is the initiator of the Source Academy, an immersive online experiential environment for learning programming used in CS1101S and at the University of San Francisco. He designs and develops open-source software on GitHub, co-founded the software company Workforce Optimizer Pte Ltd with Alan Sevugan, and supervised Rahul Singhal’s PhD, which led to the formation of the education-A.I. company Cerebry. 
Martin founded the multidisciplinary initiatives NUS Seafarers, a programme for maritime exploration that was active 2017-2020, FrogWorks, a prototyping studio at the iDP in the NUS Faculty of Engineering that was active 2011-2016, and The Physics of Sailing, a collaboration with NUS physics professors that was active 2011-2017.</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~henz</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinhenz/ced23f33-d573-4549-afc7-b640154aa027/small.jpg</picture_url>
          <person_id>martinhenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kok-Lim</first_name>
          <last_name>Low</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>koklimlow</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Daryl</first_name>
          <last_name>Tan</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>daryltan1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SPLASH-E</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e81627dd-cd12-4947-afc6-8153f78bd262</subevent_id>
    <title>APLAS Keynote Talks: Invited talk 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-keynote-talks</url>
    <url_link_display>Keynote Talks</url_link_display>
    <tracks>
      <track>Keynote Talks</track>
    </tracks>
    <timeslot>
      <slot_id>fd4000f1-97ad-4e99-8dc2-24e282234796</slot_id>
      <title>Session: APLAS Keynote Talks - Invited talk 1</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Hakjoo</first_name>
          <last_name>Oh</last_name>
          <affiliation>Korea University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://prl.korea.ac.kr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hakjoooh/d607b778-78f3-41c4-84d9-4693c8923bc3/small.jpg</picture_url>
          <person_id>hakjoooh</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0473613e-5217-489b-ab39-1177c0572288</slot_id>
      <event_id>dcfc0f60-1f4f-4dfa-bbaf-2da4274d67cc</event_id>
      <title> Solidifying and Advancing the Software Foundations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:00</end_time>
      <description>Software applications and technologies are built on top of foundational systems such as compilers, databases, and theorem provers. Such foundations form the trusted computing base, and fundamentally impact software quality and security. Thus, it is a critical challenge to solidify and advance them. This talk highlights general, effective techniques, and extensive, impactful efforts on finding hundreds of critical issues in widely-used compilers, database management systems, and SMT solvers. It focuses on the high-level principles and core techniques, their significant practical successes, and future opportunities and challenges.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b2bbe6fd-4f54-495c-a9c5-8db44886e88e</subevent_id>
    <title>LIVE: Talks II</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/live-2021</url>
    <url_link_display>LIVE 2021</url_link_display>
    <tracks>
      <track>LIVE 2021</track>
    </tracks>
    <timeslot>
      <slot_id>ee865cac-01d7-4de3-b354-7f5845ed43e4</slot_id>
      <title>Session: LIVE - Talks II</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>39f11b4c-f054-4052-bf6a-c5cc2d02f489</slot_id>
      <event_id>184fc628-8784-4f24-b672-5a1abb538e54</event_id>
      <title>Enhancing Liveness with Exemplars in the Newspeak IDE</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>12:10</end_time>
      <description>Traditional program editing tools are separate from program evalution tools. 
Exceptions are debuggers as well as REPLs and similar tools such as Smalltalk workspaces and object inspectors, or computational notebooks. However, these are not designed for full scale program development. Most such tools do not support evaluation of code within an abstraction, such as a function or class instance. Debuggers do allow such evaluation, but require the user to navigate to a position in the code by manually initiating an execution path that leads to that position. 
As a result of the separation of editing from evaluation, programmers writing or reading a program must mentally simulate its execution in order to understand it. To avoid the cognitive burden of such simulation, this paper argues that program editing should be tightly integrated with an evaluator, so that any expression or statement being edited can be evaluated at will. We describe the design of a development environment for the Newspeak programming language which fulfills this requirement.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gilad</first_name>
          <last_name>Bracha</last_name>
          <affiliation>Google</affiliation>
          <bio>Gilad Bracha is the creator of the Newspeak programming language and a software engineer at Google where he works on Dart. Previously, he was a VP at SAP Labs, a Distinguished Engineer at Cadence, and a Computational Theologist and Distinguished Engineer at Sun. He is co-author of the Java Language Specification, and a researcher in the area of object-oriented programming languages. Prior to joining Sun, he worked on Strongtalk, the Animorphic Smalltalk System. He received his B.Sc in Mathematics and Computer Science from Ben Gurion University in Israel and a Ph.D. in Computer Science from the University of Utah.</bio>
          <homepage_url>bracha.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/giladbracha/1ddf0ae2-05c5-4eda-bfef-b6bb9e07f769/small.jpg</picture_url>
          <person_id>giladbracha</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>def90755-c2b9-47b9-a95f-e3e0f4a58efc</slot_id>
      <event_id>2441accf-37d6-494c-86f8-9a2b0147e276</event_id>
      <title>Modifiable Software Systems: Smalltalk and HyperCard</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>11:30</end_time>
      <description>When software doesn’t fully meet the needs of its user, what are the user’s options? For commercial software, the user can lobby the manufacturer for the feature they need—but the manufacturer may not respond. For open-source software, the user can fork the repo and add the feature themselves—but this requires becoming a developer on the platform the app is written in. But there have been better options in the past history of computing: software platforms that allow users to inspect the code of their software and modify it in the same environment the software runs in. With these software platforms, anyone using the application already has all the tooling they need to see how the application works and modify it. Platforms like this have played a significant role in the advancement of personal computing; can they do so again? This paper presents two such platforms, Smalltalk and HyperCard. It explores their motivation and development, their properties and impact, and their decline and successors. It assesses these platforms to see the ways they enabled people to modify their software, and whether there are unmet needs that future platforms could address to enable users further.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Josh</first_name>
          <last_name>Justice</last_name>
          <affiliation>Big Nerd Ranch</affiliation>
          <bio>Josh Justice has worked as a developer since 2004 across backend, frontend, and native mobile platforms. He currently serves as the Web Platform Lead at Big Nerd Ranch, a web and mobile development shop in Atlanta, Georgia. In this role he explores approaches to software development that aid evolutionary design, reduce barriers to change, and increase developer productivity.</bio>
          <homepage_url>https://codingitwrong.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/joshjustice/b5a7c8e9-1051-497d-90f7-ad862a2c0616/small.jpg</picture_url>
          <person_id>joshjustice</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e65d9265-3212-4fbb-abfb-363468c15f91</slot_id>
      <event_id>6e8d77b5-e230-4edb-85c9-be614fc8e092</event_id>
      <title>Peer-to-peer Syncing and Live Editing of Shared Virtual 3D Spaces: Challenges and Opportunities</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>11:50</end_time>
      <description>As groundwork for a virtual live programming collaboration environment, we built a peer-to-peer network of devices designed for 2D and 3D interactions that independently host, edit, and sync the state of a virtual space in real time. Both updates driven by a Unity-based peer’s game engine and updates driven at 60 Hz by a browser-based peer (running in a reactive JavaScript notebook) were observed. Our system showed significantly lower latency than a popular client-server networking service for Unity, and we observed realistic physics-based interactions for over 100 shared objects using a naïve algorithm that allows a peer to claim temporary ownership of an object’s physics. We see peer-to-peer networks like this as increasingly relevant to remote and in-person collaboration on a variety of tasks including learning and programming, and identify opportunities for improvement in the tools involved in their implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Edward</first_name>
          <last_name>Misback</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/edwardmisback/ab9b6cf6-8b1a-45fe-84a9-9b3f54b103b0/small.jpg</picture_url>
          <person_id>edwardmisback</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Steven L.</first_name>
          <last_name>Tanimoto</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.washington.edu/people/faculty/tanimoto</homepage_url>
          <person_id>stevenltanimoto</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e84be56c-cf15-4c50-a99d-7f8a53f87436</slot_id>
      <event_id>1ad987fd-5c4a-477a-9f1a-de8596bdd6d2</event_id>
      <title>Instadeq: A Live Programming Environment for End User Data Analysis and Visualization</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>11:10</end_time>
      <description>Data literacy is the ability to read, understand, create, and communicate data as information. 
Gartner defines a citizen data scientist as “a person who creates or generates models that leverage predictive or prescriptive analytics, but whose primary job function is outside of the field of statistics and analytics”. 
Which tools are available to data literates and citizens data scientists? 
We present Instadeq: a live programming environment for people without coding skills that allows them to consume, transform, aggregate, filter, visualize and share charts, dashboards, data driven presentations and simple data viewer applications using a visual language for structured queries and formulas. 
Instadeq is inspired by Spreadsheets, Notebooks, Structured Editors and Visual Programming. 
The current design has evolved by experiences acquired developing 3 products in this category used by non-technical users for the last 8 year.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mariano</first_name>
          <last_name>Guerra</last_name>
          <affiliation>Instadeq</affiliation>
          <bio>Software Engineer from Cordoba, Argentina. Co-founder of instadeq.com a NoCode Data Analysis and Visualization Tool. Previously Co-founder of Event Fabric. 
I’m Language Interoperability WG Chair and Documentation Working Group Member at the Erlang Ecosystem Foundation. 
I maintain a Weekly Newsletter about the Future of Coding 
More about me here: https://marianoguerra.github.io/</bio>
          <homepage_url>https://marianoguerra.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marianoguerra/6e5225f6-29f2-49e6-8721-a92a82b570dc/small.jpg</picture_url>
          <person_id>marianoguerra</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>913de949-78af-49a7-b2ad-69c992004fb8</subevent_id>
    <title>REBLS: Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/rebls-2021</url>
    <url_link_display>REBLS 2021</url_link_display>
    <tracks>
      <track>REBLS 2021</track>
    </tracks>
    <timeslot>
      <slot_id>74712798-c714-45a7-abcf-0962daab4140</slot_id>
      <title>Session: REBLS - Session 1</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Tian</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Wisconsin-Milwaukee</affiliation>
          <bio>undefined</bio>
          <person_id>tianzhao</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>494a0338-2ed1-43fd-be01-ebb5c0e1664b</slot_id>
      <event_id>9f274b48-fc19-4a0f-89ac-6f96fadd6cfc</event_id>
      <submission_id>25</submission_id>
      <title>Poker: Visual Instrumentation of Reactive Programs With Programmable Probes</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>11:15</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:40</end_time>
      <description>This paper presents Poker, a visual instrumentation platform for reactive programs. Similar to other platforms, Poker features a visual dashboard that allows the programmer to inspect the flow of values through the reactive program. The novelty of Poker is that: (a) It features a canvas of so-called that can be dynamically wired into a running reactive program in order to instrument the running system. (b) In addition to focusing on the values flowing through the program, every probe measures a particular property about the way these values flow through the instrumented program. (c) The set of probes is open because a probe is programmed in the same language as the instrumented program. Poker is implemented for Stella, an experimental reactive programming language. The paper uses an application written in Stella to motivate the concepts provided by Poker. We show 4 different probes that help us understand the behaviour of the application and we measure the overhead of using Poker on the running application with some preliminary benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cloé</first_name>
          <last_name>Descheemaeker</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>cloedescheemaeker</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Van den Vonder</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>PhD candidate at the Software Languages Lab of the Vrije Universiteit Brussel.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/samvandenvonder/2ccd1dd4-a774-4f8b-b2a1-c601a5adc3d5/small.jpg</picture_url>
          <person_id>samvandenvonder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Thierry</first_name>
          <last_name>Renaux</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>thierryrenaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wolfgangdemeuter/cb721b79-a1aa-4583-8ba0-b1a96f896900/small.jpg</picture_url>
          <person_id>wolfgangdemeuter</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a07c40de-6341-4b47-aac2-875a4c72d7e2</slot_id>
      <event_id>32135946-a6f3-4412-9c05-a2dde9cdaf7b</event_id>
      <submission_id>72</submission_id>
      <title>Dyninka: a FaaS framework for distributed dataflow applications</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:15</end_time>
      <description>The Internet of Things (IoT) requires applications to deal with a large amount of data - streamed, processed and stored from small devices to analytical systems. Cloud computing offers a hardware solution to this issue, providing on-demand resources to process IoT data. The newer programming paradigms simplify the use of those cloud resources. The Function-as-a-Service (FaaS) and the Serverless paradigm transformed the conception of micro-services applications to the definition and the composition of several callable functions. Although defined as a distributed architectures - mostly publicly available, solutions rely on either a gateway or an internal messaging middleware. These architectures create a single point of failure in exchange for more straightforward service to service communication. 
In this article, we present Dyninka, a framework to prototype FaaS-based distributed dataflow applications rapidly. Its programming model gathers the definition and the composition of services within a single file using the multitier-programming paradigm and compile into a multitude of services deployable on cloud computing infrastructure. Dyninka is built without a gateway or a messaging platform, and services communicate directly with each other or with the cloud abstracted infrastructure. As a consequence, we reduce the network and the computation overheads introduced by a framework. 
We validate Dyninka on a Fog computing scenario with limited resources and several load profiles. For all scenarios, Dyninka shows better stability, throughput and a reduced overhead compared to OpenFaaS.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Patrik</first_name>
          <last_name>Fortier</last_name>
          <affiliation>INSA Lyon</affiliation>
          <bio>undefined</bio>
          <person_id>patrikfortier</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Frédéric</first_name>
          <last_name>Le Mouël</last_name>
          <affiliation>INSA Lyon</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.le-mouel.net/</homepage_url>
          <person_id>fredericlemouel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Julien</first_name>
          <last_name>Ponge</last_name>
          <affiliation>Red Hat, Inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://julien.ponge.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/julienponge/52b328af-ff03-4e73-b071-42f8c4746373/small.jpg</picture_url>
          <person_id>julienponge</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bc9dd765-2b32-4532-a711-cea8cbd1f3c6</slot_id>
      <event_id>d91c021e-ca9f-4737-a191-f495d678c16f</event_id>
      <submission_id>76</submission_id>
      <title>ShapeRank: Rank Polymorphism meets Reactive Streams</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>11:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>12:05</end_time>
      <description>ShapeRank is a statically typed, functional programming lan- guage designed for machine learning, data analytics and re- active programming. All ShapeRank values are multidimen- sional streams, known as hyperstreams, and all operations are automatically lifted to process hyperstreams in parallel. This lifting originates in the APL language family, and is known as rank polymorphism. ShapeRank extends rank polymorphism to hyperstreams. ShapeRank functions may be either synchronous or reactive. We introduce ShapeRank with a focus on its reactive behavior. 
**This is an in-progress paper **</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gilad</first_name>
          <last_name>Bracha</last_name>
          <affiliation>g.bracha@f5.com</affiliation>
          <bio>undefined</bio>
          <person_id>giladbracha1</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fa14ceef-868f-46a4-9b82-2895bd64f08f</subevent_id>
    <title>SPLASH Onward! Essays: Essays Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-Essays</url>
    <url_link_display>Onward! Essays</url_link_display>
    <tracks>
      <track>Onward! Essays</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>8db8a028-77fb-4751-b7be-812f5bd5804b</slot_id>
      <title>Session: SPLASH Onward! Essays - Essays Session 2</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>49800847-ee8c-4414-9c1b-1113be4ed322</slot_id>
      <event_id>ccbe3853-1f7d-4e58-9239-01fa953d1723</event_id>
      <submission_id>onward21essays-id4-p</submission_id>
      <title>The Kingdoms of Objects and Values</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>22:30</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Friedrich</first_name>
          <last_name>Steimann</last_name>
          <affiliation>Fernuniversität in Hagen</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/friedrichsteimann/0382f30a-7342-49a1-b2f6-cf7d0929220c/small.jpg</picture_url>
          <person_id>friedrichsteimann</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>938dcd42-4596-443e-aa56-886514e483ee</slot_id>
      <event_id>69c1593f-353c-46f0-85b2-479ddbd22f12</event_id>
      <submission_id>onward21essays-id2-p</submission_id>
      <title>Let a Thousand Flowers Bloom: On the Uses of Diversity in Software Testing</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>22:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alex</first_name>
          <last_name>Groce</last_name>
          <affiliation>Northern Arizona University</affiliation>
          <bio>Alex Groce received his Ph.D. in computer science from Carnegie Mellon University in 2005, and B.S. degrees in computer science and multidisciplinary studies (with a focus on English literature) from North Carolina State University in 1999. He was a core member of the Laboratory for Reliable Software at NASA’s Jet Propulsion Laboratory, and taught classes on software testing at the California Institute of Technology. His activities at JPL included a role as lead developer and designer for test automation for the Mars Science Laboratory mission’s internal flight software test team, and lead roles in testing file systems for space missions. In 2009, he joined the faculty in Computer Science at Oregon State University, and was promoted to Associate Professor in 2015. In 2017, he joined the faculty of the new School of Informatics, Computing, and Cyber Systems (SICCS) at Northern Arizona University, to focus on software testing techniques for ensuring security and reliability of complex systems, especially embedded, scientific, and systems software. 
His research interests are in software engineering, particularly testing, model checking, static analysis, automated debugging, and execution understanding. He focuses on software engineering from an “investigative” viewpoint, with an emphasis on the execution traces that programs produce — software engineering as the art and science of building programs with a desired set of executions. 
His recent work has resulted in a DSL and (he hopes) usable and powerful testing tool for Python, the TSTL system, https://github.com/agroce/tstl, as well as contributions to the DeepState C/C++ unit testing interface to symbolic execution tools and fuzzers such as AFL and libFuzzer, https://github.com/trailofbits/deepstate.</bio>
          <homepage_url>https://agroce.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexgroce/989787fc-bf10-46da-8b9b-936e9ee92df8/small.jpg</picture_url>
          <person_id>alexgroce</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>207fd8e4-4320-483b-ac39-b084fa79cddf</subevent_id>
    <title>AGERE: Opening and keynote</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/17</date>
    <url>https://2021.splashcon.org/home/agere-2021</url>
    <url_link_display>AGERE 2021</url_link_display>
    <tracks>
      <track>AGERE 2021</track>
    </tracks>
    <timeslot>
      <slot_id>9bcdeb61-8db8-4225-9f4b-e2571f50f54a</slot_id>
      <title>Session: AGERE - Opening and keynote</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Elias</first_name>
          <last_name>Castegren</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://eliasc.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/eliascastegren/377a67c9-8fc9-4e1e-8925-558021e0d5c8/small.jpg</picture_url>
          <person_id>eliascastegren</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4b2f3fed-a49d-4c65-944e-65bcbcc12c26</slot_id>
      <event_id>1d90c16a-e08c-436c-9b46-37dbb5730209</event_id>
      <title>Actors! And now? An Implementer's Perspective on High-level Concurrency Models, Debugging Tools, and the Future of Automatic Bug Mitigation</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/17</date>
      <start_time>09:10</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:10</end_time>
      <description>The actor model is a great tool for various use cases. Though, it’s not the only tool, and sometimes perhaps not even the best. Consequently, developers started mixing and matching high-level concurrency models based on the problem at hand, much like other programming abstractions. Though, this comes with various problems. For instance, we don’t usually have debugging tools that help us to make sense of the resulting system. If we even have a debugger, it may barely allow us to step through our programs instruction by instruction. 
Let’s imagine a better world! One were we can follow asynchronous messages, jump to the next transaction commit, or break on the next fork/join task created. Though, race conditions remain notoriously difficult to reproduce. One solutions it to record our program’s execution, ideally capturing the bug. Then we can replay it as often as need to identify the cause of our bug. 
The hard bit here is making record &amp;amp; replay practical. I will explain how our concurrency-model-agnostic approach allows us to record model interactions trivially for later replay, and how we minimized its run-time overhead. In the case of actor applications, we can even make the snapshotting fast to be able to limit trace sizes. 
Having better debugging capabilities is a real productivity boost. Though, some bugs will always slip through the cracks. So, what if we could prevent those bugs from causing issues? Other researchers have shown how to do it, and I’ll conclude this talk with some ideas on how we can utilize the knowledge we have in our language implementations to make such mitigation approaches fast. 
The talk is based on work done in collaboration with Dominik Aumayr, Carmen Torres Lopez, Elisa Gonzalez Boix, and Hanspeter Mössenböck.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Marr</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://stefan-marr.de/research/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefanmarr/0917eab8-ec51-465f-9ff6-1295826fd91e/small.jpg</picture_url>
          <person_id>stefanmarr</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d7dcbd3e-34f8-4254-8e4e-506560638e73</slot_id>
      <event_id>404c1ce8-a57a-4788-bd4e-a26f569e9ace</event_id>
      <title>Opening</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>09:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elias</first_name>
          <last_name>Castegren</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://eliasc.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/eliascastegren/377a67c9-8fc9-4e1e-8925-558021e0d5c8/small.jpg</picture_url>
          <person_id>eliascastegren</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Fowler</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>I’m currently a Research Associate on the STARDUST project at the University of Glasgow School of Computing Science. 
My research interests centre around typed functional programming languages, in particular functional approaches to concurrency, web programming, and data management.</bio>
          <homepage_url>http://www.simonjf.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/simonfowler/8da87b62-b333-4c60-ac4a-27594510d4b1/small.jpg</picture_url>
          <person_id>simonfowler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Joeri</first_name>
          <last_name>De Koster</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/joeridekoster/2f5765d5-6ed1-4a75-acf1-99a86a994912/small.jpg</picture_url>
          <person_id>joeridekoster</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9d481aa9-c763-43d3-ab29-8871b3d57331</subevent_id>
    <title>CONFLANG: Closing: future of configuration</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/conflang-2021</url>
    <url_link_display>CONFLANG</url_link_display>
    <tracks>
      <track>CONFLANG</track>
    </tracks>
    <timeslot>
      <slot_id>174826e5-4053-452b-9447-533de68e257b</slot_id>
      <title>Session: CONFLANG - Closing: future of configuration</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b816356e-f9f5-42f8-a517-0047d3bd2e6a</slot_id>
      <event_id>a45a3493-9af7-4d2b-b8bd-90e51ab52a79</event_id>
      <title>Structured discussion: future of configuration languages</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d0f4838e-c5e1-4ff2-b330-93d5ed5888b3</subevent_id>
    <title>SPLASH Doctoral Symposium: Afternoon</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Currents</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-Doctoral-Symposium</url>
    <url_link_display>Doctoral Symposium</url_link_display>
    <tracks>
      <track>Doctoral Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>7b61e51f-b04f-46da-855c-e445313f9c91</slot_id>
      <title>Session: SPLASH Doctoral Symposium - Afternoon</title>
      <room>Swissotel Chicago | Currents</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>42630ffc-fa9a-4aa7-a920-b0d13092644f</slot_id>
      <event_id>fa7a0238-71a4-4c1d-840b-d38d6e050afc</event_id>
      <title>Towards Deep Learning Specification</title>
      <room>Swissotel Chicago | Currents</room>
      <date>2021/10/19</date>
      <start_time>13:55</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:30</end_time>
      <description>Deep Learning techniques are applied in software systems rapidly. Therefore, it becomes necessary to specify Deep Learning (DL) application programming interfaces (APIs) for desired output. Unlike traditional software, DL-specific development occupies bugs that exhibit not only crashes but also yield low accuracy and high training time issues. Inspired by the design-by-contract (DbC) methodology, this work proposes a preemptive measure against such bugs, we call it DL Contract. DL Contract aims to document properties of DL libraries and provide developers with a mechanism to prevent low accuracy and high training time-related bugs during development. One of the main challenges towards DL Contract is to specify properties of the training process, which is inaccessible at the functional interface of the DL libraries. Thus, we introduce the notion of ML variable that allows developers to specify the properties of model architecture, data, and training behavior. To evaluate the utility of DL Contract, we intend to utilize benchmarks from prior works on DL bug detection and repair after implementing DL Contract for Python-based DL libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shibbir</first_name>
          <last_name>Ahmed</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>shibbirahmed</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>8dbcd39c-877d-440d-8780-5cdd298cc386</slot_id>
      <event_id>64c6fe19-a14c-43ca-ae22-f19158bc3aae</event_id>
      <title>Avoiding Monomorphization Bottlenecks with Phase-based Splitting</title>
      <room>Swissotel Chicago | Currents</room>
      <date>2021/10/19</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>15:05</end_time>
      <description>State-of-the-art managed runtimes apply aggressive optimizations often based on the speculative assumption that programs have low variability. However, literature shows that program behavior may evolve at run time and experience different execution “phases”. This variable behavior may hide optimization opportunities from the compiler. Taking such phases into account may thus help improving performance when applied to phase-sensitive optimizations such as lookup caches, that may generate monomorphization bottlenecks when they contain entries that are phase-specific. 
In this project, we introduce Phase-based splitting, an experimental compiler optimization that utilizes phases to guide monomorphization based on splitting. Preliminary results on micro-benchmarks show our first prototype reaches promising speedups ranging from 10 to 20% on average, peaking up to 47.6% at phase granularity. In the next steps, we aim at further evaluating the potential benefits of our approach on a richer set of benchmarks and real-world applications as well as defining heuristics to better guide phase-based splitting.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sophie</first_name>
          <last_name>Kaleba</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/sophiekaleba/83d4bbee-60e2-41f8-a354-707df6642dc8/small.jpg</picture_url>
          <person_id>sophiekaleba</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bd594d43-6bbf-4fa1-beb5-07aa9a867d7c</subevent_id>
    <title>VMIL: Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/vmil-2021</url>
    <url_link_display>VMIL 2021</url_link_display>
    <tracks>
      <track>VMIL 2021</track>
    </tracks>
    <timeslot>
      <slot_id>5ba01411-dfd0-4804-941b-520ad6daec2d</slot_id>
      <title>Session: VMIL - Session 2</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Scholliers</last_name>
          <affiliation>Universiteit Gent, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~cfscholl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophescholliers/349aebe2-c428-4d19-8b70-9e1665dea5e6/small.jpg</picture_url>
          <person_id>christophescholliers</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e3de60e-12d0-433a-ba9e-8ccc6cbd6df3</slot_id>
      <event_id>bec8bc68-e3ec-4d09-9050-50a3eef31f8b</event_id>
      <submission_id>3</submission_id>
      <title>A Small Scheme VM, Compiler and REPL in 4K</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>11:20</end_time>
      <description>Compact language implementations are increasingly popular for use in resource constrained environments. For embedded applications such as robotics and home automation, it is useful to support a Read-Eval-Print-Loop (REPL) so that a basic level of interactive development is possible directly on the device. Due to its minimalistic design the Scheme language is particularly well suited for such applications and several implementations are available with different tradeoffs. In this paper we explain the design and implementation of a compact Scheme system that supports a REPL, is extensible and has a 4 KB executable code footprint.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Samuel</first_name>
          <last_name>Yvon</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>samuelyvon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marc</first_name>
          <last_name>Feeley</last_name>
          <affiliation>Université de Montréal</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iro.umontreal.ca/~feeley</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marcfeeley/2c882fdf-a3a8-4bbf-9e03-75b3d7d08909/small.jpg</picture_url>
          <person_id>marcfeeley</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
      <badges>
        <badge>Research Paper</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>c90dbc8c-e6b4-431e-8269-486eebe63a79</slot_id>
      <event_id>da0e5d77-5b53-4cb1-803d-2e6ca0f3a839</event_id>
      <submission_id>2</submission_id>
      <title>Lightweight On-Stack Replacement in Languages with Unstructured Loops</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>11:50</end_time>
      <description>On-stack replacement (OSR) is a popular technique used by just in time (JIT) compilers. A JIT can use OSR to transfer from interpreted to compiled code in the middle of execution, immediately reaping the performance benefits of compilation. This technique typically relies on loop counters, so it cannot be easily applied to languages with unstructured control flow. It is possible to reconstruct the high-level loop structures of an unstructured language using a control flow analysis, but such an analysis can be complicated, expensive, and language-specific. In this paper, we present a more lightweight strategy for OSR in unstructured languages which relies only on detecting backward jumps. We design a simple, language-agnostic API around this strategy for language interpreters. We then discuss our implementation of the API in the Truffle framework, and the design choices we made to make it efficient and correct. In our evaluation, we integrate the API with Truffle’s LLVM bitcode interpreter, and find the technique is effective at improving start-up performance without harming warmed-up performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matt</first_name>
          <last_name>D'Souza</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>mattdsouza</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Gilles</first_name>
          <last_name>Duboscq</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/gillesduboscq/cfc3738c-9767-42e8-83d6-43eb891c50b9/small.jpg</picture_url>
          <person_id>gillesduboscq</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
      <badges>
        <badge>Research Paper</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>f9f8157c-71d1-4210-97ec-d447a8e01ca9</slot_id>
      <event_id>537c6354-c7c4-4b1c-991d-d7c64697a75d</event_id>
      <submission_id>7</submission_id>
      <title>WOOD: Extending a WebAssembly VM with Out-of-Place Debugging for IoT applications</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>12:10</end_time>
      <description>Internet of Things (IoT) enables collaboration between humans and a diverse range of machines, including embedded devices and sensors. Software development of IoT applications is challenging given the distributed nature of the applications and the limited resources of some devices. This paper focuses on an extension to the WARDuino IoT platform that enhances debugging support, an integral part of the software development cycle. 
Popular offline debugging techniques such as logs, dumps, or record &amp;amp; replay are not suitable for IoT devices as they impose too much overhead on devices and often miss contextual information on the root cause of bugs. Online debuggers seem more suitable for IoT since they enable developers to remotely debug devices, but suffer from the probe-effect, non-reproducibility issues and high latency. 
In this paper, we explore an online debugging approach that deals with the constraints of IoT devices and enables low latency remote debugging. To this end, we bring ideas of out-of-place debugging, in which the state of a running application is moved to the developer’s machine, to IoT. We implement our out-of-place debugging approach for IoT in WOOD, an extension to the WARDuino VM that executes Web Assembly on embedded devices. The paper focuses on WOOD’s features including capturing, moving and reconstructing debugging sessions, as well as support for accessing remote resources and live code updating.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Carlos Javier</first_name>
          <last_name>Rojas Castillo</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>carlosjavierrojascastillo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Marra</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>I am a pre-doctoral researcher at the Vrije Universiteit Brussel (Belgium). After completing my bachelor studies in Italy (Università degli studi di Bologna), I moved to Brussels for a master at the Vrije Universiteit Brussel, in the Software Languages Lab, and decided to start a PhD under the guide of prof. Elisa Gonzalez Boix. I also cooperate with the RMoD research group at INRIA Lille Nord-Europe. 
My research focuses on debugging concurrent and parallel applications, particularly Big Data (or data intensive) applications.</bio>
          <homepage_url>https://soft.vub.ac.be/~mmarra</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/matteomarra/71e5312b-940b-4349-afaf-fa0a934b2c49/small.jpg</picture_url>
          <person_id>matteomarra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jim</first_name>
          <last_name>Bauwens</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jimbauwens/37b45fc6-5385-45e2-8dba-cfe6fb3399cd/small.jpg</picture_url>
          <person_id>jimbauwens</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Gonzalez Boix</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/elisagonzalezboix/51a3d0ba-7330-40d4-ad16-4568d31fe2e4/small.jpg</picture_url>
          <person_id>elisagonzalezboix</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
      <badges>
        <badge>WIP Paper</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>67c69020-2f94-437e-b6b8-b7081652895c</subevent_id>
    <title>APLAS Keynote Talks: Invited talk 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-keynote-talks</url>
    <url_link_display>Keynote Talks</url_link_display>
    <tracks>
      <track>Keynote Talks</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>129055a2-6d77-46ce-ac35-4f657d8226dc</slot_id>
      <title>Session: APLAS Keynote Talks - Invited talk 2</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Xujie</first_name>
          <last_name>Si</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.mcgill.ca/~xsi/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xujiesi/239392c8-225d-49b8-8a09-05ec7ba5c7a3/small.jpg</picture_url>
          <person_id>xujiesi</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>3d9800fa-a4f4-4f43-a55d-9b9fdd069c83</slot_id>
      <event_id>181db6e0-3cfe-45c3-98cd-f72b64ec7f58</event_id>
      <title>A Separation Logic for Probabilistic Independence</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>18:00</end_time>
      <description>Probabilistic independence is a useful concept for describing the result of random sampling—a basic operation in all probabilistic languages—and for reasoning about groups of random variables. Nevertheless, existing verification methods handle independence poorly, if at all. We propose a probabilistic separation logic PSL, where separation models probabilistic independence, based on a new, probabilistic model of the logic of bunched implications (BI). The program logic PSL is capable of verifying information-theoretic security of cryptographic constructions for several well-known tasks, including private information retrieval, oblivious transfer, secure multi-party addition, and simple oblivious RAM, while reasoning purely in terms of independence and uniformity. If time permits, we will also discuss ongoing work for reasoning about conditional independence.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Justin</first_name>
          <last_name>Hsu</last_name>
          <affiliation>University of Wisconsin-Madison, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.justinh.su</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/justinhsu/a2c25b60-0dc3-48ad-a41d-238071e3fbab/small.jpg</picture_url>
          <person_id>justinhsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>82b80b2d-7234-4fdb-9412-945477a0abcf</subevent_id>
    <title>SPLASH Keynotes: SPLASH Keynote</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>4782796c-46ff-4987-a775-b0c279c94b67</slot_id>
      <title>Session: SPLASH Keynotes - SPLASH Keynote</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>09:20</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fa83b5cf-8a80-4450-b716-e6d3617ef8f7</slot_id>
      <event_id>4aea397e-24ec-43c4-a73b-26df9bb20557</event_id>
      <title>Exascale and then what?: HPC and AI for Scientific Discovery</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>09:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>10:20</end_time>
      <description>We are on the verge of deploying Exascale systems, which remarkably in the US are quite similar in architecture and programming models. But what comes after these initial exascale systems? And what does that mean for scientific discovery and the languages, tools, and frameworks we need to build future applications? Are we going to see AI accelerators break out into the mainstream? Are hybrid-HPC/AI surrogate models the future of scientific computing? And if so what is the architecture and software implication? Is a hardware disaggregation model viable for HPC applications? Heterogenous workflows connecting the edge to the core are becoming more important yet our software stacks are unprepared and do not treat workflows as first-class applications. Increasing numbers of applications in science appear to require combining data analysis, simulations, and machine learning. What is the environment we need for building these new classes of applications? In this talk, I’ll try to make sense of trends and future direction and outline some important research problems for the next decade.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Rick</first_name>
          <last_name>Stevens</last_name>
          <affiliation>Argonne National Laboratory</affiliation>
          <bio>Rick Stevens is the Associate Laboratory Director of the Computing, Environment and Life Sciences Directorate at Argonne National Laboratory, and a Professor of Computer Science at the University of Chicago, with significant responsibility in delivering on the U.S. national initiative for Exascale computing and developing the DOE initiative in Artificial Intelligence (AI) for Science. 
His research spans the computational and computer sciences from high-performance computing architecture to the building of tools and methods for bioinformatics, cancer, infectious disease, and other problems in science and engineering. A recent focus has been the development of AI methods for a variety of scientific and biomedical problems. He also specializes in collaborative visualization technology and grid computing. At Argonne, he leads the Laboratory’s AI for Science initiative and is currently focusing on high-performance computing systems which includes collaborating with Intel and Cray to launch Argonne’s first exascale computer, Aurora, as well as the National AI Accelerator Testbed which brings together leading AI scientists to provide an open and unbiased environment for the evaluation of emerging AI accelerator technologies designed to accelerate training and inference for deep learning models. 
Prof. Stevens is a member of the American Association for the Advancement of Science and has received many national honors for his research, including an R&amp;amp;D 100 award and most recently being named a Fellow of the Association of Computer Machinery (ACM) for his continuing contributions to high-performance computing.</bio>
          <homepage_url>https://www.anl.gov/profile/rick-l-stevens</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rickstevens/bf9b1b15-be38-45d6-86a8-1d6bf26e8966/small.jpg</picture_url>
          <person_id>rickstevens</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
      <badges>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c20ec651-dd25-4b4e-9fb5-916f7e6d628d</subevent_id>
    <title>SPLASH Keynotes: SPLASH Keynote</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot>
      <slot_id>e41221e2-f858-4244-83d1-4652df6195b7</slot_id>
      <title>Session: SPLASH Keynotes - SPLASH Keynote</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>09:20</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2cc51ca2-85e0-4e22-90a6-6906eee3c5da</slot_id>
      <event_id>3cd9d6e6-482e-4d66-9453-b8af77578e91</event_id>
      <title>Integrated Scientific Modeling and Lab Automation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>09:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>10:20</end_time>
      <description>The cycle of observation, hypothesis formulation, experimentation, and falsification that has driven scientific and technical progress is lately becoming automated in all its separate components. However, integration between these automated components is lacking. Theories are not placed in the same formal context as the (coded) protocols that are supposed to test them: neither description knows about the other, although they both aim to describe the same process. 
We develop integrated descriptions from which we can extract both the model of a phenomenon (for possibly automated mathematical analysis), and the steps carried out to test it (for automated execution by lab equipment). This is essential if we want to carry out automated model synthesis, falsification, and inference, by taking into account uncertainties in both the model structure and in the equipment tolerances that may jointly affect the results of experiments.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Luca</first_name>
          <last_name>Cardelli</last_name>
          <affiliation>Microsoft Research and University of Oxford</affiliation>
          <bio>Luca is a Fellow of the Royal Society, and ACM Fellow, and was awarded the Dahl-Nygaard Prize in 2007. He is a Royal Society Research Professor at the University of Oxford. Prior to that, he has worked at Bells Labs, Digital Equipment Corporation, and Microsoft Research Cambridge. He obtained his M.S. University of Pisa and his Ph.D. at the University of Edinburgh. 
His research spans object-oriented foundations, type systems, module systems, distributed programming, spatial logics, semi-structured data, databases, computer architectures, and more recently, molecular programming and semantics, systems biology, biological models, and natural computability.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/lucacardelli/827a5e0f-bbe9-4ec5-ac0a-5f4e743d0d6d/small.jpg</picture_url>
          <person_id>lucacardelli</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
      <badges>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9f82d9f1-3a0e-4805-a897-61e6a1cc4e4e</subevent_id>
    <title>BCNC: Second Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/17</date>
    <url>https://2021.splashcon.org/home/bcnc-2021</url>
    <url_link_display>Beyond Code: No Code</url_link_display>
    <tracks>
      <track>Beyond Code: No Code</track>
    </tracks>
    <timeslot>
      <slot_id>2425d74c-b815-427b-bb53-9a8687d39fce</slot_id>
      <title>Session: BCNC - Second Session</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Ahmed</first_name>
          <last_name>ElBatanony</last_name>
          <affiliation>Innopolis University</affiliation>
          <bio>undefined</bio>
          <person_id>ahmedelbatanony</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Giancarlo</first_name>
          <last_name>Succi</last_name>
          <affiliation>Innopolis University</affiliation>
          <bio>undefined</bio>
          <person_id>giancarlosucci</person_id>
        </person>
      </persons>
      <tracks>
        <track>Beyond Code: No Code</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>45b69314-213b-4e02-918a-bf5851ee6967</subevent_id>
    <title>DLS: DLS Talks 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/dls-2021</url>
    <url_link_display>Dynamic Languages Symposium</url_link_display>
    <tracks>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>048dfe84-32d6-459c-9a51-98ca84eaf3eb</slot_id>
      <title>Session: DLS - DLS Talks 2</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>41c51c84-3406-4682-80dc-71448c168246</slot_id>
      <event_id>a2bd814e-644b-4386-a2fe-63fc670a4c7d</event_id>
      <title> Union and intersection contracts are hard, actually</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>07:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>08:15</end_time>
      <description>Union and intersection types are a staple of gradually typed language such as TypeScript. While it’s long been recog- nized that union and intersection types are difficult to ver- ify statically, it may appear at first that the dynamic part of gradual typing is actually pretty simple. It turns out however, that in presence of higher-order con- tracts union and intersection are deceptively difficult. The literature on higher-order contracts with union and inter- section, while keenly aware of the fact, doesn’t really ex- plain why. We point and illustrate the problems and trade- offs inherent to union and intersection contracts, via exam- ple and a survey of the literature.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Teodoro</first_name>
          <last_name>Freund</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>teodorofreund</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yann</first_name>
          <last_name>Hamdaoui</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>I graduated with a Ph.D from IRIF (Université Paris Diderot and CNRS, France) on the translation of effectful computation into Linear Logic. I now work at Tweag I/O on the design and implementation of Nickel, a configuration programming language.</bio>
          <homepage_url>https://hamdaoui.me</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannhamdaoui/e32e29d2-8091-41a9-9239-a4497b6578f8/small.jpg</picture_url>
          <person_id>yannhamdaoui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arnaud</first_name>
          <last_name>Spiwack</last_name>
          <affiliation>Tweag</affiliation>
          <bio>Arnaud Spiwack spend the first 10 years of his working life in Academia, between Chalmers university in Gothenburg, Sweden, and École Polytechnique, Inria, and Mines ParisTech, in the Paris area. He spent this time researching dependent types, computer-verified proof, and sequent calculus. During his time in Academia, Arnaud got involved in the development of the Coq Proof Assistant, where he, in particular, re-engineered Coq’s tactic engine and gave it an abstract interface. After leaving Academia, he remained a member of the core development team of the Coq Proof Assistant. He is now a senior architect at Tweag, and is working at making the world better typed.</bio>
          <homepage_url>http://assert-false.science/arnaud/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arnaudspiwack/2658428c-5eaf-48b9-9ff9-322b4260141e/small.jpg</picture_url>
          <person_id>arnaudspiwack</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
      <badges>
        <badge>Research Paper</badge>
        <badge>Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>bbbbd066-3c65-4023-a091-23547bde668f</slot_id>
      <event_id>77995b66-f823-4c12-a66a-32f1a9318823</event_id>
      <title>Chair's Welcome and Most Notable Paper Award</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>07:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
      <badges>
        <badge>Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>e4eb37b3-952f-40b2-bd12-177b2f5d502e</slot_id>
      <event_id>2ff813f8-2b71-4bbd-8098-ecd51e17189c</event_id>
      <title>Runtime and Compiler Support for HAMTs</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>08:15</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>08:40</end_time>
      <description>Many functional languages—including Racket, Clojure, and Scala—provide a persistent-map datatype with an implementation based on Hash Array Mapped Tries (HAMTs). HAMTs enable efficient functional lookup, insertion, and deletion operations with a small memory footprint, especially when taking advantage of implementation techniques that have been developed since the original HAMT implementation. Racket’s latest HAMT implementation is based on an intermediate data structure, a stencil vector, that supports an especially compact representation of HAMTs with help from the compiler and memory manager. That is, stencil vectors provide an abstraction to improve HAMT performance without burdening the compiler with all of the complexity and design choices of a HAMT implementation. Benchmark measurements show that HAMTs in Racket have performance comparable to other state-of-the-art implementations, while stencil-vector HAMTs are more compact and run at least as fast as alternative representations in Racket.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sona</first_name>
          <last_name>Torosyan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sonatorosyan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jon</first_name>
          <last_name>Zeppieri</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>jonzeppieri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Flatt</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>Matthew Flatt is a professor in the School of Computing at the University of Utah, where he works on extensible programming languages, runtime systems, and applications of functional programming. He is one of the developers of the Racket programming language. He received his PhD from Rice University in 1999.</bio>
          <homepage_url>http://www.cs.utah.edu/~mflatt/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/matthewflatt/8be359a0-6498-4c8c-a43a-e74a3d39673c/small.jpg</picture_url>
          <person_id>matthewflatt</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
      <badges>
        <badge>Research Paper</badge>
        <badge>Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e0c87dbc-03d7-4243-a877-9bb3ca138893</subevent_id>
    <title>SPLASH Doctoral Symposium: Morning 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Currents</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-Doctoral-Symposium</url>
    <url_link_display>Doctoral Symposium</url_link_display>
    <tracks>
      <track>Doctoral Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>2a42d691-03b6-4718-9e1f-b6a0c4bc0c94</slot_id>
      <title>Session: SPLASH Doctoral Symposium - Morning 1</title>
      <room>Swissotel Chicago | Currents</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5abe0486-060a-4d94-ab4a-18f84e612c59</slot_id>
      <event_id>43ddbf51-5139-47a3-a6a0-3e93521cf49a</event_id>
      <title>Navigating your thesis and job search: sustainability and standing out [Invited Talk]</title>
      <room>Swissotel Chicago | Currents</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>84edaa08-4541-40ae-a487-250ab4061567</slot_id>
      <event_id>1d27d46d-dc9e-4962-8d49-50b91db97e1a</event_id>
      <title>Elevator Talks</title>
      <room>Swissotel Chicago | Currents</room>
      <date>2021/10/19</date>
      <start_time>10:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>10:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>be8987da-531f-447e-8750-cb984c767d45</subevent_id>
    <title>REBLS: Welcome to REBLS &amp; Keynote</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/rebls-2021</url>
    <url_link_display>REBLS 2021</url_link_display>
    <tracks>
      <track>REBLS 2021</track>
    </tracks>
    <timeslot>
      <slot_id>350777b0-f0ea-474c-833f-fb103db07c61</slot_id>
      <title>Session: REBLS - Welcome to REBLS &amp; Keynote</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>295d33d0-09a5-424b-90d4-1cbdcb131109</slot_id>
      <event_id>433062d0-b019-4422-8345-a9fbcb66ca36</event_id>
      <title>Specification and End-to-End Proof of a Reactive Language and its Compiler</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>09:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Timothy</first_name>
          <last_name>Bourke</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tbrk.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/timothybourke/747739f4-e5f1-4d96-957d-a9e98c1ba4f7/small.jpg</picture_url>
          <person_id>timothybourke</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
      <badges>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>346b8486-e351-49dc-9800-a6ffe8ebbe23</slot_id>
      <event_id>783d0e79-68fb-4c7f-a28b-75cdd888af85</event_id>
      <title>Welcome to REBLS</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1be47905-2e7b-40a8-8938-6e57fa051926</subevent_id>
    <title>APLAS Keynote Talks: Invited talk 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-keynote-talks</url>
    <url_link_display>Keynote Talks</url_link_display>
    <tracks>
      <track>Keynote Talks</track>
    </tracks>
    <timeslot>
      <slot_id>3191a99e-6d98-42e6-8695-a2ddcb9ea18d</slot_id>
      <title>Session: APLAS Keynote Talks - Invited talk 2</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
          <person_id>atsushiigarashi</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>092f1bfe-3b34-426b-b568-381f47328c0c</slot_id>
      <event_id>181db6e0-3cfe-45c3-98cd-f72b64ec7f58</event_id>
      <title>A Separation Logic for Probabilistic Independence</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:00</end_time>
      <description>Probabilistic independence is a useful concept for describing the result of random sampling—a basic operation in all probabilistic languages—and for reasoning about groups of random variables. Nevertheless, existing verification methods handle independence poorly, if at all. We propose a probabilistic separation logic PSL, where separation models probabilistic independence, based on a new, probabilistic model of the logic of bunched implications (BI). The program logic PSL is capable of verifying information-theoretic security of cryptographic constructions for several well-known tasks, including private information retrieval, oblivious transfer, secure multi-party addition, and simple oblivious RAM, while reasoning purely in terms of independence and uniformity. If time permits, we will also discuss ongoing work for reasoning about conditional independence.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Justin</first_name>
          <last_name>Hsu</last_name>
          <affiliation>University of Wisconsin-Madison, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.justinh.su</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/justinhsu/a2c25b60-0dc3-48ad-a41d-238071e3fbab/small.jpg</picture_url>
          <person_id>justinhsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>35162ce7-2874-407b-a169-518deb8b969f</subevent_id>
    <title>SPLASH Doctoral Symposium: Morning 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Currents</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-Doctoral-Symposium</url>
    <url_link_display>Doctoral Symposium</url_link_display>
    <tracks>
      <track>Doctoral Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>136ac841-b2ed-4264-88ae-3066c01a824d</slot_id>
      <title>Session: SPLASH Doctoral Symposium - Morning 2</title>
      <room>Swissotel Chicago | Currents</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>40026591-7251-428c-b51c-1a6f4369c980</slot_id>
      <event_id>3344db26-7384-4321-b98a-c129d01971bc</event_id>
      <title>Run-time Data Analysis to Drive Compiler Optimizations</title>
      <room>Swissotel Chicago | Currents</room>
      <date>2021/10/19</date>
      <start_time>10:55</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>11:30</end_time>
      <description>Throughout program execution, types may stabilize, variables may become constant, and code sections may turn out to be redundant - all information that is used by just-in-time (JIT) compilers to achieve peak performance. Yet, since JIT compilation is done on demand for individual code parts, global observations cannot be made. Moreover, global data analysis is an inherently expensive process, that collects information over large data sets. Thus, it is infeasible in dynamic compilers. With this project, we propose integrating data analysis into a dynamic runtime to speed up big data applications. The goal is to use the detailed run-time information for speculative compiler optimizations based on the shape and complexion of the data to improve performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Kloibhofer</last_name>
          <affiliation>Johannes Kepler Universität Linz</affiliation>
          <bio>undefined</bio>
          <person_id>sebastiankloibhofer</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>973e50a7-3055-4cef-94dc-7a7f2d1c1781</slot_id>
      <event_id>db93d0c5-6661-4334-a2d4-ce8053c39876</event_id>
      <title>Run-Time Data Analysis in Dynamic Runtimes</title>
      <room>Swissotel Chicago | Currents</room>
      <date>2021/10/19</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>12:05</end_time>
      <description>Databases are typically faster in processing huge amounts of data than applications with hand-coded data access. Even though modern dynamic runtimes optimize applications intensively, they cannot perform certain optimizations that are traditionally used by database systems as they lack the required information. Thus, we propose to extend the capabilities of dynamic runtimes to allow them to collect fine-grained information of the processed data at run time and use it to perform database-like optimizations. By doing so, we want to enable dynamic runtimes to significantly boost the performance of data-processing workloads. Ideally, applications should be as fast as databases in data-processing workloads by detecting the data schema at run time. To show the feasibility of our approach, we are implementing it in a polyglot dynamic runtime.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Makor</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>undefined</bio>
          <person_id>lukasmakor</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ba139950-a1bf-4b4a-8116-1bf5b074d5f8</subevent_id>
    <title>AGERE: Safety and Failures</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/17</date>
    <url>https://2021.splashcon.org/home/agere-2021</url>
    <url_link_display>AGERE 2021</url_link_display>
    <tracks>
      <track>AGERE 2021</track>
    </tracks>
    <timeslot>
      <slot_id>072c4fef-3cc7-4ca3-b7a5-05948088e35b</slot_id>
      <title>Session: AGERE - Safety and Failures</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/17</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Joeri</first_name>
          <last_name>De Koster</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/joeridekoster/2f5765d5-6ed1-4a75-acf1-99a86a994912/small.jpg</picture_url>
          <person_id>joeridekoster</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>02137088-febd-4b53-9a4d-6d87f14c6297</slot_id>
      <event_id>66638cfd-8227-4800-b5df-72d534ea8f27</event_id>
      <submission_id>2</submission_id>
      <title>Contract-Based Return-Value Commutativity: Safely exploiting contract-based commutativity for faster serializable transactions</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/17</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:15</end_time>
      <description>A key challenge of designing distributed software systems is maintaining data consistency. 
We can define data consistency and data isolation guarantees —e.g. serializability– in terms of schedules of atomic reads and writes, but this excludes schedules that would be semantically consistent. Others use manually provided information on ``non-conflicting operations'' to define guarantees that work for more applications allowing more parallel schedules. To be safe, an engineer might avoid marking operations as non-conflicting, with detrimental effects to efficiency. To be fast, they might mark more non-conflicting operations than is strictly safe. 
Our goal is to help engineers by automatically deriving commutative operations (using their respective contracts) such that more parallel schedules with global consistency are possible. We define a new general consistency and isolation guarantee named “Return-Value Serializability” to check consistency claims automatically, and we present distributed event processing algorithms that make use of the same “Contract-based Commutativity” information. We validated both the definitions and the algorithms using model-checking with TLA+. Previous work provided evidence that local coordination avoidance such as applied here has a significant positive effect on the performance of distributed transaction systems. 
Client-centric return-value commutativity promises to hit a sweet spot in design trade-offs for business applications, such as payment systems, that must scale-out while their operations are not embarrassingly parallel and consistency guarantees are of the highest priority. It can also provide design feedback, indicating that some operations will simply not scale together even before a line of code has been written.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tim</first_name>
          <last_name>Soethout</last_name>
          <affiliation>ING Bank and Centrum Wiskunde &amp; Informatica (CWI)</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/timsoethout/a9ae549f-7f5b-4454-ba93-66aaf10cf535/small.jpg</picture_url>
          <person_id>timsoethout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tijs</first_name>
          <last_name>van der Storm</last_name>
          <affiliation>CWI &amp; University of Groningen, Netherlands</affiliation>
          <bio>Tijs van der Storm is senior researcher in the Software Analysis and Transformation (SWAT) group at Centrum Wiskunde &amp;amp; Informatica (CWI) in Amsterdam, and full professor in Software Engineering at the University of Groningen in Groningen. His research focuses on improving programmer experience through new and better software languages and developing the tools and techniques to engineer them in a modular and interactive fashion.</bio>
          <homepage_url>http://www.cwi.nl/~storm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tijsvanderstorm/1c2fdfb2-3ce0-4e75-91af-35d9a48f56c5/small.jpg</picture_url>
          <person_id>tijsvanderstorm</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jurgen</first_name>
          <last_name>Vinju</last_name>
          <affiliation>CWI, Netherlands</affiliation>
          <bio> 
 Researcher, see http://jurgen.vinju.org, in 
   
   Software Language Engineering 
   Programming Languages 
   Empirical Software Engineering 
   Software Evolution 
    
 (Co)-Designer and/or (co-)engineer of (selected): 
   
   Rascal Metaprogramming Language http://www.rascalmpl.org 
   Rascal VScode https://github.com/usethesource/rascal-language-servers 
   Vallang http://www.usethesource.io/projects/vallang 
   IMP http://www.eclipse.org/imp, now Impulse http:www.usethesource.io/projects/impulse 
   OSSMETER http://www.ossmeter.org 
   ASF+SDF Meta-Environment http://www.meta-environment.org 
   SDF2 http://www.syntax-definition.org 
    
 Titles 
   
   Full professor of Automated Software Analysis at TU Eindhoven 
   Group leader Software Analysis and Transformation at Centrum Wiskunde &amp;amp; Informatica https://www.cwi.nl/research/groups/software-analysis-and-transformation 
   Co-owner of SWAT.engineering BV http://www.swat.engineering 
    
</bio>
          <homepage_url>http://homepages.cwi.nl/~jurgenv</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jurgenvinju/31e5a54c-e7a3-4c37-b0c9-ca2254e3ef59/small.jpg</picture_url>
          <person_id>jurgenvinju</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>52411caf-9165-4064-9d71-8d5fca986019</slot_id>
      <event_id>6eb4fc04-179c-4239-b9fa-68fb5e2c05f7</event_id>
      <submission_id>4</submission_id>
      <title>A model of actors and grey failures</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/17</date>
      <start_time>14:15</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:40</end_time>
      <description>We report on ongoing work on defining a model of failures for distributed systems, as a first step towards better detection and diagnostic of failures, as well as a foundation for provable reliability.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Laura</first_name>
          <last_name>Bocchi</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.kent.ac.uk/people/staff/lb514/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/laurabocchi/86b7ceaf-5ceb-4fa3-b6b1-6d1248bfcf9e/small.jpg</picture_url>
          <person_id>laurabocchi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julien</first_name>
          <last_name>Lange</last_name>
          <affiliation>Royal Holloway University of London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.rhul.ac.uk/~jlange</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/julienlange/7f3ad551-a3e6-46ce-9718-954f3147736b/small.jpg</picture_url>
          <person_id>julienlange</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Simon</first_name>
          <last_name>Thompson</last_name>
          <affiliation>IOHK, University of Kent, and ELTE</affiliation>
          <bio>Researcher, author and teacher, senior researcher for IOHK and professor at the University of Kent and ELTE, Budapest. 
His research has covered many aspects of functional programming, including verification, tool building and testing for Erlang, Haskell and OCaml. He is an author of books on type theory, Haskell and Erlang, and runs a MOOC on Erlang for FutureLearn. He is currently a senior research lead at IOHK, developing a DSL for financial contracts on blockchain.</bio>
          <homepage_url>https://www.kent.ac.uk/computing/people/3164/thompson-simon</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/simonthompson/72c4e810-3414-4761-b33b-8cb04cd48fc1/small.jpg</picture_url>
          <person_id>simonthompson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>A. Laura</first_name>
          <last_name>Voinea</last_name>
          <affiliation>University of Kent, UK</affiliation>
          <bio>undefined</bio>
          <person_id>alauravoinea</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7b71d95c-21fa-4662-ae78-f5fab536429c</slot_id>
      <event_id>aaaccb37-3888-4821-955f-3dce0ce076fa</event_id>
      <title>Closing</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/17</date>
      <start_time>15:05</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Elias</first_name>
          <last_name>Castegren</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://eliasc.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/eliascastegren/377a67c9-8fc9-4e1e-8925-558021e0d5c8/small.jpg</picture_url>
          <person_id>eliascastegren</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Fowler</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>I’m currently a Research Associate on the STARDUST project at the University of Glasgow School of Computing Science. 
My research interests centre around typed functional programming languages, in particular functional approaches to concurrency, web programming, and data management.</bio>
          <homepage_url>http://www.simonjf.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/simonfowler/8da87b62-b333-4c60-ac4a-27594510d4b1/small.jpg</picture_url>
          <person_id>simonfowler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Joeri</first_name>
          <last_name>De Koster</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/joeridekoster/2f5765d5-6ed1-4a75-acf1-99a86a994912/small.jpg</picture_url>
          <person_id>joeridekoster</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9f26370d-415e-4812-943b-9174f3602819</slot_id>
      <event_id>ceabeb3b-55d2-40ba-bbf3-a34a38fadd11</event_id>
      <submission_id>7</submission_id>
      <title>What's the Problem? Interrogating Actors to Identify the Root Cause of Concurrency Bugs</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/17</date>
      <start_time>14:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>15:05</end_time>
      <description>Programs written using Communicating Event-Loops (CEL) concurrency model do not suffer from low-level data races by design but are not exempt from other concurrency bugs, such as behavioral deadlocks and message order violations. 
When programmers need to find the root cause of a bug, they typically ask questions on the behavior of the application. Current debugging tools, however, are mostly operational, offering features at the source code level like breakpoints and watchpoints. Consequently, understanding the program behavior when debugging can take a lot of time for developers since questions on behaviors need to be map into operations in the debugger. 
Inspired by interrogative debugging, this paper proposes an interactive debugging approach for actor-based programs that enable developers to reason about the program output by selecting questions from a set of predefined questions on the code and the program’s execution. We present the design of the questions and answers, and we describe a prototype implementation in Apgar, an online debugger for actor-based programs written in SOMns. Questions are defined on key concepts of the actor model: actors, turns, messages, and promises. The debugger then computes the answers by analyzing a recorded trace of events on the program execution.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Carmen</first_name>
          <last_name>Torres Lopez</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/carmentorreslopez/7b3baa23-6f71-4c2c-adda-280f434ad79b/small.jpg</picture_url>
          <person_id>carmentorreslopez</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Louise</first_name>
          <last_name>Van Verre</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>louisevanverre</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Gonzalez Boix</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/elisagonzalezboix/51a3d0ba-7330-40d4-ad16-4568d31fe2e4/small.jpg</picture_url>
          <person_id>elisagonzalezboix</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f43cd203-2745-4656-8731-fdd54a931ceb</subevent_id>
    <title>DLS: DLS Talks 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/dls-2021</url>
    <url_link_display>Dynamic Languages Symposium</url_link_display>
    <tracks>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>880378ab-220f-4abf-81d1-b3ed940f43ab</slot_id>
      <title>Session: DLS - DLS Talks 1</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4075ca50-74f1-4d2c-b922-1ffea0391e1a</slot_id>
      <event_id>9993747b-3c5e-4b12-955b-de42f70eb152</event_id>
      <title>Analyzing Permission Transfer Channels for Dynamically Typed Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:15</end_time>
      <description>Communicating Sequential Process~(CSP) is nowadays a popular concurrency model in which threads/processes communicate by exchanging data through channels. Channels helps in orchestrating concurrent processes but do not solve per-se data races. To prevent data races in the channel model, many programming languages rely on type systems to express ownership and behavioural restrictions such as immutability. However, dynamically-typed languages require runtime mechanisms because of the lack of type information at compile-time. 
In this paper, we propose to augment channels with four different permission transfer semantics. We explore two mechanisms to implement such permission transfers at run-time: write-barriers and partial read-barriers. To validate our approach we implemented a channel framework in Pharo, and we extended it with different permission transfer semantics. We report on performance measurements of both (a) the transfer overhead on a single object and on a graph of objects, and (b) the per-object access overhead incurred by ownership checks. This work stands as a cornerstone of future work on adaptive optimisations for permission transfer channels.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Théo</first_name>
          <last_name>Rogliano</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>theorogliano</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillermo</first_name>
          <last_name>Polito</last_name>
          <affiliation>Univ. Lille, CNRS, Centrale Lille, Inria, UMR 9189 - CRIStAL - Centre de Recherche en Informatique Signal et Automatique de Lille</affiliation>
          <bio>Guille Polito is research engineer at the CRIStAL laboratory in the university of Lille, working in tight relation with the RMoD team. Guille’s main research interests are programming language development, programming tools, modular systems, and maintenance of large software systems. 
He currently works on techniques to develop modular systems and languages, and new development tools. Guille works in the development of the open source Pharo programming language and environment since 2010, and he is a member of its technical board since 2018.</bio>
          <homepage_url>https://guillep.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guillermopolito/fb027991-a37d-4375-8c71-1858ce478695/small.jpg</picture_url>
          <person_id>guillermopolito</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Luc</first_name>
          <last_name>Fabresse</last_name>
          <affiliation>Mines Douai</affiliation>
          <bio>undefined</bio>
          <person_id>lucfabresse</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stéphane</first_name>
          <last_name>Ducasse</last_name>
          <affiliation> INRIA Lille</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://stephane.ducasse.free.fr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stephaneducasse/509504d8-baa1-42b4-a71a-b441f9ae92bb/small.jpg</picture_url>
          <person_id>stephaneducasse</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
      <badges>
        <badge>Research Paper</badge>
        <badge>Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>46e336ac-6a7b-4628-b60f-f5f205446a6c</slot_id>
      <event_id>9bdff49b-71f5-4402-b9c5-72c6e4a6847f</event_id>
      <title>On Design and Use of First-Class Environments in R</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>14:15</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:40</end_time>
      <description>The R programming language is widely used for statistical computing. To enable interactive data exploration and rapid prototyping, R encourages a dynamic programming style. This programming style is support by a number of features including first-class environments. R is the only language, with millions of users, that provides a full reflective interface for manipulating environments. With the great flexibility afforded by first-class environments, comes challenges for reasoning about code and significant restrictions about what transformations a compiler is allowed to apply to programs. This paper is an overview of the environment interface refined over two decades. We explain the rationale behind the design and document how environments are used in the wild by the means of a corpus analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
      <badges>
        <badge>Research Paper</badge>
        <badge>Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>dbd20693-2efb-4e71-b4e6-3f2c8521e28b</slot_id>
      <event_id>b34908e0-77cf-44d3-a0e4-e7848afc6c69</event_id>
      <title>CompGen: Generation of Fast JIT Compilers in a Multi-Language VM</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>14:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>15:05</end_time>
      <description>The first Futamura projection enables compilation and high performance code generation of user programs by partial evaluation of language interpreters. Previous work has shown that it yields the same peak performance as a specialized JIT compiler. However, this comes with the downside of additional compile time: Partial evaluation of language interpreters has to specialize interpreter code on the fly to the dynamic types used at run time to create efficient target code. As a result, the time spent on partial evaluation itself is a significant contributor to the overall compile time of a method. 
The second Futamura projection solves this problem by self-applying partial evaluation on the partial evaluation algorithm, effectively generating language-specific compilers from interpreters. This typically reduces compilation time compared to the first projection. Previous work employed the second projection to some extent, however we are not aware of any usage of the generic second Futamura projection in a state-of-the-art language runtime. 
To solve the problems of self-application and code-size explosion, this paper proposes CompGen, an approach based on code generation of subsets of language interpreters. It is loosely based upon the idea of the second Futamura projection. Our implementation of CompGen for GraalVM shows that our usage of a novel code-generation algorithm allows us to generate efficient compilers that emit fast target programs which easily outperform the first Futamura projection in compilation time. We evaluated our approach with the high-performance JavaScript implementation of GraalVM and standard JavaScript benchmarks, showing that our approach achieves &amp;gt; 2X speedups of partial evaluation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Latifi</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>Researcher and PhD student at the Johannes Kepler University in Linz, Austria.</bio>
          <homepage_url>https://florian-latifi.at</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/florianlatifi/a986450f-d097-4d8e-8448-4ebfc1a2206e/small.jpg</picture_url>
          <person_id>florianlatifi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Leopoldseder</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.davidleopoldseder.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidleopoldseder/e0b1ae47-d779-400d-8f0f-0b3cce3e0f7f/small.jpg</picture_url>
          <person_id>davidleopoldseder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christian</first_name>
          <last_name>Wimmer</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Christian Wimmer is the architect of GraalVM Native Image. He was one of the first engineer of the GraalVM project, and helped growing it from a research project of Oracle Labs to a supported Oracle product. He believes that all languages should be equally fast, and that we therefore need to stop writing individual VMs and instead have one polyglot VM. His research interests span from compilers, virtual machines, and secure systems to component-based software architectures. 
He received a Dr. techn. degree in Computer Science (advisor: Prof. Hanspeter Mössenböck) and a Dipl.-Ing. degree in Computer Science, both from the Johannes Kepler University Linz, Austria. Before the time at Oracle, he was a postdoctoral researcher at the Department of Computer Science of the University of California, Irvine. He worked with Prof. Michael Franz at the Secure Systems and Software Laboratory on compiler optimizations, dynamic programming languages, and language-based security.</bio>
          <homepage_url>http://www.christianwimmer.at/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/christianwimmer/faa7e48f-04de-4752-83a4-efdf6b175be1/small.jpg</picture_url>
          <person_id>christianwimmer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hanspeter</first_name>
          <last_name>Mössenböck</last_name>
          <affiliation>JKU Linz, Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ssw.jku.at/General/Staff/HM/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hanspetermossenbock/3a16b6f0-00fa-4ef3-93df-13ea4a29430c/small.jpg</picture_url>
          <person_id>hanspetermossenbock</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
      <badges>
        <badge>Research Paper</badge>
        <badge>Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d957e057-6e1c-4661-a34b-77a5a6cd0bdf</subevent_id>
    <title>VMIL: Session 4</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/vmil-2021</url>
    <url_link_display>VMIL 2021</url_link_display>
    <tracks>
      <track>VMIL 2021</track>
    </tracks>
    <timeslot>
      <slot_id>1284a655-35cd-4b3c-a5e5-737a5a8e1f9c</slot_id>
      <title>Session: VMIL - Session 4</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Gregor</first_name>
          <last_name>Richards</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://the.gregor.institute/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gregorrichards/bd8bf252-24c9-4721-a495-c06a6949a332/small.jpg</picture_url>
          <person_id>gregorrichards</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>93eb6de2-779c-48da-97df-82e7a254ebe7</slot_id>
      <event_id>442348a9-49f0-4b3a-bf17-c0fd95ab7c59</event_id>
      <title>GraalVM Native Image: Large-scale static analysis for Java</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:40</end_time>
      <description>GraalVM Native Image combines static analysis, heap snapshotting, and ahead-of-time compilation to produce a highly optimized standalone executable for a Java application. In this talk, we first introduce the overall architecture of GraalVM Native Image: instead of “just” compiling Java bytecode ahead of time, it also initializes part of the application at build time. This reduces the startup time and memory footprint of the application at run time. 
In the second part of the talk, we dive into details of the points-to analysis. We show which of our original research ideas worked or did not work when analyzing large production applications; and we show the benefits of tightly integrating the static analysis with the ahead-of-time compiler.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Wimmer</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Christian Wimmer is the architect of GraalVM Native Image. He was one of the first engineer of the GraalVM project, and helped growing it from a research project of Oracle Labs to a supported Oracle product. He believes that all languages should be equally fast, and that we therefore need to stop writing individual VMs and instead have one polyglot VM. His research interests span from compilers, virtual machines, and secure systems to component-based software architectures. 
He received a Dr. techn. degree in Computer Science (advisor: Prof. Hanspeter Mössenböck) and a Dipl.-Ing. degree in Computer Science, both from the Johannes Kepler University Linz, Austria. Before the time at Oracle, he was a postdoctoral researcher at the Department of Computer Science of the University of California, Irvine. He worked with Prof. Michael Franz at the Secure Systems and Software Laboratory on compiler optimizations, dynamic programming languages, and language-based security.</bio>
          <homepage_url>http://www.christianwimmer.at/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/christianwimmer/faa7e48f-04de-4752-83a4-efdf6b175be1/small.jpg</picture_url>
          <person_id>christianwimmer</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
      <badges>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>c34250bd-98c7-46bd-a118-20af9705389d</slot_id>
      <event_id>4a2f0ebb-6e41-4c00-a5bd-75e79e2f1c5f</event_id>
      <title>Closing</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gregor</first_name>
          <last_name>Richards</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://the.gregor.institute/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gregorrichards/bd8bf252-24c9-4721-a495-c06a6949a332/small.jpg</picture_url>
          <person_id>gregorrichards</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Rigger</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>Manuel Rigger is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Zhendong Su. He is working on programming language implementation, software reliability, and systems. He completed his PhD at Johannes Kepler University Linz, mentored by Hanspeter Mössenböck, and is known for his work on Sulong to support the safe execution of LLVM-based languages.</bio>
          <homepage_url>http://www.manuelrigger.at/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/manuelrigger/47e268e9-158c-471f-a7e9-442216c54550/small.jpg</picture_url>
          <person_id>manuelrigger</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2b7fae21-1e51-4684-84ef-57124466382c</subevent_id>
    <title>SPLASH Onward! Essays: Essays Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-Essays</url>
    <url_link_display>Onward! Essays</url_link_display>
    <tracks>
      <track>Onward! Essays</track>
    </tracks>
    <timeslot>
      <slot_id>1b795d50-9da3-4f3b-a538-fff8cf2430f8</slot_id>
      <title>Session: SPLASH Onward! Essays - Essays Session 2</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>27077bdd-6885-4b90-ab78-5ecd7facd0d8</slot_id>
      <event_id>69c1593f-353c-46f0-85b2-479ddbd22f12</event_id>
      <submission_id>onward21essays-id2-p</submission_id>
      <title>Let a Thousand Flowers Bloom: On the Uses of Diversity in Software Testing</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alex</first_name>
          <last_name>Groce</last_name>
          <affiliation>Northern Arizona University</affiliation>
          <bio>Alex Groce received his Ph.D. in computer science from Carnegie Mellon University in 2005, and B.S. degrees in computer science and multidisciplinary studies (with a focus on English literature) from North Carolina State University in 1999. He was a core member of the Laboratory for Reliable Software at NASA’s Jet Propulsion Laboratory, and taught classes on software testing at the California Institute of Technology. His activities at JPL included a role as lead developer and designer for test automation for the Mars Science Laboratory mission’s internal flight software test team, and lead roles in testing file systems for space missions. In 2009, he joined the faculty in Computer Science at Oregon State University, and was promoted to Associate Professor in 2015. In 2017, he joined the faculty of the new School of Informatics, Computing, and Cyber Systems (SICCS) at Northern Arizona University, to focus on software testing techniques for ensuring security and reliability of complex systems, especially embedded, scientific, and systems software. 
His research interests are in software engineering, particularly testing, model checking, static analysis, automated debugging, and execution understanding. He focuses on software engineering from an “investigative” viewpoint, with an emphasis on the execution traces that programs produce — software engineering as the art and science of building programs with a desired set of executions. 
His recent work has resulted in a DSL and (he hopes) usable and powerful testing tool for Python, the TSTL system, https://github.com/agroce/tstl, as well as contributions to the DeepState C/C++ unit testing interface to symbolic execution tools and fuzzers such as AFL and libFuzzer, https://github.com/trailofbits/deepstate.</bio>
          <homepage_url>https://agroce.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexgroce/989787fc-bf10-46da-8b9b-936e9ee92df8/small.jpg</picture_url>
          <person_id>alexgroce</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>acd15d73-8406-42ca-b740-35b965e96b62</slot_id>
      <event_id>ccbe3853-1f7d-4e58-9239-01fa953d1723</event_id>
      <submission_id>onward21essays-id4-p</submission_id>
      <title>The Kingdoms of Objects and Values</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Friedrich</first_name>
          <last_name>Steimann</last_name>
          <affiliation>Fernuniversität in Hagen</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/friedrichsteimann/0382f30a-7342-49a1-b2f6-cf7d0929220c/small.jpg</picture_url>
          <person_id>friedrichsteimann</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fba385b8-8052-4aa8-9416-b3bc9fd6de12</subevent_id>
    <title>HATRA: Novel Interfaces and Discussion</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/hatra-2021</url>
    <url_link_display>Human Aspects of Types and Reasoning Assistants</url_link_display>
    <tracks>
      <track>Human Aspects of Types and Reasoning Assistants</track>
    </tracks>
    <timeslot>
      <slot_id>64f4604e-9ea5-4b22-b3a7-1294570106cd</slot_id>
      <title>Session: HATRA - Novel Interfaces and Discussion</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>45f3d142-c0b0-49e1-962a-c79f66101f08</slot_id>
      <event_id>e748422d-7d89-457d-87d7-c1bed6bddb57</event_id>
      <title>General discussion</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>17:00</end_time>
      <description>We will have group discussion about future directions for HATRA research.</description>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8f63debf-b496-4c60-97f2-6bcb552e3ac2</slot_id>
      <event_id>2ebd7881-1695-4056-b7a7-da07b73dd614</event_id>
      <submission_id>2</submission_id>
      <title>Typed Image-based Programming with Structure Editing</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>15:55</end_time>
      <description>Many beloved programming systems are image-based: self-contained worlds that persist both code and data in a single file. Examples include Smalltalk, LISP, HyperCard, Flash, and spreadsheets. Image-based programming avoids much of the complexity of modern programming technology stacks and encourages more casual and exploratory programming. However conventional file-based programming has better support for collaboration and deployment. These problems have been blamed for the limited commercial success of Smalltalk. We propose to enable collaboration in image-based programming via types and structure editing. 
We focus on the problem of schema change on persistent data. We turn to static types, which paradoxically require more schema change but also provide a mechanism to express and execute those changes. To determine those changes we turn to structure editing, so that we can capture changes in type definitions with sufficient fidelity to automatically adapt the data to suit. We conjecture that typical schema changes can be handled through structure editing of static types. 
That positions us to tackle collaboration with what could be called version control for structure editing. We present a theory realizing this idea, which is our main technical contribution. While we focus here on editing types, if we can extend the approach to cover the entire programming experience then it would offer a new way to collaborate in image-based programming.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Edwards</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://alarmingdevelopment.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanedwards/3bc9c5ec-29fc-4efd-b8bc-6ba62fa73ec1/small.jpg</picture_url>
          <person_id>jonathanedwards</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tomas</first_name>
          <last_name>Petricek</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>Tomas is a Lecturer at University of Kent and a Collaborating Fellow at the Alan Turing Institute in London. He is building programming tools that integrate with modern data sources (open government data, data published by citizen initiatives) and let users easily create analyses and visualizations that are linked to the original data source, making the analyses more transparent, reproducible, but also easy to adapt. His early work on the project can be found at http://thegamma.net. 
Tomas’ many other interests include open-source and functional programming (he is an active contributor to the F# ecosystem), programming language theory (his PhD thesis on “coeffects” develops a theory of context-aware programming language language), but also understanding programming through the perspective of philosophy of science.</bio>
          <homepage_url>http://tomasp.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomaspetricek/405de991-6537-4d65-8499-fde0dcc8c5cd/small.jpg</picture_url>
          <person_id>tomaspetricek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b325e030-be6f-4be6-98e8-a0d905d9dfdc</slot_id>
      <event_id>f8e11e43-1fe1-4cf8-a714-66ba55757b3f</event_id>
      <submission_id>3</submission_id>
      <title>A New Medium for Communicating Research on Programming Languages</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>15:55</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:10</end_time>
      <description>Papers about programming languages involve complex notations, systems, and proofs. Static PDFs offer little support in understanding such concepts. We describe Nota, a framework for academic papers that uses the browser’s interactive capabilities to support comprehension in context. Nota uses hover effects, tooltips, expandable sections, toggle-able explanations, and other interactions to help readers understand a language’s syntax and semantics. We demonstrate the use of Nota by rewriting a PL paper using its primitives, and also by writing this paper in Nota.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Will</first_name>
          <last_name>Crichton</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://willcrichton.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/willcrichton/03949743-0d45-4f73-9496-b6ab65dc7f5c/small.jpg</picture_url>
          <person_id>willcrichton</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f12d2632-f74a-441f-b530-21770fd22819</slot_id>
      <event_id>d4129398-fb89-4fd6-9b74-83771e945719</event_id>
      <title>Paper discussion, session 3</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>16:10</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:20</end_time>
      <description>We will spend the final 20 minutes of each session discussing the papers from that session.</description>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4906dd2e-fd39-4a3e-aa5f-ea776fce7436</subevent_id>
    <title>LIVE: Talks III</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/live-2021</url>
    <url_link_display>LIVE 2021</url_link_display>
    <tracks>
      <track>LIVE 2021</track>
    </tracks>
    <timeslot>
      <slot_id>88464756-11b3-4f8e-b0e2-4f1b33118812</slot_id>
      <title>Session: LIVE - Talks III</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5dcdecb9-1e87-40fc-a866-998f3cc4024c</slot_id>
      <event_id>bc9b4fb1-55c8-4607-a3bf-feabfae48fc7</event_id>
      <title>Restructuring Structure Editing</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:50</end_time>
      <description>Structure editors have long promised to improve the programming experience for all, but are often too slow or difficult to use. In this essay, we describe a new approach to structure editing, called tile-based editing, that recovers many of the flexible and linear editing affordances of text editors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Moon</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidmoon/07fbf417-4cfe-4fd0-93b2-05c3dbeb61ec/small.jpg</picture_url>
          <person_id>davidmoon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Omar</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>https://fplab.mplse.org/</bio>
          <homepage_url>https://web.eecs.umich.edu/~comar</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/cyrusomar/6f85cfe7-5130-42cf-9976-450725051201/small.jpg</picture_url>
          <person_id>cyrusomar</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>767d6416-fe39-4023-bec0-e0b3ec72823c</slot_id>
      <event_id>a8ece4bf-3079-4676-8a68-e4b732538bed</event_id>
      <title>Supporting Network Editing and Experimentation for Novice Deep Learning Programmers</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:10</end_time>
      <description>Network editing and model experimentation are critical processes in the development of deep learning (DL) applications. This paper presents ODEN, an IDE that supports these two processes for novice DL programmers. It consists of a network editing mode and an experimenting mode, which correspond to the two processes of DL application development. The network editing mode utilizes the live programming technique to synchronously provide tensor shape visualization when the user modifies the network structure. The experimenting mode then takes the edited network structure and helps manage the DL model experimentation. Novices can conveniently transit between network editing and experimentation to iteratively improve model performance with the tool.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chunqi</first_name>
          <last_name>Zhao</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>chunqizhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tsukasa</first_name>
          <last_name>Fukusato</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>tsukasafukusato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jun</first_name>
          <last_name>Kato</last_name>
          <affiliation>National Institute of Advanced Industrial Science and Technology (AIST)</affiliation>
          <bio>Jun Kato is a Human-Computer Interaction researcher at National Institute of Advanced Industrial Science and Technology (AIST), Japan. He has focused on improving Programming Experience (PX) by creating toolkits and integrated development environments. He has worked for Microsoft and Adobe Research and received a Ph.D. from The University of Tokyo under the supervision of Prof. Takeo Igarashi in 2014.</bio>
          <homepage_url>https://junkato.jp</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/junkato/946564ad-0347-4e3c-8dbb-625e3449c713/small.jpg</picture_url>
          <person_id>junkato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Takeo</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-ui.is.s.u-tokyo.ac.jp/~takeo/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/takeoigarashi/331d08f6-2c4a-4a7d-82dc-1f4fadcdd7f1/small.jpg</picture_url>
          <person_id>takeoigarashi</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e345d2d0-2d74-4165-97c6-2692478fec92</slot_id>
      <event_id>e9921c67-2240-4d07-b75c-adda2aed3591</event_id>
      <title>Inkbase: Programmable Ink</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>15:10</end_time>
      <description>With a pen and a piece of paper, anyone can write a journal entry, draw a diagram, perform a calculation, or sketch a cartoon. Even as more sophisticated technologies arise, pen and paper maintain important roles in our lives because nothing has matched their combination of accessibility, immediacy, and flexibility. 
Digital tablet/stylus sketchbooks adapt pen and paper into the world of digital media. In doing so, they trade away some of paper’s advantages (like cheapness &amp;amp; tangibility) in exchange for new computational powers (like nondestructive editing &amp;amp; ease of transmission). But in this trade, digital sketchbooks haven’t yet won the greatest computational capability of all. This is the ability to define entirely new computational behaviors, that is, to program. 
The success of spreadsheets demonstrates that, given the right environment, ordinary people can make effective use of open-ended programmability – to speed computations, explore “what if?” scenarios, and explore information in entirely new ways. 
What would be possible if hand-written sketchbooks were programmable like spreadsheets? 
To explore this question, we built Inkbase, a programmable digital sketchbook. Inkbase integrates a conventional ink-on-tablet interface with an open-ended programming environment. With Inkbase, we studied how programmability might fluidly augment: 
 
 organizational tasks 
 creative sketching 
 visual explanation 
 technical thought 
 … and everything else we do with pen and paper. 
</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Horowitz</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>joshuahorowitz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Szymon</first_name>
          <last_name>Kaliski</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>szymonkaliski1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Lindenbaum</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>jameslindenbaum</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f2fe3437-572c-4fd6-b869-c799b18515f7</slot_id>
      <event_id>efed64f8-2135-4c27-b736-44777d5c6fa9</event_id>
      <title>TypeCell: A New Live Programming Environment for the Web</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:30</end_time>
      <description>TypeCell is a new application platform that aims to make software development more open and simple, by removing a lot of barriers in (web application) development. By reducing layers of complexity, and integrating a live-programming environment as a first-class citizen in an end-user block-based document editor, we want to create an open source platform where users can instantly inspect, edit and collaborate on the software they’re using.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yousef</first_name>
          <last_name>El-Dardiry</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>yousefeldardiry</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>534457b4-0d47-4c32-8aeb-f5cfbd0de424</subevent_id>
    <title>SPLASH Awards: Awards</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-awards</url>
    <url_link_display>Awards</url_link_display>
    <tracks>
      <track>Awards</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>01d1ee2e-b6ed-4ad0-9653-4d6433e33aff</slot_id>
      <title>Session: SPLASH Awards - Awards</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>17:00</start_time>
      <end_time>17:20</end_time>
      <tracks>
        <track>Awards</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>c352bcc8-0023-411b-8e96-b9c7e70cb99e</slot_id>
      <event_id>fa5fb5f4-0b6b-404a-90be-226c87cf9558</event_id>
      <title>SPLASH Awards</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>17:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>Awards</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2cd01a22-3191-4a75-a2c7-284e2efdcce4</subevent_id>
    <title>LIVE: Keynote and Talks I</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/live-2021</url>
    <url_link_display>LIVE 2021</url_link_display>
    <tracks>
      <track>LIVE 2021</track>
    </tracks>
    <timeslot>
      <slot_id>339b00b7-6f45-4490-a21c-d30e4d404eb1</slot_id>
      <title>Session: LIVE - Keynote and Talks I</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>03e6a595-7c06-44ba-b0eb-2a688226f334</slot_id>
      <event_id>375734f5-16c5-443b-8fbe-fde7b0f1736c</event_id>
      <title>Joker: A Unified Interaction Model For Web Customization</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>10:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>10:20</end_time>
      <description>Tools that enable end-users to customize websites typically use a two-stage workflow: first, users extract data into a structured form; second, they use that extracted data to augment the original website in some way. This two-stage workflow poses a usability barrier because it requires users to make upfront decisions about what data to extract, rather than allowing them to incrementally extract data as they augment it. 
In this paper, we present a new, unified interaction model for web customization that encompasses both extraction and augmentation. The key idea is to provide users with a spreadsheet-like formula language that can be used for both data extraction and augmentation. We also provide a programming-by-demonstration (PBD) interface that allows users to create data extraction formulas by clicking on elements in the website. This model allows users to naturally and iteratively move between extraction and augmentation. 
To illustrate our unified interaction model, we have implemented a tool called Joker which is an extension of Wildcard, a prior web customization system. Through case studies, we show that Joker can be used to customize many real-world websites. We also present a formative user study with five participants, which showed that people with a wide range of technical backgrounds can use Joker to customize websites, and also revealed some interesting limitations of our approach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kapaya</first_name>
          <last_name>Katongo</last_name>
          <affiliation>Massachusetts Institute of Technology (MIT)</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/kapayakatongo/0bb05564-60fd-437b-81be-6237ffe8514a/small.jpg</picture_url>
          <person_id>kapayakatongo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Geoffrey</first_name>
          <last_name>Litt</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>geoffreylitt1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kathryn</first_name>
          <last_name>Jin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>kathrynjin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jackson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/dnj/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danieljackson/af0a2e34-3659-427b-849e-054c1508ff9e/small.jpg</picture_url>
          <person_id>danieljackson</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c4fc162b-80d8-41b0-b01b-4196ac2134d1</slot_id>
      <event_id>b97c22c0-5df2-452a-aa43-4a305aec88c8</event_id>
      <title>Software as Computational Media</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>10:00</end_time>
      <description>In this talk, I will present research on how to create software that can be shaped by its users in use. The concept of applications is ubiquitous and completely taken for granted in modern computing. Software doesn’t have to be synonymous with applications, and there is great potential to be unlocked if we break out of them. In this talk, I will argue for a renewed focus on developing computational media and show efforts we have undertaken to demonstrate how software can be made differently. I will, among other things, present past and present work on the Webstrates (webstrates.net) platform.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Clemens</first_name>
          <last_name>Nylandsted Klokmose</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.klokmose.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/clemensnylandstedklokmose/d0b09e30-e032-4663-bf9a-7070b17fcf11/small.jpg</picture_url>
          <person_id>clemensnylandstedklokmose</person_id>
        </person>
      </persons>
      <tracks>
        <track>LIVE 2021</track>
      </tracks>
      <badges>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9b3ebf57-a762-46da-a5ac-e97744ce9033</subevent_id>
    <title>SPLASH Onward! Essays: Essays Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-Essays</url>
    <url_link_display>Onward! Essays</url_link_display>
    <tracks>
      <track>Onward! Essays</track>
    </tracks>
    <timeslot>
      <slot_id>bb0ddddf-49b6-4533-ad99-3f9dceaa0cc3</slot_id>
      <title>Session: SPLASH Onward! Essays - Essays Session 1</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Nada</first_name>
          <last_name>Amin</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://namin.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadaamin/b083e70b-31f9-4a88-89ba-ae54f8ec9315/small.jpg</picture_url>
          <person_id>nadaamin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>27791d4a-e3ed-417e-bc7f-45305bfc9ec4</slot_id>
      <event_id>5d3ee16e-9b3a-4ef2-8613-7460b6b8831b</event_id>
      <submission_id>onward21essays-id3-p</submission_id>
      <title>Programming as Architecture, Design, and Urban Planning</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tomas</first_name>
          <last_name>Petricek</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>Tomas is a Lecturer at University of Kent and a Collaborating Fellow at the Alan Turing Institute in London. He is building programming tools that integrate with modern data sources (open government data, data published by citizen initiatives) and let users easily create analyses and visualizations that are linked to the original data source, making the analyses more transparent, reproducible, but also easy to adapt. His early work on the project can be found at http://thegamma.net. 
Tomas’ many other interests include open-source and functional programming (he is an active contributor to the F# ecosystem), programming language theory (his PhD thesis on “coeffects” develops a theory of context-aware programming language language), but also understanding programming through the perspective of philosophy of science.</bio>
          <homepage_url>http://tomasp.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomaspetricek/405de991-6537-4d65-8499-fde0dcc8c5cd/small.jpg</picture_url>
          <person_id>tomaspetricek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>82a3c016-f4c3-48c5-96f9-9dc416c3473a</slot_id>
      <event_id>d9d6e0ac-f9e4-415c-9e4a-5ff0f2802def</event_id>
      <submission_id>onward21essays-id6-p</submission_id>
      <title>Angelic and Demonic Visitation: School Memories</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Leila</first_name>
          <last_name>Salem</last_name>
          <affiliation>University of Toronto</affiliation>
          <bio>undefined</bio>
          <person_id>leilasalem</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d80c8d23-1959-4d8c-a13a-ee9436382683</subevent_id>
    <title>CONFLANG: Configuration management</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/conflang-2021</url>
    <url_link_display>CONFLANG</url_link_display>
    <tracks>
      <track>CONFLANG</track>
    </tracks>
    <timeslot>
      <slot_id>3a567e10-15a4-4ff0-a1d3-9a09672648a5</slot_id>
      <title>Session: CONFLANG - Configuration management</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Jürgen</first_name>
          <last_name>Cito</last_name>
          <affiliation>TU Wien and Facebook</affiliation>
          <bio>CS Professor at TU Wien, Researcher/Software Engineer at Facebook</bio>
          <homepage_url>http://people.csail.mit.edu/jcito/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jurgencito/8f3b8480-88a3-4e18-a139-789c23a8ccb8/small.jpg</picture_url>
          <person_id>jurgencito</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Marcel</first_name>
          <last_name>van Lohuizen</last_name>
          <affiliation>CUE</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cuelang.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marcelvanlohuizen/13e4d829-753a-45dd-9831-d4e0744973fb/small.jpg</picture_url>
          <person_id>marcelvanlohuizen</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>43676dc1-a572-4be4-8009-f6a9493c34fb</slot_id>
      <event_id>d1fc1f7d-5c2b-4b30-a4df-9316ff8a1654</event_id>
      <title>Local Expectation Testing for Terraform</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:10</end_time>
      <description>With the rise of large, distributed systems, Infrastructure-as-code (IaC) has evolved from a best practice to a requirement in industry environments. Hashicorp’s Terraform has become the go to IaC solution for many companies. In this talk, we explore potential solutions for testing Terraform locally using AWS-mocking tools LocalStack and Moto. Specifically, this talk proposes a framework for testing Terraform configurations that can: 
 
 identify errors locally that were previously only detectable in the cloud 
 speed up test run time 
 save costs 
 
Our findings show the benefits of testing Terraform configurations locally but highlight the need for further research.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zach</first_name>
          <last_name>Gleason</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>zachgleason</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sreenidish</first_name>
          <last_name>Chinmayanilayam</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sreenidishchinmayanilayam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yaroslav</first_name>
          <last_name>Buzko</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>yaroslavbuzko</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>78699460-9a7b-4df8-937d-53d70ac257f7</slot_id>
      <event_id>cea743ad-1f16-4404-b3d7-d608a3ec58d8</event_id>
      <title>Scuemata: A Framework for Evolvable, Composable Data Schema</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:15</end_time>
      <description>This talk lays out Scuemata, a CUE-based framework for expressing data schemas that aims directly at these issues of schema evolution and backwards compatibility. It does not seek to innovate in defining schema themselves (beyond what CUE natively offers vis-a-vis other schema languages). Rather, Scuemata defines a logical meta-structure around schemas that allows for: 
 
 All versions of a schema to be declared in a single place, easing analysis for humans and machines 
 Enforcement that migrations are written when a particular schema change is backwards-incompatible 
 Standard ways of expressing the risks and insufficiency of automated migrations 
 Encapsulating the problem of data validation and migration to a boring, standardized process that can be isolated to process boundaries of programs 
 Standard interfaces and tools for consuming any scuemata-defined schema, allowing generic tooling to be written for tasks like language translation, API generation, and more 
 Standardized composition of scuemata, allowing large schema to be broken down into discrete subcomponents managed by different groups, each evolving independently 
 Seamless integration into larger programs and ecosystems. (Scuemata are currently used by Grafana to express schema are complex, pluggable, and compositional, and canonical in three languages.) 
 
Scuemata is based on a premise borne of years of experience with how most developers actually deal with versioning and compatibility in their day-to-day programming. Schema authors generally want to either maintain backwards compatibility, or else define migration paths - but absent simple structures, easy verification, and supportive tooling, doing so is often too onerous and nonstandardized to justify. By providing formalisms that encapsulate the meta-problems of schema evolution, we aim to reduce friction to the point where that calculus can shift.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sam</first_name>
          <last_name>Boyer</last_name>
          <affiliation>Grafana Labs</affiliation>
          <bio>undefined</bio>
          <person_id>samboyer</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bc1180ae-df2d-4fe4-8ec5-3ca650f7a51e</slot_id>
      <event_id>73b6bc38-823b-40af-9786-6c552e0fea31</event_id>
      <title>Analyzing Infrastructure as Code to Prevent Intra-update Sniping Vulnerabilities</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:55</end_time>
      <description>Infrastructure as Code is a popular approach to computing infrastructure management that allows users to leverage tools such as version control, automatic deployments, and program analysis for infrastructure configurations. Benefits of IaC are well-known among practitioners: the entire infrastructure is described accurately by a configuration file, making it easy to debug or visualize the infrastructure. The infrastructure can be version controlled and documented as with any other programming language. The tools help guarantee identical configuration of hosts, making it an essential practice for security and maintainability.However, during an upgrade, the infrastructure goes through a series of partial updates. When not properly configured, some of these partial updates might contain a violation of the intended security policy,even if the initial infrastructure and the target infrastructure are both perfectly secure. An attacker could perform a “sniping attack” during the upgrade to access information or gain control of infrastructure they would normally not be able to. We empirically validated our claims by reenacting this in both Amazon’s AWS and Google Cloud. 
In this work we have modeled IaC configurations as a dataflow graph between resources, where edges are protected by security resources. We use this representation to compute the intended security policy for the initial and target deployments and their resources. We statically analyze the two infrastructures and build a safe over-approximation of the possible intermediate states. We use this over-approximation to compute an under-approximation of the security level of resources, in any possible intermediate state.If a resource is more secure or as secure as its counter part in the initial or target deployment,the tool does not report any warnings. If a resource is less secure than intended, the tool reports a potential vulnerability and suggests adding a dependency to ensure IaC tools will follow a secure upgrade plan.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julien</first_name>
          <last_name>Lepiller</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <person_id>julienlepiller</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cfd1646f-fe29-4e0d-8ae7-173949525253</slot_id>
      <event_id>06ec625d-ef43-4d62-bba2-b7a289a4370e</event_id>
      <title>Intra-update Sniping Vulnerabilities in Smart Contracts</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>11:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:05</end_time>
      <description>Smart contracts (SCs) are documents that automatically execute an agreement between users as defined by code. The contract is distributed across a decentralized blockchain network, such as Ethereum and are irreversible and require no assumption of trust in a third party. SCs have spawned a variety of new decentralized applications – “DApps” – including games, marketplaces, financial platforms, and tokens. Creating DApps requires configuring multiple SCs together, for example having one SC handle authentication, one SC for transaction, and another for traceable computation. We can imagine various SCs as modular pieces in a larger application: one contract can authenticate the user, one contract keeps track of public info, one contract receives messages, and so on. So far, most DApp configurations are relatively small, consisting of only a few interlocked contracts, similar to the early days of cloud computing, where there were few resource types available (e.g. AWS started with just the EC2 and S3 services). However, just as cloud computing has grown in complexity (AWS now offers more than 200 different cloud services), we predict DApp configurations will grow in complexity as the applications space continues to grow. 
Just as we anticipate the growth of SCs to mirror the growth experienced in cloud infrastructure in terms of impact, adoption, and complexity, we also expect similar issues to arise in issues of security. We specifically focus on Intraupdate Sniping Vulnerabilities, as described by Lepiller et al. These vulnerabilities arise in the management of cloud resource configuration files (e.g. AWS Cloudformation or Terraform) for cloud resources. An intraupdate sniping vulnerabilities describes a situation that occurs during the upgrade process from one cloud resource configuration to another. Even if both the initial configuration, ConfigA , and target configuration, ConfigB , are secure, an intermediate state that occurs during the upgrade process may be insecure relative toConfigA and ConfigB . In the context of SCs this vulnerability may arise with the use of proxy contracts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mark</first_name>
          <last_name>Santolucito</last_name>
          <affiliation>Barnard College, Columbia University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.marksantolucito.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marksantolucito/51821284-64c1-46e0-b979-96e8324079bf/small.jpg</picture_url>
          <person_id>marksantolucito</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shmuel</first_name>
          <last_name>Berman</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>shmuelberman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brennen</first_name>
          <last_name>Yu</last_name>
          <affiliation>Columbia University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>brennenyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stella</first_name>
          <last_name>Lessler</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>stellalessler</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>da86c7cc-dc0c-4653-bb27-5d7e41463c84</slot_id>
      <event_id>90be8d2a-7587-407d-aba7-be48375bfd96</event_id>
      <title>Continuous Configuration Testing</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>10:55</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:00</end_time>
      <description>Configuration management is an integral part of modern DevOps-based cloud system management. Many critical operations are done by updating configurations to dynamically change system behavior in production. Today, large-scale cloud and Internet services evolve rapidly, with hundreds to thou-sands of configuration changes deployed daily. At Facebook, thousands of configuration changes are committed every day, outpacing the frequency of code changes. It is not surprising to hear that “cloud feels more about configuration management than software engineering". With the high velocity of changes, faulty configurations inevitably have become major causes of system failures and service outages. For example, faulty configurations are reported as the second largest cause of service disruptions in a main Google production service. 
Many configuration-induced failures led to catastrophic impacts. In March 2019, a misconfiguration led to Facebook’s largest outage in terms of duration (14 hours); in June 2021, a seemingly-valid configuration change at Fastly triggered an undiscovered software bug and broke the Internet for an hour.We argue that continuous testing is a key missing piece of today’s configuration management practice. Despite the “configuration-as-code” movement, there is no widely-used, systematic con-figuration testing technique and thus configuration changes are not unit-tested—imagining a world where code changes only go through manual review and static analysis, without regression testing.We will introduce the idea of configuration testing, a new testing technique that enables configuration changes to be unit-tested in DevOps-based continuous integration/deployment. The basic idea of configuration testing is connecting system configurations to software tests so that configuration changes can be tested in the context of code affected by the changes. We will introduce a new type of tests, termed Ctests, to fill the critical need of configuration testing. Ctests complement static validation (the de facto protection), analogous to how testing complements static analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tianyin</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://tianyin.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tianyinxu1/e97e4373-f937-4b16-b4e0-4eec79f5eb77/small.jpg</picture_url>
          <person_id>tianyinxu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e40e2a43-8a7f-4dd0-9218-6a5e6f2bae19</slot_id>
      <event_id>13ec9ed0-adaf-4741-b826-76307bfb8f5a</event_id>
      <title>Configuration management: Q&amp;A and discussion</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>11:15</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7afb2ab2-bed2-4898-a76b-20e9b44284df</subevent_id>
    <title>Scala: Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/17</date>
    <url>https://2021.splashcon.org/home/scala-2021</url>
    <url_link_display>12th ACM SIGPLAN Scala Symposium</url_link_display>
    <tracks>
      <track>12th ACM SIGPLAN Scala Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>9af66b7d-41f7-48f1-bc46-1fc55a748329</slot_id>
      <title>Session: Scala - Session 2</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Sébastien</first_name>
          <last_name>Doeraene</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Sébastien Doeraene is a compiler/runtime systems hacker and a Scala enthusiast. Best known as the author of Scala.js, he is now executive director of the Scala Center. He holds a PhD from EPFL, having worked under the supervision of Prof. Martin Odersky, and a master’s degree in computer science engineering from Université catholique de Louvain in Belgium. When he is not busy coding, he sings in choirs and a cappella groups such as the Ensemble Vocal Évohé, or composes for said choirs.</bio>
          <homepage_url>https://lampwww.epfl.ch/~doeraene/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sebastiendoeraene/a6fd635a-6c1a-4896-a79f-234ccfaa2d7e/small.jpg</picture_url>
          <person_id>sebastiendoeraene</person_id>
        </person>
      </persons>
      <tracks>
        <track>12th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9dc665e5-ddc5-4320-a9d6-959a0e15687a</slot_id>
      <event_id>833739da-488f-4958-8e24-1cfc764eb0df</event_id>
      <submission_id>6</submission_id>
      <title>Safe Object Initialization, Abstractly</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/17</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:30</end_time>
      <description>Objects under initialization are fragile: some of their fields are not yet initialized. Consequently, accessing those uninitialized fields directly or indirectly may result in program crashes or abnormal behaviors at runtime. 
A newly created object goes through several states during its initialization, beginning with all fields being empty until all of them are filled. Therefore, accessing the field of an object has to respect its initialization \emph{typestate}. The problem of safe initialization of objects is in essence a typestate safety problem. However, ensuring typestate safety statically, without manual annotation of typestates in the source code, is a challenge, due to \emph{aliasing}, \emph{virtual method calls} and \emph{typestate polymorphism}. 
In this work, we introduce a novel analysis based on abstract interpreters. Compared to the previous approaches, our analysis is simpler and easier to extend, and it does not require any user annotations. The analysis is inter-procedural and context-sensitive, yet it has good performance thanks to \emph{local reasoning} and \emph{heap monotonicity}.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fengyun</first_name>
          <last_name>Liu</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/fengyunliu/0d2f6c57-4b56-43e2-8cdb-c53e0e55c7d8/small.jpg</picture_url>
          <person_id>fengyunliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Enze</first_name>
          <last_name>Xing</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>enzexing</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Nguyen Cao</first_name>
          <last_name>Pham</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>nguyencaopham</person_id>
        </person>
      </persons>
      <tracks>
        <track>12th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ba96c59d-b3cd-4d48-ad08-0f628d83031a</slot_id>
      <event_id>5c5bc51e-5c3c-441b-9977-da321fdfa3a2</event_id>
      <submission_id>1</submission_id>
      <title>Implementing Path-Dependent GADT Reasoning for Scala 3</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:10</end_time>
      <description>Generalized Algebraic Data Types (GADT) are a popular programming language feature allowing advanced type-level properties to be encoded in the data types of a program. While Scala does not have direct support for them, GADT definitions can be encoded through Scala class hierarchies. Moreover, the Scala 3 compiler recently augmented its pattern matching capabilities to reason about such class hierarchies, making GADT-based programming practical in Scala. However, the current implementation can only reason about type parameters, but Scala’s type system also features singleton types and abstract type members (collectively known as path-dependent types), about which GADT-style reasoning is also useful and important. In this paper, we show how we extended the existing constraint-based GADT reasoning of the Scala 3 compiler to also consider path-dependent types, making Scala’s support for GADT programming complete and also bringing Scala closer to its formal foundations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yichen</first_name>
          <last_name>Xu</last_name>
          <affiliation>Beijing University of Posts and Telecommunications</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.yichenxu.me</homepage_url>
          <person_id>yichenxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aleksander</first_name>
          <last_name>Boruch-Gruszecki</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <person_id>aleksanderboruchgruszecki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lionel</first_name>
          <last_name>Parreaux</last_name>
          <affiliation>The Hong Kong University of Science and Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cse.ust.hk/admin/people/faculty/profile/parreaux</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lionelparreaux/292d178a-af9d-419f-9e04-8a4672226fd5/small.jpg</picture_url>
          <person_id>lionelparreaux</person_id>
        </person>
      </persons>
      <tracks>
        <track>12th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b4127135-c5e0-45a5-9240-4631f48283c1</subevent_id>
    <title>DLS: DLS Talks 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/dls-2021</url>
    <url_link_display>Dynamic Languages Symposium</url_link_display>
    <tracks>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>bfab50af-9ce4-4e52-964d-648c29b4ccbd</slot_id>
      <title>Session: DLS - DLS Talks 1</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>21a18983-3db6-4ef5-ad72-5d32e7a91ca7</slot_id>
      <event_id>b34908e0-77cf-44d3-a0e4-e7848afc6c69</event_id>
      <title>CompGen: Generation of Fast JIT Compilers in a Multi-Language VM</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>22:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>23:05</end_time>
      <description>The first Futamura projection enables compilation and high performance code generation of user programs by partial evaluation of language interpreters. Previous work has shown that it yields the same peak performance as a specialized JIT compiler. However, this comes with the downside of additional compile time: Partial evaluation of language interpreters has to specialize interpreter code on the fly to the dynamic types used at run time to create efficient target code. As a result, the time spent on partial evaluation itself is a significant contributor to the overall compile time of a method. 
The second Futamura projection solves this problem by self-applying partial evaluation on the partial evaluation algorithm, effectively generating language-specific compilers from interpreters. This typically reduces compilation time compared to the first projection. Previous work employed the second projection to some extent, however we are not aware of any usage of the generic second Futamura projection in a state-of-the-art language runtime. 
To solve the problems of self-application and code-size explosion, this paper proposes CompGen, an approach based on code generation of subsets of language interpreters. It is loosely based upon the idea of the second Futamura projection. Our implementation of CompGen for GraalVM shows that our usage of a novel code-generation algorithm allows us to generate efficient compilers that emit fast target programs which easily outperform the first Futamura projection in compilation time. We evaluated our approach with the high-performance JavaScript implementation of GraalVM and standard JavaScript benchmarks, showing that our approach achieves &amp;gt; 2X speedups of partial evaluation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Latifi</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>Researcher and PhD student at the Johannes Kepler University in Linz, Austria.</bio>
          <homepage_url>https://florian-latifi.at</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/florianlatifi/a986450f-d097-4d8e-8448-4ebfc1a2206e/small.jpg</picture_url>
          <person_id>florianlatifi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Leopoldseder</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.davidleopoldseder.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidleopoldseder/e0b1ae47-d779-400d-8f0f-0b3cce3e0f7f/small.jpg</picture_url>
          <person_id>davidleopoldseder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christian</first_name>
          <last_name>Wimmer</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Christian Wimmer is the architect of GraalVM Native Image. He was one of the first engineer of the GraalVM project, and helped growing it from a research project of Oracle Labs to a supported Oracle product. He believes that all languages should be equally fast, and that we therefore need to stop writing individual VMs and instead have one polyglot VM. His research interests span from compilers, virtual machines, and secure systems to component-based software architectures. 
He received a Dr. techn. degree in Computer Science (advisor: Prof. Hanspeter Mössenböck) and a Dipl.-Ing. degree in Computer Science, both from the Johannes Kepler University Linz, Austria. Before the time at Oracle, he was a postdoctoral researcher at the Department of Computer Science of the University of California, Irvine. He worked with Prof. Michael Franz at the Secure Systems and Software Laboratory on compiler optimizations, dynamic programming languages, and language-based security.</bio>
          <homepage_url>http://www.christianwimmer.at/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/christianwimmer/faa7e48f-04de-4752-83a4-efdf6b175be1/small.jpg</picture_url>
          <person_id>christianwimmer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hanspeter</first_name>
          <last_name>Mössenböck</last_name>
          <affiliation>JKU Linz, Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ssw.jku.at/General/Staff/HM/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hanspetermossenbock/3a16b6f0-00fa-4ef3-93df-13ea4a29430c/small.jpg</picture_url>
          <person_id>hanspetermossenbock</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
      <badges>
        <badge>Research Paper</badge>
        <badge>Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>46f09562-bd76-41b0-b48c-cab1c289cdba</slot_id>
      <event_id>9bdff49b-71f5-4402-b9c5-72c6e4a6847f</event_id>
      <title>On Design and Use of First-Class Environments in R</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>22:15</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>22:40</end_time>
      <description>The R programming language is widely used for statistical computing. To enable interactive data exploration and rapid prototyping, R encourages a dynamic programming style. This programming style is support by a number of features including first-class environments. R is the only language, with millions of users, that provides a full reflective interface for manipulating environments. With the great flexibility afforded by first-class environments, comes challenges for reasoning about code and significant restrictions about what transformations a compiler is allowed to apply to programs. This paper is an overview of the environment interface refined over two decades. We explain the rationale behind the design and document how environments are used in the wild by the means of a corpus analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
      <badges>
        <badge>Research Paper</badge>
        <badge>Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>ac2ca061-f144-4848-abff-0265b278fa7d</slot_id>
      <event_id>9993747b-3c5e-4b12-955b-de42f70eb152</event_id>
      <title>Analyzing Permission Transfer Channels for Dynamically Typed Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>22:15</end_time>
      <description>Communicating Sequential Process~(CSP) is nowadays a popular concurrency model in which threads/processes communicate by exchanging data through channels. Channels helps in orchestrating concurrent processes but do not solve per-se data races. To prevent data races in the channel model, many programming languages rely on type systems to express ownership and behavioural restrictions such as immutability. However, dynamically-typed languages require runtime mechanisms because of the lack of type information at compile-time. 
In this paper, we propose to augment channels with four different permission transfer semantics. We explore two mechanisms to implement such permission transfers at run-time: write-barriers and partial read-barriers. To validate our approach we implemented a channel framework in Pharo, and we extended it with different permission transfer semantics. We report on performance measurements of both (a) the transfer overhead on a single object and on a graph of objects, and (b) the per-object access overhead incurred by ownership checks. This work stands as a cornerstone of future work on adaptive optimisations for permission transfer channels.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Théo</first_name>
          <last_name>Rogliano</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>theorogliano</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillermo</first_name>
          <last_name>Polito</last_name>
          <affiliation>Univ. Lille, CNRS, Centrale Lille, Inria, UMR 9189 - CRIStAL - Centre de Recherche en Informatique Signal et Automatique de Lille</affiliation>
          <bio>Guille Polito is research engineer at the CRIStAL laboratory in the university of Lille, working in tight relation with the RMoD team. Guille’s main research interests are programming language development, programming tools, modular systems, and maintenance of large software systems. 
He currently works on techniques to develop modular systems and languages, and new development tools. Guille works in the development of the open source Pharo programming language and environment since 2010, and he is a member of its technical board since 2018.</bio>
          <homepage_url>https://guillep.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guillermopolito/fb027991-a37d-4375-8c71-1858ce478695/small.jpg</picture_url>
          <person_id>guillermopolito</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Luc</first_name>
          <last_name>Fabresse</last_name>
          <affiliation>Mines Douai</affiliation>
          <bio>undefined</bio>
          <person_id>lucfabresse</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stéphane</first_name>
          <last_name>Ducasse</last_name>
          <affiliation> INRIA Lille</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://stephane.ducasse.free.fr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stephaneducasse/509504d8-baa1-42b4-a71a-b441f9ae92bb/small.jpg</picture_url>
          <person_id>stephaneducasse</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
      <badges>
        <badge>Research Paper</badge>
        <badge>Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3b54915c-4762-4723-882b-55cf1506d660</subevent_id>
    <title>APLAS Keynote Talks: Invited talk 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-keynote-talks</url>
    <url_link_display>Keynote Talks</url_link_display>
    <tracks>
      <track>Keynote Talks</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>d426b18d-9e37-4c73-ac1b-daaba8872f7e</slot_id>
      <title>Session: APLAS Keynote Talks - Invited talk 1</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Xinyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>I’m an assistant professor in the Computer Science and Engineering Department at the University of Michigan, Ann Arbor.</bio>
          <homepage_url>https://web.eecs.umich.edu/~xwangsd/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xinyuwang/ccbe37b1-293c-4205-8386-295e20bce0d7/small.jpg</picture_url>
          <person_id>xinyuwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>fbf088e0-3719-4e58-bb71-415e6e76ec78</slot_id>
      <event_id>dcfc0f60-1f4f-4dfa-bbaf-2da4274d67cc</event_id>
      <title> Solidifying and Advancing the Software Foundations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>18:00</end_time>
      <description>Software applications and technologies are built on top of foundational systems such as compilers, databases, and theorem provers. Such foundations form the trusted computing base, and fundamentally impact software quality and security. Thus, it is a critical challenge to solidify and advance them. This talk highlights general, effective techniques, and extensive, impactful efforts on finding hundreds of critical issues in widely-used compilers, database management systems, and SMT solvers. It focuses on the high-level principles and core techniques, their significant practical successes, and future opportunities and challenges.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynote Talks</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d2eae53f-93bd-4316-84d1-82817a92ee0b</subevent_id>
    <title>AGERE: Behavioural Types</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/17</date>
    <url>https://2021.splashcon.org/home/agere-2021</url>
    <url_link_display>AGERE 2021</url_link_display>
    <tracks>
      <track>AGERE 2021</track>
    </tracks>
    <timeslot>
      <slot_id>97a4ab8b-ac6d-47a1-bd3c-9f6529f5de91</slot_id>
      <title>Session: AGERE - Behavioural Types</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Fowler</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>I’m currently a Research Associate on the STARDUST project at the University of Glasgow School of Computing Science. 
My research interests centre around typed functional programming languages, in particular functional approaches to concurrency, web programming, and data management.</bio>
          <homepage_url>http://www.simonjf.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/simonfowler/8da87b62-b333-4c60-ac4a-27594510d4b1/small.jpg</picture_url>
          <person_id>simonfowler</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>357a2718-4cb2-4198-93bf-38ce883697b2</slot_id>
      <event_id>a9f77c33-3fd1-41ed-a74f-d78e69a89262</event_id>
      <submission_id>1</submission_id>
      <title>Towards Practical Protocol Verification via Minimal Orchestration in ACP</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/17</date>
      <start_time>11:15</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:40</end_time>
      <description>We report ongoing work on the analysis of the protocols that pervade concurrent and distributed software. These protocols are key to ensure that communicating programs interact correctly, without communication errors and deadlocks. 
We focus on multiparty session types (MPST), an approach that uses governing multiparty protocols as types to verify the correctness of message-passing programs. Rather than the π-calculus, we target the verification of programs by relying on ACP (the Algebra of Communicating Processes) as specification language; rather than typing, we aim to adopt model checking using the mCRL2 toolset.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bas</first_name>
          <last_name>van den Heuvel</last_name>
          <affiliation>University of Groningen</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://basvdheuvel.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/basvandenheuvel/167036c5-55eb-4a71-a954-97f3ead3b6c6/small.jpg</picture_url>
          <person_id>basvandenheuvel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Pérez</last_name>
          <affiliation>University of Groningen, The Netherlands</affiliation>
          <bio>I am an associate professor at the University of Groningen (The Netherlands), where I lead the research group Fundamental Computing.</bio>
          <homepage_url>http://www.jperez.nl</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgeaperez/4e196e9f-a731-4e6d-9291-594dde28347f/small.jpg</picture_url>
          <person_id>jorgeaperez</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ac42f63b-8678-46f8-997d-322d116585de</slot_id>
      <event_id>3c899f6f-117d-48f6-8c27-eb6c09a7ecc5</event_id>
      <submission_id>3</submission_id>
      <title>Session Types in Elixir</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:15</end_time>
      <description>This paper proposes an adaptation of session types to provide behavioural information about public functions in Elixir modules. We formalise typechecking rules for the main constructs of the language. This allows us to statically determine whether a function implementation observes its session endpoint specification. Based on this type system, we then construct a tool that automates typechecking for Elixir modules.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gerard</first_name>
          <last_name>Tabone</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/gerardtabone/a5922b3a-b7d4-4c39-b791-8821d729f434/small.jpg</picture_url>
          <person_id>gerardtabone</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Francalanza</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://staff.um.edu.mt/afra1/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/adrianfrancalanza/6e6d0dd9-c580-4596-abde-30e3716ea961/small.jpg</picture_url>
          <person_id>adrianfrancalanza</person_id>
        </person>
      </persons>
      <tracks>
        <track>AGERE 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cb794080-6076-4e27-94ea-f646aabbea89</subevent_id>
    <title>BCNC: First Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/17</date>
    <url>https://2021.splashcon.org/home/bcnc-2021</url>
    <url_link_display>Beyond Code: No Code</url_link_display>
    <tracks>
      <track>Beyond Code: No Code</track>
    </tracks>
    <timeslot>
      <slot_id>97aece53-ba37-4dae-b554-951fb243ae95</slot_id>
      <title>Session: BCNC - First Session</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Ahmed</first_name>
          <last_name>ElBatanony</last_name>
          <affiliation>Innopolis University</affiliation>
          <bio>undefined</bio>
          <person_id>ahmedelbatanony</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Giancarlo</first_name>
          <last_name>Succi</last_name>
          <affiliation>Innopolis University</affiliation>
          <bio>undefined</bio>
          <person_id>giancarlosucci</person_id>
        </person>
      </persons>
      <tracks>
        <track>Beyond Code: No Code</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6ddf7ff2-b461-4672-97d6-164b4af55a45</subevent_id>
    <title>SPLASH Awards: Awards</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-awards</url>
    <url_link_display>Awards</url_link_display>
    <tracks>
      <track>Awards</track>
    </tracks>
    <timeslot>
      <slot_id>b2f97c80-a9d7-4a17-81af-5fce9d819550</slot_id>
      <title>Session: SPLASH Awards - Awards</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>09:00</start_time>
      <end_time>09:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
          <person_id>isildillig</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Sophia</first_name>
          <last_name>Drossopoulou</last_name>
          <affiliation>Facebook and Imperial College London</affiliation>
          <bio>I am leading the London Probable team at Facebook, and a Professor of Programming Languages at the Department of Computing, Imperial College, London, UK.</bio>
          <homepage_url>https://wp.doc.ic.ac.uk/sd/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sophiadrossopoulou/f9f2890b-55bd-4796-94ab-fe3291277c90/small.jpg</picture_url>
          <person_id>sophiadrossopoulou</person_id>
        </person>
      </persons>
      <tracks>
        <track>Awards</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3a5cda19-8538-45b1-915e-ad6a5a77026f</slot_id>
      <event_id>fa5fb5f4-0b6b-404a-90be-226c87cf9558</event_id>
      <title>SPLASH Awards</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>09:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>Awards</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ec86d05e-c657-4df0-8ff1-4d57af30cfc4</subevent_id>
    <title>Scala: Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/17</date>
    <url>https://2021.splashcon.org/home/scala-2021</url>
    <url_link_display>12th ACM SIGPLAN Scala Symposium</url_link_display>
    <tracks>
      <track>12th ACM SIGPLAN Scala Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>ff8fe7ab-4af4-4320-848d-635c3a41ab6e</slot_id>
      <title>Session: Scala - Session 1</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Sébastien</first_name>
          <last_name>Doeraene</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Sébastien Doeraene is a compiler/runtime systems hacker and a Scala enthusiast. Best known as the author of Scala.js, he is now executive director of the Scala Center. He holds a PhD from EPFL, having worked under the supervision of Prof. Martin Odersky, and a master’s degree in computer science engineering from Université catholique de Louvain in Belgium. When he is not busy coding, he sings in choirs and a cappella groups such as the Ensemble Vocal Évohé, or composes for said choirs.</bio>
          <homepage_url>https://lampwww.epfl.ch/~doeraene/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sebastiendoeraene/a6fd635a-6c1a-4896-a79f-234ccfaa2d7e/small.jpg</picture_url>
          <person_id>sebastiendoeraene</person_id>
        </person>
      </persons>
      <tracks>
        <track>12th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6292edc2-9203-47df-ab71-f7c4467024d2</slot_id>
      <event_id>187ddd31-abc4-4d88-ba57-70e22a33f44c</event_id>
      <submission_id>4</submission_id>
      <title>Safer Exceptions for Scala</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/17</date>
      <start_time>09:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:00</end_time>
      <description>We describe a scheme for reflecting exceptions as capabilities in the Scala type system that keeps notational overhead to a minimum and avoids well-known problems with Java’s checked exceptions framework. The scheme makes exceptions safer but not fully safe since the capability for throwing an exception may still yet escape its enclosing try block. To address this limitation, we also propose a type system which prevents capabilities from escaping.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>EPFL</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java. 
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as academic director of the Scala center.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinodersky/fc1dd696-d0d4-47cb-9d9a-bba012d98f9e/small.jpg</picture_url>
          <person_id>martinodersky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aleksander</first_name>
          <last_name>Boruch-Gruszecki</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <person_id>aleksanderboruchgruszecki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan Immanuel</first_name>
          <last_name>Brachthäuser</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanbrachthauser/f9c0b5dc-9b85-444f-baed-e807673f202d/small.jpg</picture_url>
          <person_id>jonathanbrachthauser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Edward</first_name>
          <last_name>Lee</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <person_id>edwardlee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
          <person_id>ondrejlhotak</person_id>
        </person>
      </persons>
      <tracks>
        <track>12th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9aa41b37-ac13-49dd-9263-578dbedd53b5</slot_id>
      <event_id>232f6e9a-08a4-4263-bd84-37be4e5978d8</event_id>
      <submission_id>5</submission_id>
      <title>Pathless Scala: a calculus for the rest of Scala</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/17</date>
      <start_time>10:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:20</end_time>
      <description>Recent work on the DOT calculus successfully put core aspects of Scala on a sound foundation, but subtyping in DOT is structural and therefore not easily amenable to studying the parts of Scala that are deeply tied to its nominal subtyping system. On the other hand, the Featherweight Java calculus has proven to be a great basis for studying many aspects of Java and Java-like languages. Continuing this tradition, we present Pathless Scala: an extension of Featherweight Generic Java that closely models multiple inheritance and intersection types as they exist in the Scala language today. We define the semantics of Pathless Scala by erasing it to a simpler calculus in a way that closely models how Scala is compiled to Java bytecode in practice. More than a one-off, we believe that this calculus could be extended to describe many more features of Scala, although reconciling it with DOT remains an open problem.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Martres</last_name>
          <affiliation>EPFL</affiliation>
          <bio>PhD student at EPFL in the LAMP group working on the Scala 3 compiler</bio>
          <homepage_url>http://guillaume.martres.me</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guillaumemartres/34840d2d-eb20-4dd2-8797-de6a5d8ce474/small.jpg</picture_url>
          <person_id>guillaumemartres</person_id>
        </person>
      </persons>
      <tracks>
        <track>12th ACM SIGPLAN Scala Symposium</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>86bf46f0-ff75-43fe-a31d-9afd7e3c1fa4</subevent_id>
    <title>DSM: Introduction and Cases</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/dsm-2021</url>
    <url_link_display>DSM'21</url_link_display>
    <tracks>
      <track>DSM'21</track>
    </tracks>
    <timeslot>
      <slot_id>7928925c-4cbc-4791-ab13-21e7777526c2</slot_id>
      <title>Session: DSM - Introduction and Cases</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e634c50-b575-49de-bc9b-9c1c7c68571f</slot_id>
      <event_id>c70dd60b-9e43-46bb-949b-9d9427ed3beb</event_id>
      <submission_id>8</submission_id>
      <title>PrintTalk: a Constraint-based Imperative DSL for 3D Printing</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>09:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:00</end_time>
      <description>We present PrintTalk, a DSL to “program” 3D objects, called “gadgets”. PrintTalk also features “topologies”, which are predefined spacial arrangements of gadgets. Gadgets are composed by executing a gadget script (possibly consisting of subscripts) that ‘draws’ the gadget in the 3D scene. However, executing the script also returns a number of constraint variables. These variables can be constrained inside the gadget and can also be bound outside the gadget in order to constrain the produced gadgets after the facts. This is the essence of the gadget composition mechanism of PrintTalk. PrintTalk is implemented in DrRacket. Running a PrintTalk program generates a file that is sent to the 3D printer. We validate PrintTalk qualitatively by comparing the code for complex gadgets with the code needed to print those gadgets in existing languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jef</first_name>
          <last_name>Jacobs</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>jefjacobs</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jens</first_name>
          <last_name>Nicolay</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/~jnicolay/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jensnicolay/307f2d75-b933-43f4-ae6c-1cb9a2db8e92/small.jpg</picture_url>
          <person_id>jensnicolay</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christophe</first_name>
          <last_name>De Troyer</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>christophedetroyer2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wolfgangdemeuter/cb721b79-a1aa-4583-8ba0-b1a96f896900/small.jpg</picture_url>
          <person_id>wolfgangdemeuter</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>463fb80b-43f0-4000-8d61-50f57023394e</slot_id>
      <event_id>a23c6155-6f4f-44af-8039-6c4d961bc56d</event_id>
      <submission_id>7</submission_id>
      <title>MOLEGA: Modeling Language for Educational Card Games</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>09:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:40</end_time>
      <description>Domain-specific modeling languages abstractly represent domain knowledge in a way that users can more easily understand the model content without technical expertise. These languages can be created for any domain, provided the necessary knowledge is available. This research uses educational game design as a demonstration of the power of domain-specific modeling. Games are useful tools in supplementing the traditional education of students, however, many educators often do not possess the design or technical skills to develop a custom game for their own use. MOLEGA (the Modeling Language for Educational Card Games) is a domain-specific modeling language that provides a guided model design environment for these users. Using MOLEGA, users can create visual models, inspired by UML class diagrams, to represent their desired card game, based on two selected variants. User models are then used to generate executable source code for a mobile-compatible, browser-based game that can be deployed on a server by following the provided instructions. MOLEGA is evaluated for validity and correctness using a suite of example models.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kaylynn</first_name>
          <last_name>Borror</last_name>
          <affiliation>Miami University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/kaylynnborror/924df1e3-c4c7-4e6c-8fdb-8d24fc003997/small.jpg</picture_url>
          <person_id>kaylynnborror</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Eric</first_name>
          <last_name>Rapos</last_name>
          <affiliation>Miami University</affiliation>
          <bio>Dr Rapos is an Assistant Professor in the Department of Computer Science &amp;amp; Software Engineering at Miami University University, working primarily on research in Software Engineering. 
Dr Rapos obtained his PhD from Queen’s University in Kingston, Canada in 2017, while also working as a Teaching Fellow for the University, instructing several classes. Dr Rapos also completed his MSc and undergraduate degrees at Queen’s University. 
Dr Rapos’ research areas of interest are: model-driven engineering, model-based testing, software evolution, test co-evolution, and co-evolution of model based tests. Dr Rapos has worked closely with industry professionals in the automotive domain to conduct relevant and interesting research.</bio>
          <homepage_url>http://users.miamioh.edu/rapose/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ericrapos/f6037c85-cfb6-4d58-ab4a-7d607eaeffdf/small.jpg</picture_url>
          <person_id>ericrapos</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>46a0da8a-f383-4f7d-bd86-f39c44ca4121</slot_id>
      <event_id>88145197-c460-4e68-aa68-ab908fee3c7b</event_id>
      <title>Introduction</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:20</end_time>
      <description>Introduction to the workshop, Introduction of the participants</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeff</first_name>
          <last_name>Gray</last_name>
          <affiliation>University of Alabama</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gray.cs.ua.edu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeffgray/1f2fd602-bac6-49dd-86e4-549b5dc88528/small.jpg</picture_url>
          <person_id>jeffgray</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matti</first_name>
          <last_name>Rossi</last_name>
          <affiliation>Aalto University School of Business</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.aalto.fi/index.html?profilepage=isfor#!matti_rossi</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mattirossi/25339e6c-8192-48c1-8f9d-282bdef59e5f/small.jpg</picture_url>
          <person_id>mattirossi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Sprinkle</last_name>
          <affiliation>University of Arizona</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ece.arizona.edu/jonathan-sprinkle</homepage_url>
          <person_id>jonathansprinkle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Juha-Pekka</first_name>
          <last_name>Tolvanen</last_name>
          <affiliation>MetaCase</affiliation>
          <bio>Juha-Pekka Tolvanen (jpt@metacase.com) is the CEO of MetaCase. He has been involved in domain-specific approaches and tools, notably metamodeling and code generator development since 1991. Juha-Pekka holds a Ph.D. in computer science from the University of Jyväskylä, Finland and received best national dissertation award 1999. He acts as a consultant world-wide for modeling language and code generation development. Juha-Pekka has authored a book (Domain-Specific Modeling, Wiley) and over 90 articles in software development magazines, journals and conferences.</bio>
          <homepage_url>http://www.metacase.com/blogs/jpt/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juhapekkatolvanen/f9d40f6a-1246-473e-b3bd-048707e141a0/small.jpg</picture_url>
          <person_id>juhapekkatolvanen</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f43774c0-2194-4c4a-824c-5ef8e9d9728a</slot_id>
      <event_id>918c86c1-2823-491d-b3c9-9361ad63a46f</event_id>
      <submission_id>2</submission_id>
      <title>Industrial Experiences With the Evolution of a DSL</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>10:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:20</end_time>
      <description>At Philips IGT, we develop and produce interventional X-ray systems. For a controller in these systems we have an approximately five years old domain specific language. Like general programming languages, domains specific languages also evolve. These languages co-evolve together with their domain. The language used at IGT was initially created for one system type. Because of our positive experiences with the language, we want to evolve the language to support a family of systems. In this paper we report on our experiences with the modifications we made to the original language. We made these changes preserving the behavior of the existing system instance. To prevent confidentiality issues we use a Lego robot in our examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mathijs</first_name>
          <last_name>Schuts</last_name>
          <affiliation>Philips &amp; Radboud University</affiliation>
          <bio>undefined</bio>
          <person_id>mathijsschuts</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marco</first_name>
          <last_name>Alonso</last_name>
          <affiliation>Philips</affiliation>
          <bio>undefined</bio>
          <person_id>marcoalonso</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jozef</first_name>
          <last_name>Hooman</last_name>
          <affiliation>TNO &amp; Radboud University</affiliation>
          <bio>undefined</bio>
          <person_id>jozefhooman</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d67c5c81-73df-4c04-97dd-385dd785e0a9</subevent_id>
    <title>SPLASH Keynotes: SPLASH Keynote</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>ecaf664a-b751-43bd-b0d2-bbd609c4cbd4</slot_id>
      <title>Session: SPLASH Keynotes - SPLASH Keynote</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>17:20</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>ddf16e4f-40bd-41b2-8c3e-3dc96063ff9f</slot_id>
      <event_id>3cd9d6e6-482e-4d66-9453-b8af77578e91</event_id>
      <title>Integrated Scientific Modeling and Lab Automation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>17:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>18:20</end_time>
      <description>The cycle of observation, hypothesis formulation, experimentation, and falsification that has driven scientific and technical progress is lately becoming automated in all its separate components. However, integration between these automated components is lacking. Theories are not placed in the same formal context as the (coded) protocols that are supposed to test them: neither description knows about the other, although they both aim to describe the same process. 
We develop integrated descriptions from which we can extract both the model of a phenomenon (for possibly automated mathematical analysis), and the steps carried out to test it (for automated execution by lab equipment). This is essential if we want to carry out automated model synthesis, falsification, and inference, by taking into account uncertainties in both the model structure and in the equipment tolerances that may jointly affect the results of experiments.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Luca</first_name>
          <last_name>Cardelli</last_name>
          <affiliation>Microsoft Research and University of Oxford</affiliation>
          <bio>Luca is a Fellow of the Royal Society, and ACM Fellow, and was awarded the Dahl-Nygaard Prize in 2007. He is a Royal Society Research Professor at the University of Oxford. Prior to that, he has worked at Bells Labs, Digital Equipment Corporation, and Microsoft Research Cambridge. He obtained his M.S. University of Pisa and his Ph.D. at the University of Edinburgh. 
His research spans object-oriented foundations, type systems, module systems, distributed programming, spatial logics, semi-structured data, databases, computer architectures, and more recently, molecular programming and semantics, systems biology, biological models, and natural computability.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/lucacardelli/827a5e0f-bbe9-4ec5-ac0a-5f4e743d0d6d/small.jpg</picture_url>
          <person_id>lucacardelli</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
      <badges>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>577eb8a6-3182-40f3-b6bc-b345c1b912e9</subevent_id>
    <title>VMIL: Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/vmil-2021</url>
    <url_link_display>VMIL 2021</url_link_display>
    <tracks>
      <track>VMIL 2021</track>
    </tracks>
    <timeslot>
      <slot_id>3984dae9-c4ab-4275-b7a3-7a6d7619e94b</slot_id>
      <title>Session: VMIL - Session 1</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Marr</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://stefan-marr.de/research/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefanmarr/0917eab8-ec51-465f-9ff6-1295826fd91e/small.jpg</picture_url>
          <person_id>stefanmarr</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4f4eeb1d-4fd9-4bae-8f7c-d0a628ac4c84</slot_id>
      <event_id>f9d56ad2-304e-453c-b2e4-2aea951f734e</event_id>
      <submission_id>6</submission_id>
      <title>Lightweight IOT abstractions for Embedded WebAssembly</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>10:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>10:20</end_time>
      <description>WebAssembly is a novel safe virtual machine instruction set supported by all major browsers. Its main strengths are safety, portability, compact code representation and fast code execution. These properties also make it an attractive target for execution on small embedded devices. In recent years we have seen several virtual machines such as WARDuino, wasm-micro-runtime and WASM3 supporting WebAssembly on a wide range of embedded devices. Unfortunately the WebAssembly instruction set does not lend itself to implementing IOT communication. In particular there are no instructions in the VM to interrupt code. On embedded devices, interrupts are a fundamental building block of responsive applications. 
In this paper we propose the inclusion of a set of IOT primitives which allows WebAssembly to support both synchronous and asynchronous communication primitives. To support the latter, we extended the VM with a lightweight interruption mechanism. We have formalized our extensions and implemented our extension in the WARDuino VM to support both HTTP and MQTT. An example IOT application written in Rust and compiled to WebAssembly running on an ESP32 shows that our extensions are stable and perform well over several testing days.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tom</first_name>
          <last_name>Lauwaerts</last_name>
          <affiliation>Universiteit Gent, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>tomlauwaerts</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Gurdeep Singh</last_name>
          <affiliation>Universiteit Gent, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://beardhatcode.be</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/robbertgurdeepsingh/755ae4c9-55dc-460f-b072-55cb8b62731c/small.jpg</picture_url>
          <person_id>robbertgurdeepsingh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Scholliers</last_name>
          <affiliation>Universiteit Gent, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~cfscholl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophescholliers/349aebe2-c428-4d19-8b70-9e1665dea5e6/small.jpg</picture_url>
          <person_id>christophescholliers</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
      <badges>
        <badge>WIP Paper</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>57d25081-4a6b-4a20-8c74-0a03acc8c31f</slot_id>
      <event_id>a3d3a71e-1d25-4fa6-b667-a72d7934c331</event_id>
      <title>Reflections on a decade of MoarVM, a runtime for the Raku programming language</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>10:00</end_time>
      <description>MoarVM was born out of youthful arrogance. I was contributing to Raku (then Perl 6) compiler development, looking at the Parrot virtual machine we were targeting at the time, considering some of our challenges with it (especially regarding performance and threading), and thought: what if I could design and build something better…in my copious free time? Within a few years, helped along by the contributions of tens of other open source volunteers, MoarVM almost entirely replaced Parrot as the language’s runtime of choice. 
Nearly a decade has passed since work on MoarVM began. Starting out as a simple register-based bytecode interpreter, MoarVM has steadily incorporated many of the tricks of the trade: type specialization, deoptimization, inlining, on stack replacement, JIT compilation, and basic escape analysis. As these fell into place, they drove a further change: hot operations that had been implemented as complex primitives in the VM for speed steadily became bottlenecks for further improvement, as the optimizer had no visibility into them, and thus were gradually eliminated. Most recently, a new generalized dispatch mechanism has arrived, eliminating numerous special-cased mechanisms (for example, method and multiple dispatch caches) with a single, programmable, approach. Being a multi-language VM has never been a goal - yet achieving better performance while managing complexity has led MoarVM to become ever more abstracted from the Raku language. 
In this session I will review MoarVM’s journey so far, picking out some of the most interesting challenges faced, lessons learned, and trade-offs encountered. I will also discuss the new generalized dispatch mechanism and its concept of resumable dispatch, which is allowing us to take on optimization of some language features that have thus far been stubbornly slow - but which also brings its own share of new challenges.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Worthington</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanworthington/036820d9-7abf-4d19-be95-a0337a71707a/small.jpg</picture_url>
          <person_id>jonathanworthington</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
      <badges>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>01b3569c-9181-47a3-9335-7e0bbe107ec0</subevent_id>
    <title>SPLASH Keynotes: SPLASH Keynote</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-splash-keynotes</url>
    <url_link_display>Keynotes</url_link_display>
    <tracks>
      <track>Keynotes</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>28d9633c-c93e-43dc-afcc-1b119d3d07aa</slot_id>
      <title>Session: SPLASH Keynotes - SPLASH Keynote</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:20</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>Keynotes</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>77c3355e-c0a4-4bd2-901e-cc8a16528eda</slot_id>
      <event_id>4aea397e-24ec-43c4-a73b-26df9bb20557</event_id>
      <title>Exascale and then what?: HPC and AI for Scientific Discovery</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>18:20</end_time>
      <description>We are on the verge of deploying Exascale systems, which remarkably in the US are quite similar in architecture and programming models. But what comes after these initial exascale systems? And what does that mean for scientific discovery and the languages, tools, and frameworks we need to build future applications? Are we going to see AI accelerators break out into the mainstream? Are hybrid-HPC/AI surrogate models the future of scientific computing? And if so what is the architecture and software implication? Is a hardware disaggregation model viable for HPC applications? Heterogenous workflows connecting the edge to the core are becoming more important yet our software stacks are unprepared and do not treat workflows as first-class applications. Increasing numbers of applications in science appear to require combining data analysis, simulations, and machine learning. What is the environment we need for building these new classes of applications? In this talk, I’ll try to make sense of trends and future direction and outline some important research problems for the next decade.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Rick</first_name>
          <last_name>Stevens</last_name>
          <affiliation>Argonne National Laboratory</affiliation>
          <bio>Rick Stevens is the Associate Laboratory Director of the Computing, Environment and Life Sciences Directorate at Argonne National Laboratory, and a Professor of Computer Science at the University of Chicago, with significant responsibility in delivering on the U.S. national initiative for Exascale computing and developing the DOE initiative in Artificial Intelligence (AI) for Science. 
His research spans the computational and computer sciences from high-performance computing architecture to the building of tools and methods for bioinformatics, cancer, infectious disease, and other problems in science and engineering. A recent focus has been the development of AI methods for a variety of scientific and biomedical problems. He also specializes in collaborative visualization technology and grid computing. At Argonne, he leads the Laboratory’s AI for Science initiative and is currently focusing on high-performance computing systems which includes collaborating with Intel and Cray to launch Argonne’s first exascale computer, Aurora, as well as the National AI Accelerator Testbed which brings together leading AI scientists to provide an open and unbiased environment for the evaluation of emerging AI accelerator technologies designed to accelerate training and inference for deep learning models. 
Prof. Stevens is a member of the American Association for the Advancement of Science and has received many national honors for his research, including an R&amp;amp;D 100 award and most recently being named a Fellow of the Association of Computer Machinery (ACM) for his continuing contributions to high-performance computing.</bio>
          <homepage_url>https://www.anl.gov/profile/rick-l-stevens</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rickstevens/bf9b1b15-be38-45d6-86a8-1d6bf26e8966/small.jpg</picture_url>
          <person_id>rickstevens</person_id>
        </person>
      </persons>
      <tracks>
        <track>Keynotes</track>
      </tracks>
      <badges>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>15ab0d6a-6b17-44fe-a5a7-9be8dc0a3ef4</subevent_id>
    <title>REBLS: Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/rebls-2021</url>
    <url_link_display>REBLS 2021</url_link_display>
    <tracks>
      <track>REBLS 2021</track>
    </tracks>
    <timeslot>
      <slot_id>20951738-e2f0-4cb5-b609-1116f11c188d</slot_id>
      <title>Session: REBLS - Session 2</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Alan</first_name>
          <last_name>Jeffrey</last_name>
          <affiliation>Roblox</affiliation>
          <bio>Software Engineer at Roblox, working on gradual typing and type inference for the Luau programming language.</bio>
          <homepage_url>http://asaj.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alanjeffrey1/85292841-a6a7-416c-8808-fc36002bf1bd/small.jpg</picture_url>
          <person_id>alanjeffrey1</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0818fe33-6976-45b2-8a68-fae7e0026df9</slot_id>
      <event_id>7ca4e63b-adfd-4272-b8ab-0a6e8f86faea</event_id>
      <submission_id>35</submission_id>
      <title>Symmetric Distributed Applications</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>14:15</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:40</end_time>
      <description>A program is deterministic if multiple re-executions with the same inputs always lead to the same state. Even concurrent instances of a deterministic program should observe identical behavior—in real time—if assigned the same set of inputs. In this work, we propose real-time reproducibility for distributed programs. Multiple instances of the same interactive application can broadcast asynchronous inputs and yet conform to identical behavior. Collaborative networked applications, such as watch parties, document editing, and video games can benefit from this approach. We name this class of applications as symmetric distributed applications. Using a standard event-driven API to wait and emit events, programmers write code as if the application executes in a single machine. Our middleware intercepts event generation and synchronizes all instances in a consistent timeline so that receipt is identically reproducible. Not only distributed applications benefit from consistency and determinism but also development and testing can be done in a single instance with the same guarantees. In our experiments, the middleware can handle applications with 25 FPS, distributed in up to 25 nodes over the Internet, with an event latency below 350ms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Francisco</first_name>
          <last_name>Sant'Anna</last_name>
          <affiliation>Rio de Janeiro State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ceu-lang.org/chico</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/franciscosantanna/1f911a5d-2e99-444d-a3cc-07d7cd77804b/small.jpg</picture_url>
          <person_id>franciscosantanna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rodrigo</first_name>
          <last_name>Santos</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>rodrigosantos2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Noemi</first_name>
          <last_name>Rodriguez</last_name>
          <affiliation>PUC-Rio</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/noemirodriguez/17c7bbb7-e9bb-43ff-9bf5-90a641184444/small.jpg</picture_url>
          <person_id>noemirodriguez</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1fa43cb5-2f35-4ec3-9ea3-f4847016ce95</slot_id>
      <event_id>243cf145-cb8a-4895-953b-61cb1cbaa9bc</event_id>
      <submission_id>43</submission_id>
      <title>Trampoline Variables: A General Method for State Accumulation in Reactive Programming</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:15</end_time>
      <description>Reactive programming is all about relegating the management of a program’s state changes to the realm of the runtime environment. Nevertheless, sometimes it is still necessary to enrich a reactive program with state variables that are explicitly updated by the programmer. In current reactive languages this is accomplished either by polluting the reactive paradigm with imperative constructs or by relying on built-in operators such as foldp. 
This paper introduces trampoline variables, a new general mechanism that allows reactive programs to manipulate state explicitly without resorting to imperative programming. We show that our proposal is at least as powerful as existing built-in reactive operators. We also analyse how reactive programs with trampoline variables can be composed and how they can form the basis to replace stateful constituents of a running reactive program — a.k.a. hotswapping — in a coherent way. The latter is an essential building block towards live IDEs for reactive programming languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bjarno</first_name>
          <last_name>Oeyen</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.bjarno.xyz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bjarnooeyen/c798be09-5fc6-45f6-9840-071793035cef/small.jpg</picture_url>
          <person_id>bjarnooeyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Van den Vonder</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>PhD candidate at the Software Languages Lab of the Vrije Universiteit Brussel.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/samvandenvonder/2ccd1dd4-a774-4f8b-b2a1-c601a5adc3d5/small.jpg</picture_url>
          <person_id>samvandenvonder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wolfgangdemeuter/cb721b79-a1aa-4583-8ba0-b1a96f896900/small.jpg</picture_url>
          <person_id>wolfgangdemeuter</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>41c0d95e-51d6-4990-95cf-7c000e5cf0c3</slot_id>
      <event_id>aa9d3672-ae76-4b40-aef7-56d80f1911a7</event_id>
      <submission_id>57</submission_id>
      <title>Analysing the performance and costs of reactive programming libraries in Java</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/18</date>
      <start_time>14:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>15:05</end_time>
      <description>Modern services running in cloud and edge environments need to be resource-efficient to increase deployment density and reduce operating costs. Asynchronous I/O combined with asynchronous programming provides a solid technical foundation to reach these goals. Reactive programming and reactive streams are gaining traction in the Java ecosystem. However, reactive streams implementations tend to be complex to work with and maintain. This paper discusses the performance of the three major reactive streams compliant libraries used in Java applications: RxJava, Project Reactor, and SmallRye Mutiny. As we will show, advanced optimization techniques such as operator fusion do not yield better performance on realistic I/O-bound workloads, and they significantly increase development and maintenance costs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julien</first_name>
          <last_name>Ponge</last_name>
          <affiliation>Red Hat, Inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://julien.ponge.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/julienponge/52b328af-ff03-4e73-b071-42f8c4746373/small.jpg</picture_url>
          <person_id>julienponge</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arthur</first_name>
          <last_name>Navarro</last_name>
          <affiliation>Red Hat</affiliation>
          <bio>undefined</bio>
          <person_id>arthurnavarro</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Clément</first_name>
          <last_name>Escoffier</last_name>
          <affiliation>Red Hat</affiliation>
          <bio>undefined</bio>
          <person_id>clementescoffier1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Frédéric</first_name>
          <last_name>Le Mouël</last_name>
          <affiliation>INSA Lyon</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.le-mouel.net/</homepage_url>
          <person_id>fredericlemouel</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBLS 2021</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b6432640-f1c5-4091-82ce-378b69fbc524</subevent_id>
    <title>DSM: Verification and validation, Tooling</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/dsm-2021</url>
    <url_link_display>DSM'21</url_link_display>
    <tracks>
      <track>DSM'21</track>
    </tracks>
    <timeslot>
      <slot_id>1b0ed1d6-e068-4d6b-bdc1-3d17d9169577</slot_id>
      <title>Session: DSM - Verification and validation, Tooling</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>709c4707-0783-4e04-ab94-359e59cfcf64</slot_id>
      <event_id>f7827e83-8ce7-4d4d-89aa-80038702a796</event_id>
      <submission_id>9</submission_id>
      <title>Differential-FORMULA: Towards a Semantic Backplane for Incremental Modeling</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:50</end_time>
      <description>This paper presents our preliminary results developing an incremental query and transformation engine for our modeling framework. Our prior framework combined WebGME, a cloud-based collaborative modeling tool, with FORMULA, a language and tool for specifying and analyzing domainspecific modeling languages. While this arrangement has been successful for defining non-trivial languages in domains like CPS, one ongoing challenge is the scalability of executing model queries and transformations on large models. The inherent incremental nature of the modeling process exacerbates this scalability issue: model queries and transformations are repeatedly performed on incrementally updated models. To address this issue, we are developing an incremental version of FORMULA that can perform efficient model queries and transformations in the face of continual model updates. This paper describes our experiences designing this incremental version, including the challenges we faced and design decisions. We also report encouraging benchmark results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qishen</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Vanderbilt University</affiliation>
          <bio>undefined</bio>
          <person_id>qishenzhang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Balasubramanian</last_name>
          <affiliation>Vanderbilt University</affiliation>
          <bio>undefined</bio>
          <person_id>danielbalasubramanian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tamas</first_name>
          <last_name>Kecskes</last_name>
          <affiliation>Vanderbilt University</affiliation>
          <bio>undefined</bio>
          <person_id>tamaskecskes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Janos</first_name>
          <last_name>Sztipanovits</last_name>
          <affiliation>Vanderbilt University</affiliation>
          <bio>undefined</bio>
          <person_id>janossztipanovits</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bce10ab5-5866-4032-940c-1e30dd158d0c</slot_id>
      <event_id>b7460eec-1acd-4e59-b9b1-243545fa2689</event_id>
      <title>Discussion and summary</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>12:10</end_time>
      <description>Discussion on the papers and themes of the workshop</description>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c11188a8-62e8-4381-b063-07940954811e</slot_id>
      <event_id>0e2794df-9a32-4a9a-9d7c-1204fd2c260e</event_id>
      <submission_id>4</submission_id>
      <title>Co-designing DSL Quality Assurance Measures for and with Non-programming Experts</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:10</end_time>
      <description>Domain-specific languages seek to provide domain guarantees that eliminate many errors allowed by general-purpose languages. Still, a domain-specific language requires additional quality assurance measures to ensure that specifications behave as intended by the users. However, some domains may have specific quality assurance measures (e.g., proofs, experiments, or case studies) with little tradition of using quality assurance measures customary to software engineering. We investigate the possibility of accommodating such domains by conducting a workshop with 11 prospective users of a domain-specific language named MAL for the pension industry. The workshop emphasised the need for supporting actuaries with new analytical tools for quality assurance and resulted in three designs: quantity monitors let users identify outlier behaviour, fragment debugging lets users debug with limited evaluative power, and debugging spreadsheets let users visualise, analyse, and remodel concrete calculations with an established domain tool. Based on our experiences, we hypothesise that co-design workshops are a viable approach for DSLs in a similar situation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Holger</first_name>
          <last_name>Borum</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/holgerborum/bac7a92b-0aa5-4cc2-80b4-269eb6cf0a94/small.jpg</picture_url>
          <person_id>holgerborum</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Seidl</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophseidl/3e8becb0-bfa5-4cfe-a0ba-3c2439a9db0a/small.jpg</picture_url>
          <person_id>christophseidl</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Sestoft</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.itu.dk/people/sestoft/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/petersestoft/fb3cebdd-f127-45c3-b33d-53e917c431f7/small.jpg</picture_url>
          <person_id>petersestoft</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f13515fe-7910-4a75-9ca1-086f865392c5</slot_id>
      <event_id>7f0eb685-f8f4-4151-8564-674b997b9b70</event_id>
      <submission_id>3</submission_id>
      <title>Integration of Modeling and Verification for System Model Based on KARMA Language</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/18</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:30</end_time>
      <description>Model-based systems engineering enables to verify the system performance using system behavior models, which can identify design faults that do not meet the stakeholders’ requirements as early as possible, thus reducing the R&amp;amp;D cost and error risks. Currently, different domain engineers make use of different modeling languages to create their own behavior models. Different behavior models are verified by different approaches. It is difficult to adopt a unified integrated platform to support the modeling and verification of heterogeneous behavior models during the conceptual design phase. This paper proposes a unified modeling and verification approach supporting system formalisms and verification. The KARMA language is used to support the unified formalisms across MBSE models and dynamic simulations for different domain specific models. In order to describe the behavior model more precisely and to facilitate verification, the syntax of hybrid automata is integrated into KARMA. We implemented behavior models and their verification in MetaGraph, a multi-architecture modeling tool. Finally, the effectiveness of the proposed approach is validated by two cases: 1) the scenario of booking railway tickets using BPMN models; 2) the behavior performance simulation of unmanned vehicles using a SysML state machine diagram.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jie</first_name>
          <last_name>Ding</last_name>
          <affiliation>Beijing Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>jieding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michel</first_name>
          <last_name>Reniers</last_name>
          <affiliation>TU/e</affiliation>
          <bio>undefined</bio>
          <person_id>michelreniers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jinzhi</first_name>
          <last_name>Lu</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <person_id>jinzhilu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Guoxin</first_name>
          <last_name>Wang</last_name>
          <affiliation>Beijing Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>guoxinwang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Lei</first_name>
          <last_name>Feng</last_name>
          <affiliation>KTH Royal Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>leifeng</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Kiritsis</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <person_id>dimitriskiritsis</person_id>
        </person>
      </persons>
      <tracks>
        <track>DSM'21</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>37776b7a-e3b6-458b-ac25-30b84e67b861</subevent_id>
    <title>HATRA: Types, Proofs, and Design Theory</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/hatra-2021</url>
    <url_link_display>Human Aspects of Types and Reasoning Assistants</url_link_display>
    <tracks>
      <track>Human Aspects of Types and Reasoning Assistants</track>
    </tracks>
    <timeslot>
      <slot_id>d936865e-ea07-43b4-a8e6-df0321a07bf2</slot_id>
      <title>Session: HATRA - Types, Proofs, and Design Theory</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Alan</first_name>
          <last_name>Jeffrey</last_name>
          <affiliation>Roblox</affiliation>
          <bio>Software Engineer at Roblox, working on gradual typing and type inference for the Luau programming language.</bio>
          <homepage_url>http://asaj.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alanjeffrey1/85292841-a6a7-416c-8808-fc36002bf1bd/small.jpg</picture_url>
          <person_id>alanjeffrey1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>02ec6bba-ac3c-4fa3-ae45-a27d75dfc90e</slot_id>
      <event_id>c56f9ce1-547b-45ed-8bb1-59ea0e73162c</event_id>
      <submission_id>5</submission_id>
      <title>Toward SMT-Based Refinement Types in Agda</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:50</end_time>
      <description>Dependent types offer great versatility and power, but developing proofs with them can be tedious and requires considerable human guidance. We propose to integrate Satisfiability Modulo Theories (SMT)-based refinement types into the dependently-typed language Agda in an effort to ease some of the burden of programming with dependent types and combine the strengths of the two approaches to mechanized theorem proving.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gan</first_name>
          <last_name>Shen</last_name>
          <affiliation>University of California, Santa Cruz, USA</affiliation>
          <bio>undefined</bio>
          <person_id>ganshen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lindsey</first_name>
          <last_name>Kuper</last_name>
          <affiliation>University of California at Santa Cruz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://users.soe.ucsc.edu/~lkuper/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lindseykuper/f5b1f248-82e4-45ec-ab90-1d543b02d204/small.jpg</picture_url>
          <person_id>lindseykuper</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18b2e702-3bd4-47b4-a355-c748192437c0</slot_id>
      <event_id>a72ec915-2a92-4ff7-a7ef-419aff0ae595</event_id>
      <submission_id>6</submission_id>
      <title>Toward Hole-Driven Development with Liquid Haskell</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:35</end_time>
      <description>Liquid Haskell is an extension to the Haskell programming language that adds support for refinement types: data types augmented with SMT-decidable logical predicates that refine the set of values that can inhabit a type. Furthermore, Liquid Haskell’s support for refinement reflection enables the use of Haskell for general-purpose mechanized theorem proving. A growing list of large-scale mechanized proof developments in Liquid Haskell take advantage of this capability. Adding theorem-proving capabilities to a “legacy” language like Haskell lets programmers directly verify properties of real-world Haskell programs (taking advantage of the existing highly tuned compiler, run-time system, and libraries), just by writing Haskell. However, more established proof assistants like Agda and Coq offer far better support for interactive proof development and insight into the proof state (for instance, what subgoals still need to be proved to finish a partially-complete proof). In contrast, Liquid Haskell provides only coarse-grained feedback to the user – either it reports a type error, or not – unfortunately hindering its usability as a theorem prover. 
In this paper, we propose improving the usability of Liquid Haskell by extending it with support for Agda-style typed holes and interactive editing commands that take advantage of them. In Agda, typed holes allow programmers to indicate unfinished parts of a proof, and incrementally complete the proof in a dialogue with the compiler. While GHC Haskell already has its own Agda-inspired support for typed holes, we posit that typed holes would be especially powerful and useful if combined with Liquid Haskell’s refinement types and SMT automation. We discuss how typed holes might work in Liquid Haskell, and we consider possible implementation approaches and next steps.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Redmond</last_name>
          <affiliation>University of California at Santa Cruz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://orcid.org/0000-0001-5702-0860</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/patrickredmond/6e9be812-651d-4346-aa44-b9271eb1a89e/small.jpg</picture_url>
          <person_id>patrickredmond</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Gan</first_name>
          <last_name>Shen</last_name>
          <affiliation>University of California, Santa Cruz, USA</affiliation>
          <bio>undefined</bio>
          <person_id>ganshen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lindsey</first_name>
          <last_name>Kuper</last_name>
          <affiliation>University of California at Santa Cruz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://users.soe.ucsc.edu/~lkuper/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lindseykuper/f5b1f248-82e4-45ec-ab90-1d543b02d204/small.jpg</picture_url>
          <person_id>lindseykuper</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>97f5ae4a-7658-4804-9cf4-b67674bb0c17</slot_id>
      <event_id>ff44a779-9897-4832-ae5f-c594596e9fd6</event_id>
      <title>Paper discussion, session 2</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>15:10</end_time>
      <description>We will spend the final 20 minutes of each session discussing the papers from that session.</description>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bba37019-7fe6-41cd-9fff-9978e618e22e</slot_id>
      <event_id>415ba232-9695-49e1-be1a-617a3408c8ee</event_id>
      <submission_id>4</submission_id>
      <title>Toward a Theory of Programming Language and Reasoning Assistant Design: Minimizing Cognitive Load</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:05</end_time>
      <description>Current approaches to making programming languages and reasoning assistants more effective for people focus on leveraging feedback from users and on evaluating the success of particular techniques. These approaches, although helpful, may not result in systems that are as usable as possible, and may not lead to general design principles. This paper advocates for leveraging theories from cognitive science, focusing on cognitive load theory, to design more effective programming languages and reasoning assistants. Development of these theories may enable designers to create more effective programming languages and reasoning assistants at lower cost.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>University of Maryland at College Park</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umd.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fec8d067-10b8-41c8-9675-b81a8d7b5d9f</slot_id>
      <event_id>84a4e172-8a3e-466e-9d0b-f3ca38df019a</event_id>
      <submission_id>9</submission_id>
      <title>Towards an Incremental Dataset of Proofs</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:20</end_time>
      <description>In this work, we describe an approach for a data-centered user study for proof assistant tools, targeting jsCoq. While we were not yet able to obtain an initial dataset from students enrolled in a Programming Languages course for Fall 2021, we report several hypothesis that could be validated upon the analysis of this data. Up to this point, there are no records of user studies involving large amounts of data for none of the existing tools. An analysis centered on user data could improve the overall usability of these interfaces by revealing issues with their design. In the educational field, the investigation could also help lecturers and staff to understand the students’ struggles and issues when learning Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hanneli</first_name>
          <last_name>Tavante</last_name>
          <affiliation>McGill University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.hannelita.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hannelitavante/d031f580-6c8e-4244-8d36-0be5335e261a/small.jpg</picture_url>
          <person_id>hannelitavante</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a53df478-53e0-47fe-953e-ceb67a9ac537</subevent_id>
    <title>DLS: DLS Talks 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/dls-2021</url>
    <url_link_display>Dynamic Languages Symposium</url_link_display>
    <tracks>
      <track>Dynamic Languages Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>5d3899c1-58d6-440f-a511-aacee5bf9dca</slot_id>
      <title>Session: DLS - DLS Talks 2</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1e4733e7-ba6c-4c1a-99bd-ae30d09f99c9</slot_id>
      <event_id>a2bd814e-644b-4386-a2fe-63fc670a4c7d</event_id>
      <title> Union and intersection contracts are hard, actually</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>15:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:15</end_time>
      <description>Union and intersection types are a staple of gradually typed language such as TypeScript. While it’s long been recog- nized that union and intersection types are difficult to ver- ify statically, it may appear at first that the dynamic part of gradual typing is actually pretty simple. It turns out however, that in presence of higher-order con- tracts union and intersection are deceptively difficult. The literature on higher-order contracts with union and inter- section, while keenly aware of the fact, doesn’t really ex- plain why. We point and illustrate the problems and trade- offs inherent to union and intersection contracts, via exam- ple and a survey of the literature.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Teodoro</first_name>
          <last_name>Freund</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>teodorofreund</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yann</first_name>
          <last_name>Hamdaoui</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>I graduated with a Ph.D from IRIF (Université Paris Diderot and CNRS, France) on the translation of effectful computation into Linear Logic. I now work at Tweag I/O on the design and implementation of Nickel, a configuration programming language.</bio>
          <homepage_url>https://hamdaoui.me</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannhamdaoui/e32e29d2-8091-41a9-9239-a4497b6578f8/small.jpg</picture_url>
          <person_id>yannhamdaoui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arnaud</first_name>
          <last_name>Spiwack</last_name>
          <affiliation>Tweag</affiliation>
          <bio>Arnaud Spiwack spend the first 10 years of his working life in Academia, between Chalmers university in Gothenburg, Sweden, and École Polytechnique, Inria, and Mines ParisTech, in the Paris area. He spent this time researching dependent types, computer-verified proof, and sequent calculus. During his time in Academia, Arnaud got involved in the development of the Coq Proof Assistant, where he, in particular, re-engineered Coq’s tactic engine and gave it an abstract interface. After leaving Academia, he remained a member of the core development team of the Coq Proof Assistant. He is now a senior architect at Tweag, and is working at making the world better typed.</bio>
          <homepage_url>http://assert-false.science/arnaud/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arnaudspiwack/2658428c-5eaf-48b9-9ff9-322b4260141e/small.jpg</picture_url>
          <person_id>arnaudspiwack</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
      <badges>
        <badge>Research Paper</badge>
        <badge>Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>30be21ce-3b68-4562-b83e-6a65be713945</slot_id>
      <event_id>2ff813f8-2b71-4bbd-8098-ecd51e17189c</event_id>
      <title>Runtime and Compiler Support for HAMTs</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>16:15</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:40</end_time>
      <description>Many functional languages—including Racket, Clojure, and Scala—provide a persistent-map datatype with an implementation based on Hash Array Mapped Tries (HAMTs). HAMTs enable efficient functional lookup, insertion, and deletion operations with a small memory footprint, especially when taking advantage of implementation techniques that have been developed since the original HAMT implementation. Racket’s latest HAMT implementation is based on an intermediate data structure, a stencil vector, that supports an especially compact representation of HAMTs with help from the compiler and memory manager. That is, stencil vectors provide an abstraction to improve HAMT performance without burdening the compiler with all of the complexity and design choices of a HAMT implementation. Benchmark measurements show that HAMTs in Racket have performance comparable to other state-of-the-art implementations, while stencil-vector HAMTs are more compact and run at least as fast as alternative representations in Racket.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sona</first_name>
          <last_name>Torosyan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>sonatorosyan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jon</first_name>
          <last_name>Zeppieri</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>jonzeppieri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Flatt</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>Matthew Flatt is a professor in the School of Computing at the University of Utah, where he works on extensible programming languages, runtime systems, and applications of functional programming. He is one of the developers of the Racket programming language. He received his PhD from Rice University in 1999.</bio>
          <homepage_url>http://www.cs.utah.edu/~mflatt/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/matthewflatt/8be359a0-6498-4c8c-a43a-e74a3d39673c/small.jpg</picture_url>
          <person_id>matthewflatt</person_id>
        </person>
      </persons>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
      <badges>
        <badge>Research Paper</badge>
        <badge>Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>e0d09b80-0418-43bc-9094-c046c66d423e</slot_id>
      <event_id>77995b66-f823-4c12-a66a-32f1a9318823</event_id>
      <title>Chair's Welcome and Most Notable Paper Award</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>15:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>Dynamic Languages Symposium</track>
      </tracks>
      <badges>
        <badge>Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>922b2264-71a7-4b71-951f-45f9517b68b7</subevent_id>
    <title>HATRA: Type Systems</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/hatra-2021</url>
    <url_link_display>Human Aspects of Types and Reasoning Assistants</url_link_display>
    <tracks>
      <track>Human Aspects of Types and Reasoning Assistants</track>
    </tracks>
    <timeslot>
      <slot_id>6593710c-ded0-4071-acfc-a7e51b25e5a4</slot_id>
      <title>Session: HATRA - Type Systems</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Chris</first_name>
          <last_name>Martens</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>Ph.D. Carnegie Mellon University, 2015 
Postdoc UC Santa Cruz, 2015-2016 
Assistant Professor, NC State University, 2016-present</bio>
          <homepage_url>http://go.ncsu.edu/cmartens</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chrismartens/962dad73-d5f2-486d-a080-7722ef25ed3f/small.jpg</picture_url>
          <person_id>chrismartens</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>076844b2-2616-44c4-9459-c19ddcb68ccb</slot_id>
      <event_id>a6b65a27-21bf-4be2-a5f7-a84044f0374a</event_id>
      <submission_id>7</submission_id>
      <title>Human Aspects of SASyLF, an Educational Proof Assistant for Type Theory</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>11:05</end_time>
      <description>An increasing number of programming language courses include content on type theory. But learning about type theory is hard: students must learn what constitutes a rigorous proof and how to construct one. We have designed the SASyLF proof assistant to help students learn to write proofs about programming languages. SASyLF allows students to write proofs in any text editor, using a syntax very similar to what is used in classrooms—ensuring that instructors need not spend a lot of time teaching details of the tool. SASyLF’s built-in support for variable binding, inherited from its LF foundations, avoids the need for students to learn arcane variable encodings and allows us to provide good error messages. We provide an overview of SASyLF’s design, plans to integrate it into a course and widely used textbook, and the feedback we’ve gotten from students so far.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>67fa70db-93ff-4815-be8d-cf63d66cf972</slot_id>
      <event_id>2eb94ae9-3b23-493a-872f-a186eacb231c</event_id>
      <title>Paper discussion, session 1</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>12:10</end_time>
      <description>We will spend the final 20 minutes of each session discussing the papers from that session.</description>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a6236bbc-50c7-4d26-8af0-4839a8c1979f</slot_id>
      <event_id>f754d754-9de0-4474-9c55-777cbf5f93fd</event_id>
      <submission_id>10</submission_id>
      <title>User-driven design and evaluation of Liquid Types in Java</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>11:50</end_time>
      <description>Bugs that are detected earlier during the development lifecycle are easier and cheaper to fix, whereas bugs that are found during production are difficult and expensive to address, and may have dire consequences. Type systems are particularly effective at identifying and preventing bugs early in the development lifecycle by causing invalid programs to result in build failure. Liquid Types are more powerful than those found in mainstream programming languages, allowing the detection of more classes of bugs. However, while Liquid Types were proposed in 2008 with their integration in ML and subsequently introduced in C (2012), Javascript(2012) and Haskell(2014) through language extensions, they have yet to become widely adopted by mainstream developers. This paper investigates how Liquid Types can be integrated in a mainstream programming language, Java, by proposing a new design that aims to lower the barrier to entry and adapts to problems that Java developers commonly encounter at runtime. To promote accessibility, we conducted a series of developer surveys to design the syntax of LiquidJava, our prototype. To evaluate the prototype’s usability, we conducted a user study of 30 Java developers, concluding that users intend to use LiquidJava and that it helped to find more bugs and debug faster.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Catarina</first_name>
          <last_name>Gamboa</last_name>
          <affiliation>LASIGE, Faculdade de Ciências da Universidade de Lisboa</affiliation>
          <bio>PhD Student at LASIGE, Faculdade de Ciências da Universidade de Lisboa</bio>
          <homepage_url>https://catarinagamboa.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/catarinaventuragamboa/75b53901-e755-46da-960f-bd2dee6b1533/small.jpg</picture_url>
          <person_id>catarinaventuragamboa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Paulo</first_name>
          <last_name>Santos</last_name>
          <affiliation>LASIGE, Faculdade de Ciências da Universidade de Lisboa</affiliation>
          <bio>Ph.D. Student at LASIGE at Faculdade de Ciências da Universidade de Lisboa and ISR at Carnegie Mellon University</bio>
          <homepage_url>https://pcanelas.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/paulosantos/8bb70a8a-8456-4004-9b79-dec1e8b41374/small.jpg</picture_url>
          <person_id>paulosantos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christopher Steven</first_name>
          <last_name>Timperley</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophersteventimperley/82fa0d49-60f8-4ed4-b172-671842481ef3/small.jpg</picture_url>
          <person_id>christophersteventimperley</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alcides</first_name>
          <last_name>Fonseca</last_name>
          <affiliation>LASIGE, Faculdade de Ciências da Universidade de Lisboa</affiliation>
          <bio>see alcidesfonseca.com</bio>
          <homepage_url>http://alcidesfonseca.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alcidesfonseca/e083ce86-e20f-4c70-95c6-6769df458db4/small.jpg</picture_url>
          <person_id>alcidesfonseca</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c5b2f7ca-efbb-4944-9292-cf5cb761b389</slot_id>
      <event_id>c60bb2ea-ed2a-40a1-967c-1da8786483fe</event_id>
      <submission_id>8</submission_id>
      <title>An Empirical Study of Protocols in Smart Contracts</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>11:20</end_time>
      <description>Smart contracts are programs that are executed on a blockhain. They have been used for applications in voting, decentralized finance, and supply chain management. However, vulnerabilities in smart contracts have been abused by hackers, leading to financial losses. Understanding state machine protocols in smart contracts has been identified as important to catching common bugs, improving documentation, and optimizing smart contracts. We analyze Solidity smart contracts deployed on the Ethereum blockchain and study the prevalence of protocols and protocol-based bugs, as well as opportunities for gas optimizations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Timothy</first_name>
          <last_name>Mou</last_name>
          <affiliation>Swarthmore College</affiliation>
          <bio>undefined</bio>
          <person_id>timothymou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>University of Maryland at College Park</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umd.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d35159a4-0117-41c2-92d8-e26bd06d8af3</slot_id>
      <event_id>dbb1a1e2-76c7-4f0f-9b64-86ab58a863c0</event_id>
      <submission_id>1</submission_id>
      <title>Position Paper: Goals of the Luau Type System</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/19</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>11:35</end_time>
      <description>Luau is the scripting language that powers user-generated experiences on the Roblox platform. It is a statically-typed language, based on the dynamically-typed Lua language, with type inference. These types are used for providing editor assistance in Roblox Studio, the IDE for authoring Roblox experiences. Due to Roblox’s uniquely heterogeneous developer community, Luau must operate in a somewhat different fashion than a traditional statically-typed language. In this paper, we describe some of the goals of the Luau type system, focusing on where the goals differ from those of other type systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lily</first_name>
          <last_name>Brown</last_name>
          <affiliation>Roblox</affiliation>
          <bio>undefined</bio>
          <person_id>lilybrown</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andy</first_name>
          <last_name>Friesen</last_name>
          <affiliation>Roblox</affiliation>
          <bio>undefined</bio>
          <person_id>andyfriesen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Alan</first_name>
          <last_name>Jeffrey</last_name>
          <affiliation>Roblox</affiliation>
          <bio>Software Engineer at Roblox, working on gradual typing and type inference for the Luau programming language.</bio>
          <homepage_url>http://asaj.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alanjeffrey1/85292841-a6a7-416c-8808-fc36002bf1bd/small.jpg</picture_url>
          <person_id>alanjeffrey1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Human Aspects of Types and Reasoning Assistants</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d83230c0-60a9-4340-afd7-9dc66d925857</subevent_id>
    <title>SPLASH Onward! Essays: Essays Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-Essays</url>
    <url_link_display>Onward! Essays</url_link_display>
    <tracks>
      <track>Onward! Essays</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>824a6f16-2ebb-4536-bace-13de7579591e</slot_id>
      <title>Session: SPLASH Onward! Essays - Essays Session 1</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Gibbons</last_name>
          <affiliation>Department of Computer Science, University of Oxford</affiliation>
          <bio>I am Professor of Computing in the Department of Computer Science at the University of Oxford. I also lead the Algebra of Programming research group. I have served as Deputy Head of Department, and as Director of the Software Engineering Programme, which offers part-time professional Masters’ degrees in Software Engineering and in Software and Systems Security. I am Editor-in-Chief of the Journal of Functional Programming, Chair of the ICFP Steering Committee, Past Vice Chair of ACM SIGPLAN, Past Chair of IFIP WG2.1. Before taking up this post in 1999, I held lectureships at Oxford Brookes University and the University of Auckland, New Zealand.</bio>
          <homepage_url>http://www.cs.ox.ac.uk/jeremy.gibbons/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeremygibbons/17403e55-a926-41cf-ae21-08abecea187c/small.jpg</picture_url>
          <person_id>jeremygibbons</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>638db432-f284-41cb-aa74-4f6c929e437b</slot_id>
      <event_id>d9d6e0ac-f9e4-415c-9e4a-5ff0f2802def</event_id>
      <submission_id>onward21essays-id6-p</submission_id>
      <title>Angelic and Demonic Visitation: School Memories</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>08:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Leila</first_name>
          <last_name>Salem</last_name>
          <affiliation>University of Toronto</affiliation>
          <bio>undefined</bio>
          <person_id>leilasalem</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>9a011290-2f5c-4d14-9d08-85cb039747d7</slot_id>
      <event_id>5d3ee16e-9b3a-4ef2-8613-7460b6b8831b</event_id>
      <submission_id>onward21essays-id3-p</submission_id>
      <title>Programming as Architecture, Design, and Urban Planning</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>08:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tomas</first_name>
          <last_name>Petricek</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>Tomas is a Lecturer at University of Kent and a Collaborating Fellow at the Alan Turing Institute in London. He is building programming tools that integrate with modern data sources (open government data, data published by citizen initiatives) and let users easily create analyses and visualizations that are linked to the original data source, making the analyses more transparent, reproducible, but also easy to adapt. His early work on the project can be found at http://thegamma.net. 
Tomas’ many other interests include open-source and functional programming (he is an active contributor to the F# ecosystem), programming language theory (his PhD thesis on “coeffects” develops a theory of context-aware programming language language), but also understanding programming through the perspective of philosophy of science.</bio>
          <homepage_url>http://tomasp.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomaspetricek/405de991-6537-4d65-8499-fde0dcc8c5cd/small.jpg</picture_url>
          <person_id>tomaspetricek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Essays</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>066648d9-aa28-49a2-8b9d-0e123ada2930</subevent_id>
    <title>CONFLANG: Languages</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/conflang-2021</url>
    <url_link_display>CONFLANG</url_link_display>
    <tracks>
      <track>CONFLANG</track>
    </tracks>
    <timeslot>
      <slot_id>2b2093ff-6d05-49e7-b25e-28bfc6faaf8f</slot_id>
      <title>Session: CONFLANG - Languages</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Jeannerod</last_name>
          <affiliation>IRIF, Université de Paris</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://nicolas.jeannerod.fr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nicolasjeannerod/372761c8-e960-41bd-a28e-586de68a861b/small.jpg</picture_url>
          <person_id>nicolasjeannerod</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Mark</first_name>
          <last_name>Santolucito</last_name>
          <affiliation>Barnard College, Columbia University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.marksantolucito.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marksantolucito/51821284-64c1-46e0-b979-96e8324079bf/small.jpg</picture_url>
          <person_id>marksantolucito</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2291a4f0-e8d3-4e10-8ba1-b7bfb755c3f6</slot_id>
      <event_id>7646883f-edb2-4255-bc83-2467d530ff3f</event_id>
      <title>A Language for Configuring Security Policies</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:05</end_time>
      <description>Shape Security uses a language called DEX1 to configure security policies used to defend enterprises against Botnet attacks. DEX is a purely functional, decidable, statically typed language designed to facilitate configuration and analysis. By design, it is not Turing-complete. The language does not permit recursion and has no explicit looping constructs. Iteration over finite collections is provided via list comprehensions. As a result, a program written entirely in DEX can never diverge or crash. 
The talks introduce DEX. The talk will then list a number of feature of the language, from typing to null handling, and give an experience report on the usage and the past and foreseeable evolution of the DEX language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gilad</first_name>
          <last_name>Bracha</last_name>
          <affiliation>g.bracha@f5.com</affiliation>
          <bio>undefined</bio>
          <person_id>giladbracha1</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>24a10fb8-1760-4c0c-97db-0c9395952439</slot_id>
      <event_id>70055170-a6f0-438e-9993-4f5e8fbcf926</event_id>
      <title>Languages: Q&amp;A and discussion</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>09:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>54d6470e-fef8-47d5-aa01-10d5217bcbcf</slot_id>
      <event_id>0036c525-3be4-4f51-a678-22b1fc98d836</event_id>
      <title>The Pitfalls of Ansible’s Variable and Template Expression Semantics</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>09:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:15</end_time>
      <description>Ansible is a widely-used Infrastructure-as-Code (IaC) lan- guage for managing the configuration of machines in a digital infrastructure. The reliability of configuration definition files, which Ansible calls “playbooks”, is of the upmost importance. However, Ansible employs semantics unlike those found in traditional programming languages, the unexpected behaviour of which could surprise developers. Next to forming a steep learning curve for newcomers, this semantics also hinders both manual and mechanical verification. In this presentation, we will show a number of potential pitfalls caused by a combination of unconventional semantic properties of Ansible variables and template expressions. The purpose of this talk is three-fold: 1. To spread awareness of the unconventional semantics of Ansible and possible pitfalls to practitioners. 2. To entice tool builders to work on code analysers and bug detectors related to these pitfalls. 3. To stimulate language designers to address these pitfalls with safer alternatives.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruben</first_name>
          <last_name>Opdebeeck</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <person_id>rubenopdebeeck</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Coen</first_name>
          <last_name>De Roover</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~cderoove/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/coenderoover/ef3a26a6-56c3-420e-b1ce-b4a0e6cd653e/small.jpg</picture_url>
          <person_id>coenderoover</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>842f9a0b-b4c3-45c7-9080-d8084ce44c89</slot_id>
      <event_id>f6431b88-7d80-4b9e-8143-1685c4a3ed3b</event_id>
      <title>Typing in Nickel and elsewhere</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>09:15</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:20</end_time>
      <description>Typing is an eternal subject of discord amongst programming language de- signers and practitioners. On the one hand, dynamic typing is flexible and forgiving, allowing one to focus on the business logic. For rapid prototyping, dynamic typing just doesn’t get in the way. On the other hand, as soon as a piece of software exceeds a particular (not so big) size, the permissive nature of dynamic typing becomes dangerous. In a production code base consisting of many moving parts interacting together, and where failure can have important negative consequences, static typing bring structure, clarity, and eliminate a whole class of bug early. 
Until recently, static typing was most popular for compiled general-purpose languages and system programming. Dynamic typing was still dominant for scripting languages and in particular for web-oriented languages. But the functional programming paradigm shift of recent years have now brought static typing to the web. What about the emerging world of configuration languages? In this talk, I’ll try to explain why the question of typing for configuration languages is quite different than for general-purpose languages. We introduce the type and contract system of Nickel, a configuration language we are currently developing at Tweag, that mixes both static typing and dynamic typing. We then have a tour of other configuration languages with similar use cases, to explore the different trade-offs and design choices they made.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yann</first_name>
          <last_name>Hamdaoui</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>I graduated with a Ph.D from IRIF (Université Paris Diderot and CNRS, France) on the translation of effectful computation into Linear Logic. I now work at Tweag I/O on the design and implementation of Nickel, a configuration programming language.</bio>
          <homepage_url>https://hamdaoui.me</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannhamdaoui/e32e29d2-8091-41a9-9239-a4497b6578f8/small.jpg</picture_url>
          <person_id>yannhamdaoui</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>feb28705-3b05-4c06-b847-72364ea2c9d8</slot_id>
      <event_id>1364b115-e3c9-4c8b-b691-6b5f95636df3</event_id>
      <title>Provenance of Configuration Programming Language muPuppet</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>09:05</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:10</end_time>
      <description>Increased complexity of configuration tasks in computing systems has brought out automatic configuration management tools and high level languages for specifying configurations, such as Puppet, a popular configuration management tool, providing its own language. However, both configuration languages and the validations lack formalization that provides high confidence in their security. The correctness of configurations built in these tools is not guaranteed and especially there is little aid for correcting configuration errors. At most, their correctness relies on existing techniques or tools invented for other purposes besides the system, but these techniques are not integrated with configuration systems. As configuration languages are domain-specific languages with distinctive features, it is worthwhile to equip them with suitable formalisms. We propose to use formal semantics in programming language theory and “provenance” techniques rooted in database research to provide formalisms for understanding and correcting configuration errors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Weili</first_name>
          <last_name>Fu</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>weilifu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Paul</first_name>
          <last_name>Anderson</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>paulanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Cheney</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/jcheney/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamescheney/fad2c5e0-4605-4bd7-a0bb-aa02ec0b60ba/small.jpg</picture_url>
          <person_id>jamescheney</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>057d2c3c-1edf-4f64-83e6-0224986c96fd</subevent_id>
    <title>CONFLANG: Experience reports</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/home/conflang-2021</url>
    <url_link_display>CONFLANG</url_link_display>
    <tracks>
      <track>CONFLANG</track>
    </tracks>
    <timeslot>
      <slot_id>a2c719fe-01bf-4b28-ad6b-1f212c54e000</slot_id>
      <title>Session: CONFLANG - Experience reports</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Dolstra</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.linkedin.com/in/edolstra/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/eelcodolstra/0bb27aef-3cb1-4bc6-8c42-ea7e3ad5b6f6/small.jpg</picture_url>
          <person_id>eelcodolstra</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Yann</first_name>
          <last_name>Hamdaoui</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>I graduated with a Ph.D from IRIF (Université Paris Diderot and CNRS, France) on the translation of effectful computation into Linear Logic. I now work at Tweag I/O on the design and implementation of Nickel, a configuration programming language.</bio>
          <homepage_url>https://hamdaoui.me</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannhamdaoui/e32e29d2-8091-41a9-9239-a4497b6578f8/small.jpg</picture_url>
          <person_id>yannhamdaoui</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>36cc3eca-0479-4d5a-96ab-20543deac236</slot_id>
      <event_id>3eafa6b9-9270-4954-b8e5-c50787ca3756</event_id>
      <title>Case Study: Building and testing programming assignments with Nix</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>13:55</end_time>
      <description>We use Nix to build and test student assignments for a systems programming course that we teach. Many tools have been used by many teachers to automate this kind of task. Some tools support one or more specific programming environments. We speculate that many teachers simply write their own automation scripts, specific to the programming environment they teach in their course. Using Nix, we can decouple the supported programming environments from the automation around them, so that a user can freely specify a programming environment and a tool can provide some artifact, automated workflow or service that uses or provides the specified environment. We have used Nix to build several teaching tools around the same declared environment: 
 
 A grading pipeline which ingests all submissions for a specific assignment after they have been submitted, runs the tests for them and then outputs build logs and test results. This output is then handed over to several tutors for manual inspection. 
 A self-updating VM tied to a repo on GitHub, which students can download and use to work on their assignments. 
 A working prototype of a Go-based web service where students can upload their assignment submission and get immediate feedback while they are still actively working on it.We have already employed the first two of those processes in practice during the last term. 
 
During our talk: 
 
 We would like to briefly introduce what our tools do for context and motivation. 
 We would then pick a few interesting properties from the above list and present our various attempts to achieve them as users of Nix 
 In between we would gather different approaches to individual problems we might have not thought of from the audience. 
 
We do have solutions to get some of those properties, but some of our solutions are terrible hacks. We are also still actively working on this project, so we expect to make improvements to some of our current solutions until then.We think that discussing needs that arise when writing tools like this, where individual build steps require additional control and the user cares about other outputs of the process than the build result, would be beneficial for the Nix ecosystem.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Schwaighofer</last_name>
          <affiliation>JKU Linz, Austria</affiliation>
          <bio>undefined</bio>
          <person_id>martinschwaighofer</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c98eca41-ddc3-4658-a4fe-02c0b47fa867</slot_id>
      <event_id>1584ba09-7622-46b6-8a4a-d11e2d1c5fbc</event_id>
      <title>Experience report: Q&amp;A and discussion</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d06ce7cd-2003-4dd5-bf9b-17056e3b4004</slot_id>
      <event_id>575bc3b4-2a52-48d4-9ec1-e608e8b175ad</event_id>
      <title>Six Ways Configuration Systems Fail</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>14:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:05</end_time>
      <description>Configuration‌ ‌is‌ ‌a‌ ‌difficult‌ ‌problem,‌ ‌in‌ ‌part‌ ‌because‌ ‌it‌ ‌often‌ ‌lacks‌ ‌a‌ ‌clear‌ ‌definition‌ ‌–‌ ‌and‌ ‌even‌‌ when‌ ‌it‌ ‌has‌ ‌one,‌ ‌that‌ ‌definition‌ ‌encompasses‌ ‌both‌ ‌technical‌ ‌and‌ ‌social‌ ‌aspects‌ ‌of‌ ‌building‌ ‌and‌‌ operating‌ ‌software‌ ‌systems –‌ ‌there‌ ‌are‌ ‌many‌ ‌systems‌ ‌involved‌ ‌and‌ ‌many‌ ‌stakeholders.‌ ‌And‌ ‌it’s‌‌ an‌ ‌important‌ ‌problem:‌ ‌configuration‌ ‌errors‌ ‌are‌ ‌frequently‌ ‌cited‌ ‌as‌ ‌the‌ ‌causes‌ ‌of‌ ‌production‌‌ outages.‌ 
I‌ ‌have‌ ‌designed,‌ ‌built,‌ ‌and‌ ‌used‌ ‌a‌ ‌number‌ ‌of‌ ‌configuration‌ ‌systems‌ ‌in‌ ‌organizations‌ ‌both‌ ‌large‌‌ and‌ ‌small.‌ ‌Despite‌ ‌spending‌ ‌years‌ ‌studying‌ ‌the‌ ‌design‌ ‌and‌ ‌implementation‌ ‌of‌ ‌programming‌‌ languages,‌ ‌I‌ ‌was‌ ‌not‌ ‌adequately‌ ‌prepared:‌ ‌configuration‌ ‌is‌ ‌not‌ ‌merely‌ ‌about‌ ‌defining‌ ‌a‌‌ language‌ ‌but‌ ‌also‌ ‌includes‌ ‌how‌ ‌that‌ ‌language‌ ‌will‌ ‌be‌ ‌used‌ ‌(and‌ ‌by‌ ‌whom)‌ ‌as‌ ‌well‌ ‌as‌ ‌how‌‌ software‌ ‌systems‌ ‌will‌ ‌manipulate,‌ ‌create,‌ ‌and‌ ‌consume‌ ‌configuration.‌ ‌In‌ ‌this‌ ‌talk,‌ ‌I’ll‌ ‌present‌ ‌six‌‌ ways‌ ‌these‌ ‌configuration‌ ‌systems‌ ‌have‌ ‌failed‌ ‌(along‌ ‌with‌ ‌concrete‌ ‌examples)‌ ‌so‌ ‌that‌ ‌others‌ ‌can‌‌ avoid‌ ‌the‌ ‌mistakes‌ ‌I’ve‌ ‌made‌ ‌and‌ ‌the‌ ‌pitfalls‌ ‌that‌ ‌I‌ ‌have‌ ‌encountered.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Spoonhower</last_name>
          <affiliation>Lightstep</affiliation>
          <bio>Daniel “Spoons” Spoonhower is a co-founder at LightStep, where he’s building performance management tools for modern software systems. Previously, Spoons spent almost six years at Google where he worked on developer tools as part of both Google’s internal infrastructure and Cloud Platform teams. He has published papers on the performance of parallel programs, garbage collection, and real-time programming. He has a PhD in programming languages from Carnegie Mellon University but still hasn’t found one he loves.</bio>
          <homepage_url>https://www.linkedin.com/in/spoons/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danielspoonhower/1e5d493d-1210-4a9f-982a-c59d73966086/small.jpg</picture_url>
          <person_id>danielspoonhower</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e4d789ac-6e56-49ce-ad12-d44930038c47</slot_id>
      <event_id>78a3731a-71a6-4534-b734-c6ef4a56390b</event_id>
      <title>Large-Scale Engineering of Configuration with Unification</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/18</date>
      <start_time>13:55</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:00</end_time>
      <description>In this talk, we introduce CUE, a new aspect-oriented, constraint-based configuration language that deploys a more formal approach to configuration aimed at solving many of the issues that persist with more conventional approaches. You will leave with an understanding of the CUE language, and an appreciation of how it can help mitigate the challenges associated with large-scale configurations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marcel</first_name>
          <last_name>van Lohuizen</last_name>
          <affiliation>CUE</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cuelang.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marcelvanlohuizen/13e4d829-753a-45dd-9831-d4e0744973fb/small.jpg</picture_url>
          <person_id>marcelvanlohuizen</person_id>
        </person>
      </persons>
      <tracks>
        <track>CONFLANG</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>67849182-5812-45b5-b906-3279c61ff47f</subevent_id>
    <title>SPLASH Doctoral Symposium: Afternoon 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Currents</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-Doctoral-Symposium</url>
    <url_link_display>Doctoral Symposium</url_link_display>
    <tracks>
      <track>Doctoral Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>f6de485e-7203-452c-a5a8-b82ebc28c3b7</slot_id>
      <title>Session: SPLASH Doctoral Symposium - Afternoon 2</title>
      <room>Swissotel Chicago | Currents</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>194fd2b6-a26e-431d-871e-009cc7e3b902</slot_id>
      <event_id>603107bf-a2ab-4cfb-9a63-6bf03aedefc5</event_id>
      <title>Test Overfitting: Challenges, Approaches and Measurements</title>
      <room>Swissotel Chicago | Currents</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:15</end_time>
      <description>Dynamic automated program repair (APR) techniques have promising results, which use test suites for bug localization and evaluating candidate patches. Several studies have shown that generated patches by dynamic APR tools that pass its test suite do not always correctly implement the program’s expected behavior, which is known as test overfitting. My research aims to provide fresh insight into the test overfitting problem by using formal methods.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Amirfarhad</first_name>
          <last_name>Nilizadeh</last_name>
          <affiliation>University of Central Florida</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/amirfarhadnilizadeh/4be0d65c-8538-4573-9f26-e7d3f2a96659/small.jpg</picture_url>
          <person_id>amirfarhadnilizadeh</person_id>
        </person>
      </persons>
      <tracks>
        <track>Doctoral Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>556d9d66-73a2-4ea6-a761-e37b03cc8cf2</subevent_id>
    <title>VMIL: Session 3</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/home/vmil-2021</url>
    <url_link_display>VMIL 2021</url_link_display>
    <tracks>
      <track>VMIL 2021</track>
    </tracks>
    <timeslot>
      <slot_id>cf06ca12-1897-4881-8d0d-9e9a1904ac2a</slot_id>
      <title>Session: VMIL - Session 3</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Flatt</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>Matthew Flatt is a professor in the School of Computing at the University of Utah, where he works on extensible programming languages, runtime systems, and applications of functional programming. He is one of the developers of the Racket programming language. He received his PhD from Rice University in 1999.</bio>
          <homepage_url>http://www.cs.utah.edu/~mflatt/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/matthewflatt/8be359a0-6498-4c8c-a43a-e74a3d39673c/small.jpg</picture_url>
          <person_id>matthewflatt</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>409430b4-8918-4260-b680-8433ea448b2d</slot_id>
      <event_id>485c4af5-dbf0-4f2f-80b2-5d7862fcd61e</event_id>
      <title>Cross-Domain Compilation: Exploiting Synergies Across the CS Community</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:50</end_time>
      <description>Developing a new programming language, constructing a new domain-specific compiler, writing a new verification tool, optimizing a large application, designing a microprocessor, or verifying some of its components, all of these tasks require today a multi-year project. While most of the underlying problems are inherently hard and cannot be accelerated magically, we are additionally slowed down by a lack of well-defined interfaces that prevent us to exploit synergies between CS sub-communities. In this presentation, I raise the question of how we can accelerate the innovation speed of our CS technology stack to levels recently seen in deep learning, battery electric vehicles, or rocket launches. While I won’t provide an answer, I will share the latest developments from the LLVM compiler community where the recent introduction of MLIR initiated the design of numerous IR abstractions that can be freely composed to build hybrid tools crossing community boundaries, that can be analyzed to gain a deep understanding of the various IR abstractions, and which may be the seed of a new abstraction sharing economy in our community. I will share some of my very own steps in this space on analyzing and understanding the various IR abstractions already in existence and will point out new cross-community collaboration opportunities. This talk concludes by raising the question of how we as researchers can build impactful and lasting open-source communities to move from interfacing software to towards building bridges between communities.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Grosser</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.grosser.es</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobiasgrosser/1ee43044-14e9-497e-a230-90f96a8da867/small.jpg</picture_url>
          <person_id>tobiasgrosser</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
      <badges>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>b53233ab-ff15-4e1b-960a-c6f3d474ad18</slot_id>
      <event_id>1c56fd67-b74f-4d53-9aaa-3bbb0208a232</event_id>
      <submission_id>1</submission_id>
      <title>YJIT: A Basic Block Versioning JIT Compiler for CRuby</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/19</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>15:10</end_time>
      <description>Ruby is a dynamically typed programming language with a large breadth of features which has grown in popularity with the rise of the modern web, and remains at the core of the implementation of many widely-used websites. 
CRuby, the default implementation of the language, features a JIT compiler known as MJIT, but developers often do not enable it in production environments, because it does not always yield performance improvements on real-world software. Attempts to independently reimplement the Ruby language, such as JRuby and TruffleRuby have shown impressive performance results on benchmarks, but often lag behind CRuby when it comes to supporting new additions to the language, which limits their adoption. 
We introduce YJIT, a new JIT compiler built inside CRuby based on a Lazy Basic Block Versioning (LBBV) architecture. We show that while our compiler does not match the peak performance of TruffleRuby, it offers near-100% compatibility with existing Ruby code, impressively fast warmup, and speedups from 15% to 19% on sizeable benchmarks based on real-world software.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maxime</first_name>
          <last_name>Chevalier-Boisvert</last_name>
          <affiliation>Shopify</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://pointersgonewild.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/maximechevalierboisvert/8db10a92-e54a-484e-80b2-07662f398a11/small.jpg</picture_url>
          <person_id>maximechevalierboisvert</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Noah</first_name>
          <last_name>Giibbs</last_name>
          <affiliation>Shopify</affiliation>
          <bio>undefined</bio>
          <person_id>noahgiibbs</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean</first_name>
          <last_name>Boussier</last_name>
          <affiliation>Shopify</affiliation>
          <bio>undefined</bio>
          <person_id>jeanboussier</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Si Xing "Alan"</first_name>
          <last_name>Wu</last_name>
          <affiliation>Shopify</affiliation>
          <bio>undefined</bio>
          <person_id>sixingalanwu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Patterson</last_name>
          <affiliation>Shopify</affiliation>
          <bio>undefined</bio>
          <person_id>aaronpatterson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Newton</last_name>
          <affiliation>Shopify</affiliation>
          <bio>undefined</bio>
          <person_id>kevinnewton</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>John</first_name>
          <last_name>Hawthorn</last_name>
          <affiliation>GitHub</affiliation>
          <bio>undefined</bio>
          <person_id>johnhawthorn</person_id>
        </person>
      </persons>
      <tracks>
        <track>VMIL 2021</track>
      </tracks>
      <badges>
        <badge>WIP Paper</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c8876e97-ec5e-4ec1-a1b2-5cedeb5aa8d5</subevent_id>
    <title>SPLASH REBASE: Language</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>b8d7e8d6-7d7d-4eba-a86c-39ee8302ad4e</slot_id>
      <title>Session: SPLASH REBASE - Language</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_time>12:20</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9f0b3074-7bc3-495a-8144-01e954fe34dc</slot_id>
      <event_id>7e8c53e1-4f19-4ca6-986c-a600d986d130</event_id>
      <title>A Retrospective on the Design of the Swift Programming Language</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>12:20</end_time>
      <description>How swiftly did Swift become Swift? What were the main roadblocks and challenges? Where is the language going next? These and many other Swift-related questions will be discussed by the speakers. Audience interaction is welcome.</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Dave</first_name>
          <last_name>Abrahams</last_name>
          <affiliation>Adobe</affiliation>
          <bio>Dave Abrahams is a specialist in programming language and library design and a recognized leader in the Swift and C++ programming language communities. He is a principal designer of the Swift programming language, a founding member of Boost.org, a former longstanding member of the ISO C++ standardization committee, and co-author of a book in Bjarne Stroustrup’s “C++ In Depth” series. Dave is a natural collaborator known for his insights into hard problems and is an in-demand speaker at conferences all over the world. His mission is to fix software development. 
Most recently (since 2013), Dave was at Apple developing the Swift language and standard library, and then the SwiftUI declarative UI framework. He remained an active member of the Swift core team, guiding the language’s evolution, throughout. 
Dave’s range of experience in industry includes application software development, framework design, embedded systems, and natural language processing. He is the author of eight Boost libraries and has made contributions to numerous others. 
Dave’s first major accomplishment in the C++ community was to create and promote an understanding of exception-safety that is still the standard today. Known as the “Abrahams Guarantees.” this framework is now part of the standard library. In 2001 he founded Boost Consulting (now Boostpro Computing) to realize the promise of advanced, open-source C++ libraries.</bio>
          <homepage_url>https://daveabrahams.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/daveabrahams/86bb1515-07f1-4cbd-b812-f4b994a0862d/small.jpg</picture_url>
          <person_id>daveabrahams</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roman</first_name>
          <last_name>Elizarov</last_name>
          <affiliation>JetBrains</affiliation>
          <bio>undefined</bio>
          <person_id>romanelizarov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Denys</first_name>
          <last_name>Shabalin</last_name>
          <affiliation>Google</affiliation>
          <bio>Hacking on compilers and frameworks for machine learning at Google Research.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/denysshabalin/9ee8b323-f1ae-49d0-8233-a0aa1cc91899/small.jpg</picture_url>
          <person_id>denysshabalin</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c866736c-6484-460a-b14f-b378406df647</subevent_id>
    <title>SPLASH Opening: SPLASH Start</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-opening</url>
    <url_link_display>Opening</url_link_display>
    <tracks>
      <track>Opening</track>
    </tracks>
    <timeslot>
      <slot_id>405de603-92af-40a9-ab91-b23afbc40a1d</slot_id>
      <title>Session: SPLASH Opening - SPLASH Start</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>09:00</start_time>
      <end_time>09:01</end_time>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5fa6d4ff-6576-40ce-b7f6-a79943f74074</slot_id>
      <event_id>c8da7aa6-2f36-4498-8dcc-2c6f2da523e4</event_id>
      <title>SPLASH Conference at Chicago Starts Now</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>09:01</end_time>
      <description>undefined</description>
      <tracks>
        <track>Opening</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>67093e9b-3fc5-477c-bbc6-f5b1a4db86c1</subevent_id>
    <title>SPLASH REBASE: Interfaces</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>508e4b76-3850-4f7a-898a-29fcc0bc14c9</slot_id>
      <title>Session: SPLASH REBASE - Interfaces</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_time>15:20</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18ca22d1-254b-48fb-9613-f036ce98bb13</slot_id>
      <event_id>eb759645-6767-4c37-a52a-91bf27701cc1</event_id>
      <title>A Brief History of the API, Revisited</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>15:20</end_time>
      <description>How do we design interfaces? What is a good design? How can we tell that something is wrong? Josh Bloch has many years of hands on experience working on the Java Collection framework as well as the math library. He will engage us into a discussion of keys principles. Josh has also been active on the legal front, battling for the right to reimplement interfaces. He will update us on the latest developments.</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Josh</first_name>
          <last_name>Bloch</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>joshbloch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Doug</first_name>
          <last_name>Lea</last_name>
          <affiliation>State University of New York (SUNY) Oswego</affiliation>
          <bio>Doug Lea is a professor of Computer Science at the State University of New York at Oswego. He is an author of books, articles, reports, and standardization efforts on object oriented software development including those on specification, design and implementation techniques, distributed, concurrent, and parallel object systems, and software reusability; and has served as chair, organizer, or program committee member for many conferences and workshops in these areas. He is the primary author of several widely used software packages and components.</bio>
          <homepage_url>http://gee.cs.oswego.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/douglea/3419ce80-c31d-4958-b043-53f6d89a34cd/small.jpg</picture_url>
          <person_id>douglea</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>83b7d59e-33e6-4f07-b5d3-107096142cd9</subevent_id>
    <title>SPLASH Opening: Opening Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-opening</url>
    <url_link_display>Opening</url_link_display>
    <tracks>
      <track>Opening</track>
    </tracks>
    <timeslot>
      <slot_id>850e0546-6af0-47ec-93cc-33daa32adab7</slot_id>
      <title>Session: SPLASH Opening - Opening Session</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>09:00</start_time>
      <end_time>09:20</end_time>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>182570e0-b949-428d-bc41-96ed52659cee</slot_id>
      <event_id>479c9271-75b9-4332-a52e-2443916ed203</event_id>
      <title>Opening Session</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>09:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>General Chair</role>
          <sort_key>1</sort_key>
          <first_name>Hridesh</first_name>
          <last_name>Rajan</last_name>
          <affiliation>Iowa State University</affiliation>
          <bio>Hridesh Rajan is a Professor and Chair of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the department chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a AAAS fellow, a distinguished member of the ACM, and a member of IEEE. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
          <homepage_url>https://hridesh.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
          <person_id>hrideshrajan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Opening</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bbde985c-2e8c-4ed3-ba0f-a23f6ed16f48</subevent_id>
    <title>SPLASH Opening: Reception</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-opening</url>
    <url_link_display>Opening</url_link_display>
    <tracks>
      <track>Opening</track>
    </tracks>
    <timeslot>
      <slot_id>a727e3b6-5a48-4cb4-aa6d-787c25eedcdb</slot_id>
      <title>Session: SPLASH Opening - Reception</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>17:00</start_time>
      <end_time>18:50</end_time>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cb10b757-ac1f-4ffb-9e21-e7938e6bc8e5</slot_id>
      <event_id>8e548b3d-7e89-4c53-ab08-185cc101f9b0</event_id>
      <title>Reception</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>240f08f4-1925-46df-8381-e026e704e67b</subevent_id>
    <title>SPLASH Opening: Opening Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-opening</url>
    <url_link_display>Opening</url_link_display>
    <tracks>
      <track>Opening</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>a7d2f4f2-2ebf-40ff-954e-f87653b07e4c</slot_id>
      <title>Session: SPLASH Opening - Opening Session</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_time>17:20</end_time>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>60378c0a-3c6e-4afe-90a9-45c800cde12f</slot_id>
      <event_id>479c9271-75b9-4332-a52e-2443916ed203</event_id>
      <title>Opening Session</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>17:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>General Chair</role>
          <sort_key>1</sort_key>
          <first_name>Hridesh</first_name>
          <last_name>Rajan</last_name>
          <affiliation>Iowa State University</affiliation>
          <bio>Hridesh Rajan is a Professor and Chair of Computer Science at Iowa State University, where he has been since 2005. Professor Rajan earned his MS and Ph.D. from the University of Virginia in 2004 and 2005 respectively. Professor Rajan’s recent research and educational activities are aimed at decreasing the barrier to entry to data-driven sciences to broaden participation. His work on the Boa project is aimed at the invention and refinement of programming languages and cyberinfrastructures that democratize data-driven science &amp;amp; engineering, including software engineering. His work on the Midwest Big Data Summer School is experimenting with broadly accessible data science curricula. Professor Rajan was the founding general chair of the Midwest Big Data Summer School. Professor Rajan’s research interests also include programming language design and implementation, and software engineering. He leads two research projects: Panini, whose goals are to enable modular reasoning about concurrent programs, and Boa that was established in Summer 2012 as an end-to-end infrastructure for analyzing large-scale software repositories and other open data sets. Professor Rajan is the director of the Laboratory for Software Design at Iowa State University, director of graduate admissions and recruitment for the Department of Computer Science. He serves as the department chair of the Department of Computer Science and served as the Professor-In-Charge of the Data Science education programs at Iowa State University from 2017-2019, and chair of the information technology committee for the university from 2015-2019. Professor Rajan served on the steering committee of the Midwest Big Data Hub, a consortium of universities in the Midwest region of the United States focused on promoting data science activities. Professor Rajan is a recipient of the National Science Foundation CAREER award in 2009, LAS Award for Early Achievement in Research in 2010, a Big-12 Fellowship in 2012. He is a 2018-19 Fulbright U.S. Scholar, a AAAS fellow, a distinguished member of the ACM, and a member of IEEE. He is also the inaugural holder of the Kingland Professorship in the Department of Computer Science.</bio>
          <homepage_url>https://hridesh.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hrideshrajan/f57a0842-20af-4fd4-b79f-5d673c2c485c/small.jpg</picture_url>
          <person_id>hrideshrajan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Opening</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>499a3e3f-bb92-4424-9374-00918d82ed50</subevent_id>
    <title>SPLASH REBASE: Education</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>7a4ad424-0da8-4110-9618-9b4b27e4b1ce</slot_id>
      <title>Session: SPLASH REBASE - Education</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/19</date>
      <start_time>07:30</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7312549f-6a50-464e-97b2-51d73c6f7414</slot_id>
      <event_id>2057383b-829f-41f8-b380-f81fc5c68a3a</event_id>
      <title>Hedy: Creating a gradual programming language</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/19</date>
      <start_time>07:30</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>09:00</end_time>
      <description>Hedy is a gradual programming language to make learning programming easier. The core idea of Hedy is that it uses different language levels. In level 1, there is hardly any syntax at all, for example printing is done with: 
print hello F# eXchange 
In every level, new syntax and concepts are added, until kids are doing a subset of Python in level 22 with conditions, loops, variables and lists. The leveled approach means that learners do not have to learn all syntax rules at once. Hedy is aimed at children that want to get started with textual programming languages, but for whom starting with Python might still be too complex. 
Hedy is open source, runs in the browser, is free to use, and available in fifteen different languages (Including English, Spanish, Chinese and Hindi). Hedy was launched in early 2020 and since then almost 1.5 million Hedy programs have been created by children worldwide. Try Hedy at www.hedycode.com. 
In this talk, Felienne will dive into the pedagogy behind Hedy, but also expand on the technical aspects of Hedy. For example, a set of increasingly complex grammars, rather than one grammar, poses new challenges for language design.</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Felienne</first_name>
          <last_name>Hermans</last_name>
          <affiliation>Leiden University</affiliation>
          <bio>Felienne is associate professor at the Leiden Institute of Advanced Computer Science at Leiden University, where she heads the Programming Education Research Lab (PERL). Felienne’s work focuses on the question how to best teach programming to kids and students, investigating misconceptions, didactic strategies and programming environments. Felienne is a co-editor of the ACM journal Transactions on Computing Education, and a host at the IEEE podcast SE Radio, one of the most popular software engineering podcasts on the web. She writes a monthly column for Dutch IT magazine AG Connect and she ran the Joy of Coding conference for 6 years. When she is not coding, blogging or teaching, she is probably knitting, running or playing a (board)game. 
Felienne blogs at felienne.com</bio>
          <homepage_url>http://www.felienne.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/feliennehermans/f1233e68-176f-4ecc-a70f-932b9370f82e/small.jpg</picture_url>
          <person_id>feliennehermans</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Federico</first_name>
          <last_name>Tomassetti</last_name>
          <affiliation>Independent</affiliation>
          <bio>After I got a PhD on MDD and DSL I started working with a few companies (including TripAdvisor and Groupon) in four countries (Italy, Germany, Ireland and France). 
I am currently a consultant on Language Engineering. I help companies developing languages and supporting tools.</bio>
          <homepage_url>http://tomassetti.me</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/federicotomassetti/79407fc4-c64e-4def-8076-bad8266ca001/small.jpg</picture_url>
          <person_id>federicotomassetti</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e6c54e36-e4c2-4ba1-9b90-18e4ca14c48d</subevent_id>
    <title>SPLASH Opening: Reception</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-opening</url>
    <url_link_display>Opening</url_link_display>
    <tracks>
      <track>Opening</track>
    </tracks>
    <timeslot>
      <slot_id>4bbd1c13-4125-432d-b849-ef1c2da28688</slot_id>
      <title>Session: SPLASH Opening - Reception</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_time>18:50</end_time>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d021ea9a-8441-4943-9610-8532c2557b70</slot_id>
      <event_id>8e548b3d-7e89-4c53-ab08-185cc101f9b0</event_id>
      <title>Reception</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>Opening</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8370a2bf-a320-4deb-97d1-24f6dc181b10</subevent_id>
    <title>SPLASH REBASE: Hardware</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>9e0c45fd-8763-40cf-923b-856dbc5c15be</slot_id>
      <title>Session: SPLASH REBASE - Hardware</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_time>17:10</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d173ac63-84e3-4989-856a-086ea9031f02</slot_id>
      <event_id>e0967510-d921-4712-9acf-d5a45ffc357b</event_id>
      <title>Fragmentation of Machine Architecture</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>17:10</end_time>
      <description>Not too many years ago, the machine architecture supported by consumer devices looked to be converging on a largely uniform model, the Intel x86 instruction set &amp;amp; OpenCL/GL GPU computation. But now, hardware architecture is increasingly fragmented and complex, while at the same time, the marketplace is demanding higher performance and interactivity across a more extensive range of devices. This talk looks at how we got here, the challenges of supporting these architectures from software applications, and an opening to discuss how software languages will play a role in making sense of the chaos.</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sean</first_name>
          <last_name>Parent</last_name>
          <affiliation>Adobe</affiliation>
          <bio>Sean Parent is a principal scientist and software architect for Adobe’s mobile digital imaging group. Sean has been at Adobe since 1993 when he joined as a senior engineer working on Photoshop and later managed Adobe’s Software Technology Lab. In 2009 Sean spent a year at Google working on Chrome OS before returning to Adobe. From 1988 through 1993 Sean worked at Apple, where he was part of the system software team that developed the technologies allowing Apple’s successful transition to PowerPC.</bio>
          <homepage_url>https://sean-parent.stlab.cc</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/seanparent1/91ee2b3c-0f05-4ae9-aaa3-cf2423877bd1/small.jpg</picture_url>
          <person_id>seanparent1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mario</first_name>
          <last_name>Wolczko</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://labs.oracle.com/people/mario</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mariowolczko/cbf01e95-3325-467b-b760-d8928c4c5e6b/small.jpg</picture_url>
          <person_id>mariowolczko</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dde32fa9-5881-4202-aff2-286c6a369191</subevent_id>
    <title>SPLASH REBASE: Dynamism</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-rebase</url>
    <url_link_display>REBASE</url_link_display>
    <tracks>
      <track>REBASE</track>
    </tracks>
    <timeslot>
      <slot_id>81c2ef14-806f-42d7-8159-40c8f39f19a9</slot_id>
      <title>Session: SPLASH REBASE - Dynamism</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>REBASE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>edc8a968-e5c1-4365-b48e-11abe1cf2d16</slot_id>
      <event_id>7fb6dd26-ec25-4492-aad4-83348e135cf8</event_id>
      <title>The F# view on the Static / Dynamic divide</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>10:30</end_time>
      <description>Programming languages come with increasingly powerful type-level programming features and meta-programming facilities – both of which shift part of the computation from dynamic (our traditional notion of “run-time”) to static (what often think of as “compile-time”). This boundary is being blurred as compilation increasingly happens at run-time and computations are staged. This means we have to start thinking about debuggers and profilers for our type systems. But we must also ask whether that additional expressive power is actually a net positive. Where is the point of diminishing returns?</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Don</first_name>
          <last_name>Syme</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>I am a Principal Researcher at Microsoft Research, Cambridge. I work with researchers, Microsoft and open source communities to make better programming technologies, and, through that, make people more productive and happier. My main responsibility is the design and implementation of the F# programming language. I’ve also worked on the design of virtual machines, the C# language (being co-responsible for C# and .NET generics, and one of many contributors to C# asynchronous programming) and, indirectly, Visual Basic and other .NET languages.</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/dsyme/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/donsyme/fa86de30-3931-4f30-95b6-779e84998496/small.jpg</picture_url>
          <person_id>donsyme</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nicholas</first_name>
          <last_name>Matsakis</last_name>
          <affiliation>Amazon, USA</affiliation>
          <bio>Nicholas Matsakis is at Amazon, before he was a senior researcher at Mozilla research and a member of the Rust core team. He has been working on Rust for four years and did much of the initial work on its type system and other core features. He has also done work in several just-in-time compilers as well as building high-performance networking systems. He did his undergraduate study at MIT, graduating in 2001, and later obtained a PhD in 2011, working with Thomas Gross at ETH Zurich.</bio>
          <homepage_url>http://smallcultfollowing.com/babysteps/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nicholasmatsakis/e5f35064-f24e-4001-8939-5cd1f78fd538/small.jpg</picture_url>
          <person_id>nicholasmatsakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>REBASE</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b5a0969a-2d8b-406f-b972-ae573266e4c0</subevent_id>
    <title>SPLASH Ask Me Anything (AMA): AMA Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-ask-me-anything--ama-</url>
    <url_link_display>Ask Me Anything (AMA)</url_link_display>
    <tracks>
      <track>Ask Me Anything (AMA)</track>
    </tracks>
    <timeslot>
      <slot_id>b0b26135-fc0d-4243-921e-e6c74e1e390c</slot_id>
      <title>Session: SPLASH Ask Me Anything (AMA) - AMA Session</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>18:20</start_time>
      <end_time>18:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Alan</first_name>
          <last_name>Jeffrey</last_name>
          <affiliation>Alcatel-Lucent Bell Labs</affiliation>
          <bio>undefined</bio>
          <person_id>alanjeffrey</person_id>
        </person>
      </persons>
      <tracks>
        <track>Ask Me Anything (AMA)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>db0c516c-2586-43e1-be4d-958a3b92057a</slot_id>
      <event_id>754ed478-9409-48b7-a054-dd3a25f7d775</event_id>
      <title>Invited Speaker</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Ashley</first_name>
          <last_name>Williams</last_name>
          <affiliation>Cloudflare</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/ashleywilliams/9c395e3b-63ec-4080-a803-8eb84512cfc5/small.jpg</picture_url>
          <person_id>ashleywilliams</person_id>
        </person>
      </persons>
      <tracks>
        <track>Ask Me Anything (AMA)</track>
      </tracks>
      <badges>
        <badge>AMA</badge>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8323489c-c362-4d9c-857e-ec2114ebe1e9</subevent_id>
    <title>SPLASH Ask Me Anything (AMA): AMA Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-ask-me-anything--ama-</url>
    <url_link_display>Ask Me Anything (AMA)</url_link_display>
    <tracks>
      <track>Ask Me Anything (AMA)</track>
    </tracks>
    <timeslot>
      <slot_id>2af1e92d-3b01-4928-9b0f-2f3feba72259</slot_id>
      <title>Session: SPLASH Ask Me Anything (AMA) - AMA Session</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>10:20</start_time>
      <end_time>10:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Tatlock</last_name>
          <affiliation>University of Washington, Seattle</affiliation>
          <bio>Associate Professor at the University of Washington</bio>
          <homepage_url>https://ztatlock.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zacharytatlock/87af1196-2d8d-4bd5-a692-018d3939a00f/small.jpg</picture_url>
          <person_id>zacharytatlock</person_id>
        </person>
      </persons>
      <tracks>
        <track>Ask Me Anything (AMA)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>27808715-6d84-40f4-9eea-f31d4428456d</slot_id>
      <event_id>87f94e4f-9943-4c73-a167-0074bb6911d1</event_id>
      <title>Invited Speaker</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Leslie</first_name>
          <last_name>Lamport</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/leslielamport/08ebb0db-8053-43f1-88e2-fee58cb6f3b6/small.jpg</picture_url>
          <person_id>leslielamport</person_id>
        </person>
      </persons>
      <tracks>
        <track>Ask Me Anything (AMA)</track>
      </tracks>
      <badges>
        <badge>AMA</badge>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>81a3a7a3-7835-4b4a-b2ce-b40daab3f5c8</subevent_id>
    <title>SPLASH Onward! Papers: Onward! Keynote Talk</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>9d1c2f7a-6fa3-4054-9d0a-b88976d14e9f</slot_id>
      <title>Session: SPLASH Onward! Papers - Onward! Keynote Talk</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>17:20</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>c17481a0-322c-4322-92b8-902d89d2d1f6</slot_id>
      <event_id>35abc255-2ef4-4837-af5f-9c0784a6fcca</event_id>
      <title>Designing Safe Programmed Molecular Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>17:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>18:20</end_time>
      <description>Molecular programming uses the computational power of DNA and other biomolecules to create nanoscale systems. Many of these will be safety-critical, such as bio-compatible diagnostic sensors and targeted drug-delivery devices. Design of these programmed molecular systems needs to assure safe outcomes from very many, very small, fault-prone components operating simultaneously in a dynamic environment. Some of this can be achieved by adapting existing software engineering methods, but molecular programming also presents new challenges that will require new methods. This talk discusses an example of such a challenge, describes how we design safety-critical building blocks, and presents work in progress to ascertain how robust a molecular program is. Similar approaches also will help design safe non-molecular systems with highly distributed, autonomous, fault-prone components operating in dynamic environments.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Robyn</first_name>
          <last_name>Lutz</last_name>
          <affiliation>Iowa State University</affiliation>
          <bio>Robyn Lutz is a professor of computer science at Iowa State University. She was also on the technical staff of Jet Propulsion Laboratory, California Institute of Technology, from 1983 to 2012, most recently in the Software System Engineering group. Her research interests include safety-critical software systems, product lines, and the specification and verification of molecular programmed nanosystems. She is an ACM Distinguished Scientist. She was program chair of the International Requirements Engineering Conference in 2014 and general chair in 2006. She has served two terms as an associate editor of IEEE Transactions on Software Engineering and on the editorial boards of the journals Software: Testing, Verification and Reliability, Software and System Modeling, and Requirements Engineering.</bio>
          <homepage_url>https://robynlutz.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/robynlutz/1043c71b-da1c-417a-83ec-34347a6c10b2/small.jpg</picture_url>
          <person_id>robynlutz</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6198204f-b651-449e-a0e0-f330d9222b78</subevent_id>
    <title>SPLASH Onward! Papers: Onward! Paper Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>e35825fd-5469-4326-afc4-3b46b247674b</slot_id>
      <title>Session: SPLASH Onward! Papers - Onward! Paper Session 2</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Hidehiko</first_name>
          <last_name>Masuhara</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
          <person_id>hidehikomasuhara</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>41623aff-ba69-431d-ad86-b878e759bbc8</slot_id>
      <event_id>2013a3de-a0a1-4586-91cf-a5c3d4b998b6</event_id>
      <submission_id>11</submission_id>
      <title>Kotlin Coroutines: Design and Implementation</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:05</end_time>
      <description>Asynchronous programming is having its “renaissance” moment in recent years. Created in the 1980s, it was in use for quite some time, but with the advent of multi-core processors, it has been sidestepped by multi-threaded programming, which was (for a long time) the de facto standard of performing concurrent computations. However, since the 2000s, more and more programming languages have began to include the support for asynchronous programming, some built around asynchronicity from the start, others including it later in their evolution. 
In this paper, we explore the design and implementation of asynchronous programming in Kotlin, a multiplatform programming language from JetBrains, which uses coroutines for asynchronicity. Kotlin provides a compact built-in API for coroutine support, thus giving a lot of implementation freedom to the developer; this flexibility allows to transparently support different flavours of asynchronous programming within the same language. 
We overview existing approaches to asynchronous programming, zoom in and talk about coroutines in detail, and describe how they are used in Kotlin as the basis for asynchronous computations. Along the way, we show the flexibility of Kotlin coroutines, highlight several existing problems with asynchronicity, how they are fixed or worked-around in Kotlin, and also mention future directions asynchronous programming might explore.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Roman</first_name>
          <last_name>Elizarov</last_name>
          <affiliation>JetBrains</affiliation>
          <bio>undefined</bio>
          <person_id>romanelizarov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Belyaev</last_name>
          <affiliation>Saint Petersburg Polytechnic University / JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mikhail-belyaev.me</homepage_url>
          <person_id>mikhailbelyaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marat</first_name>
          <last_name>Akhin</last_name>
          <affiliation>Saint Petersburg Polytechnic University / JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://research.jetbrains.org/researchers/marat.akhin</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/maratakhin/611a55a5-2d2b-4633-9bf2-e5fd1952df56/small.jpg</picture_url>
          <person_id>maratakhin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ilmir</first_name>
          <last_name>Usmanov</last_name>
          <affiliation>JetBrains GmbH</affiliation>
          <bio>undefined</bio>
          <person_id>ilmirusmanov</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>6635057c-b862-4512-a97c-a413d6609d15</slot_id>
      <event_id>f77a59ba-575f-4997-a122-2336da8c6a72</event_id>
      <submission_id>10</submission_id>
      <title>SkyQuery: An Aerial Drone Video Sensing Platform</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>22:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:50</end_time>
      <description>Video-based sensing from aerial drones, especially small multirotor drones, can provide rich data for numerous applications, including traffic analysis (computing traffic flow volumes), precision agriculture (periodically evaluating plant health), and wildlife population management (estimating population sizes). However, aerial drone video sensing applications must handle a surprisingly wide range of tasks: video frames must be aligned so that we can equate coordinates of objects that appear in different frames, video data must be analyzed to extract application-specific insights, and drone routes must be computed that maximize the value of newly captured video. To address these challenges, we built SkyQuery, a novel aerial drone video sensing platform that provides an expressive, high-level programming language to make it straightforward for users to develop complex long-running sensing applications. SkyQuery combines novel methods for fast video frame alignment and detection of small objects in top-down aerial drone video to efficiently execute applications with diverse video analysis workflows and data distributions, thereby allowing application developers to focus on the unique qualities of their particular application rather than general video processing, data analysis, and drone routing tasks. We conduct diverse case studies using SkyQuery in parking monitoring, pedestrian activity mapping, and traffic hazard detection scenarios to demonstrate the generalizability and effectiveness of our system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Favyen</first_name>
          <last_name>Bastani</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>favyenbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Songtao</first_name>
          <last_name>He</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>songtaohe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziwen</first_name>
          <last_name>Jiang</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <person_id>ziwenjiang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Osbert</first_name>
          <last_name>Bastani</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://obastani.github.io</homepage_url>
          <person_id>osbertbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sam</first_name>
          <last_name>Madden</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sammadden</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>8800983f-6242-4a73-8664-cdeefe58fdac</slot_id>
      <event_id>9f76f988-b925-4637-b537-a889063cde4e</event_id>
      <submission_id>12</submission_id>
      <title>Motivating Complexity Understanding By Profiling Energy Usage</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>22:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:35</end_time>
      <description>Computer science and software engineering students are typically taught to evaluate resource use in terms of time complexity. Developers use asymptotic analysis to compare algorithms by calculating how time grows as a function of input size. However, two factors have limited traditional models of complexity as pedagogical tools. First, modern systems are so fast that even relatively inefficient algorithms can quickly process large sets of data. Second, analysis is not universally engaging; only some students care about efficiency for the sake of efficiency. Our project proposes using measurements of energy consumption and concomitant environmental impact to better engage students with efficiency and its implications. 
Since current students have a strong level of concern about environmental consequences, we believe energy usage data will be more concrete and motivating than differences in time and will deepen the appreciation students have for computational complexity by using real-world measurements and by tying energy usage to climate change. We also believe that these future software engineers will be better equipped to contribute to the field by understanding the broader impact of software choices and resource usage. This approach is meant to augment and give meaning to traditional measurements of computational complexity, rather than supplant them.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Gross</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>joshuagross</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jacoby</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>danieljacoby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Coogan</last_name>
          <affiliation>Blackburn College</affiliation>
          <bio>undefined</bio>
          <person_id>kevincoogan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Helman</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>aaronhelman</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>92dab1a1-fd48-479f-aa1a-6107c191d80e</slot_id>
      <event_id>6f69f227-02b2-4a33-941a-f0f43b49ac3e</event_id>
      <submission_id>3</submission_id>
      <title>Dala: A Simple Capability-Based Dynamic Language Design For Data Race-Freedom</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>22:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:20</end_time>
      <description>Dynamic languages like Erlang, Clojure, JavaScript, and E adopted data-race freedom by design. To enforce data-race freedom, these languages either deep copy objects during actor (thread) communication or proxy back to their owning thread. We present Dala, a simple programming model that ensures data-race freedom while supporting efficient inter-thread communication. Dala is a dynamic, concurrent, capability-based language that relies on three core capabilities: immutable values can be shared freely; isolated mutable objects can be transferred between threads but not aliased; local objects can be aliased within their owning thread but not dereferenced by other threads. Objects with capabilities can co-exist with unsafe objects, that are unchecked and may suffer data races, without compromising the safety of safe objects. We present a formal model of Dala, prove data race-freedom and state and prove a dynamic gradual guarantee. These theorems guarantee data race-freedom when using safe capabilities and show that the addition of capabilities is semantics preserving modulo permission and cast errors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kiko</first_name>
          <last_name>Fernandez-Reyes</last_name>
          <affiliation>Uppsala University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.plresearcher.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kikofernandezreyes/83984e89-a3fc-4e54-b33f-b8d23ae5fd29/small.jpg</picture_url>
          <person_id>kikofernandezreyes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isaac Oscar</first_name>
          <last_name>Gariano</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>isaacoscargariano</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Noble</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.mcs.vuw.ac.nz/~kjx/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesnoble/397692f7-f014-4032-a93d-bc522e882d80/small.jpg</picture_url>
          <person_id>jamesnoble</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Erin</first_name>
          <last_name>Greenwood-Thessman</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/eringreenwoodthessman/72ea1c0a-3bbf-45af-a431-2f5d613ec270/small.jpg</picture_url>
          <person_id>eringreenwoodthessman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Homer</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ecs.vuw.ac.nz/~mwh</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelhomer/16fc38e2-021c-4b11-8ea6-752cf9b2c0a9/small.jpg</picture_url>
          <person_id>michaelhomer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobiaswrigstad/51b1bbdb-d077-4128-ad29-ec14657617a7/small.jpg</picture_url>
          <person_id>tobiaswrigstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>d0c581f9-1041-4c1d-9383-4d0df9500531</slot_id>
      <event_id>87b029ac-56df-46a5-935f-34cf591a9e0d</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c62bf10d-9303-4b79-b283-76c4813d1db7</subevent_id>
    <title>SPLASH Onward! Papers: Onward! Paper Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>47d157ab-d32c-4830-b55d-5c53df6c417d</slot_id>
      <title>Session: SPLASH Onward! Papers - Onward! Paper Session 2</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Scholliers</last_name>
          <affiliation>Universiteit Gent, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~cfscholl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophescholliers/349aebe2-c428-4d19-8b70-9e1665dea5e6/small.jpg</picture_url>
          <person_id>christophescholliers</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2572180f-63b8-4234-ae0f-d0873ebc53ea</slot_id>
      <event_id>9f76f988-b925-4637-b537-a889063cde4e</event_id>
      <submission_id>12</submission_id>
      <title>Motivating Complexity Understanding By Profiling Energy Usage</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:35</end_time>
      <description>Computer science and software engineering students are typically taught to evaluate resource use in terms of time complexity. Developers use asymptotic analysis to compare algorithms by calculating how time grows as a function of input size. However, two factors have limited traditional models of complexity as pedagogical tools. First, modern systems are so fast that even relatively inefficient algorithms can quickly process large sets of data. Second, analysis is not universally engaging; only some students care about efficiency for the sake of efficiency. Our project proposes using measurements of energy consumption and concomitant environmental impact to better engage students with efficiency and its implications. 
Since current students have a strong level of concern about environmental consequences, we believe energy usage data will be more concrete and motivating than differences in time and will deepen the appreciation students have for computational complexity by using real-world measurements and by tying energy usage to climate change. We also believe that these future software engineers will be better equipped to contribute to the field by understanding the broader impact of software choices and resource usage. This approach is meant to augment and give meaning to traditional measurements of computational complexity, rather than supplant them.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Gross</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>joshuagross</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jacoby</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>danieljacoby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Coogan</last_name>
          <affiliation>Blackburn College</affiliation>
          <bio>undefined</bio>
          <person_id>kevincoogan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Helman</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>aaronhelman</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>28955cdf-2aba-4008-a7f9-353bf5129e5f</slot_id>
      <event_id>6f69f227-02b2-4a33-941a-f0f43b49ac3e</event_id>
      <submission_id>3</submission_id>
      <title>Dala: A Simple Capability-Based Dynamic Language Design For Data Race-Freedom</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:20</end_time>
      <description>Dynamic languages like Erlang, Clojure, JavaScript, and E adopted data-race freedom by design. To enforce data-race freedom, these languages either deep copy objects during actor (thread) communication or proxy back to their owning thread. We present Dala, a simple programming model that ensures data-race freedom while supporting efficient inter-thread communication. Dala is a dynamic, concurrent, capability-based language that relies on three core capabilities: immutable values can be shared freely; isolated mutable objects can be transferred between threads but not aliased; local objects can be aliased within their owning thread but not dereferenced by other threads. Objects with capabilities can co-exist with unsafe objects, that are unchecked and may suffer data races, without compromising the safety of safe objects. We present a formal model of Dala, prove data race-freedom and state and prove a dynamic gradual guarantee. These theorems guarantee data race-freedom when using safe capabilities and show that the addition of capabilities is semantics preserving modulo permission and cast errors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kiko</first_name>
          <last_name>Fernandez-Reyes</last_name>
          <affiliation>Uppsala University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.plresearcher.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kikofernandezreyes/83984e89-a3fc-4e54-b33f-b8d23ae5fd29/small.jpg</picture_url>
          <person_id>kikofernandezreyes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isaac Oscar</first_name>
          <last_name>Gariano</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>isaacoscargariano</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Noble</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.mcs.vuw.ac.nz/~kjx/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesnoble/397692f7-f014-4032-a93d-bc522e882d80/small.jpg</picture_url>
          <person_id>jamesnoble</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Erin</first_name>
          <last_name>Greenwood-Thessman</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/eringreenwoodthessman/72ea1c0a-3bbf-45af-a431-2f5d613ec270/small.jpg</picture_url>
          <person_id>eringreenwoodthessman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Homer</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ecs.vuw.ac.nz/~mwh</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelhomer/16fc38e2-021c-4b11-8ea6-752cf9b2c0a9/small.jpg</picture_url>
          <person_id>michaelhomer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobiaswrigstad/51b1bbdb-d077-4128-ad29-ec14657617a7/small.jpg</picture_url>
          <person_id>tobiaswrigstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>5fd333b6-5096-4078-8fb2-ae607eb993b7</slot_id>
      <event_id>2013a3de-a0a1-4586-91cf-a5c3d4b998b6</event_id>
      <submission_id>11</submission_id>
      <title>Kotlin Coroutines: Design and Implementation</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:05</end_time>
      <description>Asynchronous programming is having its “renaissance” moment in recent years. Created in the 1980s, it was in use for quite some time, but with the advent of multi-core processors, it has been sidestepped by multi-threaded programming, which was (for a long time) the de facto standard of performing concurrent computations. However, since the 2000s, more and more programming languages have began to include the support for asynchronous programming, some built around asynchronicity from the start, others including it later in their evolution. 
In this paper, we explore the design and implementation of asynchronous programming in Kotlin, a multiplatform programming language from JetBrains, which uses coroutines for asynchronicity. Kotlin provides a compact built-in API for coroutine support, thus giving a lot of implementation freedom to the developer; this flexibility allows to transparently support different flavours of asynchronous programming within the same language. 
We overview existing approaches to asynchronous programming, zoom in and talk about coroutines in detail, and describe how they are used in Kotlin as the basis for asynchronous computations. Along the way, we show the flexibility of Kotlin coroutines, highlight several existing problems with asynchronicity, how they are fixed or worked-around in Kotlin, and also mention future directions asynchronous programming might explore.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Roman</first_name>
          <last_name>Elizarov</last_name>
          <affiliation>JetBrains</affiliation>
          <bio>undefined</bio>
          <person_id>romanelizarov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Belyaev</last_name>
          <affiliation>Saint Petersburg Polytechnic University / JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mikhail-belyaev.me</homepage_url>
          <person_id>mikhailbelyaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marat</first_name>
          <last_name>Akhin</last_name>
          <affiliation>Saint Petersburg Polytechnic University / JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://research.jetbrains.org/researchers/marat.akhin</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/maratakhin/611a55a5-2d2b-4633-9bf2-e5fd1952df56/small.jpg</picture_url>
          <person_id>maratakhin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ilmir</first_name>
          <last_name>Usmanov</last_name>
          <affiliation>JetBrains GmbH</affiliation>
          <bio>undefined</bio>
          <person_id>ilmirusmanov</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>a4b0b1f4-66ff-4333-9c5b-7eadf89375ee</slot_id>
      <event_id>f77a59ba-575f-4997-a122-2336da8c6a72</event_id>
      <submission_id>10</submission_id>
      <title>SkyQuery: An Aerial Drone Video Sensing Platform</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:50</end_time>
      <description>Video-based sensing from aerial drones, especially small multirotor drones, can provide rich data for numerous applications, including traffic analysis (computing traffic flow volumes), precision agriculture (periodically evaluating plant health), and wildlife population management (estimating population sizes). However, aerial drone video sensing applications must handle a surprisingly wide range of tasks: video frames must be aligned so that we can equate coordinates of objects that appear in different frames, video data must be analyzed to extract application-specific insights, and drone routes must be computed that maximize the value of newly captured video. To address these challenges, we built SkyQuery, a novel aerial drone video sensing platform that provides an expressive, high-level programming language to make it straightforward for users to develop complex long-running sensing applications. SkyQuery combines novel methods for fast video frame alignment and detection of small objects in top-down aerial drone video to efficiently execute applications with diverse video analysis workflows and data distributions, thereby allowing application developers to focus on the unique qualities of their particular application rather than general video processing, data analysis, and drone routing tasks. We conduct diverse case studies using SkyQuery in parking monitoring, pedestrian activity mapping, and traffic hazard detection scenarios to demonstrate the generalizability and effectiveness of our system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Favyen</first_name>
          <last_name>Bastani</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>favyenbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Songtao</first_name>
          <last_name>He</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>songtaohe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziwen</first_name>
          <last_name>Jiang</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <person_id>ziwenjiang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Osbert</first_name>
          <last_name>Bastani</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://obastani.github.io</homepage_url>
          <person_id>osbertbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sam</first_name>
          <last_name>Madden</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sammadden</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>eab0b9f9-148f-42b5-a23b-dedaba6cd1ac</slot_id>
      <event_id>87b029ac-56df-46a5-935f-34cf591a9e0d</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b1063a8d-dd34-4434-aacb-910485a7ae8b</subevent_id>
    <title>SPLASH Ask Me Anything (AMA): AMA Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-ask-me-anything--ama-</url>
    <url_link_display>Ask Me Anything (AMA)</url_link_display>
    <tracks>
      <track>Ask Me Anything (AMA)</track>
    </tracks>
    <timeslot>
      <slot_id>e1d87eda-b003-43c6-bf12-078721fed8e7</slot_id>
      <title>Session: SPLASH Ask Me Anything (AMA) - AMA Session</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>18:20</start_time>
      <end_time>18:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Manu</first_name>
          <last_name>Sridharan</last_name>
          <affiliation>University of California at Riverside</affiliation>
          <bio>I’m an associate professor at the University of California, Riverside. Previously I worked at IBM Research, Samsung Research, and Uber. My research focuses on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
          <homepage_url>http://manu.sridharan.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
          <person_id>manusridharan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Ask Me Anything (AMA)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>87d0de59-e6dd-4a33-bede-e4392241a801</slot_id>
      <event_id>699cfeca-5240-418f-89b9-320ece98abb6</event_id>
      <title>Invited Speaker</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Abadi</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://users.soe.ucsc.edu/~abadi/home.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinabadi/082202e6-c10a-45ed-b843-746524c2192b/small.jpg</picture_url>
          <person_id>martinabadi</person_id>
        </person>
      </persons>
      <tracks>
        <track>Ask Me Anything (AMA)</track>
      </tracks>
      <badges>
        <badge>AMA</badge>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3fa158e6-3491-4d84-94c5-5157266e2bf4</subevent_id>
    <title>SPLASH Ask Me Anything (AMA): AMA Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/track/splash-2021-ask-me-anything--ama-</url>
    <url_link_display>Ask Me Anything (AMA)</url_link_display>
    <tracks>
      <track>Ask Me Anything (AMA)</track>
    </tracks>
    <timeslot>
      <slot_id>ae1da56d-e44e-4d98-a59b-6095a26a0490</slot_id>
      <title>Session: SPLASH Ask Me Anything (AMA) - AMA Session</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>18:20</start_time>
      <end_time>18:50</end_time>
      <tracks>
        <track>Ask Me Anything (AMA)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>43f18afb-3e10-4bde-8938-bbb0e06d6c1b</subevent_id>
    <title>SPLASH Onward! Papers: Onward! Keynote Talk</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>0b738fc3-4ba5-4b2a-972b-ff2fd83211c2</slot_id>
      <title>Session: SPLASH Onward! Papers - Onward! Keynote Talk</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>09:20</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca7aa168-7548-45e2-85a6-31818f0272a9</slot_id>
      <event_id>35abc255-2ef4-4837-af5f-9c0784a6fcca</event_id>
      <title>Designing Safe Programmed Molecular Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>09:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>10:20</end_time>
      <description>Molecular programming uses the computational power of DNA and other biomolecules to create nanoscale systems. Many of these will be safety-critical, such as bio-compatible diagnostic sensors and targeted drug-delivery devices. Design of these programmed molecular systems needs to assure safe outcomes from very many, very small, fault-prone components operating simultaneously in a dynamic environment. Some of this can be achieved by adapting existing software engineering methods, but molecular programming also presents new challenges that will require new methods. This talk discusses an example of such a challenge, describes how we design safety-critical building blocks, and presents work in progress to ascertain how robust a molecular program is. Similar approaches also will help design safe non-molecular systems with highly distributed, autonomous, fault-prone components operating in dynamic environments.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Robyn</first_name>
          <last_name>Lutz</last_name>
          <affiliation>Iowa State University</affiliation>
          <bio>Robyn Lutz is a professor of computer science at Iowa State University. She was also on the technical staff of Jet Propulsion Laboratory, California Institute of Technology, from 1983 to 2012, most recently in the Software System Engineering group. Her research interests include safety-critical software systems, product lines, and the specification and verification of molecular programmed nanosystems. She is an ACM Distinguished Scientist. She was program chair of the International Requirements Engineering Conference in 2014 and general chair in 2006. She has served two terms as an associate editor of IEEE Transactions on Software Engineering and on the editorial boards of the journals Software: Testing, Verification and Reliability, Software and System Modeling, and Requirements Engineering.</bio>
          <homepage_url>https://robynlutz.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/robynlutz/1043c71b-da1c-417a-83ec-34347a6c10b2/small.jpg</picture_url>
          <person_id>robynlutz</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>846f7dbf-98d8-4e29-8725-6886553924d4</subevent_id>
    <title>SPLASH Ask Me Anything (AMA): AMA Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-ask-me-anything--ama-</url>
    <url_link_display>Ask Me Anything (AMA)</url_link_display>
    <tracks>
      <track>Ask Me Anything (AMA)</track>
    </tracks>
    <timeslot>
      <slot_id>01d2efb8-f592-451e-8dbe-c0299960041e</slot_id>
      <title>Session: SPLASH Ask Me Anything (AMA) - AMA Session</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>10:20</start_time>
      <end_time>10:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Ask Me Anything (AMA)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6c01841b-8ffb-4558-a8d5-a1ff0a448c80</slot_id>
      <event_id>fd2be0c2-e193-42cb-8a49-ec51bdc23091</event_id>
      <title>Invited Speaker</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Rand</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>I am an Assistant Professor of Computer Science at the University of Chicago, part of the Programming Languages Research Group and the Chicago Quantum Exchange. 
My main interest is in applying techniques from programming languages and formal verification to the domain of quantum computation. Some of my major projects include the QWIRE quantum circuit language (with Jennifer Paykin) and the VOQC verified optimizing compiler (with Kesha Hietala). I’m currently interested in verified optimization, error-correction, type systems, and programming abstractions for quantum computing.</bio>
          <homepage_url>http://people.cs.uchicago.edu/~rand/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/robertrand/55e0e41c-245e-4474-9dcc-038bb78ec518/small.jpg</picture_url>
          <person_id>robertrand</person_id>
        </person>
      </persons>
      <tracks>
        <track>Ask Me Anything (AMA)</track>
      </tracks>
      <badges>
        <badge>AMA</badge>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ba608d75-0b21-414d-8b86-f71e37c6c1ad</subevent_id>
    <title>SPLASH Ask Me Anything (AMA): AMA Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/track/splash-2021-ask-me-anything--ama-</url>
    <url_link_display>Ask Me Anything (AMA)</url_link_display>
    <tracks>
      <track>Ask Me Anything (AMA)</track>
    </tracks>
    <timeslot>
      <slot_id>d35bb94d-9cc6-4318-b816-5710896a9108</slot_id>
      <title>Session: SPLASH Ask Me Anything (AMA) - AMA Session</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>10:20</start_time>
      <end_time>10:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Talia</first_name>
          <last_name>Ringer</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>I am an incoming assistant professor at University of Illinois at Urbana-Champaign. My main interest is in making program verification using interactive theorem provers more accessible through better proof engineering tools and practices, especially when it comes to maintaining proofs as programs change over time. My vision is a future of verification that is accessible to all programmers, not just to experts. I got my Ph.D. from University of Washington in June 2021, where I was an NSF GRFP fellow and a P.E.O fellow. Prior to graduate school, I earned my bachelor’s in mathematics and computer science from University of Maryland, then worked at Amazon as a software engineer for three years. I am the founder and chair of the SIGPLAN-M mentoring program, and a contributor to the Coq interactive theorem prover. 
Oh, and I am currently looking for students! Please apply!</bio>
          <homepage_url>https://dependenttyp.es</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/taliaringer/1a95a492-cf5a-4225-8efb-ac834a36fa16/small.jpg</picture_url>
          <person_id>taliaringer</person_id>
        </person>
      </persons>
      <tracks>
        <track>Ask Me Anything (AMA)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7dd52558-3846-4c6e-aeaa-4f9f98110c76</slot_id>
      <event_id>31cb0fe1-67a8-40ef-aeb2-ef74dd37643f</event_id>
      <title>Invited Speaker</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Heidy</first_name>
          <last_name>Khlaaf</last_name>
          <affiliation>University College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://heidyk.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/heidykhlaaf/c93abf82-b520-4638-8efe-bc1779ce2830/small.jpg</picture_url>
          <person_id>heidykhlaaf</person_id>
        </person>
      </persons>
      <tracks>
        <track>Ask Me Anything (AMA)</track>
      </tracks>
      <badges>
        <badge>AMA</badge>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b5572da5-61d6-4cc1-b847-27939f3ba335</subevent_id>
    <title>SPLASH Onward! Papers: Onward! Paper Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>285c3128-2a49-46f9-ab47-4c0f365a520d</slot_id>
      <title>Session: SPLASH Onward! Papers - Onward! Paper Session 1</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Shigeru</first_name>
          <last_name>Chiba</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csg.ci.i.u-tokyo.ac.jp/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shigeruchiba/b57db719-4160-4e39-9f41-ef3facc9e449/small.jpg</picture_url>
          <person_id>shigeruchiba</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>17dfc907-3ea3-48bc-941c-62f54493038a</slot_id>
      <event_id>ed615e6c-703b-40b2-adf5-3ba0be78f021</event_id>
      <submission_id>13</submission_id>
      <title>Towards Self-Adaptable Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>19:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:35</end_time>
      <description>Over recent years, self-adaptation has become a concern for many software systems that have to operate in complex and changing environments. At the core of self-adaptation, there is a feedback loop and associated trade-off reasoning to decide on the best course of action. However, existing software languages do not abstract the development and execution of such feedback loops for self-adaptable systems. Developers have to fall back to ad-hoc solutions to implement self-adaptable systems, often with wide-ranging design implications (e.g., explicit MAPE-K loop). Furthermore, existing software languages do not capitalize on monitored usage data of a language and its modeling environment. This hinders the continuous and automatic evolution of a software language based on feedback loops from the modeling environment and runtime software system. To address the aforementioned issues, this paper introduces the concept of Self-Adaptable Language (SAL) to abstract the feedback loops at both system and language levels. We propose L-MODA (Language, Models, and Data) as a conceptual reference framework that characterizes the possible feedback loops abstracted into a SAL. To demonstrate SALs, we present emerging results on the abstraction of the system feedback loop into the language semantics. We report on the concept of Self-Adaptable Virtual Machines as an example of semantic adaptation in a language interpreter.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gwendal</first_name>
          <last_name>Jouneaux</last_name>
          <affiliation>Univ. Rennes, Inria, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.gwendal-jouneaux.fr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gwendaljouneaux/da056fcb-c509-4aaa-89bd-7eca0c55ce85/small.jpg</picture_url>
          <person_id>gwendaljouneaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes 1, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gunter</first_name>
          <last_name>Mussbacher</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/guntermussbacher/f1452019-54bd-4b93-bbdb-eaece6059e96/small.jpg</picture_url>
          <person_id>guntermussbacher</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>1e770879-4010-4bc1-ab7b-c1fb83663bec</slot_id>
      <event_id>0f80dc7c-040a-4764-a133-5e55b5519014</event_id>
      <submission_id>4</submission_id>
      <title>Neural Surrogates of Programs</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>19:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:50</end_time>
      <description>\emph{Neural surrogates}, neural networks that are trained to compute the same function as a given program, provide alternative representations of classical programs with different properties that are useful for a variety of programming tasks. With neural compilation, programmers develop a neural surrogate that replicates the behavior of the original program to deploy to end-users in place of the original program. With neural adaptation, programmers first develop a neural surrogate of a program then continue to train the neural surrogate on a different task. With neural surrogate optimization, programmers develop a neural surrogate of the original program, optimize input parameters of that neural surrogate using gradient descent, then plug the optimized input parameters back into the original program. Compared to standard programming approaches on these tasks, neural surrogates are more efficient and result in higher accuracy. 
However, the approaches in the literature for developing neural surrogates are disparate. We identify the \emph{neural surrogate programming methodology} common to these approaches, consisting of the \emph{specification} of the problem, the \emph{design} of the neural network architecture, the \emph{training} of the neural network, and the \emph{deployment} considerations of the system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alex</first_name>
          <last_name>Renda</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.alexrenda.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexrenda1/ac1a0658-f452-4012-9317-7b9828864eb7/small.jpg</picture_url>
          <person_id>alexrenda1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yi</first_name>
          <last_name>Ding</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://y-ding.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yiding/17d36271-6bb2-44b2-8274-88f3a520bf9c/small.jpg</picture_url>
          <person_id>yiding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>250790ad-588f-43c2-8b92-89e077b35b35</slot_id>
      <event_id>645df455-35ac-42ea-bfb9-de49bf84c5d7</event_id>
      <title>Onward! Welcome</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:05</end_time>
      <description>undefined</description>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a328fca9-8159-4910-8706-f578270ceae8</slot_id>
      <event_id>a7c8cbe2-0dca-4ddf-95b1-1261b79c3555</event_id>
      <submission_id>7</submission_id>
      <title>Natural Language-Guided Programming</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>19:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:20</end_time>
      <description>In today’s software world with its cornucopia of reusable software libraries, when a programmer is faced with a programming task that they suspect can be completed through the use of a library, they often look for code examples using a search engine and then manually adapt found examples to their specific context of use. We put forward a vision based on a new breed of developer tools that have the potential to largely automate this process. The key idea is to adapt code autocompletion tools such that they take into account not only the developer’s already-written code but also the intent of the task the developer is trying to achieve next, formulated in plain natural language. We call this practice of enriching the code with natural language intent to facilitate its completion language-guided programming. 
To show that this idea is feasible we design, implement and benchmark a tool that solves this problem in the context of a specific domain (data science) and a specific programming language (Python). Central to the tool is the use of language models trained on a large corpus of documented code. Our initial experiments confirm the feasibility of the idea but also make it clear that we have only scratched the surface of what may become possible in the future. We end the paper with a comprehensive research agenda to stimulate additional research in the budding area of language-guided programming.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Geert</first_name>
          <last_name>Heyman</last_name>
          <affiliation>Nokia Bell Labs, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>geertheyman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rafael</first_name>
          <last_name>Huysegems</last_name>
          <affiliation>Nokia Bell Labs, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>rafaelhuysegems</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pascal</first_name>
          <last_name>Justen</last_name>
          <affiliation>Nokia Bell Labs, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>pascaljusten</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Van Cutsem</last_name>
          <affiliation>Nokia Bell Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://tvcutsem.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomvancutsem/d758e20f-3414-45b2-a82f-af50d8a3b6b3/small.jpg</picture_url>
          <person_id>tomvancutsem</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>d9a9ed11-0468-4aba-9dbf-7483f133a34d</slot_id>
      <event_id>87b029ac-56df-46a5-935f-34cf591a9e0d</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0970f2f0-5f73-4605-9719-1c5b213ffb73</subevent_id>
    <title>SPLASH Onward! Papers: Onward! Paper Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-Onward-papers</url>
    <url_link_display>Onward! Papers</url_link_display>
    <tracks>
      <track>Onward! Papers</track>
    </tracks>
    <timeslot>
      <slot_id>04e335fc-9ac6-41de-8977-68d171ff1527</slot_id>
      <title>Session: SPLASH Onward! Papers - Onward! Paper Session 1</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wolfgangdemeuter/cb721b79-a1aa-4583-8ba0-b1a96f896900/small.jpg</picture_url>
          <person_id>wolfgangdemeuter</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4467cf1e-dfa4-449b-8a4d-0a075270165e</slot_id>
      <event_id>645df455-35ac-42ea-bfb9-de49bf84c5d7</event_id>
      <title>Onward! Welcome</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:05</end_time>
      <description>undefined</description>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>7db97e33-c37b-46c5-8100-f85fbd0b537a</slot_id>
      <event_id>87b029ac-56df-46a5-935f-34cf591a9e0d</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>82acac3f-7e60-4c3a-bb00-8048352a2ce6</slot_id>
      <event_id>0f80dc7c-040a-4764-a133-5e55b5519014</event_id>
      <submission_id>4</submission_id>
      <title>Neural Surrogates of Programs</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:50</end_time>
      <description>\emph{Neural surrogates}, neural networks that are trained to compute the same function as a given program, provide alternative representations of classical programs with different properties that are useful for a variety of programming tasks. With neural compilation, programmers develop a neural surrogate that replicates the behavior of the original program to deploy to end-users in place of the original program. With neural adaptation, programmers first develop a neural surrogate of a program then continue to train the neural surrogate on a different task. With neural surrogate optimization, programmers develop a neural surrogate of the original program, optimize input parameters of that neural surrogate using gradient descent, then plug the optimized input parameters back into the original program. Compared to standard programming approaches on these tasks, neural surrogates are more efficient and result in higher accuracy. 
However, the approaches in the literature for developing neural surrogates are disparate. We identify the \emph{neural surrogate programming methodology} common to these approaches, consisting of the \emph{specification} of the problem, the \emph{design} of the neural network architecture, the \emph{training} of the neural network, and the \emph{deployment} considerations of the system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alex</first_name>
          <last_name>Renda</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.alexrenda.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexrenda1/ac1a0658-f452-4012-9317-7b9828864eb7/small.jpg</picture_url>
          <person_id>alexrenda1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yi</first_name>
          <last_name>Ding</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://y-ding.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yiding/17d36271-6bb2-44b2-8274-88f3a520bf9c/small.jpg</picture_url>
          <person_id>yiding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>c55312ee-da20-492a-a3a2-50aae4c9db8f</slot_id>
      <event_id>ed615e6c-703b-40b2-adf5-3ba0be78f021</event_id>
      <submission_id>13</submission_id>
      <title>Towards Self-Adaptable Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:35</end_time>
      <description>Over recent years, self-adaptation has become a concern for many software systems that have to operate in complex and changing environments. At the core of self-adaptation, there is a feedback loop and associated trade-off reasoning to decide on the best course of action. However, existing software languages do not abstract the development and execution of such feedback loops for self-adaptable systems. Developers have to fall back to ad-hoc solutions to implement self-adaptable systems, often with wide-ranging design implications (e.g., explicit MAPE-K loop). Furthermore, existing software languages do not capitalize on monitored usage data of a language and its modeling environment. This hinders the continuous and automatic evolution of a software language based on feedback loops from the modeling environment and runtime software system. To address the aforementioned issues, this paper introduces the concept of Self-Adaptable Language (SAL) to abstract the feedback loops at both system and language levels. We propose L-MODA (Language, Models, and Data) as a conceptual reference framework that characterizes the possible feedback loops abstracted into a SAL. To demonstrate SALs, we present emerging results on the abstraction of the system feedback loop into the language semantics. We report on the concept of Self-Adaptable Virtual Machines as an example of semantic adaptation in a language interpreter.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gwendal</first_name>
          <last_name>Jouneaux</last_name>
          <affiliation>Univ. Rennes, Inria, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.gwendal-jouneaux.fr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gwendaljouneaux/da056fcb-c509-4aaa-89bd-7eca0c55ce85/small.jpg</picture_url>
          <person_id>gwendaljouneaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes 1, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gunter</first_name>
          <last_name>Mussbacher</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/guntermussbacher/f1452019-54bd-4b93-bbdb-eaece6059e96/small.jpg</picture_url>
          <person_id>guntermussbacher</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>f390fc4b-72a9-4b8c-a731-5900b1cc0c94</slot_id>
      <event_id>a7c8cbe2-0dca-4ddf-95b1-1261b79c3555</event_id>
      <submission_id>7</submission_id>
      <title>Natural Language-Guided Programming</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:20</end_time>
      <description>In today’s software world with its cornucopia of reusable software libraries, when a programmer is faced with a programming task that they suspect can be completed through the use of a library, they often look for code examples using a search engine and then manually adapt found examples to their specific context of use. We put forward a vision based on a new breed of developer tools that have the potential to largely automate this process. The key idea is to adapt code autocompletion tools such that they take into account not only the developer’s already-written code but also the intent of the task the developer is trying to achieve next, formulated in plain natural language. We call this practice of enriching the code with natural language intent to facilitate its completion language-guided programming. 
To show that this idea is feasible we design, implement and benchmark a tool that solves this problem in the context of a specific domain (data science) and a specific programming language (Python). Central to the tool is the use of language models trained on a large corpus of documented code. Our initial experiments confirm the feasibility of the idea but also make it clear that we have only scratched the surface of what may become possible in the future. We end the paper with a comprehensive research agenda to stimulate additional research in the budding area of language-guided programming.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Geert</first_name>
          <last_name>Heyman</last_name>
          <affiliation>Nokia Bell Labs, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>geertheyman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rafael</first_name>
          <last_name>Huysegems</last_name>
          <affiliation>Nokia Bell Labs, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>rafaelhuysegems</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pascal</first_name>
          <last_name>Justen</last_name>
          <affiliation>Nokia Bell Labs, Belgium</affiliation>
          <bio>undefined</bio>
          <person_id>pascaljusten</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Van Cutsem</last_name>
          <affiliation>Nokia Bell Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://tvcutsem.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomvancutsem/d758e20f-3414-45b2-a82f-af50d8a3b6b3/small.jpg</picture_url>
          <person_id>tomvancutsem</person_id>
        </person>
      </persons>
      <tracks>
        <track>Onward! Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3ffdb289-9d84-467a-b0dc-cebea260c2ab</subevent_id>
    <title>SPLASH Posters: Posters Virtual Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>e1fd89f5-7045-4919-8ccf-cd1500633ce5</slot_id>
      <title>Session: SPLASH Posters - Posters Virtual Session</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>18:20</start_time>
      <end_time>18:50</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>00db0e75-130d-4771-bbcc-0122babcd496</slot_id>
      <event_id>0c6be8ac-f91e-4d3e-beb0-09c6868620e8</event_id>
      <title>SkyQuery: An Aerial Drone Video Sensing Platform</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Favyen</first_name>
          <last_name>Bastani</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>favyenbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Songtao</first_name>
          <last_name>He</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>songtaohe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziwen</first_name>
          <last_name>Jiang</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <person_id>ziwenjiang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Osbert</first_name>
          <last_name>Bastani</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://obastani.github.io</homepage_url>
          <person_id>osbertbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sam</first_name>
          <last_name>Madden</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sammadden</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Onward! Papers</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>57c10d6c-ce6d-41bc-b2a1-bc4395a06cba</slot_id>
      <event_id>665c7068-1d16-4e89-86ba-02fad49e4102</event_id>
      <title>The Semantics of Shared Memory in Intel CPU/FPGA Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dan</first_name>
          <last_name>Iorga</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~di13/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/daniorga/dac1a236-b8e7-462e-a2c3-2713314bf843/small.jpg</picture_url>
          <person_id>daniorga</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alastair F.</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I’m a PhD student at Imperial College London supervised by Alastair Donaldson. I study testing and modeling of many-core systems, with an emphasis on fine-grained communication idioms.</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~trs15/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tylersorensen/a5910621-6b59-4729-be27-e5dfae22a495/small.jpg</picture_url>
          <person_id>tylersorensen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>96b840ae-9ed7-43d7-9af5-59a5906a9410</slot_id>
      <event_id>f5c2ceaa-c4db-4342-b5f0-3ac6be7dba06</event_id>
      <title>Dala: A Simple Capability-Based Dynamic Language Design For Data Race-Freedom</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kiko</first_name>
          <last_name>Fernandez-Reyes</last_name>
          <affiliation>Uppsala University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.plresearcher.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kikofernandezreyes/83984e89-a3fc-4e54-b33f-b8d23ae5fd29/small.jpg</picture_url>
          <person_id>kikofernandezreyes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isaac Oscar</first_name>
          <last_name>Gariano</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <person_id>isaacoscargariano1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Noble</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.mcs.vuw.ac.nz/~kjx/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesnoble/397692f7-f014-4032-a93d-bc522e882d80/small.jpg</picture_url>
          <person_id>jamesnoble</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Erin</first_name>
          <last_name>Greenwood-Thessman</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/eringreenwoodthessman/72ea1c0a-3bbf-45af-a431-2f5d613ec270/small.jpg</picture_url>
          <person_id>eringreenwoodthessman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Homer</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ecs.vuw.ac.nz/~mwh</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelhomer/16fc38e2-021c-4b11-8ea6-752cf9b2c0a9/small.jpg</picture_url>
          <person_id>michaelhomer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobiaswrigstad/51b1bbdb-d077-4128-ad29-ec14657617a7/small.jpg</picture_url>
          <person_id>tobiaswrigstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Onward! Papers</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>ad10b96b-a7a4-429f-b19c-e7006d97c3df</slot_id>
      <event_id>8d987350-230b-4a6c-8cbe-dc285e88de75</event_id>
      <title>Generative Type-Aware Mutation for Testing SMT Solvers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jiwon</first_name>
          <last_name>Park</last_name>
          <affiliation>École Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>jiwonpark</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wintered.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Demo</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>d49a5700-9ca2-456f-9420-351a90715df0</slot_id>
      <event_id>7b0b529f-4a90-41ca-aadd-711922e26f4a</event_id>
      <title>Much ADO about Failures: A Fault-Aware Model for Compositional Verification of Strongly Consistent Distributed Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wolf</first_name>
          <last_name>Honore</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <person_id>wolfhonore</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jieung</first_name>
          <last_name>Kim</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/jkim</homepage_url>
          <person_id>jieungkim</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ji-Yong</first_name>
          <last_name>Shin</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.jiyongshin.info</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jiyongshin/887e7089-7e73-4b28-8c02-9dc79624fe5d/small.jpg</picture_url>
          <person_id>jiyongshin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
          <person_id>zhongshao</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>f238e6b6-5e26-4954-8c57-6fc373771e2d</slot_id>
      <event_id>3d930e90-52db-4006-a0bd-f6d7eb039c54</event_id>
      <title>Towards Self-Adaptable Languages</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gwendal</first_name>
          <last_name>Jouneaux</last_name>
          <affiliation>Univ. Rennes, Inria, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.gwendal-jouneaux.fr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gwendaljouneaux/da056fcb-c509-4aaa-89bd-7eca0c55ce85/small.jpg</picture_url>
          <person_id>gwendaljouneaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes 1, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gunter</first_name>
          <last_name>Mussbacher</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/guntermussbacher/f1452019-54bd-4b93-bbdb-eaece6059e96/small.jpg</picture_url>
          <person_id>guntermussbacher</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Onward! Papers</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>fbccdcae-7794-4229-9511-f102649bafed</slot_id>
      <event_id>6d684e5e-335d-4898-bf2a-c36ce83e0c91</event_id>
      <title>Reconciling Optimization with Secure Compilation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Son</first_name>
          <last_name>Tuan Vu</last_name>
          <affiliation>ARM</affiliation>
          <bio>undefined</bio>
          <person_id>sontuanvu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Albert</first_name>
          <last_name>Cohen</last_name>
          <affiliation>Google</affiliation>
          <bio>Albert is a research scientist at Google. He has been a research scientist at Inria from 2000 to 2018. He graduated from École Normale Supérieure de Lyon and received his PhD from the University of Versailles in 1999 (awarded two national prizes). He has been a visiting scholar at the University of Illinois, an invited professor at Philips Research, and a visiting scientist at Facebook Artificial Intelligence Research. Albert Cohen works on parallelizing and optimizing compilers, parallel programming languages and systems and synchronous programming for reactive control systems. He served as the general or program chair of major conferences, including PLDI, PPoPP, HiPEAC, CC, the embedded software track of DAC, and as a member of the editorial board of ACM TACO and IJPP. He coauthored more than 180 peer-reviewed papers and has been the advisor for 26 PhD theses. Several research projects initiated by Albert Cohen resulted in effective transfer to production compilers and programming environments in industry.</bio>
          <homepage_url>https://who.rocq.inria.fr/Albert.Cohen</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/albertcohen/3684aca0-5e45-4ea1-bece-82d71228da32/small.jpg</picture_url>
          <person_id>albertcohen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arnaud</first_name>
          <last_name>de Grandmaison</last_name>
          <affiliation>ARM</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/arnauddegrandmaison/e359aaef-874f-472d-9bbd-01eaef90cd1c/small.jpg</picture_url>
          <person_id>arnauddegrandmaison</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Guillon</last_name>
          <affiliation>STMicroelectronics</affiliation>
          <bio>undefined</bio>
          <person_id>christopheguillon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Karine</first_name>
          <last_name>Heydemann</last_name>
          <affiliation>Sorbonne Université, CNRS, Laboratoire d'Informatique de Paris 6, LIP6</affiliation>
          <bio>undefined</bio>
          <person_id>karineheydemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>65e2f8b3-7017-408f-af71-4334d33c42fd</subevent_id>
    <title>SPLASH PLMW: Mentoring</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot>
      <slot_id>7b58ed91-2584-4c6f-8ac0-e9d385122d03</slot_id>
      <title>Session: SPLASH PLMW - Mentoring</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ac5a3306-9fe5-4817-aaf1-a230e2536502</slot_id>
      <event_id>e6319e0c-481b-47b2-9c27-a66222ee940a</event_id>
      <title>Closing Remarks</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c0d58bb8-1fbf-41bc-ad12-6e1b0d3e263e</slot_id>
      <event_id>feb3456e-20e1-4145-80dc-76b9267690e5</event_id>
      <title>Mentoring Sessions</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:40</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>59e034f4-c9a4-4a04-8f82-df5db762abad</subevent_id>
    <title>SPLASH PLMW: Graduate Student Perspectives</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>72fe90f7-67a0-472f-ba82-24b07d9c494e</slot_id>
      <title>Session: SPLASH PLMW - Graduate Student Perspectives</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>0c641b60-7e2d-4946-bff3-28125cd516b3</slot_id>
      <event_id>40998865-4083-4932-b254-dc73d88f6fa5</event_id>
      <title>Current Student Panel</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>83b8575e-1731-49cf-a25c-286ec535635e</subevent_id>
    <title>SPLASH PLMW: Graduate Student Perspectives</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot>
      <slot_id>9261ef36-cdb3-4093-96f2-9e669606568d</slot_id>
      <title>Session: SPLASH PLMW - Graduate Student Perspectives</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fc889a27-1ef5-407f-af5b-4b4b7e0aa0f4</slot_id>
      <event_id>40998865-4083-4932-b254-dc73d88f6fa5</event_id>
      <title>Current Student Panel</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4f8258a3-44d1-4307-977d-92dfdd545ba3</subevent_id>
    <title>SPLASH Posters: Posters Virtual Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>4cc2ae63-b7c9-4b67-8ebb-768ef2a3a0e2</slot_id>
      <title>Session: SPLASH Posters - Posters Virtual Session</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>10:20</start_time>
      <end_time>10:50</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3255ea09-f6ff-49c9-a8b0-e526e09f00a8</slot_id>
      <event_id>67e78f6b-da94-465d-896e-f258069eae7c</event_id>
      <title>Coarsening Optimization for Differentiable Programming</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xipeng</first_name>
          <last_name>Shen</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>Xipeng Shen is an associate professor at the Computer Science Department, North Carolina State University (NCSU). He is a receipt of NSF CAREER Award, DOE Early Career Award, and Google Faculty Research Award. He is an ACM Distinguished Speaker, and a senior member of IEEE. Prior to joining NC State in 2014, Shen was the Adina Allen Term Distinguished Associate Professor at The College of William and Mary. He had served as a consultant to Intel Labs and Cisco, and a Visiting Researcher at MIT and Microsoft Research. He received his Ph.D. in Computer Science from University of Rochester in 2006.</bio>
          <homepage_url>http://people.engr.ncsu.edu/xshen5/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xipengshen/7ba54e69-f90a-4cf7-90d2-19fdd5f42e87/small.jpg</picture_url>
          <person_id>xipengshen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guoqiang</first_name>
          <last_name>Zhang</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
          <person_id>guoqiangzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Irene</first_name>
          <last_name>Dea</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>irenedea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Samantha</first_name>
          <last_name>Andow</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>samanthaandow</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Emilio</first_name>
          <last_name>Arroyo-Fang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>emilioarroyofang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Neal</first_name>
          <last_name>Gafter</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>nealgafter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Johann</first_name>
          <last_name>George</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/johanngeorge/f99a55e9-45f5-4516-9791-9d211a03e432/small.jpg</picture_url>
          <person_id>johanngeorge</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Melissa</first_name>
          <last_name>Grueter</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>melissagrueter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Erik</first_name>
          <last_name>Meijer</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Erik Meijer has been trying to bridge the ridge between theory and practice for most of his career. He is perhaps best known for his work on, amongst others, Haskell, C#, Visual Basic, and Dart programming languages, as well as for his contributions to LINQ and the Reactive Framework (Rx). Most recently he is on a quest to make uncertainty a first-class citizen in mainstream programming languages.</bio>
          <homepage_url>https://twitter.com/headinthebox</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/erikmeijer/caccbe57-ed32-4b35-966a-886c97f93d47/small.jpg</picture_url>
          <person_id>erikmeijer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Olin</first_name>
          <last_name>Shivers</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>olinshivers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Steffi</first_name>
          <last_name>Stumpos</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>steffistumpos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>12</sort_key>
          <first_name>Alanna</first_name>
          <last_name>Tempest</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>alannatempest</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>13</sort_key>
          <first_name>Christy</first_name>
          <last_name>Warden</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>christywarden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>14</sort_key>
          <first_name>Shannon</first_name>
          <last_name>Yang</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>shannonyang</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>331e543e-90c5-4b66-95c1-59335ea91c2e</slot_id>
      <event_id>8a9d392e-e4c8-4c9f-a263-cbf97f9f8b46</event_id>
      <title>Statically Bounded-Memory Delayed Sampling for Probabilistic Streams</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Baudart</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://guillaume.baudart.eu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guillaumebaudart/0ef21d31-ea41-4cfc-8df8-a62b2f483c64/small.jpg</picture_url>
          <person_id>guillaumebaudart</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charles</first_name>
          <last_name>Yuan</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>charlesyuan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>In-Person and Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>656d6842-01e8-4ba3-8236-b2c7e09b3c57</slot_id>
      <event_id>2000224e-65d2-4312-9dab-553c4abb2f43</event_id>
      <title>Compilation of Sparse Array Programming Models</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rawn</first_name>
          <last_name>Henry</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>rawnhenry</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivia</first_name>
          <last_name>Hsu</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>oliviahsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rohan</first_name>
          <last_name>Yadav</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>rohanyadav1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Kunle</first_name>
          <last_name>Olukotun</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arsenalfc.stanford.edu/kunle</homepage_url>
          <person_id>kunleolukotun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Prof. Saman Amarasinghe leads the Commit compiler research group in MIT’s Computer Science &amp;amp; Artificial Intelligence Laboratory (CSAIL), which focuses on programming languages and compilers that maximize application performance on modern computing platforms. He is a world leader in the field of high-performance domain-specific languages. Prof. Amarasinghe’s group developed the Halide, TACO, Simit, StreamIt, StreamJIT, PetaBricks, MILK, Cimple, and GraphIt domain-specific languages and compilers, all of which combine language design and sophisticated compilation techniques to deliver unprecedented performance for targeted application domains such as image processing, stream computations, and graph analytics. Dr. Amarasinghe also pioneered the application of machine learning for compiler optimizations, from Meta optimization in 2003 to OpenTuner extendable autotuner today. With professor Anant Agarwal, he co-led the Raw architecture project, which did pioneering work on scalable multicores. Prof. Amarasinghe’s entrepreneurship activities include founding Determina, Inc. (acquired by VMWare) based on computer security research pioneered in his research group at MIT and co-founding Lanka Internet Services, Ltd., the first Internet Service Provider in Sri Lanka. Prof. Amarasinghe is also the faculty director of MIT Global Startup Labs, whose summer programs in 17 countries have helped to create more than 20 thriving startups. Prof. Amarasinghe developed the popular Performance Engineering of Software Systems (6.172) class with Professor Charles Leiserson. He also created individualized software project classes such as the Open Source Software Project Lab, the Open Source Entrepreneurship Lab, and the Bring Your Own Software Project Lab.</bio>
          <homepage_url>http://people.csail.mit.edu/saman</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/samanamarasinghe/9e4ed1ad-ff3e-468e-b1a8-36ffb2c882ef/small.jpg</picture_url>
          <person_id>samanamarasinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>In-Person and Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>82f2a778-d2b5-4db2-9424-b09ee39f0252</slot_id>
      <event_id>a731774b-842a-4f12-b7d2-c9c173a58041</event_id>
      <title>Study of the Subtyping Machine of Nominal Subtyping with Variance</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ori</first_name>
          <last_name>Roth</last_name>
          <affiliation>Technion</affiliation>
          <bio>Ori Roth is a PhD student at the Technion—Israel Institute of Technology. His research interests include programming languages, software engineering, and automata theory.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/oriroth/f303c081-564f-4bb5-8037-c59de38bd235/small.jpg</picture_url>
          <person_id>oriroth</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Demo</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8f84a6b2-4535-47a4-831c-c02698df3c99</subevent_id>
    <title>SPLASH PLMW: Introduction to SPLASH</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot>
      <slot_id>644dc139-8318-4474-a9d4-001035bd5c49</slot_id>
      <title>Session: SPLASH PLMW - Introduction to SPLASH</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>46c0ba38-d45f-4f60-b664-714ca605a84d</slot_id>
      <event_id>9df416db-af69-4b2c-abe6-4b16a5a780d2</event_id>
      <title>A Tour through the Program</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>09:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>09:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9e5aaac5-6612-4191-9b80-eaaa6d17b6e7</slot_id>
      <event_id>feb3456e-20e1-4145-80dc-76b9267690e5</event_id>
      <title>Mentoring Sessions</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>09:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>10:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>da896258-e712-4d9f-a14a-c30e98c093c8</slot_id>
      <event_id>c8cfd98d-a1c2-432d-b78a-b37bf9ce6f83</event_id>
      <title>How to Navigate SPLASH</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>09:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>920c0463-6061-4381-94fd-ece66a4ad2d8</subevent_id>
    <title>SPLASH Posters: Posters In-Person Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>450b1ac5-a109-4bac-8e6b-b0fb556ff8eb</slot_id>
      <title>Session: SPLASH Posters - Posters In-Person Session</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2bc40ab8-f08f-4e38-8905-3ecd65c82fab</slot_id>
      <event_id>b05465ba-0f5d-492f-9499-056bd552e7ba</event_id>
      <title>Programming and Execution Models for Parallel Bounded Exhaustive Testing</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nader</first_name>
          <last_name>Al Awar</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>naderalawar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kush</first_name>
          <last_name>Jain</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>kushjain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chris</first_name>
          <last_name>Rossbach</last_name>
          <affiliation>The University of Texas at Austin and VMware Research Group</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.utexas.edu/~rossbach</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chrisrossbach/d36775ec-4ad9-4010-ae6e-ba41c5f9d61d/small.jpg</picture_url>
          <person_id>chrisrossbach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milos</first_name>
          <last_name>Gligoric</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/milosgligoric/4d0671ae-937e-4f08-b499-092379ff7ad3/small.jpg</picture_url>
          <person_id>milosgligoric</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>OOPSLA</badge>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>3647acda-a5eb-45dc-a22f-4c6b577ca735</slot_id>
      <event_id>ff194ecc-185f-46e5-be0d-bbc50837b761</event_id>
      <title>Motivating Complexity Understanding By Profiling Energy Usage</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Gross</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>joshuagross</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Coogan</last_name>
          <affiliation>Blackburn College</affiliation>
          <bio>undefined</bio>
          <person_id>kevincoogan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jacoby</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>danieljacoby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Helman</last_name>
          <affiliation>California State University Monterey Bay</affiliation>
          <bio>undefined</bio>
          <person_id>aaronhelman</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>Onward! Papers</badge>
        <badge>Demo</badge>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>4010c7e3-4e62-400f-a0e3-f28f757c14c8</slot_id>
      <event_id>196421da-f736-4b85-97c5-b75638bdb5e7</event_id>
      <title>Verifying Concurrent Multicopy Search Structures</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nisarg</first_name>
          <last_name>Patel</last_name>
          <affiliation>New York University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>nisargpatel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Siddharth</first_name>
          <last_name>Krishna</last_name>
          <affiliation>Microsoft Research, Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.nyu.edu/~siddharth/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/siddharthkrishna/fb064b85-b50f-4fba-9626-67ed7a75b358/small.jpg</picture_url>
          <person_id>siddharthkrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dennis</first_name>
          <last_name>Shasha</last_name>
          <affiliation>New York University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dennisshasha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Wies</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.nyu.edu/wies/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thomaswies/e43dd6b5-97dc-433f-9708-836bd6364a01/small.jpg</picture_url>
          <person_id>thomaswies</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>OOPSLA</badge>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>56ec854b-5429-431e-889e-181a89aeee60</slot_id>
      <event_id>b847f21a-bd4a-4b30-8a59-3c67a176b5cb</event_id>
      <title>Copy-and-Patch Compilation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Haoran</first_name>
          <last_name>Xu</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>haoranxu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>OOPSLA</badge>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>8b4016b2-cc13-463e-893e-76a9f076a5d6</slot_id>
      <event_id>3dc1734f-ed92-4fad-9e3f-fdc7a392b58f</event_id>
      <title>QuickSilver: Modeling and Parameterized Verification for Distributed Agreement-Based Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nouraldin</first_name>
          <last_name>Jaber</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/nouraldinjaber/0aeeca1f-ae9b-4220-85ef-02510d406a10/small.jpg</picture_url>
          <person_id>nouraldinjaber</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christopher</first_name>
          <last_name>Wagner</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/christopherwagner/571f9f20-6c46-40bb-a5b5-0ac8ad448fdf/small.jpg</picture_url>
          <person_id>christopherwagner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Swen</first_name>
          <last_name>Jacobs</last_name>
          <affiliation>CISPA Helmholtz Center for Information Security</affiliation>
          <bio>undefined</bio>
          <person_id>swenjacobs1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University. 
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures. 
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University. I received an NSF CAREER Award in 2012, a Department of Energy Early Career Research Award in 2013, and the Presidential Early Career Award for Scientists and Engineers in 2016.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
          <person_id>milindkulkarni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Roopsha</first_name>
          <last_name>Samanta</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/roopsha/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/roopshasamanta/3d74f41a-6adb-447b-8426-4a7fd9079dd4/small.jpg</picture_url>
          <person_id>roopshasamanta</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>OOPSLA</badge>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>8f934f01-7bf3-45f5-be3f-4ebc70d8b0bd</slot_id>
      <event_id>2000224e-65d2-4312-9dab-553c4abb2f43</event_id>
      <title>Compilation of Sparse Array Programming Models</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rawn</first_name>
          <last_name>Henry</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>rawnhenry</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivia</first_name>
          <last_name>Hsu</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>oliviahsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rohan</first_name>
          <last_name>Yadav</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>rohanyadav1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Kunle</first_name>
          <last_name>Olukotun</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arsenalfc.stanford.edu/kunle</homepage_url>
          <person_id>kunleolukotun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Prof. Saman Amarasinghe leads the Commit compiler research group in MIT’s Computer Science &amp;amp; Artificial Intelligence Laboratory (CSAIL), which focuses on programming languages and compilers that maximize application performance on modern computing platforms. He is a world leader in the field of high-performance domain-specific languages. Prof. Amarasinghe’s group developed the Halide, TACO, Simit, StreamIt, StreamJIT, PetaBricks, MILK, Cimple, and GraphIt domain-specific languages and compilers, all of which combine language design and sophisticated compilation techniques to deliver unprecedented performance for targeted application domains such as image processing, stream computations, and graph analytics. Dr. Amarasinghe also pioneered the application of machine learning for compiler optimizations, from Meta optimization in 2003 to OpenTuner extendable autotuner today. With professor Anant Agarwal, he co-led the Raw architecture project, which did pioneering work on scalable multicores. Prof. Amarasinghe’s entrepreneurship activities include founding Determina, Inc. (acquired by VMWare) based on computer security research pioneered in his research group at MIT and co-founding Lanka Internet Services, Ltd., the first Internet Service Provider in Sri Lanka. Prof. Amarasinghe is also the faculty director of MIT Global Startup Labs, whose summer programs in 17 countries have helped to create more than 20 thriving startups. Prof. Amarasinghe developed the popular Performance Engineering of Software Systems (6.172) class with Professor Charles Leiserson. He also created individualized software project classes such as the Open Source Software Project Lab, the Open Source Entrepreneurship Lab, and the Bring Your Own Software Project Lab.</bio>
          <homepage_url>http://people.csail.mit.edu/saman</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/samanamarasinghe/9e4ed1ad-ff3e-468e-b1a8-36ffb2c882ef/small.jpg</picture_url>
          <person_id>samanamarasinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>In-Person and Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>95388337-33a2-4960-b024-25eb220f0a8e</slot_id>
      <event_id>8044d80e-0443-4590-9220-5424b15f09a9</event_id>
      <title>Rewrite Rule Inference Using Equality Saturation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chandrakana</first_name>
          <last_name>Nandi</last_name>
          <affiliation>Certora, inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cnandi.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chandrakananandi/a90ad233-62bb-4a90-8e9d-9afd969ef245/small.jpg</picture_url>
          <person_id>chandrakananandi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Max</first_name>
          <last_name>Willsey</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.mwillsey.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/maxwillsey/ff552459-e263-42a5-b17b-1301d482943d/small.jpg</picture_url>
          <person_id>maxwillsey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Amy</first_name>
          <last_name>Zhu</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <person_id>amyzhu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yisu Remy</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>PhD student at University of Washington.</bio>
          <homepage_url>https://remy.wang</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yisuremywang1/5aec4d9a-13a9-460e-8154-fc72a368b4f9/small.jpg</picture_url>
          <person_id>yisuremywang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Brett</first_name>
          <last_name>Saiki</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <person_id>brettsaiki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Adam</first_name>
          <last_name>Anderson</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <person_id>adamanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Adriana</first_name>
          <last_name>Schulz</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <person_id>adrianaschulz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Dan</first_name>
          <last_name>Grossman</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~djg/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dangrossman/941e0321-e962-4f03-9027-ba9f0448e7df/small.jpg</picture_url>
          <person_id>dangrossman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Tatlock</last_name>
          <affiliation>University of Washington, Seattle</affiliation>
          <bio>Associate Professor at the University of Washington</bio>
          <homepage_url>https://ztatlock.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zacharytatlock/87af1196-2d8d-4bd5-a692-018d3939a00f/small.jpg</picture_url>
          <person_id>zacharytatlock</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>OOPSLA</badge>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>ba8be543-fce6-4c92-8a06-f2828e7e0a44</slot_id>
      <event_id>b4998869-9061-435d-9983-f65c0e07b4c3</event_id>
      <title>Static Detection of Silent Misconfigurations with Deep Interaction Analysis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jialu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jialuzhang/7427a686-f97e-42da-9f0b-4b94122d30f3/small.jpg</picture_url>
          <person_id>jialuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ruzica</first_name>
          <last_name>Piskac</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/~piskac/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ruzicapiskac/5643c034-322b-49cb-9686-ebb925bd37ed/small.jpg</picture_url>
          <person_id>ruzicapiskac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ennan</first_name>
          <last_name>Zhai</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ennanzhai.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ennanzhai/4ab41fb7-50ce-4cde-b173-2b1b7d957b82/small.jpg</picture_url>
          <person_id>ennanzhai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tianyin</first_name>
          <last_name>Xu</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>tianyinxu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>OOPSLA</badge>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>c2c0604c-2222-4a99-8ada-a3174773be20</slot_id>
      <event_id>8a9d392e-e4c8-4c9f-a263-cbf97f9f8b46</event_id>
      <title>Statically Bounded-Memory Delayed Sampling for Probabilistic Streams</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Baudart</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://guillaume.baudart.eu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guillaumebaudart/0ef21d31-ea41-4cfc-8df8-a62b2f483c64/small.jpg</picture_url>
          <person_id>guillaumebaudart</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charles</first_name>
          <last_name>Yuan</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>charlesyuan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>In-Person and Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>f91bcf3e-a26c-481f-aecd-c2816aa3f410</slot_id>
      <event_id>2cdc5269-7bc7-4152-a66b-841842e43f14</event_id>
      <title>Programming with Neural Surrogates of Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alex</first_name>
          <last_name>Renda</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>alexrenda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yi</first_name>
          <last_name>Ding</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://y-ding.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yiding/17d36271-6bb2-44b2-8274-88f3a520bf9c/small.jpg</picture_url>
          <person_id>yiding</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>Onward! Papers</badge>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>fbede4bf-fd33-4da2-8807-5fa27dac5b3a</slot_id>
      <event_id>bbac71bc-2593-42d1-bdff-114770dc1c54</event_id>
      <title>Reachability Types: Tracking Aliasing and Separation in Higher-Order Functional Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuyan</first_name>
          <last_name>Bao</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuyanbao.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuyanbao/29054831-172d-4005-9e61-a5f62bd70c76/small.jpg</picture_url>
          <person_id>yuyanbao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guannan</first_name>
          <last_name>Wei</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://continuation.passing.style</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guannanwei/e1971b4b-ebd3-429b-b28c-0c2cfb0f0289/small.jpg</picture_url>
          <person_id>guannanwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Bračevac</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://bracevac.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/oliverbracevac/17c0ac71-a156-4868-8df9-d4ae4cd669e7/small.jpg</picture_url>
          <person_id>oliverbracevac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yuxuan</first_name>
          <last_name>Jiang</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>yuxuanjiang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Qiyang</first_name>
          <last_name>He</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>qiyanghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>OOPSLA</badge>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>86f32777-c72e-4bfe-8212-75dad2ab617f</subevent_id>
    <title>SPLASH PLMW: Career Perspectives</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>c8054045-16d4-4a2d-ad8e-dcfaef67f84c</slot_id>
      <title>Session: SPLASH PLMW - Career Perspectives</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>0a141f90-f28c-4f92-9e44-21a2a751286c</slot_id>
      <event_id>7cec55c1-6dca-4fb5-8296-9086c8d221a3</event_id>
      <title>PL/SE Career Panel</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5b720242-94aa-41aa-afc6-c54e3fc18be2</subevent_id>
    <title>SPLASH Posters: Posters Virtual Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>eee55cd7-74e0-4a96-a8f8-e76cc279caaf</slot_id>
      <title>Session: SPLASH Posters - Posters Virtual Session</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>10:20</start_time>
      <end_time>10:50</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>73d9ea37-d1e4-41c2-9cd8-eb0115ecffa3</slot_id>
      <event_id>0c6be8ac-f91e-4d3e-beb0-09c6868620e8</event_id>
      <title>SkyQuery: An Aerial Drone Video Sensing Platform</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Favyen</first_name>
          <last_name>Bastani</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>favyenbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Songtao</first_name>
          <last_name>He</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>songtaohe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziwen</first_name>
          <last_name>Jiang</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <person_id>ziwenjiang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Osbert</first_name>
          <last_name>Bastani</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://obastani.github.io</homepage_url>
          <person_id>osbertbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sam</first_name>
          <last_name>Madden</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sammadden</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Onward! Papers</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>810df5a8-b17f-4432-8905-84db7c8bf1fe</slot_id>
      <event_id>f5c2ceaa-c4db-4342-b5f0-3ac6be7dba06</event_id>
      <title>Dala: A Simple Capability-Based Dynamic Language Design For Data Race-Freedom</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kiko</first_name>
          <last_name>Fernandez-Reyes</last_name>
          <affiliation>Uppsala University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.plresearcher.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kikofernandezreyes/83984e89-a3fc-4e54-b33f-b8d23ae5fd29/small.jpg</picture_url>
          <person_id>kikofernandezreyes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isaac Oscar</first_name>
          <last_name>Gariano</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <person_id>isaacoscargariano1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Noble</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.mcs.vuw.ac.nz/~kjx/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesnoble/397692f7-f014-4032-a93d-bc522e882d80/small.jpg</picture_url>
          <person_id>jamesnoble</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Erin</first_name>
          <last_name>Greenwood-Thessman</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/eringreenwoodthessman/72ea1c0a-3bbf-45af-a431-2f5d613ec270/small.jpg</picture_url>
          <person_id>eringreenwoodthessman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Homer</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ecs.vuw.ac.nz/~mwh</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelhomer/16fc38e2-021c-4b11-8ea6-752cf9b2c0a9/small.jpg</picture_url>
          <person_id>michaelhomer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobiaswrigstad/51b1bbdb-d077-4128-ad29-ec14657617a7/small.jpg</picture_url>
          <person_id>tobiaswrigstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Onward! Papers</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>890e26d7-69a0-459b-900e-3fbaadeecf04</slot_id>
      <event_id>7b0b529f-4a90-41ca-aadd-711922e26f4a</event_id>
      <title>Much ADO about Failures: A Fault-Aware Model for Compositional Verification of Strongly Consistent Distributed Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wolf</first_name>
          <last_name>Honore</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <person_id>wolfhonore</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jieung</first_name>
          <last_name>Kim</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/jkim</homepage_url>
          <person_id>jieungkim</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ji-Yong</first_name>
          <last_name>Shin</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.jiyongshin.info</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jiyongshin/887e7089-7e73-4b28-8c02-9dc79624fe5d/small.jpg</picture_url>
          <person_id>jiyongshin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
          <person_id>zhongshao</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>8d2f05c1-f53e-4dbf-837c-80a90dda575d</slot_id>
      <event_id>665c7068-1d16-4e89-86ba-02fad49e4102</event_id>
      <title>The Semantics of Shared Memory in Intel CPU/FPGA Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dan</first_name>
          <last_name>Iorga</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~di13/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/daniorga/dac1a236-b8e7-462e-a2c3-2713314bf843/small.jpg</picture_url>
          <person_id>daniorga</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alastair F.</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I’m a PhD student at Imperial College London supervised by Alastair Donaldson. I study testing and modeling of many-core systems, with an emphasis on fine-grained communication idioms.</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~trs15/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tylersorensen/a5910621-6b59-4729-be27-e5dfae22a495/small.jpg</picture_url>
          <person_id>tylersorensen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>d6e7f559-d852-4f29-9d77-b1ffd62d9539</slot_id>
      <event_id>8d987350-230b-4a6c-8cbe-dc285e88de75</event_id>
      <title>Generative Type-Aware Mutation for Testing SMT Solvers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jiwon</first_name>
          <last_name>Park</last_name>
          <affiliation>École Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>jiwonpark</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wintered.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Demo</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>efd684b4-0116-47ef-8437-76e40266e6e6</slot_id>
      <event_id>3d930e90-52db-4006-a0bd-f6d7eb039c54</event_id>
      <title>Towards Self-Adaptable Languages</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gwendal</first_name>
          <last_name>Jouneaux</last_name>
          <affiliation>Univ. Rennes, Inria, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.gwendal-jouneaux.fr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gwendaljouneaux/da056fcb-c509-4aaa-89bd-7eca0c55ce85/small.jpg</picture_url>
          <person_id>gwendaljouneaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes 1, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gunter</first_name>
          <last_name>Mussbacher</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/guntermussbacher/f1452019-54bd-4b93-bbdb-eaece6059e96/small.jpg</picture_url>
          <person_id>guntermussbacher</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Onward! Papers</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>efe7f914-ca6a-40d7-a661-da0184a481a5</slot_id>
      <event_id>6d684e5e-335d-4898-bf2a-c36ce83e0c91</event_id>
      <title>Reconciling Optimization with Secure Compilation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Son</first_name>
          <last_name>Tuan Vu</last_name>
          <affiliation>ARM</affiliation>
          <bio>undefined</bio>
          <person_id>sontuanvu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Albert</first_name>
          <last_name>Cohen</last_name>
          <affiliation>Google</affiliation>
          <bio>Albert is a research scientist at Google. He has been a research scientist at Inria from 2000 to 2018. He graduated from École Normale Supérieure de Lyon and received his PhD from the University of Versailles in 1999 (awarded two national prizes). He has been a visiting scholar at the University of Illinois, an invited professor at Philips Research, and a visiting scientist at Facebook Artificial Intelligence Research. Albert Cohen works on parallelizing and optimizing compilers, parallel programming languages and systems and synchronous programming for reactive control systems. He served as the general or program chair of major conferences, including PLDI, PPoPP, HiPEAC, CC, the embedded software track of DAC, and as a member of the editorial board of ACM TACO and IJPP. He coauthored more than 180 peer-reviewed papers and has been the advisor for 26 PhD theses. Several research projects initiated by Albert Cohen resulted in effective transfer to production compilers and programming environments in industry.</bio>
          <homepage_url>https://who.rocq.inria.fr/Albert.Cohen</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/albertcohen/3684aca0-5e45-4ea1-bece-82d71228da32/small.jpg</picture_url>
          <person_id>albertcohen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arnaud</first_name>
          <last_name>de Grandmaison</last_name>
          <affiliation>ARM</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/arnauddegrandmaison/e359aaef-874f-472d-9bbd-01eaef90cd1c/small.jpg</picture_url>
          <person_id>arnauddegrandmaison</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Guillon</last_name>
          <affiliation>STMicroelectronics</affiliation>
          <bio>undefined</bio>
          <person_id>christopheguillon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Karine</first_name>
          <last_name>Heydemann</last_name>
          <affiliation>Sorbonne Université, CNRS, Laboratoire d'Informatique de Paris 6, LIP6</affiliation>
          <bio>undefined</bio>
          <person_id>karineheydemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8ec0a1ab-8d2d-4a41-89e4-5cb1c5a2489d</subevent_id>
    <title>SPLASH Posters: Posters Virtual Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>2713bffe-5cee-42e9-b46c-bff783c0013c</slot_id>
      <title>Session: SPLASH Posters - Posters Virtual Session</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>18:20</start_time>
      <end_time>18:50</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>5dc3a2f2-8583-46f9-82cc-1f43040f3d06</slot_id>
      <event_id>6a7aa1ed-0b9e-43f8-8bfb-cc79aca0eee0</event_id>
      <title>Scalability and Precision by Combining Expressive Type Systems and Deductive Verification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>18:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Lanzinger</last_name>
          <affiliation>Karlsruhe Institute of Technology (KIT)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://formal.iti.kit.edu/~lanzinger/</homepage_url>
          <person_id>florianlanzinger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Weigl</last_name>
          <affiliation>Karlsruhe Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>alexanderweigl</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mattias</first_name>
          <last_name>Ulbrich</last_name>
          <affiliation>Karlsruhe Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://formal.iti.kit.edu/~ulbrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mattiasulbrich/93c421cd-7529-43d3-8968-366d6ba1753d/small.jpg</picture_url>
          <person_id>mattiasulbrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Werner</first_name>
          <last_name>Dietl</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ece.uwaterloo.ca/~wdietl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wernerdietl/f6ddc3ef-7134-4260-a182-a71ed88842cb/small.jpg</picture_url>
          <person_id>wernerdietl</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Demo</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>df29b83b-d2e1-4758-8e6d-f3e1bcf642ef</slot_id>
      <event_id>e2fe330b-2985-49e7-92b0-4e8d19066a49</event_id>
      <title>Formal Verification of High-Level Synthesis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>18:35</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yann</first_name>
          <last_name>Herklotz</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>My research focuses on formalising the process of converting high-level programming language descriptions to correct hardware that is functionally equivalent to the input. This process is called high-level synthesis (HLS), and allows software to be turned into custom accelerators automatically, which can then be placed on field-programmable gate arrays (FPGAs). An implementation in the Coq theorem prover called Vericert can be found on Github.</bio>
          <homepage_url>https://yannherklotz.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannherklotz/8a826a69-2e1a-4062-b141-594d84b9d987/small.jpg</picture_url>
          <person_id>yannherklotz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>Pollard</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>jamespollard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nadesh</first_name>
          <last_name>Ramanathan</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>nadeshramanathan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Demo</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0364b67c-591a-463a-99e5-59e3ca4cdd26</subevent_id>
    <title>SPLASH Posters: Posters Virtual Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot>
      <slot_id>858d2c19-d0b9-4aad-8f11-d6b618d2b121</slot_id>
      <title>Session: SPLASH Posters - Posters Virtual Session</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>10:20</start_time>
      <end_time>10:50</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6755276b-ccfa-4c8f-b1ef-359bcac7241b</slot_id>
      <event_id>e2fe330b-2985-49e7-92b0-4e8d19066a49</event_id>
      <title>Formal Verification of High-Level Synthesis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>10:35</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yann</first_name>
          <last_name>Herklotz</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>My research focuses on formalising the process of converting high-level programming language descriptions to correct hardware that is functionally equivalent to the input. This process is called high-level synthesis (HLS), and allows software to be turned into custom accelerators automatically, which can then be placed on field-programmable gate arrays (FPGAs). An implementation in the Coq theorem prover called Vericert can be found on Github.</bio>
          <homepage_url>https://yannherklotz.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannherklotz/8a826a69-2e1a-4062-b141-594d84b9d987/small.jpg</picture_url>
          <person_id>yannherklotz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>Pollard</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>jamespollard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nadesh</first_name>
          <last_name>Ramanathan</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>nadeshramanathan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Demo</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>818c332e-8a41-4cda-b340-c62cf3181bcd</slot_id>
      <event_id>6a7aa1ed-0b9e-43f8-8bfb-cc79aca0eee0</event_id>
      <title>Scalability and Precision by Combining Expressive Type Systems and Deductive Verification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>10:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>10:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Lanzinger</last_name>
          <affiliation>Karlsruhe Institute of Technology (KIT)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://formal.iti.kit.edu/~lanzinger/</homepage_url>
          <person_id>florianlanzinger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Weigl</last_name>
          <affiliation>Karlsruhe Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>alexanderweigl</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mattias</first_name>
          <last_name>Ulbrich</last_name>
          <affiliation>Karlsruhe Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://formal.iti.kit.edu/~ulbrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mattiasulbrich/93c421cd-7529-43d3-8968-366d6ba1753d/small.jpg</picture_url>
          <person_id>mattiasulbrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Werner</first_name>
          <last_name>Dietl</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ece.uwaterloo.ca/~wdietl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wernerdietl/f6ddc3ef-7134-4260-a182-a71ed88842cb/small.jpg</picture_url>
          <person_id>wernerdietl</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Demo</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7f75ec84-32b5-409d-813b-b3fc9a1063a1</subevent_id>
    <title>SPLASH Posters: Posters Virtual Session</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-Posters</url>
    <url_link_display>Posters</url_link_display>
    <tracks>
      <track>Posters</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>473cb7a5-1b7a-4a38-98d5-3a79a6a2760d</slot_id>
      <title>Session: SPLASH Posters - Posters Virtual Session</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>18:20</start_time>
      <end_time>18:50</end_time>
      <tracks>
        <track>Posters</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>1324f7bf-40e9-41fd-822c-bc745f146df9</slot_id>
      <event_id>a731774b-842a-4f12-b7d2-c9c173a58041</event_id>
      <title>Study of the Subtyping Machine of Nominal Subtyping with Variance</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ori</first_name>
          <last_name>Roth</last_name>
          <affiliation>Technion</affiliation>
          <bio>Ori Roth is a PhD student at the Technion—Israel Institute of Technology. His research interests include programming languages, software engineering, and automata theory.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/oriroth/f303c081-564f-4bb5-8037-c59de38bd235/small.jpg</picture_url>
          <person_id>oriroth</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Demo</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>7ca12297-29ad-4570-bad7-e801567a1ed4</slot_id>
      <event_id>8a9d392e-e4c8-4c9f-a263-cbf97f9f8b46</event_id>
      <title>Statically Bounded-Memory Delayed Sampling for Probabilistic Streams</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Baudart</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://guillaume.baudart.eu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guillaumebaudart/0ef21d31-ea41-4cfc-8df8-a62b2f483c64/small.jpg</picture_url>
          <person_id>guillaumebaudart</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charles</first_name>
          <last_name>Yuan</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>charlesyuan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>In-Person and Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a12c12c1-f748-486f-8a9d-1320af0677a3</slot_id>
      <event_id>2000224e-65d2-4312-9dab-553c4abb2f43</event_id>
      <title>Compilation of Sparse Array Programming Models</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rawn</first_name>
          <last_name>Henry</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>rawnhenry</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivia</first_name>
          <last_name>Hsu</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>oliviahsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rohan</first_name>
          <last_name>Yadav</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>rohanyadav1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Kunle</first_name>
          <last_name>Olukotun</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arsenalfc.stanford.edu/kunle</homepage_url>
          <person_id>kunleolukotun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Prof. Saman Amarasinghe leads the Commit compiler research group in MIT’s Computer Science &amp;amp; Artificial Intelligence Laboratory (CSAIL), which focuses on programming languages and compilers that maximize application performance on modern computing platforms. He is a world leader in the field of high-performance domain-specific languages. Prof. Amarasinghe’s group developed the Halide, TACO, Simit, StreamIt, StreamJIT, PetaBricks, MILK, Cimple, and GraphIt domain-specific languages and compilers, all of which combine language design and sophisticated compilation techniques to deliver unprecedented performance for targeted application domains such as image processing, stream computations, and graph analytics. Dr. Amarasinghe also pioneered the application of machine learning for compiler optimizations, from Meta optimization in 2003 to OpenTuner extendable autotuner today. With professor Anant Agarwal, he co-led the Raw architecture project, which did pioneering work on scalable multicores. Prof. Amarasinghe’s entrepreneurship activities include founding Determina, Inc. (acquired by VMWare) based on computer security research pioneered in his research group at MIT and co-founding Lanka Internet Services, Ltd., the first Internet Service Provider in Sri Lanka. Prof. Amarasinghe is also the faculty director of MIT Global Startup Labs, whose summer programs in 17 countries have helped to create more than 20 thriving startups. Prof. Amarasinghe developed the popular Performance Engineering of Software Systems (6.172) class with Professor Charles Leiserson. He also created individualized software project classes such as the Open Source Software Project Lab, the Open Source Entrepreneurship Lab, and the Bring Your Own Software Project Lab.</bio>
          <homepage_url>http://people.csail.mit.edu/saman</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/samanamarasinghe/9e4ed1ad-ff3e-468e-b1a8-36ffb2c882ef/small.jpg</picture_url>
          <person_id>samanamarasinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge>In-Person and Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>daec6fea-fdd3-4bab-9d7e-ec50d0b14c5b</slot_id>
      <event_id>67e78f6b-da94-465d-896e-f258069eae7c</event_id>
      <title>Coarsening Optimization for Differentiable Programming</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>18:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>18:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xipeng</first_name>
          <last_name>Shen</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>Xipeng Shen is an associate professor at the Computer Science Department, North Carolina State University (NCSU). He is a receipt of NSF CAREER Award, DOE Early Career Award, and Google Faculty Research Award. He is an ACM Distinguished Speaker, and a senior member of IEEE. Prior to joining NC State in 2014, Shen was the Adina Allen Term Distinguished Associate Professor at The College of William and Mary. He had served as a consultant to Intel Labs and Cisco, and a Visiting Researcher at MIT and Microsoft Research. He received his Ph.D. in Computer Science from University of Rochester in 2006.</bio>
          <homepage_url>http://people.engr.ncsu.edu/xshen5/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xipengshen/7ba54e69-f90a-4cf7-90d2-19fdd5f42e87/small.jpg</picture_url>
          <person_id>xipengshen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guoqiang</first_name>
          <last_name>Zhang</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
          <person_id>guoqiangzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Irene</first_name>
          <last_name>Dea</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>irenedea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Samantha</first_name>
          <last_name>Andow</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>samanthaandow</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Emilio</first_name>
          <last_name>Arroyo-Fang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>emilioarroyofang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Neal</first_name>
          <last_name>Gafter</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>nealgafter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Johann</first_name>
          <last_name>George</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/johanngeorge/f99a55e9-45f5-4516-9791-9d211a03e432/small.jpg</picture_url>
          <person_id>johanngeorge</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Melissa</first_name>
          <last_name>Grueter</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>melissagrueter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Erik</first_name>
          <last_name>Meijer</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Erik Meijer has been trying to bridge the ridge between theory and practice for most of his career. He is perhaps best known for his work on, amongst others, Haskell, C#, Visual Basic, and Dart programming languages, as well as for his contributions to LINQ and the Reactive Framework (Rx). Most recently he is on a quest to make uncertainty a first-class citizen in mainstream programming languages.</bio>
          <homepage_url>https://twitter.com/headinthebox</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/erikmeijer/caccbe57-ed32-4b35-966a-886c97f93d47/small.jpg</picture_url>
          <person_id>erikmeijer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Olin</first_name>
          <last_name>Shivers</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>olinshivers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Steffi</first_name>
          <last_name>Stumpos</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>steffistumpos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>12</sort_key>
          <first_name>Alanna</first_name>
          <last_name>Tempest</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>alannatempest</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>13</sort_key>
          <first_name>Christy</first_name>
          <last_name>Warden</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>christywarden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>14</sort_key>
          <first_name>Shannon</first_name>
          <last_name>Yang</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>shannonyang</person_id>
        </person>
      </persons>
      <tracks>
        <track>Posters</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>OOPSLA</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>675076c1-2083-4e03-9c75-702846634052</subevent_id>
    <title>SPLASH PLMW: Introduction to SPLASH</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>a82aab2a-e674-47fb-9a69-fbb2b4f5e855</slot_id>
      <title>Session: SPLASH PLMW - Introduction to SPLASH</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>5c40d758-f0a2-44c3-b55e-207c605ed501</slot_id>
      <event_id>9df416db-af69-4b2c-abe6-4b16a5a780d2</event_id>
      <title>A Tour through the Program</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>17:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>17:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>9fbdd55a-df48-4afd-97e8-0fdd090c34ae</slot_id>
      <event_id>feb3456e-20e1-4145-80dc-76b9267690e5</event_id>
      <title>Mentoring Sessions</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>17:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>18:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>f6e9ed35-63bb-4023-8932-e508fa6c4753</slot_id>
      <event_id>c8cfd98d-a1c2-432d-b78a-b37bf9ce6f83</event_id>
      <title>How to Navigate SPLASH</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>17:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>28e07262-ce6b-4203-aed9-1c4dd4462dbe</subevent_id>
    <title>SPLASH PLMW: Career Perspectives</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-PLMW</url>
    <url_link_display>PLMW@SPLASH</url_link_display>
    <tracks>
      <track>PLMW@SPLASH</track>
    </tracks>
    <timeslot>
      <slot_id>9fbc7fd7-e56c-4026-9b54-0b05e40ace8e</slot_id>
      <title>Session: SPLASH PLMW - Career Perspectives</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8c126525-fe9e-4270-b744-e2452f78ff2d</slot_id>
      <event_id>7cec55c1-6dca-4fb5-8296-9086c8d221a3</event_id>
      <title>PL/SE Career Panel</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>PLMW@SPLASH</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c2fc44c0-c8ce-4416-8373-03e5631e835f</subevent_id>
    <title>SLE: SLE/GPCE Session 5</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sle-2021</url>
    <url_link_display>SLE (Software Language Engineering) 2021</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2021</track>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot>
      <slot_id>f3baa3f5-c3b2-4ec8-b8b7-6f68c0e0a21f</slot_id>
      <title>Session: SLE - SLE/GPCE Session 5</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science and chair of the Programming Languages Group at Delft University of Technology. His current research is on the foundation and implementation of declarative specification of programming languages. He studied at the University of Amsterdam (master 1993; doctorate 1997), and worked at the Oregon Graduate Institute (postdoc 1997-1998), Utrecht University (assistant professor 1998-2006), and TU Delft (associate professor 2006-2013, full professor since 2013). 
His research interests include (domain-specific) programming languages, language engineering, program transformation, and declarative language definition. With his students he has designed and implemented the Spoofax language workbench, as well as several domain-specific languages, including DSLs for syntax definition (SDF3), program transformation (Stratego), static semantics (Statix), software deployment (Nix), and web application development (WebDSL). Applications of WebDSL include the researchr conference hosting site and the WebLab learning management system.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
          <person_id>eelcovisser</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0be193a2-ab0f-4d3b-8d76-2be1c55b1ccc</slot_id>
      <event_id>9bf0d567-6dd2-43ce-8e3f-d34234f72a99</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>10:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6d66258c-7a27-4947-b7da-30ced0f1d565</slot_id>
      <event_id>973121e8-34fe-4e2b-b368-0c84d6a61a30</event_id>
      <submission_id>6</submission_id>
      <title>Metaprogramming with Combinators</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>09:45</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>10:00</end_time>
      <description>There are a wide array of methods for writing code generators. We advocate for a point in the design space, which we call metaprogramming with combinators, where programmers use (and write) combinator libraries that directly manipulate object language terms. The key language feature that makes this style of programming palatable is quasiquotation. Our approach leverages quasiquation and other host language features to provide what is essentially a rich, well-typed macro language. Unlike other approaches, metaprogramming with combinators allows full control over generated code, thereby also providing full control over performance and resource usage. This control does not require sacrificing the ability to write high-level abstractions. We demonstrate metaprogramming with combinators through several code generators written in Haskell that produce VHDL targeted to Xilinx FPGAs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mahshid</first_name>
          <last_name>Shahmohammadian</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <person_id>mahshidshahmohammadian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Geoffrey</first_name>
          <last_name>Mainland</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.drexel.edu/~mainland/</homepage_url>
          <person_id>geoffreymainland</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>9473e150-a439-445e-bc26-93626bbabe2c</slot_id>
      <event_id>b0370501-3004-4d97-999e-22e02e3f92bd</event_id>
      <submission_id>21</submission_id>
      <title>Multi-Stage Programming with Generative and Analytical Macros</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>09:30</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:45</end_time>
      <description>In metaprogramming, code generation and code analysis are complementary. Traditionally, principled metaprogramming extensions for programming languages, like MetaML and BER MetaOCaml, offer strong foundations for code generation but lack equivalent support for code analysis. Similarly, existing macro systems are biased towards the code generation aspect. 
In this work, we present a calculus for macros featuring both code generation and code analysis. The calculus directly models separate compilation of macros, internalizing a commonly neglected aspect of macros. The system ensures that the generated code is well-typed and hygienic. 
We implement our system in Scala 3, provide a formalization, and prove its soundness.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Stucki</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://github.com/nicolasstucki</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nicolasstucki/4dfca9be-ecc5-4acb-a0bf-078dfb4abbf0/small.jpg</picture_url>
          <person_id>nicolasstucki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan Immanuel</first_name>
          <last_name>Brachthäuser</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanbrachthauser/f9c0b5dc-9b85-444f-baed-e807673f202d/small.jpg</picture_url>
          <person_id>jonathanbrachthauser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>EPFL</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java. 
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as academic director of the Scala center.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinodersky/fc1dd696-d0d4-47cb-9d9a-bba012d98f9e/small.jpg</picture_url>
          <person_id>martinodersky</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>bc2f48ab-53d2-4346-8682-3c3acb04ecac</slot_id>
      <event_id>f543f436-3672-458d-b29e-a56692560d3c</event_id>
      <submission_id>24</submission_id>
      <title>HACCLE: Metaprogramming for Secure Multi-Party Computation</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>09:15</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:30</end_time>
      <description>Cryptographic techniques have the potential to enable distrusting parties to collaborate in fundamentally new ways, but their practical implementation poses numerous challenges. An important class of such cryptographic techniques is known as secure multi-party computation (MPC). Developing secure MPC applications in realistic scenarios requires extensive knowledge spanning multiple areas of cryptography and systems. And while the steps to arrive at a solution for a particular application are laborious, it remains difficult to make the implementation efficient, and cumbersome to apply those same steps to a slightly different application from scratch. Hence, it is an important problem to design a programming language and a compiler toolchain for secure MPC applications with minimum effort and using techniques accessible to non-experts in cryptography. 
In this paper, we present the HACCLE (High Assurance Compositional Cryptography: Languages and Environments) toolchain, specifically targeted to MPC applications. The toolchain contains an embedded domain-specific language (Harpoon) for software developers without cryptographic expertise to write MPC-based programs, and uses \emph{lightweight modular staging} (LMS) for code generation. Harpoon programs are compiled into acyclic circuits represented in HACCLE’s Intermediate Representation (HIR) that serves as an abstraction for implementing a computation using different cryptographic protocols such as secret sharing, homomorphic encryption, or garbled circuits. Implementations of different cryptographic protocols serve as different backends of our toolchain. The extensible design of HIR allows cryptographic experts to plug in new primitives and protocols to realize computations. And the use of standard metaprogramming techniques lowers the development effort significantly. 
We have implemented Harpoon and HACCLE, and used them to program interesting algorithms and applications (e.g., secure auction, matrix-vector multiplication, and merge sort). We show that the performance is improved by using our optimization strategies and heuristics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuyan</first_name>
          <last_name>Bao</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>yuyanbao1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kirshanthan</first_name>
          <last_name>Sundararajah</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kirshanthans.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kirshanthansundararajah/f5841aed-2fcf-4507-b0ee-49d7bed313ef/small.jpg</picture_url>
          <person_id>kirshanthansundararajah</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Raghav</first_name>
          <last_name>Malik</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/raghavmalik/772f3505-7946-4766-99b3-f6b6c97192cc/small.jpg</picture_url>
          <person_id>raghavmalik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Qianchuan</first_name>
          <last_name>Ye</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/ye202/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/qianchuanye/83304b4c-6b92-4773-9f69-e7055c793823/small.jpg</picture_url>
          <person_id>qianchuanye</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Christopher</first_name>
          <last_name>Wagner</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/christopherwagner/571f9f20-6c46-40bb-a5b5-0ac8ad448fdf/small.jpg</picture_url>
          <person_id>christopherwagner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Nouraldin</first_name>
          <last_name>Jaber</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/nouraldinjaber/0aeeca1f-ae9b-4220-85ef-02510d406a10/small.jpg</picture_url>
          <person_id>nouraldinjaber</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Fei</first_name>
          <last_name>Wang</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>feiwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Mohammad Hassan</first_name>
          <last_name>Ameri</last_name>
          <affiliation>Purdue university</affiliation>
          <bio>undefined</bio>
          <person_id>mohammadhassanameri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Donghang</first_name>
          <last_name>Lu</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>donghanglu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Seto</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>alexanderseto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Delaware</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/bendy/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benjamindelaware/39bbf6b3-d145-435c-8956-8acf8cfcaffa/small.jpg</picture_url>
          <person_id>benjamindelaware</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>12</sort_key>
          <first_name>Roopsha</first_name>
          <last_name>Samanta</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/roopsha/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/roopshasamanta/3d74f41a-6adb-447b-8426-4a7fd9079dd4/small.jpg</picture_url>
          <person_id>roopshasamanta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>13</sort_key>
          <first_name>Aniket</first_name>
          <last_name>Kate</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>aniketkate</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>14</sort_key>
          <first_name>Christina</first_name>
          <last_name>Garman</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>christinagarman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>15</sort_key>
          <first_name>Jeremiah</first_name>
          <last_name>Blocki</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>jeremiahblocki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>16</sort_key>
          <first_name>Pierre-David</first_name>
          <last_name>Letourneau</last_name>
          <affiliation>Reservoir Labs</affiliation>
          <bio>undefined</bio>
          <person_id>pierredavidletourneau</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>17</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Meister</last_name>
          <affiliation>Reservoir Labs</affiliation>
          <bio>undefined</bio>
          <person_id>benoitmeister1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>18</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Springer</last_name>
          <affiliation>Reservoir Labs</affiliation>
          <bio>undefined</bio>
          <person_id>jonathanspringer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>19</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>20</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University. 
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures. 
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University. I received an NSF CAREER Award in 2012, a Department of Energy Early Career Research Award in 2013, and the Presidential Early Career Award for Scientists and Engineers in 2016.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
          <person_id>milindkulkarni</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>fa5313ac-08df-4777-97dc-f14864b32259</slot_id>
      <event_id>bdc15ba9-7bbe-4361-bc81-f63ec2005af2</event_id>
      <submission_id>35</submission_id>
      <title>Type-safe generation of modules in applicative and generative styles</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:15</end_time>
      <description>The MetaML approach for multi-stage programming provides the static guarantee of type safety and scope safety for generated code regardless of the actual values of static parameters. While the traditional MetaML approach is restricted to term generation, Watanabe et al. presents a preliminary study on a two-stage language for generating ML-style modules, which provides high-level abstractions for large-scale programming. Unfortunately, their language has the problems of limited expressiveness and incomplete proofs of properties, and also an efficiency problem (the code-explosion problem). Recently, Sato et al. solved the latter issue, while the former problems are left as they are. This paper introduces refined two-stage programming languages for generating ML-style modules, which solve the above issues. Our languages accommodate module generation for two different module styles: first-class modules with generative functors and second-class modules with applicative functors, which are supported, but cannot be generated by MetaOCaml. Since generative functors and applicative functors have their own merits and demerits, our languages can be a better basis for the study of module generation. We also present a type-preserving translation from our languages to plain MetaOCaml, and an implementation based on the translations. Finally, we show the result of our experiments against a microbencmark, which shows that our translation does not have the code-explosion problem, and there are cases where module-generation is effective for program specialization.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuhi</first_name>
          <last_name>Sato</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
          <person_id>yuhisato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yukiyoshi</first_name>
          <last_name>Kameyama</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tsukuba.ac.jp/~kam/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yukiyoshikameyama/a7ae9aee-0992-4ddf-ae1d-6fee59d9e814/small.jpg</picture_url>
          <person_id>yukiyoshikameyama</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>82bb2bd3-0b59-4194-a3b3-40b0fa47eb0c</subevent_id>
    <title>GPCE: GPCE/SLE Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/gpce-2021</url>
    <url_link_display>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2021</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>69d77a2d-770b-41a2-a42b-56535e9fdd22</slot_id>
      <title>Session: GPCE - GPCE/SLE Session 2</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Eli</first_name>
          <last_name>Tilevich</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.vt.edu/~tilevich</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/elitilevich/10b9c85c-8a75-4acb-a0fe-e00c91dd0bb6/small.jpg</picture_url>
          <person_id>elitilevich</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>67d1a165-ec8c-441d-98c7-efa3eec6da23</slot_id>
      <event_id>c5b4c471-5d34-49c8-b9cf-38139c8819c2</event_id>
      <submission_id>6</submission_id>
      <title>Executing Certified Model Transformations on Apache Spark</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>19:35</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:50</end_time>
      <description>Formal reasoning on model transformation languages allows users to certify model transformations against transformation contracts. The CoqTL language includes a specification of a transformation engine in the Coq interactive theorem prover. An executable engine can be automatically extracted from this specification. Transformation contracts are proved by the user against the CoqTL specification and guaranteed to hold on the transformation running on the extracted implementation of CoqTL. The design of the transformation engine specification in CoqTL aims at simplifying the certification step, but this requirement harms the execution performance of the extracted engine. In this paper, we aim at providing a scalable distributed implementation of the CoqTL specification. To achieve this objective we proceed in two steps. First, we introduce a refined specification of CoqTL that increases the engine parallelization. We present a mechanized proof of the equivalence with standard CoqTL. Second, we develop a prototype implementation of the refined specification, on top of Spark, a modern data-analytics distributed framework. Finally, by evaluating the performance of a simple case study, we assess the speedup our solution can reach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jolan</first_name>
          <last_name>Philippe</last_name>
          <affiliation>IMT Atlantique</affiliation>
          <bio>undefined</bio>
          <person_id>jolanphilippe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Massimo</first_name>
          <last_name>Tisi</last_name>
          <affiliation>IMT Atlantique, LS2N (UMR CNRS 6004)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://massimotisi.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/massimotisi2/37b12ca8-08d4-430c-a957-9fb868e2dc97/small.jpg</picture_url>
          <person_id>massimotisi2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hélène</first_name>
          <last_name>Coullon</last_name>
          <affiliation>IMT Atlantique</affiliation>
          <bio>undefined</bio>
          <person_id>helenecoullon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gerson</first_name>
          <last_name>Sunyé</last_name>
          <affiliation>Université de Nantes, LS2N</affiliation>
          <bio>undefined</bio>
          <person_id>gersonsunye1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>83ff1168-17fb-42f7-94b0-5887e2012ebc</slot_id>
      <event_id>39b6d8a1-da11-453e-a8a4-16fb2f3bf829</event_id>
      <submission_id>18</submission_id>
      <title>New Ideas: Automated Engineering of Metamorphic Testing Environments for Domain-Specific Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:58</end_time>
      <description>Domain-specific languages (DSLs) encompass syntax and semantics. Two crucial aspects for the trustworthy application of DSLs within development projects are their semantic correctness, and proper testing support for their users. Testing is frequently used to verify correctness, but is often done informally – which may yield unreliable results – and requires substantial effort for creating suitable test cases and oracles. 
To alleviate this situation, we propose an automated technique for building metamorphic testing environments for DSLs. Metamorphic testing identifies expected relationships between the outputs of two consecutive tests, reducing the effort in specifying oracles and creating test cases manually. This new ideas paper presents the overarching concepts, the architecture and a prototype implementation. We illustrate our proposal using a DSL to model and simulate data centres.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pablo C</first_name>
          <last_name>Canizares</last_name>
          <affiliation>Autonomous University of Madrid, Spain</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/pabloccanizares/0e147de1-ab7c-403a-9653-8f2fa4a6d926/small.jpg</picture_url>
          <person_id>pabloccanizares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pablo</first_name>
          <last_name>Gómez-Abajo</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>Pablo Gómez-Abajo is an assistant professor at the department of computer science of the Universidad Autónoma de Madrid. He got his bachelor’s degree in 2006 and after 8 years in the industry, he returned to Academia and joined the Modelling and Software Engineering research group in 2015. He finished his master’s degree in research in computer science in 2016 with a special mention in his final project “A framework for the automated generation of exercises via model mutation”. He has three publications in journals and has participated in five international conferences. He finished his PhD in computer science “A domain-specific language for model mutation” in 2020 with the highest possible mark.</bio>
          <homepage_url>https://www.gomezabajo.es/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/pablogomezabajo/f86cfe1f-2cd4-4162-8783-bfadb31a06ea/small.jpg</picture_url>
          <person_id>pablogomezabajo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Alberto</first_name>
          <last_name>Núňez</last_name>
          <affiliation>University Complutense of Madrid, Spain.</affiliation>
          <bio>Alberto Núñez was born in Valencia, Spain, in 1980. He received the M.Sc. and Ph.D. degrees in computer science from the Carlos III University of Madrid, Spain, in 2005 and 2011, respectively. He is currently an Associate Professor with the Software Systems and Computation Department, Complutense University of Madrid, Spain. He has published more than 40 research papers in journals, books, and national and international conferences. His research interests include formal testing, performance analysis, high performance computing, and modelling of cloud systems, especially on how to perform models and simulations. He received the IBM Ph.D. Fellowship Award, in 2009. He regularly serves on the Program Committee of conferences, such as IWANN, MeT and ICCCI.</bio>
          <homepage_url>http://antares.sip.ucm.es/cana/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/albertonunez/4d1b4ca1-b74f-4849-826c-3c5c395fd6ab/small.jpg</picture_url>
          <person_id>albertonunez</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Esther</first_name>
          <last_name>Guerra</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/estherguerra/97c7b02d-4019-49ce-a45a-4bd908e4c2a2/small.jpg</picture_url>
          <person_id>estherguerra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Autonomous University of Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a1736588-44b2-43dc-a83d-b89f59598574</slot_id>
      <event_id>7b1c0828-cfd5-49ff-8467-9f341079e0cd</event_id>
      <title>Discussion, Questions, Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>19:58</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>beca5ccd-7a3c-4efb-9d70-d7a5816665ec</slot_id>
      <event_id>52162c2c-b58f-4bf6-8bfd-aa4df8dc3e4b</event_id>
      <title>GPCE Keynote - Live Programming and Programming by Example: Better Together</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:20</end_time>
      <description>Live programming is a paradigm in which values from program execution are shown to the programmer through continual feedback. Programming by example is a paradigm in which code is synthesized from example values showing a desired behavior. This talk presents some of our recent research that combines these two paradigms in beneficial ways. I will walk through our ideas, explain our contributions, discuss what we learned and finally provide thoughts for the future.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sorin</first_name>
          <last_name>Lerner</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/users/lerner/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sorinlerner/3d3b1a70-e2f8-4d3a-a1bc-9c4e17dad80b/small.jpg</picture_url>
          <person_id>sorinlerner</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>c7e35207-8836-4b75-ac69-ded5d76229da</slot_id>
      <event_id>2b3eb64f-c0f9-4ad3-b113-1dec06a4f5f9</event_id>
      <submission_id>20</submission_id>
      <title>Automating the Synthesis of Recommender Systems for Modelling Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>19:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:35</end_time>
      <description>We are witnessing an increasing interest in building recommender systems (RSs) for all sorts of Software Engineering activities. Modelling is no exception to this trend, as modelling environments are being enriched with RSs that help building models by providing recommendations based on previous solutions to similar problems in the same domain. However, building a RS from scratch requires considerable effort and specialized knowledge. 
To alleviate this problem, we propose an automated approach to the generation of RSs for modelling languages. Our approach is model-based, and so we provide a domain-specific language called Droid to configure every aspect of the RS (like the type and features of the recommended items, the recommendation method, and the evaluation metrics). The RS so configured can be deployed as a service, and we provide an out-of-the-box integration of this service with the EMF tree editor. To assess the usefulness of our proposal, we present a case study on the integration of a generated RS with an existing modelling chatbot, and report an offline experiment that yields promising results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lissette</first_name>
          <last_name>Almonte</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://droid-dsl.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lissettealmonte/e8fbe316-0ed0-4aad-8bc6-17a59c206258/small.jpg</picture_url>
          <person_id>lissettealmonte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sara</first_name>
          <last_name>Perez-Soler</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <person_id>saraperezsoler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Esther</first_name>
          <last_name>Guerra</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/estherguerra/97c7b02d-4019-49ce-a45a-4bd908e4c2a2/small.jpg</picture_url>
          <person_id>estherguerra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Iván</first_name>
          <last_name>Cantador</last_name>
          <affiliation>Universidad Autonoma de Madrid</affiliation>
          <bio>undefined</bio>
          <person_id>ivancantador</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Autonomous University of Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>41448e13-c778-4930-a497-4cfbed11d82b</subevent_id>
    <title>GPCE: GPCE/SLE Session 3</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/gpce-2021</url>
    <url_link_display>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot>
      <slot_id>e57fdb22-d3a8-4a7d-a0bc-a0f0ee49d511</slot_id>
      <title>Session: GPCE - GPCE/SLE Session 3</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Davide</first_name>
          <last_name>Di Ruscio</last_name>
          <affiliation>University of L'Aquila</affiliation>
          <bio>Davide Di Ruscio is Associate Professor at the Department of Information Engineering Computer Science and Mathematics of the University of L’Aquila (Italy). His main research interests are related to several aspects of Model Driven Engineering (MDE) including domain specific modelling languages, model transformations, model differencing, and model evolution. Over the last decade, he has applied MDE techniques in different application domains including service-based software systems, autonomous systems, and open source software (OSS). He has been in the PC and involved in the organization of several workshops and conferences, and served as reviewer for many journals like IEEE Transactions on Software Engineering, Empirical Software Engineering, Science of Computer Programming, Software and Systems Modeling, and Journal of Systems and Software. Currently, he is the technical director of the EU H2020 CROSSMINER project (http://www.crossminer.org)</bio>
          <homepage_url>http://people.disim.univaq.it/diruscio</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidediruscio/7e305e30-5b6a-4249-9a66-fbfbfe2db31b/small.jpg</picture_url>
          <person_id>davidediruscio</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1ffec9c5-9034-49c1-80a9-49eb444bc2d9</slot_id>
      <event_id>6cb74ab3-5834-4f3e-b5c6-56c554779d1d</event_id>
      <submission_id>3</submission_id>
      <title>Towards Supporting SPL Engineering in Low-Code Platforms using a DSL Approach</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:35</end_time>
      <description>Low-code platforms enable those who are now called citizen developers to autonomously build complete applications, such as web applications or mobile applications. Some of these platforms also offer support for reuse to facilitate the development of similar applications. The offered mechanisms are usually elementary, they allow module reuse or building a new application from a template. However, they are insufficient to achieve the industrial level reuse necessary for software product lines (SPL). In fact, these platforms were conceived to help building standalone applications, not software families and even fewer software product lines. The paper argues that the major limitation is that these platforms seldom provide access to their metamodel, the access to application’s models and code is also limited and, therefore, makes it harder to analyze commonality and variability and construct models based on it. The paper proposes an approach to surpass these limitations: firstly, a metamodel of the applications built with the platform is obtained, and then, based on the metamodel, a domain-specific language (DSL) that can express the models of the applications, including variability, is constructed. With this DSL, users can easily combine and reuse models from different applications to explore and build similar applications. The solution is illustrated with an industrial case study. A discussion of the results is presented as well as its limitations and related work. The authors hope that this work provides inspiration and some ideas that the community can explore to facilitate the adoption and implementation of SPLs in the context, and supported by, low-code platforms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexandre</first_name>
          <last_name>Bragança</last_name>
          <affiliation>Institute of Engineering of Porto – Polytechnic of Porto (ISEP/IPP)</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexandrebraganca/a975d705-f884-420d-ab29-5b9ad36430b3/small.jpg</picture_url>
          <person_id>alexandrebraganca</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isabel</first_name>
          <last_name>Azevedo</last_name>
          <affiliation>Games, Interaction and Learning Technologies (GILT) - Institute of Engineering of Porto – Polytechnic of Porto (ISEP/IPP)</affiliation>
          <bio>undefined</bio>
          <person_id>isabelazevedo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nuno</first_name>
          <last_name>Bettencourt</last_name>
          <affiliation>Interdisciplinary Studies Research Center (ISRC) – Institute of Engineering of Porto – Polytechnic of Porto (ISEP/IPP)</affiliation>
          <bio>undefined</bio>
          <person_id>nunobettencourt</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Carlos</first_name>
          <last_name>Morais</last_name>
          <affiliation>NumbersBelieve</affiliation>
          <bio>undefined</bio>
          <person_id>carlosmorais</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Diogo</first_name>
          <last_name>Teixeira</last_name>
          <affiliation>NumbersBelieve</affiliation>
          <bio>undefined</bio>
          <person_id>diogoteixeira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>David</first_name>
          <last_name>Caetano</last_name>
          <affiliation>NumbersBelieve</affiliation>
          <bio>undefined</bio>
          <person_id>davidcaetano</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>39cf6b6c-d2d8-4688-b9e2-173ded2a369d</slot_id>
      <event_id>2f5730cd-6e81-4edf-950f-b18abe169215</event_id>
      <submission_id>28</submission_id>
      <title>On-Stack Replacement for Program Generators and Source-to-Source Compilers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:50</end_time>
      <description>On-stack replacement (OSR) describes the ability to replace currently executing code with a different version, either a more optimized one (tiered execution) or a more general one (deoptimization to undo speculative optimization). While OSR is a key component in all modern VMs for languages like Java or JavaScript, OSR has only recently been studied as a more abstract program transformation, independent of language VMs. Still, previous work has only considered OSR in the context of low-level execution models based on stack frames, labels, and jumps. 
With the goal of making OSR more broadly applicable, this paper presents a surprisingly simple pattern for implementing OSR in source-to-source compilers or explicit program generators that target languages with structured control flow (loops and conditionals). We evaluate our approach through experiments demonstrating both tiered execution and speculative optimization, based on representative code patterns in the context of a state-of-the-art in-memory database system that compiles SQL queries to C at runtime. We further show that casting OSR as a high-level transformation enables new speculative optimization patterns beyond what is commonly implemented in language VMs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gregory</first_name>
          <last_name>Essertel</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>gregoryessertel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ruby</first_name>
          <last_name>Tahboub</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/rtahboub/index.htm</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rubytahboub/860662b0-0580-4bac-bb8a-64b7849333a2/small.jpg</picture_url>
          <person_id>rubytahboub</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>49cb1292-1f76-4268-96cf-0be010d36316</slot_id>
      <event_id>e27d703b-7803-4980-b6f0-2b57ef2e63ab</event_id>
      <submission_id>2</submission_id>
      <title>The Life Cycle of Features in Highly-Configurable Software Systems Evolving in Space and Time</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:20</end_time>
      <description>Feature annotation based on preprocessor directives is the most common mechanism in Highly-Configurable Software Systems (HCSSs) to select the features to be included in a system variant. However, it is challenging to understand, maintain, and evolve feature fragments guarded by #ifdef directives. Yet, despite HCSSs being implemented in Version Control Systems, the support for evolving features in space and time is still challenging. To extend the knowledge on this topic, we analyze the feature life cycle in space and time. Specifically, we introduce an automated mining approach and apply it to four HCSSs, analyzing commits of their entire development life cycle (13 to 20 years and 37500 commits). This goes beyond existing studies, which investigated only differences between releases or entire systems. Our results show that features undergo frequent changes, often with substantial modifications of their code. The findings of our empirical analyses stress the need for better support of system evolution in space and time at the level of features. In addition to these analyses, we contribute with an automated mining approach for the analysis of system evolution at the level of features. Furthermore, we also make available our dataset for new studies on feature evolution in HCSSs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriela Karoline</first_name>
          <last_name>Michelon</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>PhD student at Johannes Kepler University Linz as Junior Researcher at the Institute for Software Systems Engineering and LIT Secure and Correct Systems Lab. Graduated in Computer Science in 2016 at the University Federal Technological of Paraná – Campus Medianeira. Specialist in Software Engineering in 2018. Master in Computational Technologies for Agribusiness in 2018 at the Federal Technological University of Paraná - Campus Medianeira with a period of three months in the University of California, Davis.</bio>
          <homepage_url>https://gabrielamichelon.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gabrielakarolinemichelon/5ef51ae0-2922-412b-a3f8-b67dd546443d/small.jpg</picture_url>
          <person_id>gabrielakarolinemichelon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wesley</first_name>
          <last_name>Assunção</last_name>
          <affiliation>Pontifical Catholic University of Rio de Janeiro (PUC-Rio)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wesleyklewerton.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wesleyassuncao/c497acd7-b294-46fb-986e-a35f9fac27a1/small.jpg</picture_url>
          <person_id>wesleyassuncao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Obermann</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>undefined</bio>
          <person_id>davidobermann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Linsbauer</last_name>
          <affiliation>TU Braunschweig</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/lukaslinsbauer1/9bd521de-e5c5-40f4-8a48-c620cb6b4950/small.jpg</picture_url>
          <person_id>lukaslinsbauer1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Paul</first_name>
          <last_name>Grünbacher</last_name>
          <affiliation>Johannes Kepler University Linz, Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://paul.gruenbacher.at</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/paulgrunbacher/7cc53429-4f75-4f1e-85cc-90e400045b3a/small.jpg</picture_url>
          <person_id>paulgrunbacher</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Egyed</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>Alexander Egyed is Professor for Software-Intensive Systems at the Johannes Kepler University, Austria. He received his Doctorate from the University of Southern California, USA and worked in industry for many years. He is most recognized for his work on software and systems design – particularly on variability, consistency, and traceability.</bio>
          <homepage_url>http://www.alexander-egyed.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexanderegyed/b2c26061-4e47-42cc-ab6a-528e99583f7b/small.jpg</picture_url>
          <person_id>alexanderegyed</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>94e2ac92-1872-46b6-96e2-6f1a1427ae2d</slot_id>
      <event_id>ddf5336e-5697-40aa-a3b7-8562a642f07f</event_id>
      <submission_id>5</submission_id>
      <title>A Variational Database Management System</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:05</end_time>
      <description>Many problems require working with data that varies in its structure and content. Likewise, many tools have been developed to deal with different kinds of this problem, e.g., schema evolution tools or data integration tools. However, these approaches address only the specific kind of variation in databases resulting in two problems: Some fail to address all users’ needs for their specific kind of variation and all fail to address the interaction of different kinds of variation in databases. For example, neither schema evolution nor data integration systems can manage the data variation when an integrated database evolves over time. In this paper, we define a generic framework that explicitly accounts for variation in databases. Thus, it captures variation in the structure and content of a database and allows queries to express variational information needs. Our framework adds expressiveness to databases since it can encode any kind of variation. We design and implement a variational database management system as an abstraction layer over a traditional relational database. Using previously developed use cases that show the feasibility of our framework, we demonstrate the performance of different approaches used in our system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Parisa</first_name>
          <last_name>Ataei</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>parisaataei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fariba</first_name>
          <last_name>Khan</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>faribakhan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eric</first_name>
          <last_name>Walkingshaw</last_name>
          <affiliation>Unaffiliated</affiliation>
          <bio>undefined</bio>
          <person_id>ericwalkingshaw1</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>c4e7c51a-c348-44a2-8eaa-84a7f1103d72</slot_id>
      <event_id>a18c69f6-bf48-4e09-986b-b82097c5800f</event_id>
      <title>Discussion, Questions, Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>43ec501f-5440-4ae9-bf99-a4621e0b3a62</subevent_id>
    <title>SLE: SLE/GPCE Session 6</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sle-2021</url>
    <url_link_display>SLE (Software Language Engineering) 2021</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2021</track>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot>
      <slot_id>9956f5fb-e9b3-48fc-b131-bf2dfd258e18</slot_id>
      <title>Session: SLE - SLE/GPCE Session 6</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Vadim</first_name>
          <last_name>Zaytsev</last_name>
          <affiliation>University of Twente, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://grammarware.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vadimzaytsev/fe6c221f-75d5-4fbc-ac41-be9c99349b5d/small.jpg</picture_url>
          <person_id>vadimzaytsev</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>19d6f66b-50ee-4d34-bfb4-bff785a483ae</slot_id>
      <event_id>75bbcf77-fd35-49e7-a3ca-2450da7386b8</event_id>
      <submission_id>12</submission_id>
      <title>Vision: Bias in Systematic Grammar-Based Test Suite Construction Algorithms</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:43</end_time>
      <description>The core of grammar-based test suite construction algorithms is a procedure to derive a set of specific phrases, which are then converted into sentences that can be fed into the system under test. This process includes several degrees of freedom and different implementations choose different but ultimately fixed solutions. We show that these fixed choices inherently bias the generated test suite. 
We quantify these biases and evaluate the effect they have on coverage over the system under test for which the test suite is constructed. We show that the effect of these biases remain prevalent in large real world grammars and systems, even when the test suites grow very large.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoff</first_name>
          <last_name>Rossouw</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <person_id>christoffrossouw</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>66a427c9-9676-4955-a0c1-a49c11a88cd4</slot_id>
      <event_id>ba7452c9-2b20-416d-9e9d-2729e6174030</event_id>
      <submission_id>5</submission_id>
      <title>Fast Incremental PEG Parsing</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:05</end_time>
      <description>Incremental parsing is an integral part of code analysis performed by text editors and integrated development environments. This paper presents new methods to significantly improve the efficiency of incremental parsing for Parsing Expression Grammars (PEGs). We build on Incremental Packrat Parsing, an algorithm that adapts packrat parsing to an incremental setting, by implementing the memoization table as an interval tree with special support for shifting intervals, and modifying the memoization strategy to create tree structures in the table. Our approach enables reparsing in time logarithmic in the size of the input for typical edits, compared with linear-time reparsing for Incremental Packrat Parsing. We implement our methods in a prototype called GPeg, a parsing machine for PEGs with support for dynamic parsers (an important feature for runtime extensibility in editors). Experiments show that GPeg has strong performance (sub-5ms reparse times) across a variety of input sizes (tens to hundreds of megabytes) and grammar types (from full language grammars to “island” grammars), and compares well with existing incremental parsers. As a complete application example, we also implement a syntax highlighting engine on top of GPeg, and a prototype editor, along with some optimizations for this particular use-case.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Yedidia</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zyedidia.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zacharyyedidia/c3ff7e7b-9e7e-420d-b5f6-648765cbe62b/small.jpg</picture_url>
          <person_id>zacharyyedidia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chong</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Stephen Chong is a Gordon McKay Professor of Computer Science in the Harvard John A. Paulson School of Engineering and Applied Sciences. Steve’s research focuses on programming languages, information security, and the intersection of these two areas. He is the recipient of an NSF CAREER award, an AFOSR Young Investigator award, and a Sloan Research Fellowship. He received a PhD from Cornell University, and a bachelor’s degree from Victoria University of Wellington, New Zealand.</bio>
          <homepage_url>https://people.seas.harvard.edu/~chong/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stephenchong/91e43651-bcd6-40dc-b231-4c92711b0e95/small.jpg</picture_url>
          <person_id>stephenchong</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>7f590a54-071b-418c-b916-fc5b9313d9cf</slot_id>
      <event_id>d2a351ab-6925-489a-973b-88f21de65a05</event_id>
      <submission_id>33</submission_id>
      <title>Automatic Grammar Repair</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:35</end_time>
      <description>We describe the first approach to automatically repair bugs in context-free grammars: given a grammar that fails some tests in a given test suite, we iteratively and gradually improve the grammar until it passes all tests. Our core idea is to build on spectrum-based fault localization to identify promising repair sites (i.e., specific positions in rules), and to apply grammar patches at these sites whenever they satisfy explicitly formulated pre-conditions necessary to potentially improve the grammar. 
We have implemented this approach in the gfixr system, and successfully used it to fix grammars students submitted as homeworks in a compiler engineering course, and to map one Pascal dialect grammar against another dialect. 
gfixr can be configured to explore the repair space in different ways, and can also take advantage of counterexamples to enable restriction patches that make the grammar less permissive.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Moeketsi</first_name>
          <last_name>Raselimo</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/moeketsiraselimo/2f088517-eaa4-451a-befd-21f6bb9837f2/small.jpg</picture_url>
          <person_id>moeketsiraselimo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>9fa18985-efdc-40bc-9c63-c2ca9825d0d3</slot_id>
      <event_id>239feb7d-9134-4d66-a0af-d859a58d738b</event_id>
      <submission_id>15</submission_id>
      <title>Faster Reachability Analysis for LR(1) Parsers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:20</end_time>
      <description>We present a novel algorithm for reachability in an LR(1) automaton. For each transition in the automaton, the problem is to determine under what conditions this transition can be taken, that is, which (minimal) input fragment and which lookahead symbol allow taking this transition. Our algorithm outperforms Pottier’s algorithm (2016) by up to three orders of magnitude on real-world grammars. Among other applications, this vastly improves the scalability of Jeffery’s error reporting technique (2003), where a mapping of (reachable) error states to messages must be created and maintained.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Frédéric</first_name>
          <last_name>Bour</last_name>
          <affiliation>Tarides</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://def.lakaban.net</homepage_url>
          <person_id>fredericbour</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>François</first_name>
          <last_name>Pottier</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gallium.inria.fr/~fpottier/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/francoispottier/8f390103-6b3f-4cf0-8bf9-891b0596b9b7/small.jpg</picture_url>
          <person_id>francoispottier</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>b9c7b491-4cc0-454f-b1df-731e6a1c4605</slot_id>
      <event_id>9f8c7895-e581-40ad-b45a-960150a2f290</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>11:51</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e0494d8d-028b-4b6b-8c4b-324b13bd484b</slot_id>
      <event_id>9f6a14d7-8413-4511-b2ee-7881c6ccdfd5</event_id>
      <submission_id>22</submission_id>
      <title>Compiling pattern matching to in-place modifications</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>11:43</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:51</end_time>
      <description>Algebraic data types and pattern matching are extremely productive to build programs on complex datastructures in a safe yet efficient manner. There is a rich literature on how to compile them efficiently in the context of immutable use in functional programming languages. 
However, in the context of high-performance datastructures and languages allowing (controlled) mutations, we would like to describe efficient \emph{in-place} transformations of tree-like structures such as ADTs. Additionally, such transformations should take advantage of parallelism opportunities that naturally appear in such tree-like structures. 
We present early steps towards a new technique to compile pattern matching as parallel in-place modifications of the underlying memory representation. Towards this goal, we combine the usual language approach common in pattern-matching compilation with tools from the polyhedral model, which is commonly used in high-performance code generation to output efficient C code. We present our formalism, along with a prototype implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paul</first_name>
          <last_name>Iannetta</last_name>
          <affiliation>ENS Lyon</affiliation>
          <bio>undefined</bio>
          <person_id>pauliannetta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laure</first_name>
          <last_name>Gonnord</last_name>
          <affiliation>University of Lyon &amp; LIP, France</affiliation>
          <bio>Laure Gonnord received her PhD degree in computer science from the University Joseph Fourier (Grenoble, France), in 2007. She currently holds an assistant professor position at University Lyon I/UCBL, France. She got her Habilitation in 2017. 
Her main research interests lie in the design of static analyses, with emphasis on the automatic synthesis of numerical and memory invariants and application in compilation (scheduling) and termination proofs. She belongs to the CASH team of the LIP laboratory (ENS de Lyon, France).</bio>
          <homepage_url>http://laure.gonnord.org/pro</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lauregonnord/6b741986-7933-4cba-9205-8e5e8451d8fa/small.jpg</picture_url>
          <person_id>lauregonnord</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gabriel</first_name>
          <last_name>Radanne</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gabriel.radanne.net/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gabrielradanne/ae153ba4-dd3c-4cfd-bb04-bbf449802f9b/small.jpg</picture_url>
          <person_id>gabrielradanne</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>07c3d1f0-6836-4894-b342-ba4e3fad29fe</subevent_id>
    <title>SLE: SLE/GPCE Session 7</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sle-2021</url>
    <url_link_display>SLE (Software Language Engineering) 2021</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2021</track>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot>
      <slot_id>f6f4146b-502f-49ee-861b-e29f46610942</slot_id>
      <title>Session: SLE - SLE/GPCE Session 7</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Davide</first_name>
          <last_name>Di Ruscio</last_name>
          <affiliation>University of L'Aquila</affiliation>
          <bio>Davide Di Ruscio is Associate Professor at the Department of Information Engineering Computer Science and Mathematics of the University of L’Aquila (Italy). His main research interests are related to several aspects of Model Driven Engineering (MDE) including domain specific modelling languages, model transformations, model differencing, and model evolution. Over the last decade, he has applied MDE techniques in different application domains including service-based software systems, autonomous systems, and open source software (OSS). He has been in the PC and involved in the organization of several workshops and conferences, and served as reviewer for many journals like IEEE Transactions on Software Engineering, Empirical Software Engineering, Science of Computer Programming, Software and Systems Modeling, and Journal of Systems and Software. Currently, he is the technical director of the EU H2020 CROSSMINER project (http://www.crossminer.org)</bio>
          <homepage_url>http://people.disim.univaq.it/diruscio</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidediruscio/7e305e30-5b6a-4249-9a66-fbfbfe2db31b/small.jpg</picture_url>
          <person_id>davidediruscio</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Bahman</first_name>
          <last_name>Zamani</last_name>
          <affiliation>University of Isfahan</affiliation>
          <bio>Bahman Zamani holds a Ph.D. in Computer Science from Concordia University, Montreal, QC, Canada for his work on the pattern language verification. Currently, he is an associate professor in the department of software engineering, University of Isfahan, Isfahan, Iran. His main research interest is Model-Driven Software Engineering (MDSE). He is the founder and director of the MDSE Research Group at the University of Isfahan.</bio>
          <homepage_url>https://engold.ui.ac.ir/~zamani/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bahmanzamani/6fd0fd97-1a19-469e-9743-2399e560f039/small.jpg</picture_url>
          <person_id>bahmanzamani</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>38fbf58f-692d-4f86-b9fd-372f20a49233</slot_id>
      <event_id>eb9cb457-b2ba-4cca-8b8f-1ecfc278b4b3</event_id>
      <submission_id>36</submission_id>
      <title>Understanding and Improving Model-Driven IoT Systems Through Accompanying Digital Twins</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:35</end_time>
      <description>Developers questioning why their system behaves differently than expected often have to rely on time-consuming and error-prone manual analysis of log files. Understanding the behavior of Internet of Things (IoT) applications is a challenging task because they are not only inherently hard-to-trace distributed systems, but their integration with the environment via sensors adds another layer of complexity. Related work proposes to record data during the execution of the system, which can later be replayed to analyze the system. We apply the model-driven development approach to this idea and leverage digital twins to collect the required data. We enable developers to replay and analyze the system’s executions by applying model-to-model transformations. These transformations instrument component and connector (C&amp;amp;C) architecture models with components that reproduce the system’s environment based on the data recorded by the system’s digital twin. We validate and evaluate the feasibility of our approach using a heating, ventilation, and air conditioning (HVAC) case study. By facilitating the reproduction of the system’s behavior, our method lowers the barrier to understanding the behavior of model-driven IoT systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jörg</first_name>
          <last_name>Christian Kirchhof</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://se-rwth.de/staff/kirchhof</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgchristiankirchhof/65bf9d60-f8c4-423d-83fe-4289ee3c87d6/small.jpg</picture_url>
          <person_id>jorgchristiankirchhof</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Malcher</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <person_id>lukasmalcher</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bernhard</first_name>
          <last_name>Rumpe</last_name>
          <affiliation>RWTH Aachen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.se-rwth.de/staff/rumpe/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bernhardrumpe/0f827533-83ea-4f32-ba9e-eb8b70059217/small.jpg</picture_url>
          <person_id>bernhardrumpe</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>7a5cafc8-5fd0-41eb-8bee-6a18805965c6</slot_id>
      <event_id>a2fe5709-a6fb-4eb9-b442-79d81571dc0c</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d68b1f8a-7566-4059-ab34-5b89e51fbdb7</slot_id>
      <event_id>60d3efad-cea5-4f5b-8978-c0d7e8885703</event_id>
      <submission_id>15</submission_id>
      <title>Artifact and Reference Models for Generative AI Frameworks and Build Systems</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:50</end_time>
      <description>Machine learning is a discipline which has become ubiquitous in the last few years. While the research of AI algorithms is very active and continues to reveal astonishing possibilities on a regular basis, the wide usage of these algorithms is shifting the research focus to the integration, maintenance, and evolution of AI-driven systems. Although there is a variety of machine learning frameworks on the market, there is little support for process automation and DevOps in machine learning-driven projects. In this paper, we discuss how metamodels can support the development of deep learning frameworks and help deal with the steadily increasing variety of learning algorithms. In particular, we present a deep-learning-oriented artifact model which serves as a foundation for build automation and data management in iterative, machine learning-driven development processes. Furthermore, we show how schema and reference models can be used to structure and maintain a versatile deep learning framework. Feasibility is demonstrated on several compelling and relevant state-of-the-art examples from the domains of image and natural language processing as well as decision making and autonomous driving.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abdallah</first_name>
          <last_name>Atouani</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.abdallah.at/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/abdallahatouani/30b94b4a-0912-4283-afd0-38511a0bf7d1/small.jpg</picture_url>
          <person_id>abdallahatouani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jörg</first_name>
          <last_name>Christian Kirchhof</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://se-rwth.de/staff/kirchhof</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgchristiankirchhof/65bf9d60-f8c4-423d-83fe-4289ee3c87d6/small.jpg</picture_url>
          <person_id>jorgchristiankirchhof</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Evgeny</first_name>
          <last_name>Kusmenko</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <person_id>evgenykusmenko</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bernhard</first_name>
          <last_name>Rumpe</last_name>
          <affiliation>RWTH Aachen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.se-rwth.de/staff/rumpe/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bernhardrumpe/0f827533-83ea-4f32-ba9e-eb8b70059217/small.jpg</picture_url>
          <person_id>bernhardrumpe</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>e727f17c-2559-4b31-979f-62cc8c775a04</slot_id>
      <event_id>c4f8988a-f821-4472-877f-7debd62c4400</event_id>
      <submission_id>40</submission_id>
      <title>SEALS: A framework for building Self-Adaptive Virtual Machines</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:20</end_time>
      <description>Over recent years, self-adaptation has become a major concern for software systems that evolve in changing environments. While expert developers may choose a manual implementation when self-adaptation is the primary system concern, self-adaptation should be abstracted for non-expert developers or when it is a secondary system concern. We present SEALS, a framework for building self-adaptive virtual machines for domain-specific languages. This framework provides first-class entities for the language engineer to promote domain-specific feedback loops in the definition of the DSLoperational semantics. In particular, the framework supports the definition of (i) the abstract syntax and the semantics of the language as well as the correctness envelope defining the acceptable semantics for a domain concept, (ii) the feedback loop and associated trade-off reasoning, and (iii) the adaptations and the predictive model of their impact on the trade-off. We use this framework to build three languages with self-adaptive virtual machines and discuss the relevance of the abstractions, effectiveness of correctness envelopes, and compare their code size and performance results to their manually implemented counterparts. We show that the framework provides suitable abstractions for the implementation of self-adaptive operational semantics while introducing little performance overhead compared to a manual implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gwendal</first_name>
          <last_name>Jouneaux</last_name>
          <affiliation>Univ. Rennes, Inria, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.gwendal-jouneaux.fr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gwendaljouneaux/da056fcb-c509-4aaa-89bd-7eca0c55ce85/small.jpg</picture_url>
          <person_id>gwendaljouneaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes 1, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gunter</first_name>
          <last_name>Mussbacher</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/guntermussbacher/f1452019-54bd-4b93-bbdb-eaece6059e96/small.jpg</picture_url>
          <person_id>guntermussbacher</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>fc23166b-1c3b-4585-bc01-1a118fcbd0fa</slot_id>
      <event_id>10f4854e-9741-4aee-8e3a-44cf4712a53b</event_id>
      <submission_id>25</submission_id>
      <title>A DSL for Explanatory Decision Making</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:05</end_time>
      <description>We present a Haskell-embedded DSL for multi-attribute, multi-layered decision making. In addition to solving decision problems, an important feature of the DSL is the ability to generate explanations of why a computed optimal solution is better than its alternatives. 
The functional approach and Haskell’s type system support a high-level formulation of decision-making problems, which facilitates a number of innovations, including the gradual evolution and adaptation of problem representations, a more user-friendly form of sensitivity analysis based on problem domain data, and fine-grained control over explanations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Erwig</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.engr.oregonstate.edu/~erwig/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinerwig/8fd12ecd-2d70-44d3-a670-d5ef12393f9c/small.jpg</picture_url>
          <person_id>martinerwig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Prashant</first_name>
          <last_name>Kumar</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>prashantkumar1</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>707b7ba4-c780-4f57-9db7-1fe1076b0142</subevent_id>
    <title>GPCE: GPCE/SLE Session 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/gpce-2021</url>
    <url_link_display>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2021</track>
    </tracks>
    <timeslot>
      <slot_id>61c41c99-0c1c-40c1-97d7-f1e26bd92531</slot_id>
      <title>Session: GPCE - GPCE/SLE Session 2</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Coen</first_name>
          <last_name>De Roover</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~cderoove/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/coenderoover/ef3a26a6-56c3-420e-b1ce-b4a0e6cd653e/small.jpg</picture_url>
          <person_id>coenderoover</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2f458080-9a21-45ea-9d33-52ee189948dd</slot_id>
      <event_id>39b6d8a1-da11-453e-a8a4-16fb2f3bf829</event_id>
      <submission_id>18</submission_id>
      <title>New Ideas: Automated Engineering of Metamorphic Testing Environments for Domain-Specific Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:58</end_time>
      <description>Domain-specific languages (DSLs) encompass syntax and semantics. Two crucial aspects for the trustworthy application of DSLs within development projects are their semantic correctness, and proper testing support for their users. Testing is frequently used to verify correctness, but is often done informally – which may yield unreliable results – and requires substantial effort for creating suitable test cases and oracles. 
To alleviate this situation, we propose an automated technique for building metamorphic testing environments for DSLs. Metamorphic testing identifies expected relationships between the outputs of two consecutive tests, reducing the effort in specifying oracles and creating test cases manually. This new ideas paper presents the overarching concepts, the architecture and a prototype implementation. We illustrate our proposal using a DSL to model and simulate data centres.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pablo C</first_name>
          <last_name>Canizares</last_name>
          <affiliation>Autonomous University of Madrid, Spain</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/pabloccanizares/0e147de1-ab7c-403a-9653-8f2fa4a6d926/small.jpg</picture_url>
          <person_id>pabloccanizares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pablo</first_name>
          <last_name>Gómez-Abajo</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>Pablo Gómez-Abajo is an assistant professor at the department of computer science of the Universidad Autónoma de Madrid. He got his bachelor’s degree in 2006 and after 8 years in the industry, he returned to Academia and joined the Modelling and Software Engineering research group in 2015. He finished his master’s degree in research in computer science in 2016 with a special mention in his final project “A framework for the automated generation of exercises via model mutation”. He has three publications in journals and has participated in five international conferences. He finished his PhD in computer science “A domain-specific language for model mutation” in 2020 with the highest possible mark.</bio>
          <homepage_url>https://www.gomezabajo.es/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/pablogomezabajo/f86cfe1f-2cd4-4162-8783-bfadb31a06ea/small.jpg</picture_url>
          <person_id>pablogomezabajo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Alberto</first_name>
          <last_name>Núňez</last_name>
          <affiliation>University Complutense of Madrid, Spain.</affiliation>
          <bio>Alberto Núñez was born in Valencia, Spain, in 1980. He received the M.Sc. and Ph.D. degrees in computer science from the Carlos III University of Madrid, Spain, in 2005 and 2011, respectively. He is currently an Associate Professor with the Software Systems and Computation Department, Complutense University of Madrid, Spain. He has published more than 40 research papers in journals, books, and national and international conferences. His research interests include formal testing, performance analysis, high performance computing, and modelling of cloud systems, especially on how to perform models and simulations. He received the IBM Ph.D. Fellowship Award, in 2009. He regularly serves on the Program Committee of conferences, such as IWANN, MeT and ICCCI.</bio>
          <homepage_url>http://antares.sip.ucm.es/cana/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/albertonunez/4d1b4ca1-b74f-4849-826c-3c5c395fd6ab/small.jpg</picture_url>
          <person_id>albertonunez</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Esther</first_name>
          <last_name>Guerra</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/estherguerra/97c7b02d-4019-49ce-a45a-4bd908e4c2a2/small.jpg</picture_url>
          <person_id>estherguerra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Autonomous University of Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>3834568e-b209-4688-8de8-a8c31a901437</slot_id>
      <event_id>c5b4c471-5d34-49c8-b9cf-38139c8819c2</event_id>
      <submission_id>6</submission_id>
      <title>Executing Certified Model Transformations on Apache Spark</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:50</end_time>
      <description>Formal reasoning on model transformation languages allows users to certify model transformations against transformation contracts. The CoqTL language includes a specification of a transformation engine in the Coq interactive theorem prover. An executable engine can be automatically extracted from this specification. Transformation contracts are proved by the user against the CoqTL specification and guaranteed to hold on the transformation running on the extracted implementation of CoqTL. The design of the transformation engine specification in CoqTL aims at simplifying the certification step, but this requirement harms the execution performance of the extracted engine. In this paper, we aim at providing a scalable distributed implementation of the CoqTL specification. To achieve this objective we proceed in two steps. First, we introduce a refined specification of CoqTL that increases the engine parallelization. We present a mechanized proof of the equivalence with standard CoqTL. Second, we develop a prototype implementation of the refined specification, on top of Spark, a modern data-analytics distributed framework. Finally, by evaluating the performance of a simple case study, we assess the speedup our solution can reach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jolan</first_name>
          <last_name>Philippe</last_name>
          <affiliation>IMT Atlantique</affiliation>
          <bio>undefined</bio>
          <person_id>jolanphilippe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Massimo</first_name>
          <last_name>Tisi</last_name>
          <affiliation>IMT Atlantique, LS2N (UMR CNRS 6004)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://massimotisi.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/massimotisi2/37b12ca8-08d4-430c-a957-9fb868e2dc97/small.jpg</picture_url>
          <person_id>massimotisi2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hélène</first_name>
          <last_name>Coullon</last_name>
          <affiliation>IMT Atlantique</affiliation>
          <bio>undefined</bio>
          <person_id>helenecoullon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gerson</first_name>
          <last_name>Sunyé</last_name>
          <affiliation>Université de Nantes, LS2N</affiliation>
          <bio>undefined</bio>
          <person_id>gersonsunye1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>87763d57-c883-4cd1-aebb-e751018316c8</slot_id>
      <event_id>52162c2c-b58f-4bf6-8bfd-aa4df8dc3e4b</event_id>
      <title>GPCE Keynote - Live Programming and Programming by Example: Better Together</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:20</end_time>
      <description>Live programming is a paradigm in which values from program execution are shown to the programmer through continual feedback. Programming by example is a paradigm in which code is synthesized from example values showing a desired behavior. This talk presents some of our recent research that combines these two paradigms in beneficial ways. I will walk through our ideas, explain our contributions, discuss what we learned and finally provide thoughts for the future.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sorin</first_name>
          <last_name>Lerner</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/users/lerner/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sorinlerner/3d3b1a70-e2f8-4d3a-a1bc-9c4e17dad80b/small.jpg</picture_url>
          <person_id>sorinlerner</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>ae0ac8cf-dcc0-42a0-b988-81ba90275fed</slot_id>
      <event_id>7b1c0828-cfd5-49ff-8467-9f341079e0cd</event_id>
      <title>Discussion, Questions, Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>11:58</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca9dddc0-b338-4328-8c3e-8d968fab15e4</slot_id>
      <event_id>2b3eb64f-c0f9-4ad3-b113-1dec06a4f5f9</event_id>
      <submission_id>20</submission_id>
      <title>Automating the Synthesis of Recommender Systems for Modelling Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:35</end_time>
      <description>We are witnessing an increasing interest in building recommender systems (RSs) for all sorts of Software Engineering activities. Modelling is no exception to this trend, as modelling environments are being enriched with RSs that help building models by providing recommendations based on previous solutions to similar problems in the same domain. However, building a RS from scratch requires considerable effort and specialized knowledge. 
To alleviate this problem, we propose an automated approach to the generation of RSs for modelling languages. Our approach is model-based, and so we provide a domain-specific language called Droid to configure every aspect of the RS (like the type and features of the recommended items, the recommendation method, and the evaluation metrics). The RS so configured can be deployed as a service, and we provide an out-of-the-box integration of this service with the EMF tree editor. To assess the usefulness of our proposal, we present a case study on the integration of a generated RS with an existing modelling chatbot, and report an offline experiment that yields promising results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lissette</first_name>
          <last_name>Almonte</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://droid-dsl.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lissettealmonte/e8fbe316-0ed0-4aad-8bc6-17a59c206258/small.jpg</picture_url>
          <person_id>lissettealmonte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sara</first_name>
          <last_name>Perez-Soler</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <person_id>saraperezsoler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Esther</first_name>
          <last_name>Guerra</last_name>
          <affiliation>Universidad Autónoma de Madrid</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/estherguerra/97c7b02d-4019-49ce-a45a-4bd908e4c2a2/small.jpg</picture_url>
          <person_id>estherguerra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Iván</first_name>
          <last_name>Cantador</last_name>
          <affiliation>Universidad Autonoma de Madrid</affiliation>
          <bio>undefined</bio>
          <person_id>ivancantador</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Juan</first_name>
          <last_name>de Lara</last_name>
          <affiliation>Autonomous University of Madrid</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arantxa.ii.uam.es/~jlara/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juandelara/36b5a702-1b04-48b9-8849-869aa603a88d/small.jpg</picture_url>
          <person_id>juandelara</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c544714c-1477-4cf0-bf1a-fe400b858e8b</subevent_id>
    <title>GPCE: GPCE/SLE Session 4</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/gpce-2021</url>
    <url_link_display>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2021</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>86125ad8-ef14-46f7-b8ed-ef4a66a68d4f</slot_id>
      <title>Session: GPCE - GPCE/SLE Session 4</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Barash</last_name>
          <affiliation>University of Bergen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dsl-course.org/mikbar/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mikhailbarash/d876d731-3779-4e11-8aee-de2bcef5e938/small.jpg</picture_url>
          <person_id>mikhailbarash</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>08ac11b5-3ccb-430f-a503-44c86281b8c6</slot_id>
      <event_id>65df9844-070c-4122-adea-ff24e69cdcd3</event_id>
      <submission_id>18</submission_id>
      <title>Extracting The Power of Dependent Types</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>08:25</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>08:40</end_time>
      <description>Most existing programming languages provide little support to formally state and prove properties about programs. Ad-ding such capabilities is far from trivial, as it requires significant re-engineering of the existing compilers and tools. This paper proposes a novel technique to write correct-by-con-struc-tion programs in languages without built-in verification capabilities, while maintaining the ability to use existing tools. This is achieved in three steps. Firstly, we give a shallow embedding of the language (or a subset) into a dependently typed language. Secondly, we write a program in that embedding, and we use dependent types to guarantee correctness properties of interest. Thirdly, we extract a program written in the original language, so that it can be used by the existing compilers and tools. 
Our main insight is that it is possible to express all three steps in a single language that supports both dependent typ-es and reflection. Essentially, this allows us to express a program, its formal properties, and a compiler for it hand-in-hand, offering a lot of flexibility to programmers. We demonstrate this three-step approach by embedding a subset of the PostScript language in Agda, and illustrating it with several short examples. Thus we use the power of reflection to bring the benefits of dependent types to languages that had to go without them so far.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Artjoms</first_name>
          <last_name>Šinkarovs</last_name>
          <affiliation>Heriot-Watt University, UK</affiliation>
          <bio>undefined</bio>
          <person_id>artjomssinkarovs</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jesper</first_name>
          <last_name>Cockx</last_name>
          <affiliation>TU Delft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jesper.sikanda.be</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jespercockx/113f5ec5-aa52-443e-93e2-e7d8d136577b/small.jpg</picture_url>
          <person_id>jespercockx</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>3460ea24-2bc5-41d7-a154-219a5484d365</slot_id>
      <event_id>138aa42e-f060-4c89-8f76-da77c5521751</event_id>
      <submission_id>30</submission_id>
      <title>There Is More Than One Way to Zen Your Python</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>07:55</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>08:10</end_time>
      <description>The popularity of Python can be at least partially attributed to the concept of pythonicity, loosely defined as a combination of good practices accepted within the community. Despite the popularity of both Python itself and the pythonicity of code written in it, this concept has not been studied that well, and the first attempts to define it formally are rather recent. 
In this paper, we take the next steps in exploring this topic by conducting an independent literature review in order to create a catalogue of pythonic idioms, reproduce the results of a recent paper on the usage of pythonic idioms, perform an external direct replication of it by reusing the same open source toolset and dataset, and extend the body of knowledge by also analysing how the use of pythonic idioms evolve over time in open source codebases.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aamir</first_name>
          <last_name>Farooq</last_name>
          <affiliation>Universiteit Twente</affiliation>
          <bio>undefined</bio>
          <person_id>aamirfarooq</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vadim</first_name>
          <last_name>Zaytsev</last_name>
          <affiliation>University of Twente, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://grammarware.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vadimzaytsev/fe6c221f-75d5-4fbc-ac41-be9c99349b5d/small.jpg</picture_url>
          <person_id>vadimzaytsev</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a20e13d2-6867-46bd-b865-08ad6378ac27</slot_id>
      <event_id>5c03a4dc-23f5-48ee-86f6-f3a571c4d6d1</event_id>
      <submission_id>28</submission_id>
      <title>Getting Grammars into Shape for Block-based Editors</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>08:10</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>08:25</end_time>
      <description>Block-based programming environments allow users to program by interactively arranging visual jigsaw-like program elements. They have shown to be helpful in several domains, but often require experienced developers for their creation. Previous research investigated the use of language frameworks to generate block-based editors based on grammars, but often the results provided too many, unnecessary kinds of blocks, leading to verbose and less concise environments and also programs. 
To reduce the number of interactions, we propose the use of a pipeline of transformations to simplify the original grammar, yielding a reduction of the number of (useful) kinds of blocks available in the resulting editors. We show that, up to a certain complexity, our generated block-based editors are significantly improved with respects to a set of observed aesthetic criteria. As such, analyzing and simplifying grammars before generating block-based editors allows us to derive more compact and potentially more usable block-based editors, making reuse of existing grammars through automatic generation feasible.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mauricio</first_name>
          <last_name>Verano Merino</last_name>
          <affiliation>Eindhoven University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://maveme.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mauricioveranomerino/e4a3ec56-b66f-4885-9989-c4a230e08446/small.jpg</picture_url>
          <person_id>mauricioveranomerino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tom</first_name>
          <last_name>Beckmann</last_name>
          <affiliation>Hasso Plattner Institute</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/tombeckmann/338eaf6c-48cf-4dbc-920b-e36a0853d7d3/small.jpg</picture_url>
          <person_id>tombeckmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tijs</first_name>
          <last_name>van der Storm</last_name>
          <affiliation>CWI &amp; University of Groningen, Netherlands</affiliation>
          <bio>Tijs van der Storm is senior researcher in the Software Analysis and Transformation (SWAT) group at Centrum Wiskunde &amp;amp; Informatica (CWI) in Amsterdam, and full professor in Software Engineering at the University of Groningen in Groningen. His research focuses on improving programmer experience through new and better software languages and developing the tools and techniques to engineer them in a modular and interactive fashion.</bio>
          <homepage_url>http://www.cwi.nl/~storm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tijsvanderstorm/1c2fdfb2-3ce0-4e75-91af-35d9a48f56c5/small.jpg</picture_url>
          <person_id>tijsvanderstorm</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robert</first_name>
          <last_name>Hirschfeld</last_name>
          <affiliation>Hasso Plattner Institute (HPI), University of Potsdam, Germany</affiliation>
          <bio>Robert Hirschfeld is a Professor of Computer Science at the Hasso Plattner Institute at the University of Potsdam, Germany. There he founded and leads the Software Architecture Group which is concerned with fundamental elements and structures of software. Methods and tools are developed for improving the comprehension and design of complex and interesting systems. 
Robert is interested in programming experiences and small system kernels. With his group he is working on dynamic programming languages, development tools, and runtime environments to make interactive programming more approachable. His preferred environment for exploring ideas is Squeak/Smalltalk. 
He served as a visiting professor at the Tokyo Institute of Technology (東京工業大学) and The University of Tokyo (東京大学), Japan. 
Robert was a senior researcher with DoCoMo Euro-Labs, the European research facility of NTT DoCoMo Japan, where he worked on infrastructure components for next generation mobile communication systems with a focus on dynamic service adaptation and context-oriented programming. 
Prior to joining DoCoMo Euro-Labs, he was a principal engineer at Windward Solutions in Sunnyvale, California, where he designed and implemented distributed object systems, consulted in the area of object database technologies, and developed innovative software products and applications. 
Robert received a PhD in Computer Science from the Ilmenau University of Technology, Germany.</bio>
          <homepage_url>http://www.hirschfeld.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/roberthirschfeld/994ef4df-a890-4f16-bc1b-73b117dab33c/small.jpg</picture_url>
          <person_id>roberthirschfeld</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jurgen</first_name>
          <last_name>Vinju</last_name>
          <affiliation>CWI, Netherlands</affiliation>
          <bio> 
 Researcher, see http://jurgen.vinju.org, in 
   
   Software Language Engineering 
   Programming Languages 
   Empirical Software Engineering 
   Software Evolution 
    
 (Co)-Designer and/or (co-)engineer of (selected): 
   
   Rascal Metaprogramming Language http://www.rascalmpl.org 
   Rascal VScode https://github.com/usethesource/rascal-language-servers 
   Vallang http://www.usethesource.io/projects/vallang 
   IMP http://www.eclipse.org/imp, now Impulse http:www.usethesource.io/projects/impulse 
   OSSMETER http://www.ossmeter.org 
   ASF+SDF Meta-Environment http://www.meta-environment.org 
   SDF2 http://www.syntax-definition.org 
    
 Titles 
   
   Full professor of Automated Software Analysis at TU Eindhoven 
   Group leader Software Analysis and Transformation at Centrum Wiskunde &amp;amp; Informatica https://www.cwi.nl/research/groups/software-analysis-and-transformation 
   Co-owner of SWAT.engineering BV http://www.swat.engineering 
    
</bio>
          <homepage_url>http://homepages.cwi.nl/~jurgenv</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jurgenvinju/31e5a54c-e7a3-4c37-b0c9-ca2254e3ef59/small.jpg</picture_url>
          <person_id>jurgenvinju</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>f68f3c19-84aa-438f-b86c-8ad5f3014ca9</slot_id>
      <event_id>de486fbd-4c97-4db6-a4ce-77c8e522f331</event_id>
      <title>Discussion, Questions, Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>faf72645-90c5-4398-8afd-c4330f143f47</slot_id>
      <event_id>f340a855-bbd0-40ac-b6c6-e866e008342a</event_id>
      <submission_id>38</submission_id>
      <title>A Concurrency Model for JavaScript with Cooperative Cancellation</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>07:55</end_time>
      <description>This paper proposes a concurrency model with thread abstractions and cooperative cancellation for JavaScript. JavaScript uses an event-driven model, where an active computation runs until it completes or blocks for an event while concurrent computations wait for events as callbacks. With the introduction of Promises, the control flow of callbacks can be written in a more direct style. However, the event-based model is still a source of confusion with regard to execution order, race conditions, and termination of computations. 
Thread model is a familiar concept to programmers and can help reduce errors in developing JavaScript programs. This work is a library-based design, which uses an abstraction based on reader monad to pass a thread ID through a thread’s computation. A thread can be cancelled, paused, and resumed with its thread ID. This design allows hierarchical cancellation where a child thread is cancelled if its parent is cancelled. It also defines synchronization primitives to protect shared states. A formal semantics is included to give a precise definition of the proposed model.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tian</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Wisconsin-Milwaukee</affiliation>
          <bio>undefined</bio>
          <person_id>tianzhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yonglun</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Wisconsin -- Milwaukee</affiliation>
          <bio>undefined</bio>
          <person_id>yonglunli</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f1abaf87-6841-4eb4-a92a-3c8c0ac2a076</subevent_id>
    <title>SLE: SLE/GPCE Session 5</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sle-2021</url>
    <url_link_display>SLE (Software Language Engineering) 2021</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2021</track>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>30dcb99f-50c1-4d85-8813-3c6906b693a1</slot_id>
      <title>Session: SLE - SLE/GPCE Session 5</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Paddy</first_name>
          <last_name>Krishnan</last_name>
          <affiliation>Oracle Labs, Australia</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/paddykrishnan/36e9562d-4d3c-47a8-a27b-cdae9ff14c32/small.jpg</picture_url>
          <person_id>paddykrishnan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>502820f7-dd23-4c74-ab80-5079cd51b867</slot_id>
      <event_id>973121e8-34fe-4e2b-b368-0c84d6a61a30</event_id>
      <submission_id>6</submission_id>
      <title>Metaprogramming with Combinators</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>17:45</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>18:00</end_time>
      <description>There are a wide array of methods for writing code generators. We advocate for a point in the design space, which we call metaprogramming with combinators, where programmers use (and write) combinator libraries that directly manipulate object language terms. The key language feature that makes this style of programming palatable is quasiquotation. Our approach leverages quasiquation and other host language features to provide what is essentially a rich, well-typed macro language. Unlike other approaches, metaprogramming with combinators allows full control over generated code, thereby also providing full control over performance and resource usage. This control does not require sacrificing the ability to write high-level abstractions. We demonstrate metaprogramming with combinators through several code generators written in Haskell that produce VHDL targeted to Xilinx FPGAs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mahshid</first_name>
          <last_name>Shahmohammadian</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <person_id>mahshidshahmohammadian</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Geoffrey</first_name>
          <last_name>Mainland</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.drexel.edu/~mainland/</homepage_url>
          <person_id>geoffreymainland</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>5702bbfb-f578-42bc-8581-615791b0bc03</slot_id>
      <event_id>b0370501-3004-4d97-999e-22e02e3f92bd</event_id>
      <submission_id>21</submission_id>
      <title>Multi-Stage Programming with Generative and Analytical Macros</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>17:30</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>17:45</end_time>
      <description>In metaprogramming, code generation and code analysis are complementary. Traditionally, principled metaprogramming extensions for programming languages, like MetaML and BER MetaOCaml, offer strong foundations for code generation but lack equivalent support for code analysis. Similarly, existing macro systems are biased towards the code generation aspect. 
In this work, we present a calculus for macros featuring both code generation and code analysis. The calculus directly models separate compilation of macros, internalizing a commonly neglected aspect of macros. The system ensures that the generated code is well-typed and hygienic. 
We implement our system in Scala 3, provide a formalization, and prove its soundness.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Stucki</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://github.com/nicolasstucki</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nicolasstucki/4dfca9be-ecc5-4acb-a0bf-078dfb4abbf0/small.jpg</picture_url>
          <person_id>nicolasstucki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan Immanuel</first_name>
          <last_name>Brachthäuser</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanbrachthauser/f9c0b5dc-9b85-444f-baed-e807673f202d/small.jpg</picture_url>
          <person_id>jonathanbrachthauser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>EPFL</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java. 
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as academic director of the Scala center.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinodersky/fc1dd696-d0d4-47cb-9d9a-bba012d98f9e/small.jpg</picture_url>
          <person_id>martinodersky</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>abada571-40f6-43bc-a04b-25b43a53c638</slot_id>
      <event_id>bdc15ba9-7bbe-4361-bc81-f63ec2005af2</event_id>
      <submission_id>35</submission_id>
      <title>Type-safe generation of modules in applicative and generative styles</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>17:15</end_time>
      <description>The MetaML approach for multi-stage programming provides the static guarantee of type safety and scope safety for generated code regardless of the actual values of static parameters. While the traditional MetaML approach is restricted to term generation, Watanabe et al. presents a preliminary study on a two-stage language for generating ML-style modules, which provides high-level abstractions for large-scale programming. Unfortunately, their language has the problems of limited expressiveness and incomplete proofs of properties, and also an efficiency problem (the code-explosion problem). Recently, Sato et al. solved the latter issue, while the former problems are left as they are. This paper introduces refined two-stage programming languages for generating ML-style modules, which solve the above issues. Our languages accommodate module generation for two different module styles: first-class modules with generative functors and second-class modules with applicative functors, which are supported, but cannot be generated by MetaOCaml. Since generative functors and applicative functors have their own merits and demerits, our languages can be a better basis for the study of module generation. We also present a type-preserving translation from our languages to plain MetaOCaml, and an implementation based on the translations. Finally, we show the result of our experiments against a microbencmark, which shows that our translation does not have the code-explosion problem, and there are cases where module-generation is effective for program specialization.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuhi</first_name>
          <last_name>Sato</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
          <person_id>yuhisato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yukiyoshi</first_name>
          <last_name>Kameyama</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tsukuba.ac.jp/~kam/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yukiyoshikameyama/a7ae9aee-0992-4ddf-ae1d-6fee59d9e814/small.jpg</picture_url>
          <person_id>yukiyoshikameyama</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>b06ff9c2-e7d5-463d-844d-7c1c46b2f7fc</slot_id>
      <event_id>9bf0d567-6dd2-43ce-8e3f-d34234f72a99</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>18:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>18:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>f2e62f4a-02fc-442a-aa09-4acf990ee825</slot_id>
      <event_id>f543f436-3672-458d-b29e-a56692560d3c</event_id>
      <submission_id>24</submission_id>
      <title>HACCLE: Metaprogramming for Secure Multi-Party Computation</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>17:15</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>17:30</end_time>
      <description>Cryptographic techniques have the potential to enable distrusting parties to collaborate in fundamentally new ways, but their practical implementation poses numerous challenges. An important class of such cryptographic techniques is known as secure multi-party computation (MPC). Developing secure MPC applications in realistic scenarios requires extensive knowledge spanning multiple areas of cryptography and systems. And while the steps to arrive at a solution for a particular application are laborious, it remains difficult to make the implementation efficient, and cumbersome to apply those same steps to a slightly different application from scratch. Hence, it is an important problem to design a programming language and a compiler toolchain for secure MPC applications with minimum effort and using techniques accessible to non-experts in cryptography. 
In this paper, we present the HACCLE (High Assurance Compositional Cryptography: Languages and Environments) toolchain, specifically targeted to MPC applications. The toolchain contains an embedded domain-specific language (Harpoon) for software developers without cryptographic expertise to write MPC-based programs, and uses \emph{lightweight modular staging} (LMS) for code generation. Harpoon programs are compiled into acyclic circuits represented in HACCLE’s Intermediate Representation (HIR) that serves as an abstraction for implementing a computation using different cryptographic protocols such as secret sharing, homomorphic encryption, or garbled circuits. Implementations of different cryptographic protocols serve as different backends of our toolchain. The extensible design of HIR allows cryptographic experts to plug in new primitives and protocols to realize computations. And the use of standard metaprogramming techniques lowers the development effort significantly. 
We have implemented Harpoon and HACCLE, and used them to program interesting algorithms and applications (e.g., secure auction, matrix-vector multiplication, and merge sort). We show that the performance is improved by using our optimization strategies and heuristics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuyan</first_name>
          <last_name>Bao</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>yuyanbao1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kirshanthan</first_name>
          <last_name>Sundararajah</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kirshanthans.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kirshanthansundararajah/f5841aed-2fcf-4507-b0ee-49d7bed313ef/small.jpg</picture_url>
          <person_id>kirshanthansundararajah</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Raghav</first_name>
          <last_name>Malik</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/raghavmalik/772f3505-7946-4766-99b3-f6b6c97192cc/small.jpg</picture_url>
          <person_id>raghavmalik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Qianchuan</first_name>
          <last_name>Ye</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/ye202/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/qianchuanye/83304b4c-6b92-4773-9f69-e7055c793823/small.jpg</picture_url>
          <person_id>qianchuanye</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Christopher</first_name>
          <last_name>Wagner</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/christopherwagner/571f9f20-6c46-40bb-a5b5-0ac8ad448fdf/small.jpg</picture_url>
          <person_id>christopherwagner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Nouraldin</first_name>
          <last_name>Jaber</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/nouraldinjaber/0aeeca1f-ae9b-4220-85ef-02510d406a10/small.jpg</picture_url>
          <person_id>nouraldinjaber</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Fei</first_name>
          <last_name>Wang</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>feiwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Mohammad Hassan</first_name>
          <last_name>Ameri</last_name>
          <affiliation>Purdue university</affiliation>
          <bio>undefined</bio>
          <person_id>mohammadhassanameri</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Donghang</first_name>
          <last_name>Lu</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>donghanglu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Seto</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>alexanderseto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Delaware</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/bendy/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benjamindelaware/39bbf6b3-d145-435c-8956-8acf8cfcaffa/small.jpg</picture_url>
          <person_id>benjamindelaware</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>12</sort_key>
          <first_name>Roopsha</first_name>
          <last_name>Samanta</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/roopsha/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/roopshasamanta/3d74f41a-6adb-447b-8426-4a7fd9079dd4/small.jpg</picture_url>
          <person_id>roopshasamanta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>13</sort_key>
          <first_name>Aniket</first_name>
          <last_name>Kate</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>aniketkate</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>14</sort_key>
          <first_name>Christina</first_name>
          <last_name>Garman</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>christinagarman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>15</sort_key>
          <first_name>Jeremiah</first_name>
          <last_name>Blocki</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>jeremiahblocki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>16</sort_key>
          <first_name>Pierre-David</first_name>
          <last_name>Letourneau</last_name>
          <affiliation>Reservoir Labs</affiliation>
          <bio>undefined</bio>
          <person_id>pierredavidletourneau</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>17</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Meister</last_name>
          <affiliation>Reservoir Labs</affiliation>
          <bio>undefined</bio>
          <person_id>benoitmeister1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>18</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Springer</last_name>
          <affiliation>Reservoir Labs</affiliation>
          <bio>undefined</bio>
          <person_id>jonathanspringer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>19</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>20</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University. 
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures. 
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University. I received an NSF CAREER Award in 2012, a Department of Energy Early Career Research Award in 2013, and the Presidential Early Career Award for Scientists and Engineers in 2016.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
          <person_id>milindkulkarni</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c3a2aee3-5f80-4490-8ce6-6f290700c511</subevent_id>
    <title>GPCE: GPCE/SLE Session 3</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/gpce-2021</url>
    <url_link_display>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>25ed95d4-df79-4324-8048-2ec41bd9bf30</slot_id>
      <title>Session: GPCE - GPCE/SLE Session 3</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Alex</first_name>
          <last_name>Potanin</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>I am an Associate Professor in the School of Engineering and Computer Science at Victoria University of Wellington, New Zealand. 
I am originally from Moscow, Russia with a background in Mathematics. I have completed my PhD in programming languages in 2006 and took up a job as a Lecturer in Software Engineering at Victoria University of Wellington. During my studies, I took short breaks to work as a Visiting Researcher at Purdue University, and Software Engineer at two Wellington start-ups. I spent 2013 on sabbatical at Carnegie Mellon University in Pittsburgh, PA, USA. I spent winter 2019/2020 on sabbatical at Kyoto University in Japan.</bio>
          <homepage_url>http://homepages.ecs.vuw.ac.nz/~alex/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexpotanin/614f887b-90a3-4626-b67d-fa63309b44c8/small.jpg</picture_url>
          <person_id>alexpotanin</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>16f1a08c-ff1d-4a5c-8c9e-873adb04ec3c</slot_id>
      <event_id>ddf5336e-5697-40aa-a3b7-8562a642f07f</event_id>
      <submission_id>5</submission_id>
      <title>A Variational Database Management System</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:05</end_time>
      <description>Many problems require working with data that varies in its structure and content. Likewise, many tools have been developed to deal with different kinds of this problem, e.g., schema evolution tools or data integration tools. However, these approaches address only the specific kind of variation in databases resulting in two problems: Some fail to address all users’ needs for their specific kind of variation and all fail to address the interaction of different kinds of variation in databases. For example, neither schema evolution nor data integration systems can manage the data variation when an integrated database evolves over time. In this paper, we define a generic framework that explicitly accounts for variation in databases. Thus, it captures variation in the structure and content of a database and allows queries to express variational information needs. Our framework adds expressiveness to databases since it can encode any kind of variation. We design and implement a variational database management system as an abstraction layer over a traditional relational database. Using previously developed use cases that show the feasibility of our framework, we demonstrate the performance of different approaches used in our system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Parisa</first_name>
          <last_name>Ataei</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>parisaataei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fariba</first_name>
          <last_name>Khan</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>faribakhan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eric</first_name>
          <last_name>Walkingshaw</last_name>
          <affiliation>Unaffiliated</affiliation>
          <bio>undefined</bio>
          <person_id>ericwalkingshaw1</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>365e9be0-334a-4cd9-b3a6-c5dbe0179d31</slot_id>
      <event_id>2f5730cd-6e81-4edf-950f-b18abe169215</event_id>
      <submission_id>28</submission_id>
      <title>On-Stack Replacement for Program Generators and Source-to-Source Compilers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>22:35</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:50</end_time>
      <description>On-stack replacement (OSR) describes the ability to replace currently executing code with a different version, either a more optimized one (tiered execution) or a more general one (deoptimization to undo speculative optimization). While OSR is a key component in all modern VMs for languages like Java or JavaScript, OSR has only recently been studied as a more abstract program transformation, independent of language VMs. Still, previous work has only considered OSR in the context of low-level execution models based on stack frames, labels, and jumps. 
With the goal of making OSR more broadly applicable, this paper presents a surprisingly simple pattern for implementing OSR in source-to-source compilers or explicit program generators that target languages with structured control flow (loops and conditionals). We evaluate our approach through experiments demonstrating both tiered execution and speculative optimization, based on representative code patterns in the context of a state-of-the-art in-memory database system that compiles SQL queries to C at runtime. We further show that casting OSR as a high-level transformation enables new speculative optimization patterns beyond what is commonly implemented in language VMs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gregory</first_name>
          <last_name>Essertel</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>gregoryessertel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ruby</first_name>
          <last_name>Tahboub</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/rtahboub/index.htm</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rubytahboub/860662b0-0580-4bac-bb8a-64b7849333a2/small.jpg</picture_url>
          <person_id>rubytahboub</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a0e5e89a-c59a-4771-99f0-c6ca70847cf7</slot_id>
      <event_id>e27d703b-7803-4980-b6f0-2b57ef2e63ab</event_id>
      <submission_id>2</submission_id>
      <title>The Life Cycle of Features in Highly-Configurable Software Systems Evolving in Space and Time</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>22:05</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:20</end_time>
      <description>Feature annotation based on preprocessor directives is the most common mechanism in Highly-Configurable Software Systems (HCSSs) to select the features to be included in a system variant. However, it is challenging to understand, maintain, and evolve feature fragments guarded by #ifdef directives. Yet, despite HCSSs being implemented in Version Control Systems, the support for evolving features in space and time is still challenging. To extend the knowledge on this topic, we analyze the feature life cycle in space and time. Specifically, we introduce an automated mining approach and apply it to four HCSSs, analyzing commits of their entire development life cycle (13 to 20 years and 37500 commits). This goes beyond existing studies, which investigated only differences between releases or entire systems. Our results show that features undergo frequent changes, often with substantial modifications of their code. The findings of our empirical analyses stress the need for better support of system evolution in space and time at the level of features. In addition to these analyses, we contribute with an automated mining approach for the analysis of system evolution at the level of features. Furthermore, we also make available our dataset for new studies on feature evolution in HCSSs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriela Karoline</first_name>
          <last_name>Michelon</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>PhD student at Johannes Kepler University Linz as Junior Researcher at the Institute for Software Systems Engineering and LIT Secure and Correct Systems Lab. Graduated in Computer Science in 2016 at the University Federal Technological of Paraná – Campus Medianeira. Specialist in Software Engineering in 2018. Master in Computational Technologies for Agribusiness in 2018 at the Federal Technological University of Paraná - Campus Medianeira with a period of three months in the University of California, Davis.</bio>
          <homepage_url>https://gabrielamichelon.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gabrielakarolinemichelon/5ef51ae0-2922-412b-a3f8-b67dd546443d/small.jpg</picture_url>
          <person_id>gabrielakarolinemichelon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wesley</first_name>
          <last_name>Assunção</last_name>
          <affiliation>Pontifical Catholic University of Rio de Janeiro (PUC-Rio)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wesleyklewerton.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wesleyassuncao/c497acd7-b294-46fb-986e-a35f9fac27a1/small.jpg</picture_url>
          <person_id>wesleyassuncao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Obermann</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>undefined</bio>
          <person_id>davidobermann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Linsbauer</last_name>
          <affiliation>TU Braunschweig</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/lukaslinsbauer1/9bd521de-e5c5-40f4-8a48-c620cb6b4950/small.jpg</picture_url>
          <person_id>lukaslinsbauer1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Paul</first_name>
          <last_name>Grünbacher</last_name>
          <affiliation>Johannes Kepler University Linz, Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://paul.gruenbacher.at</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/paulgrunbacher/7cc53429-4f75-4f1e-85cc-90e400045b3a/small.jpg</picture_url>
          <person_id>paulgrunbacher</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Egyed</last_name>
          <affiliation>Johannes Kepler University Linz</affiliation>
          <bio>Alexander Egyed is Professor for Software-Intensive Systems at the Johannes Kepler University, Austria. He received his Doctorate from the University of Southern California, USA and worked in industry for many years. He is most recognized for his work on software and systems design – particularly on variability, consistency, and traceability.</bio>
          <homepage_url>http://www.alexander-egyed.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexanderegyed/b2c26061-4e47-42cc-ab6a-528e99583f7b/small.jpg</picture_url>
          <person_id>alexanderegyed</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a79e451f-ba1a-456e-81e7-aed82bd41a4e</slot_id>
      <event_id>a18c69f6-bf48-4e09-986b-b82097c5800f</event_id>
      <title>Discussion, Questions, Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>e0f64481-93c1-46da-b3fa-11f285dad7be</slot_id>
      <event_id>6cb74ab3-5834-4f3e-b5c6-56c554779d1d</event_id>
      <submission_id>3</submission_id>
      <title>Towards Supporting SPL Engineering in Low-Code Platforms using a DSL Approach</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>22:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:35</end_time>
      <description>Low-code platforms enable those who are now called citizen developers to autonomously build complete applications, such as web applications or mobile applications. Some of these platforms also offer support for reuse to facilitate the development of similar applications. The offered mechanisms are usually elementary, they allow module reuse or building a new application from a template. However, they are insufficient to achieve the industrial level reuse necessary for software product lines (SPL). In fact, these platforms were conceived to help building standalone applications, not software families and even fewer software product lines. The paper argues that the major limitation is that these platforms seldom provide access to their metamodel, the access to application’s models and code is also limited and, therefore, makes it harder to analyze commonality and variability and construct models based on it. The paper proposes an approach to surpass these limitations: firstly, a metamodel of the applications built with the platform is obtained, and then, based on the metamodel, a domain-specific language (DSL) that can express the models of the applications, including variability, is constructed. With this DSL, users can easily combine and reuse models from different applications to explore and build similar applications. The solution is illustrated with an industrial case study. A discussion of the results is presented as well as its limitations and related work. The authors hope that this work provides inspiration and some ideas that the community can explore to facilitate the adoption and implementation of SPLs in the context, and supported by, low-code platforms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexandre</first_name>
          <last_name>Bragança</last_name>
          <affiliation>Institute of Engineering of Porto – Polytechnic of Porto (ISEP/IPP)</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexandrebraganca/a975d705-f884-420d-ab29-5b9ad36430b3/small.jpg</picture_url>
          <person_id>alexandrebraganca</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isabel</first_name>
          <last_name>Azevedo</last_name>
          <affiliation>Games, Interaction and Learning Technologies (GILT) - Institute of Engineering of Porto – Polytechnic of Porto (ISEP/IPP)</affiliation>
          <bio>undefined</bio>
          <person_id>isabelazevedo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nuno</first_name>
          <last_name>Bettencourt</last_name>
          <affiliation>Interdisciplinary Studies Research Center (ISRC) – Institute of Engineering of Porto – Polytechnic of Porto (ISEP/IPP)</affiliation>
          <bio>undefined</bio>
          <person_id>nunobettencourt</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Carlos</first_name>
          <last_name>Morais</last_name>
          <affiliation>NumbersBelieve</affiliation>
          <bio>undefined</bio>
          <person_id>carlosmorais</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Diogo</first_name>
          <last_name>Teixeira</last_name>
          <affiliation>NumbersBelieve</affiliation>
          <bio>undefined</bio>
          <person_id>diogoteixeira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>David</first_name>
          <last_name>Caetano</last_name>
          <affiliation>NumbersBelieve</affiliation>
          <bio>undefined</bio>
          <person_id>davidcaetano</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2cc4ac48-dbbd-4602-b2eb-4704a0126bd3</subevent_id>
    <title>GPCE: GPCE/SLE Session 4</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/gpce-2021</url>
    <url_link_display>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2021</track>
    </tracks>
    <timeslot>
      <slot_id>97fbc26f-48d1-40f3-986a-04235963c6c5</slot_id>
      <title>Session: GPCE - GPCE/SLE Session 4</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Van Wyk</last_name>
          <affiliation>University of Minnesota, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umn.edu/~evw</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ericvanwyk/3e91ebed-d1c2-4d28-a408-dddc41b5affc/small.jpg</picture_url>
          <person_id>ericvanwyk</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2b8a1775-a92d-423e-8f83-e01a156b6a11</slot_id>
      <event_id>f340a855-bbd0-40ac-b6c6-e866e008342a</event_id>
      <submission_id>38</submission_id>
      <title>A Concurrency Model for JavaScript with Cooperative Cancellation</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>15:55</end_time>
      <description>This paper proposes a concurrency model with thread abstractions and cooperative cancellation for JavaScript. JavaScript uses an event-driven model, where an active computation runs until it completes or blocks for an event while concurrent computations wait for events as callbacks. With the introduction of Promises, the control flow of callbacks can be written in a more direct style. However, the event-based model is still a source of confusion with regard to execution order, race conditions, and termination of computations. 
Thread model is a familiar concept to programmers and can help reduce errors in developing JavaScript programs. This work is a library-based design, which uses an abstraction based on reader monad to pass a thread ID through a thread’s computation. A thread can be cancelled, paused, and resumed with its thread ID. This design allows hierarchical cancellation where a child thread is cancelled if its parent is cancelled. It also defines synchronization primitives to protect shared states. A formal semantics is included to give a precise definition of the proposed model.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tian</first_name>
          <last_name>Zhao</last_name>
          <affiliation>University of Wisconsin-Milwaukee</affiliation>
          <bio>undefined</bio>
          <person_id>tianzhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yonglun</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Wisconsin -- Milwaukee</affiliation>
          <bio>undefined</bio>
          <person_id>yonglunli</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>33950c74-9fb9-44bd-949e-108965f69248</slot_id>
      <event_id>5c03a4dc-23f5-48ee-86f6-f3a571c4d6d1</event_id>
      <submission_id>28</submission_id>
      <title>Getting Grammars into Shape for Block-based Editors</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>16:10</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>16:25</end_time>
      <description>Block-based programming environments allow users to program by interactively arranging visual jigsaw-like program elements. They have shown to be helpful in several domains, but often require experienced developers for their creation. Previous research investigated the use of language frameworks to generate block-based editors based on grammars, but often the results provided too many, unnecessary kinds of blocks, leading to verbose and less concise environments and also programs. 
To reduce the number of interactions, we propose the use of a pipeline of transformations to simplify the original grammar, yielding a reduction of the number of (useful) kinds of blocks available in the resulting editors. We show that, up to a certain complexity, our generated block-based editors are significantly improved with respects to a set of observed aesthetic criteria. As such, analyzing and simplifying grammars before generating block-based editors allows us to derive more compact and potentially more usable block-based editors, making reuse of existing grammars through automatic generation feasible.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mauricio</first_name>
          <last_name>Verano Merino</last_name>
          <affiliation>Eindhoven University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://maveme.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mauricioveranomerino/e4a3ec56-b66f-4885-9989-c4a230e08446/small.jpg</picture_url>
          <person_id>mauricioveranomerino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tom</first_name>
          <last_name>Beckmann</last_name>
          <affiliation>Hasso Plattner Institute</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/tombeckmann/338eaf6c-48cf-4dbc-920b-e36a0853d7d3/small.jpg</picture_url>
          <person_id>tombeckmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tijs</first_name>
          <last_name>van der Storm</last_name>
          <affiliation>CWI &amp; University of Groningen, Netherlands</affiliation>
          <bio>Tijs van der Storm is senior researcher in the Software Analysis and Transformation (SWAT) group at Centrum Wiskunde &amp;amp; Informatica (CWI) in Amsterdam, and full professor in Software Engineering at the University of Groningen in Groningen. His research focuses on improving programmer experience through new and better software languages and developing the tools and techniques to engineer them in a modular and interactive fashion.</bio>
          <homepage_url>http://www.cwi.nl/~storm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tijsvanderstorm/1c2fdfb2-3ce0-4e75-91af-35d9a48f56c5/small.jpg</picture_url>
          <person_id>tijsvanderstorm</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robert</first_name>
          <last_name>Hirschfeld</last_name>
          <affiliation>Hasso Plattner Institute (HPI), University of Potsdam, Germany</affiliation>
          <bio>Robert Hirschfeld is a Professor of Computer Science at the Hasso Plattner Institute at the University of Potsdam, Germany. There he founded and leads the Software Architecture Group which is concerned with fundamental elements and structures of software. Methods and tools are developed for improving the comprehension and design of complex and interesting systems. 
Robert is interested in programming experiences and small system kernels. With his group he is working on dynamic programming languages, development tools, and runtime environments to make interactive programming more approachable. His preferred environment for exploring ideas is Squeak/Smalltalk. 
He served as a visiting professor at the Tokyo Institute of Technology (東京工業大学) and The University of Tokyo (東京大学), Japan. 
Robert was a senior researcher with DoCoMo Euro-Labs, the European research facility of NTT DoCoMo Japan, where he worked on infrastructure components for next generation mobile communication systems with a focus on dynamic service adaptation and context-oriented programming. 
Prior to joining DoCoMo Euro-Labs, he was a principal engineer at Windward Solutions in Sunnyvale, California, where he designed and implemented distributed object systems, consulted in the area of object database technologies, and developed innovative software products and applications. 
Robert received a PhD in Computer Science from the Ilmenau University of Technology, Germany.</bio>
          <homepage_url>http://www.hirschfeld.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/roberthirschfeld/994ef4df-a890-4f16-bc1b-73b117dab33c/small.jpg</picture_url>
          <person_id>roberthirschfeld</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jurgen</first_name>
          <last_name>Vinju</last_name>
          <affiliation>CWI, Netherlands</affiliation>
          <bio> 
 Researcher, see http://jurgen.vinju.org, in 
   
   Software Language Engineering 
   Programming Languages 
   Empirical Software Engineering 
   Software Evolution 
    
 (Co)-Designer and/or (co-)engineer of (selected): 
   
   Rascal Metaprogramming Language http://www.rascalmpl.org 
   Rascal VScode https://github.com/usethesource/rascal-language-servers 
   Vallang http://www.usethesource.io/projects/vallang 
   IMP http://www.eclipse.org/imp, now Impulse http:www.usethesource.io/projects/impulse 
   OSSMETER http://www.ossmeter.org 
   ASF+SDF Meta-Environment http://www.meta-environment.org 
   SDF2 http://www.syntax-definition.org 
    
 Titles 
   
   Full professor of Automated Software Analysis at TU Eindhoven 
   Group leader Software Analysis and Transformation at Centrum Wiskunde &amp;amp; Informatica https://www.cwi.nl/research/groups/software-analysis-and-transformation 
   Co-owner of SWAT.engineering BV http://www.swat.engineering 
    
</bio>
          <homepage_url>http://homepages.cwi.nl/~jurgenv</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jurgenvinju/31e5a54c-e7a3-4c37-b0c9-ca2254e3ef59/small.jpg</picture_url>
          <person_id>jurgenvinju</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>65507f87-8831-43a2-b27a-b5c382a5aaa8</slot_id>
      <event_id>de486fbd-4c97-4db6-a4ce-77c8e522f331</event_id>
      <title>Discussion, Questions, Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b350a6a5-4c30-42ee-9208-ca49ee12fcbf</slot_id>
      <event_id>138aa42e-f060-4c89-8f76-da77c5521751</event_id>
      <submission_id>30</submission_id>
      <title>There Is More Than One Way to Zen Your Python</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>15:55</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>16:10</end_time>
      <description>The popularity of Python can be at least partially attributed to the concept of pythonicity, loosely defined as a combination of good practices accepted within the community. Despite the popularity of both Python itself and the pythonicity of code written in it, this concept has not been studied that well, and the first attempts to define it formally are rather recent. 
In this paper, we take the next steps in exploring this topic by conducting an independent literature review in order to create a catalogue of pythonic idioms, reproduce the results of a recent paper on the usage of pythonic idioms, perform an external direct replication of it by reusing the same open source toolset and dataset, and extend the body of knowledge by also analysing how the use of pythonic idioms evolve over time in open source codebases.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aamir</first_name>
          <last_name>Farooq</last_name>
          <affiliation>Universiteit Twente</affiliation>
          <bio>undefined</bio>
          <person_id>aamirfarooq</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vadim</first_name>
          <last_name>Zaytsev</last_name>
          <affiliation>University of Twente, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://grammarware.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vadimzaytsev/fe6c221f-75d5-4fbc-ac41-be9c99349b5d/small.jpg</picture_url>
          <person_id>vadimzaytsev</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>ec13aaa7-2049-440a-b68e-f56e236517d0</slot_id>
      <event_id>65df9844-070c-4122-adea-ff24e69cdcd3</event_id>
      <submission_id>18</submission_id>
      <title>Extracting The Power of Dependent Types</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>16:25</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>16:40</end_time>
      <description>Most existing programming languages provide little support to formally state and prove properties about programs. Ad-ding such capabilities is far from trivial, as it requires significant re-engineering of the existing compilers and tools. This paper proposes a novel technique to write correct-by-con-struc-tion programs in languages without built-in verification capabilities, while maintaining the ability to use existing tools. This is achieved in three steps. Firstly, we give a shallow embedding of the language (or a subset) into a dependently typed language. Secondly, we write a program in that embedding, and we use dependent types to guarantee correctness properties of interest. Thirdly, we extract a program written in the original language, so that it can be used by the existing compilers and tools. 
Our main insight is that it is possible to express all three steps in a single language that supports both dependent typ-es and reflection. Essentially, this allows us to express a program, its formal properties, and a compiler for it hand-in-hand, offering a lot of flexibility to programmers. We demonstrate this three-step approach by embedding a subset of the PostScript language in Agda, and illustrating it with several short examples. Thus we use the power of reflection to bring the benefits of dependent types to languages that had to go without them so far.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Artjoms</first_name>
          <last_name>Šinkarovs</last_name>
          <affiliation>Heriot-Watt University, UK</affiliation>
          <bio>undefined</bio>
          <person_id>artjomssinkarovs</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jesper</first_name>
          <last_name>Cockx</last_name>
          <affiliation>TU Delft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jesper.sikanda.be</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jespercockx/113f5ec5-aa52-443e-93e2-e7d8d136577b/small.jpg</picture_url>
          <person_id>jespercockx</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>29920445-9953-4412-8789-4aad57473ac4</subevent_id>
    <title>SLE: SLE/GPCE Session 7</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sle-2021</url>
    <url_link_display>SLE (Software Language Engineering) 2021</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2021</track>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>e4d94e3e-2d48-4ab3-a195-2fa2e954c413</slot_id>
      <title>Session: SLE - SLE/GPCE Session 7</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Coen</first_name>
          <last_name>De Roover</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~cderoove/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/coenderoover/ef3a26a6-56c3-420e-b1ce-b4a0e6cd653e/small.jpg</picture_url>
          <person_id>coenderoover</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>285791bb-4e55-4d9d-8cca-f2f7af8a8735</slot_id>
      <event_id>c4f8988a-f821-4472-877f-7debd62c4400</event_id>
      <submission_id>40</submission_id>
      <title>SEALS: A framework for building Self-Adaptive Virtual Machines</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>22:05</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:20</end_time>
      <description>Over recent years, self-adaptation has become a major concern for software systems that evolve in changing environments. While expert developers may choose a manual implementation when self-adaptation is the primary system concern, self-adaptation should be abstracted for non-expert developers or when it is a secondary system concern. We present SEALS, a framework for building self-adaptive virtual machines for domain-specific languages. This framework provides first-class entities for the language engineer to promote domain-specific feedback loops in the definition of the DSLoperational semantics. In particular, the framework supports the definition of (i) the abstract syntax and the semantics of the language as well as the correctness envelope defining the acceptable semantics for a domain concept, (ii) the feedback loop and associated trade-off reasoning, and (iii) the adaptations and the predictive model of their impact on the trade-off. We use this framework to build three languages with self-adaptive virtual machines and discuss the relevance of the abstractions, effectiveness of correctness envelopes, and compare their code size and performance results to their manually implemented counterparts. We show that the framework provides suitable abstractions for the implementation of self-adaptive operational semantics while introducing little performance overhead compared to a manual implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gwendal</first_name>
          <last_name>Jouneaux</last_name>
          <affiliation>Univ. Rennes, Inria, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.gwendal-jouneaux.fr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gwendaljouneaux/da056fcb-c509-4aaa-89bd-7eca0c55ce85/small.jpg</picture_url>
          <person_id>gwendaljouneaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Barais</last_name>
          <affiliation>University of Rennes, France / Inria, France / CNRS, France / IRISA, France</affiliation>
          <bio>undefined</bio>
          <person_id>olivierbarais1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes 1, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gunter</first_name>
          <last_name>Mussbacher</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/guntermussbacher/f1452019-54bd-4b93-bbdb-eaece6059e96/small.jpg</picture_url>
          <person_id>guntermussbacher</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>2c7aa10f-bcb7-40e6-90dc-a063c94150a5</slot_id>
      <event_id>eb9cb457-b2ba-4cca-8b8f-1ecfc278b4b3</event_id>
      <submission_id>36</submission_id>
      <title>Understanding and Improving Model-Driven IoT Systems Through Accompanying Digital Twins</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>22:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:35</end_time>
      <description>Developers questioning why their system behaves differently than expected often have to rely on time-consuming and error-prone manual analysis of log files. Understanding the behavior of Internet of Things (IoT) applications is a challenging task because they are not only inherently hard-to-trace distributed systems, but their integration with the environment via sensors adds another layer of complexity. Related work proposes to record data during the execution of the system, which can later be replayed to analyze the system. We apply the model-driven development approach to this idea and leverage digital twins to collect the required data. We enable developers to replay and analyze the system’s executions by applying model-to-model transformations. These transformations instrument component and connector (C&amp;amp;C) architecture models with components that reproduce the system’s environment based on the data recorded by the system’s digital twin. We validate and evaluate the feasibility of our approach using a heating, ventilation, and air conditioning (HVAC) case study. By facilitating the reproduction of the system’s behavior, our method lowers the barrier to understanding the behavior of model-driven IoT systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jörg</first_name>
          <last_name>Christian Kirchhof</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://se-rwth.de/staff/kirchhof</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgchristiankirchhof/65bf9d60-f8c4-423d-83fe-4289ee3c87d6/small.jpg</picture_url>
          <person_id>jorgchristiankirchhof</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Malcher</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <person_id>lukasmalcher</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bernhard</first_name>
          <last_name>Rumpe</last_name>
          <affiliation>RWTH Aachen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.se-rwth.de/staff/rumpe/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bernhardrumpe/0f827533-83ea-4f32-ba9e-eb8b70059217/small.jpg</picture_url>
          <person_id>bernhardrumpe</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>63939b84-e1f3-4480-9c93-4fe14d42cfc1</slot_id>
      <event_id>10f4854e-9741-4aee-8e3a-44cf4712a53b</event_id>
      <submission_id>25</submission_id>
      <title>A DSL for Explanatory Decision Making</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:05</end_time>
      <description>We present a Haskell-embedded DSL for multi-attribute, multi-layered decision making. In addition to solving decision problems, an important feature of the DSL is the ability to generate explanations of why a computed optimal solution is better than its alternatives. 
The functional approach and Haskell’s type system support a high-level formulation of decision-making problems, which facilitates a number of innovations, including the gradual evolution and adaptation of problem representations, a more user-friendly form of sensitivity analysis based on problem domain data, and fine-grained control over explanations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Erwig</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.engr.oregonstate.edu/~erwig/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinerwig/8fd12ecd-2d70-44d3-a670-d5ef12393f9c/small.jpg</picture_url>
          <person_id>martinerwig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Prashant</first_name>
          <last_name>Kumar</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>prashantkumar1</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>7f543a87-4b70-4f89-8fed-4ddbb381fd87</slot_id>
      <event_id>a2fe5709-a6fb-4eb9-b442-79d81571dc0c</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a4872233-be63-4272-81f0-810ac76ae314</slot_id>
      <event_id>60d3efad-cea5-4f5b-8978-c0d7e8885703</event_id>
      <submission_id>15</submission_id>
      <title>Artifact and Reference Models for Generative AI Frameworks and Build Systems</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>22:35</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:50</end_time>
      <description>Machine learning is a discipline which has become ubiquitous in the last few years. While the research of AI algorithms is very active and continues to reveal astonishing possibilities on a regular basis, the wide usage of these algorithms is shifting the research focus to the integration, maintenance, and evolution of AI-driven systems. Although there is a variety of machine learning frameworks on the market, there is little support for process automation and DevOps in machine learning-driven projects. In this paper, we discuss how metamodels can support the development of deep learning frameworks and help deal with the steadily increasing variety of learning algorithms. In particular, we present a deep-learning-oriented artifact model which serves as a foundation for build automation and data management in iterative, machine learning-driven development processes. Furthermore, we show how schema and reference models can be used to structure and maintain a versatile deep learning framework. Feasibility is demonstrated on several compelling and relevant state-of-the-art examples from the domains of image and natural language processing as well as decision making and autonomous driving.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abdallah</first_name>
          <last_name>Atouani</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.abdallah.at/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/abdallahatouani/30b94b4a-0912-4283-afd0-38511a0bf7d1/small.jpg</picture_url>
          <person_id>abdallahatouani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jörg</first_name>
          <last_name>Christian Kirchhof</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://se-rwth.de/staff/kirchhof</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgchristiankirchhof/65bf9d60-f8c4-423d-83fe-4289ee3c87d6/small.jpg</picture_url>
          <person_id>jorgchristiankirchhof</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Evgeny</first_name>
          <last_name>Kusmenko</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <person_id>evgenykusmenko</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bernhard</first_name>
          <last_name>Rumpe</last_name>
          <affiliation>RWTH Aachen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.se-rwth.de/staff/rumpe/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bernhardrumpe/0f827533-83ea-4f32-ba9e-eb8b70059217/small.jpg</picture_url>
          <person_id>bernhardrumpe</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a4175c71-ac52-4b26-b587-990bd7f144a8</subevent_id>
    <title>SLE: SLE/GPCE Session 8</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sle-2021</url>
    <url_link_display>SLE (Software Language Engineering) 2021</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2021</track>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot>
      <slot_id>80052b09-063d-4a44-bb4c-453a01fe5e5e</slot_id>
      <title>Session: SLE - SLE/GPCE Session 8</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Ran</first_name>
          <last_name>Wei</last_name>
          <affiliation>Dalian University of Technology</affiliation>
          <bio>I am an associate professor at Dalian University of Technology, China since March, 2020. Before that I worked for the University of York for 8 years. My research interests mainly focus on model based system assurance and model based systems engineering. I am also a contributing member of the Goal Structuring Notation (GSN) standard and OMG’s SACM (Structured Assurance Case Metamodel) standard.</bio>
          <homepage_url>http://faculty.dlut.edu.cn/weiran/en/index.htm</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ranwei1/78e4c2d0-56af-4a66-9c8a-bd632ce130de/small.jpg</picture_url>
          <person_id>ranwei1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>17559ee3-d504-4b84-abca-cd4aca770f35</slot_id>
      <event_id>cbec2229-545a-457e-8f6a-da00c5321161</event_id>
      <submission_id>20</submission_id>
      <title>Lifted Termination Analysis by Abstract Interpretation and its Applications</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>16:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>16:25</end_time>
      <description>This paper is focused on proving termination for program families with numerical features by using abstract interpretation. Furthermore, we present an interesting application of the above lifted termination analysis for resolving ``sketches'', i.e. partial programs with missing numerical parameters (holes), such that the resulting complete programs always terminate. To successfully address the above problems, we employ an abstract interpretation-based framework for inferring sufficient preconditions for termination of single programs that synthesizes piecewise-defined ranking functions. 
We introduce a novel lifted decision tree domain for termination, in which decision nodes contain linear constraints defined over numerical features and leaf nodes contain piecewise ranking functions defined over program variables. Moreover, we encode a program sketch as a program family, thereby allowing the use of the lifted termination analysis as a program sketcher. In particular, we aim to find the variants (family members) that terminate under all possible inputs, which represent the correct sketch realizations. 
We have implemented an experimental lifted termination analyzer, called SPLFuncTion, for proving termination of $\texttt{#if}$-based C program families and for termination-directed resolving of C program sketches. We have evaluated our approach by a set of loop benchmarks from SV-COMP, and experimental results show that our approach is effective and efficient.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>S. Dimovski</last_name>
          <affiliation>Mother Teresa University, Skopje</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://aleksdimovski.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aleksandarsdimovski1/302de1d2-ceed-47e9-9987-41b7d778ee8d/small.jpg</picture_url>
          <person_id>aleksandarsdimovski1</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>50755b20-99d0-476b-8f1b-0ab224477070</slot_id>
      <event_id>52a219ce-0523-4856-a126-3b25b9f6063c</event_id>
      <submission_id>16</submission_id>
      <title>Delta-based Verification of Software Product Families</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>16:25</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>16:40</end_time>
      <description>The quest for feature- and family-oriented deductive verification of software product lines resulted in several proposals. In this paper we look at delta-oriented modeling of product lines and combine two new ideas: first, we extend Hähnle &amp;amp; Schaefer’s delta-oriented version of Liskov’s substitution principle for behavioral subtyping to work also for overridden behavior in benign cases. For this to succeed, programs need to be in a certain normal form. The required normal form turns out to be achievable in many cases by a set of program transformations, whose correctness is ensured by the recent technique of abstract execution. This is a generalization of symbolic execution that permits reasoning about abstract code elements. It is needed, because code deltas contain partially unknown code contexts in terms of “original” calls. Second, we devise a modular verification procedure for deltas based on abstract execution, representing deltas as abstract programs calling into unknown contexts. The result is a “delta-based” verification approach, where each modification of a method in a code delta is verified in isolation, but which overcomes the strict limitations of behavioral subtyping and works for many practical programs. The latter claim is substantiated with case studies and benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marco</first_name>
          <last_name>Scaletta</last_name>
          <affiliation>Technische Universität Darmstadt</affiliation>
          <bio>undefined</bio>
          <person_id>marcoscaletta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Reiner</first_name>
          <last_name>Hähnle</last_name>
          <affiliation>Technical University of Darmstadt</affiliation>
          <bio>I am Professor of Computer Science at TU Darmstadt, Germany. I received a PhD from University of Karlsruhe (now KIT) and a Habilitation from TU Vienna. From 2000 to 2011 I worked as an Associate, then Full Professor at Chalmers University of Technology.</bio>
          <homepage_url>https://www.se.tu-darmstadt.de/se/group-members/reiner-haehnle/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/reinerhahnle/1e50ca51-79fe-43ab-934f-2a13a2992f75/small.jpg</picture_url>
          <person_id>reinerhahnle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dominic</first_name>
          <last_name>Steinhöfel</last_name>
          <affiliation>CISPA Helmholtz Center for Information Security</affiliation>
          <bio>undefined</bio>
          <person_id>dominicsteinhofel1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Richard</first_name>
          <last_name>Bubel</last_name>
          <affiliation>Technische Universität Darmstadt</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/richardbubel/1dd0f6cd-cb8c-442c-a38f-cfcc98298a85/small.jpg</picture_url>
          <person_id>richardbubel</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>a3baa1c4-53ec-4a0e-85d8-c51424e202b8</slot_id>
      <event_id>04f49794-5679-4653-af38-5b6b995e0cd3</event_id>
      <submission_id>32</submission_id>
      <title>Leveraging Relational Concept Analysis for Automated Feature Location in Software Product Lines</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>15:55</end_time>
      <description>Formal Concept Analysis (FCA) has been introduced for almost a decade as a suitable method for Feature Location (FL) on a collection of product variants. Even though FCA-based FL techniques allow to locate the core of a feature implementation, they do not propose a solution to trace feature interactions to their implementation. Thus, the extracted traceability links (traces) are too inaccurate, and, in the context of SPL extraction, cannot be used to generate complete products. 
In this paper, we propose to complement FCA-based FL techniques. Our proposed technique is capable of extracting the feature implementation and the implementation of the feature interaction. This process leverages the power of Relational Concept Analysis, an extension of FCA to multi-relational data. Moreover, our technique can be applied to fine-grained artefacts, which permits it to have more accurate traces that better capture the features’ implementation and interactions. Finally, we also propose a method to reduce the size of the traces (number of features) for a better comprehension of each trace. We have applied our FL technique to five case studies of product variants. The results show that our technique produces valid traces, from which we were able to completely rebuild the set of artefacts for each initial product. Our results also show that our trace reduction removes, on average, between 31% and 85% of unnecessary features from the traces.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Hlad</last_name>
          <affiliation>LIRMM, CNRS</affiliation>
          <bio>undefined</bio>
          <person_id>nicolashlad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bérénice</first_name>
          <last_name>Lemoine</last_name>
          <affiliation>LIRMM, CNRS</affiliation>
          <bio>undefined</bio>
          <person_id>berenicelemoine</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marianne</first_name>
          <last_name>Huchard</last_name>
          <affiliation>LIRMM</affiliation>
          <bio>Marianne Huchard is Full Professor of Computer Science at the University of Montpellier since 2004, where she teaches courses in software engineering and knowledge engineering. She develops her research at LIRMM (Laboratory of Informatics, Robotics and Microelectronics at Montpellier). She obtained a PhD in computer Science in 1992, during which she investigated algorithmic questions connected to the management of multiple inheritance in various object-oriented programming languages. She conducts research in two areas: in Formal Concept Analysis (FCA), where she studies theoretical and applied aspects, and in Software Engineering, where she contributes to model-driven engineering, component-based and service-based software development, as well as migration towards software product lines. She has been deputy director of the LIRMM, and she also participated to the creation and supervision of the Master degree in Software Engineering at the University of Montpellier, where she is currently responsible for the Doctoral studies in Computer Science. She recently served as the program chair of the 13th International Conference on Concept Lattices and their Applications (CLA 2016), as the general conference chair of the 27th European Conference on Object-Oriented Programming edition, the 9th European Conference on Modelling Foundations and Applications edition and the 7th European Conference on Software Architecture (ECMFA, ECOOP, ECSA 2013), and as the general chair of the 33rd IEEE/ACM International Conference on Automated Software Engineering (ASE 2018).</bio>
          <homepage_url>https://www.lirmm.fr/users/utilisateurs-lirmm/marianne-huchard</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mariannehuchard/54809086-6157-4f7d-b8f1-aa82671b27b3/small.jpg</picture_url>
          <person_id>mariannehuchard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Abdelhak</first_name>
          <last_name>Seriai</last_name>
          <affiliation>LIRMM, CNRS and University of Montpellier</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lirmm.fr/~seriai/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/abdelhakseriai/d85a802d-c34f-468b-9d76-5adb4adea766/small.jpg</picture_url>
          <person_id>abdelhakseriai</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>b6e9048a-f000-44d3-a159-27f3e539f0c5</slot_id>
      <event_id>afd13fea-31e6-4de2-b33f-1adcdb690eae</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e3d30392-8ec0-4382-9e17-e077a563901a</slot_id>
      <event_id>2b702965-d312-4316-8d55-39a1e0d157f4</event_id>
      <submission_id>44</submission_id>
      <title>FIDDLR: Streamlining Reuse with Concern-Specific Modelling Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>15:55</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>16:10</end_time>
      <description>Model-Driven Engineering (MDE) reduces complexity, improves Separation of Concerns and promotes reuse by structuring software development as a process of model production and model refinement. Domain-Specific Modelling Languages and Aspect-Oriented Modelling techniques can reduce complexity and improve modularization of crosscutting concerns in situations where the features of general purpose modelling languages are not well aligned with the subject of study. In this article we present FIDDLR, a novel approach that integrates the ideas of Domain-Specific Modelling Languages, Concern-Oriented Reuse and MDE to modularize software development concerns that cross-cut multiple levels of abstraction of the software development process and streamline the reuse process. It also prescribes the integration of the different tooling and transformation infrastructure, i.e., model transformations, model composition and code generation. We demonstrate the effectiveness of our framework and the potential for reduced complexity and leveraged reuse by building a reusable concern that can be used to expose the services a system offers through a custom REST interface.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maximilian</first_name>
          <last_name>Schiedermeier</last_name>
          <affiliation>McGill University</affiliation>
          <bio>undefined</bio>
          <person_id>maximilianschiedermeier</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jörg</first_name>
          <last_name>Kienzle</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.mcgill.ca/~joerg/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgkienzle/5833ba8f-2294-444c-8f6a-54007a388e34/small.jpg</picture_url>
          <person_id>jorgkienzle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bettina</first_name>
          <last_name>Kemme</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>bettinakemme</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6e93a71e-5bc1-465b-a82b-dd63bb179670</subevent_id>
    <title>SLE: SLE/GPCE Session 6</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sle-2021</url>
    <url_link_display>SLE (Software Language Engineering) 2021</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2021</track>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>558db5dc-7240-441f-89e9-bbb28d52e7fc</slot_id>
      <title>Session: SLE - SLE/GPCE Session 6</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Kolovos</last_name>
          <affiliation>University of York</affiliation>
          <bio>Dimitris Kolovos is a Professor of Software Engineering in the Department of Computer Science at the University of York, where he researches and teaches automated and model-based software engineering. He is also an Eclipse Foundation committer, leading the development of the open-source Epsilon model-based software engineering platform, and an associate editor of the IET Software journal. Prof. Kolovos has co-authored more than 150 peer-reviewed papers and his research has been supported by the European Commission, UK’s Engineering and Physical Sciences Research Council (EPSRC), InnovateUK and by companies such as Rolls-Royce and IBM.</bio>
          <homepage_url>https://www-users.cs.york.ac.uk/~dkolovos</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dimitriskolovos/729a514e-e3bb-43e2-9944-6f6ef33dcaa1/small.jpg</picture_url>
          <person_id>dimitriskolovos</person_id>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Paddy</first_name>
          <last_name>Krishnan</last_name>
          <affiliation>Oracle Labs, Australia</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/paddykrishnan/36e9562d-4d3c-47a8-a27b-cdae9ff14c32/small.jpg</picture_url>
          <person_id>paddykrishnan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>1ecbfb58-8cb0-4835-ba27-3df4108d0c07</slot_id>
      <event_id>9f6a14d7-8413-4511-b2ee-7881c6ccdfd5</event_id>
      <submission_id>22</submission_id>
      <title>Compiling pattern matching to in-place modifications</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>19:43</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:51</end_time>
      <description>Algebraic data types and pattern matching are extremely productive to build programs on complex datastructures in a safe yet efficient manner. There is a rich literature on how to compile them efficiently in the context of immutable use in functional programming languages. 
However, in the context of high-performance datastructures and languages allowing (controlled) mutations, we would like to describe efficient \emph{in-place} transformations of tree-like structures such as ADTs. Additionally, such transformations should take advantage of parallelism opportunities that naturally appear in such tree-like structures. 
We present early steps towards a new technique to compile pattern matching as parallel in-place modifications of the underlying memory representation. Towards this goal, we combine the usual language approach common in pattern-matching compilation with tools from the polyhedral model, which is commonly used in high-performance code generation to output efficient C code. We present our formalism, along with a prototype implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paul</first_name>
          <last_name>Iannetta</last_name>
          <affiliation>ENS Lyon</affiliation>
          <bio>undefined</bio>
          <person_id>pauliannetta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laure</first_name>
          <last_name>Gonnord</last_name>
          <affiliation>University of Lyon &amp; LIP, France</affiliation>
          <bio>Laure Gonnord received her PhD degree in computer science from the University Joseph Fourier (Grenoble, France), in 2007. She currently holds an assistant professor position at University Lyon I/UCBL, France. She got her Habilitation in 2017. 
Her main research interests lie in the design of static analyses, with emphasis on the automatic synthesis of numerical and memory invariants and application in compilation (scheduling) and termination proofs. She belongs to the CASH team of the LIP laboratory (ENS de Lyon, France).</bio>
          <homepage_url>http://laure.gonnord.org/pro</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lauregonnord/6b741986-7933-4cba-9205-8e5e8451d8fa/small.jpg</picture_url>
          <person_id>lauregonnord</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gabriel</first_name>
          <last_name>Radanne</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gabriel.radanne.net/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gabrielradanne/ae153ba4-dd3c-4cfd-bb04-bbf449802f9b/small.jpg</picture_url>
          <person_id>gabrielradanne</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>7247de3f-3383-4054-a140-e8f4416d5fa6</slot_id>
      <event_id>75bbcf77-fd35-49e7-a3ca-2450da7386b8</event_id>
      <submission_id>12</submission_id>
      <title>Vision: Bias in Systematic Grammar-Based Test Suite Construction Algorithms</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>19:35</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:43</end_time>
      <description>The core of grammar-based test suite construction algorithms is a procedure to derive a set of specific phrases, which are then converted into sentences that can be fed into the system under test. This process includes several degrees of freedom and different implementations choose different but ultimately fixed solutions. We show that these fixed choices inherently bias the generated test suite. 
We quantify these biases and evaluate the effect they have on coverage over the system under test for which the test suite is constructed. We show that the effect of these biases remain prevalent in large real world grammars and systems, even when the test suites grow very large.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoff</first_name>
          <last_name>Rossouw</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <person_id>christoffrossouw</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>8da1b9ec-3408-402c-8638-7268e7785b36</slot_id>
      <event_id>ba7452c9-2b20-416d-9e9d-2729e6174030</event_id>
      <submission_id>5</submission_id>
      <title>Fast Incremental PEG Parsing</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:05</end_time>
      <description>Incremental parsing is an integral part of code analysis performed by text editors and integrated development environments. This paper presents new methods to significantly improve the efficiency of incremental parsing for Parsing Expression Grammars (PEGs). We build on Incremental Packrat Parsing, an algorithm that adapts packrat parsing to an incremental setting, by implementing the memoization table as an interval tree with special support for shifting intervals, and modifying the memoization strategy to create tree structures in the table. Our approach enables reparsing in time logarithmic in the size of the input for typical edits, compared with linear-time reparsing for Incremental Packrat Parsing. We implement our methods in a prototype called GPeg, a parsing machine for PEGs with support for dynamic parsers (an important feature for runtime extensibility in editors). Experiments show that GPeg has strong performance (sub-5ms reparse times) across a variety of input sizes (tens to hundreds of megabytes) and grammar types (from full language grammars to “island” grammars), and compares well with existing incremental parsers. As a complete application example, we also implement a syntax highlighting engine on top of GPeg, and a prototype editor, along with some optimizations for this particular use-case.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Yedidia</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zyedidia.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zacharyyedidia/c3ff7e7b-9e7e-420d-b5f6-648765cbe62b/small.jpg</picture_url>
          <person_id>zacharyyedidia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chong</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Stephen Chong is a Gordon McKay Professor of Computer Science in the Harvard John A. Paulson School of Engineering and Applied Sciences. Steve’s research focuses on programming languages, information security, and the intersection of these two areas. He is the recipient of an NSF CAREER award, an AFOSR Young Investigator award, and a Sloan Research Fellowship. He received a PhD from Cornell University, and a bachelor’s degree from Victoria University of Wellington, New Zealand.</bio>
          <homepage_url>https://people.seas.harvard.edu/~chong/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stephenchong/91e43651-bcd6-40dc-b231-4c92711b0e95/small.jpg</picture_url>
          <person_id>stephenchong</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a23223b9-4fb8-4b8a-b2f2-bca7d7d329f2</slot_id>
      <event_id>9f8c7895-e581-40ad-b45a-960150a2f290</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>19:51</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>ddf1568c-bc3e-4d83-80cc-507f7afe5ac7</slot_id>
      <event_id>239feb7d-9134-4d66-a0af-d859a58d738b</event_id>
      <submission_id>15</submission_id>
      <title>Faster Reachability Analysis for LR(1) Parsers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>19:05</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:20</end_time>
      <description>We present a novel algorithm for reachability in an LR(1) automaton. For each transition in the automaton, the problem is to determine under what conditions this transition can be taken, that is, which (minimal) input fragment and which lookahead symbol allow taking this transition. Our algorithm outperforms Pottier’s algorithm (2016) by up to three orders of magnitude on real-world grammars. Among other applications, this vastly improves the scalability of Jeffery’s error reporting technique (2003), where a mapping of (reachable) error states to messages must be created and maintained.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Frédéric</first_name>
          <last_name>Bour</last_name>
          <affiliation>Tarides</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://def.lakaban.net</homepage_url>
          <person_id>fredericbour</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>François</first_name>
          <last_name>Pottier</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gallium.inria.fr/~fpottier/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/francoispottier/8f390103-6b3f-4cf0-8bf9-891b0596b9b7/small.jpg</picture_url>
          <person_id>francoispottier</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>e259bcda-39fe-491a-a1a3-50dce6da91cf</slot_id>
      <event_id>d2a351ab-6925-489a-973b-88f21de65a05</event_id>
      <submission_id>33</submission_id>
      <title>Automatic Grammar Repair</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>19:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:35</end_time>
      <description>We describe the first approach to automatically repair bugs in context-free grammars: given a grammar that fails some tests in a given test suite, we iteratively and gradually improve the grammar until it passes all tests. Our core idea is to build on spectrum-based fault localization to identify promising repair sites (i.e., specific positions in rules), and to apply grammar patches at these sites whenever they satisfy explicitly formulated pre-conditions necessary to potentially improve the grammar. 
We have implemented this approach in the gfixr system, and successfully used it to fix grammars students submitted as homeworks in a compiler engineering course, and to map one Pascal dialect grammar against another dialect. 
gfixr can be configured to explore the repair space in different ways, and can also take advantage of counterexamples to enable restriction patches that make the grammar less permissive.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Moeketsi</first_name>
          <last_name>Raselimo</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/moeketsiraselimo/2f088517-eaa4-451a-befd-21f6bb9837f2/small.jpg</picture_url>
          <person_id>moeketsiraselimo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bernd</first_name>
          <last_name>Fischer</last_name>
          <affiliation>Stellenbosch University, South Africa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sun.ac.za/~bfischer/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/berndfischer/b51999f4-390c-48d9-be54-f3d1ceab7ff8/small.jpg</picture_url>
          <person_id>berndfischer</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>99eee368-eb25-48f8-ac51-e8d85afc2e05</subevent_id>
    <title>GPCE: GPCE/SLE Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/gpce-2021</url>
    <url_link_display>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2021</track>
    </tracks>
    <timeslot>
      <slot_id>f6b6ec9c-667d-40ae-b61d-4591b054f491</slot_id>
      <title>Session: GPCE - GPCE/SLE Session 1</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Emma</first_name>
          <last_name>Söderberg</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/emmasoderberg/2edc9865-4e98-41ee-a89e-1568465852e0/small.jpg</picture_url>
          <person_id>emmasoderberg</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6b5b344d-7bab-44be-a19c-4348b00c98b4</slot_id>
      <event_id>1953b8e6-dbc4-41de-82f3-767184e4791d</event_id>
      <title>SLE/GPCE Joint Welcome</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>09:20</end_time>
      <description>Joint welcome by the SLE and GPCE Program Chairs</description>
      <persons>
        <person>
          <role>Program Chair</role>
          <sort_key>1</sort_key>
          <first_name>Coen</first_name>
          <last_name>De Roover</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~cderoove/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/coenderoover/ef3a26a6-56c3-420e-b1ce-b4a0e6cd653e/small.jpg</picture_url>
          <person_id>coenderoover</person_id>
        </person>
        <person>
          <role>Program Chair</role>
          <sort_key>2</sort_key>
          <first_name>Emma</first_name>
          <last_name>Söderberg</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/emmasoderberg/2edc9865-4e98-41ee-a89e-1568465852e0/small.jpg</picture_url>
          <person_id>emmasoderberg</person_id>
        </person>
        <person>
          <role>Program Chair</role>
          <sort_key>3</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Kolovos</last_name>
          <affiliation>University of York</affiliation>
          <bio>Dimitris Kolovos is a Professor of Software Engineering in the Department of Computer Science at the University of York, where he researches and teaches automated and model-based software engineering. He is also an Eclipse Foundation committer, leading the development of the open-source Epsilon model-based software engineering platform, and an associate editor of the IET Software journal. Prof. Kolovos has co-authored more than 150 peer-reviewed papers and his research has been supported by the European Commission, UK’s Engineering and Physical Sciences Research Council (EPSRC), InnovateUK and by companies such as Rolls-Royce and IBM.</bio>
          <homepage_url>https://www-users.cs.york.ac.uk/~dkolovos</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dimitriskolovos/729a514e-e3bb-43e2-9944-6f6ef33dcaa1/small.jpg</picture_url>
          <person_id>dimitriskolovos</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>75b88757-8ac7-455a-9602-e056bdf84917</slot_id>
      <event_id>266304e3-dcf6-42bc-a743-4dca7cdb3e2c</event_id>
      <submission_id>21</submission_id>
      <title>Monilogging for Executable Domain-Specific Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>09:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:05</end_time>
      <description>Runtime monitoring and logging are fundamental techniques for analyzing and supervising the behavior of computer programs. However, supporting these techniques for a given language induces significant development costs that can hold language engineers back from providing adequate logging and monitoring tooling for new domain-specific modeling languages. Moreover, runtime monitoring and logging are generally considered as two different techniques: they are thus implemented separately which makes users prone to overlooking their potentially beneficial mutual interactions. We propose a language-agnostic, unifying framework for runtime monitoring and logging and demonstrate how it can be used to define loggers, runtime monitors and combinations of the two, aka. moniloggers. We provide an implementation of the framework that can be used with Java-based executable languages, and we evaluate it on 2 implementations of the NabLab interpreter, leveraging in turn the instrumentation facilities offered by Truffle, or those offered by AspectJ.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dorian</first_name>
          <last_name>Leroy</last_name>
          <affiliation>University of Rennes 1, Inria, France</affiliation>
          <bio>undefined</bio>
          <person_id>dorianleroy1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benoît</first_name>
          <last_name>Lelandais</last_name>
          <affiliation>CEA/DAM/DIF, France</affiliation>
          <bio>undefined</bio>
          <person_id>benoitlelandais</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marie-Pierre</first_name>
          <last_name>Oudot</last_name>
          <affiliation>CEA/DAM/DIF, France</affiliation>
          <bio>undefined</bio>
          <person_id>mariepierreoudot</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes 1, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>92d75904-7b94-46a4-93dd-97998cb078d4</slot_id>
      <event_id>3b6843f6-c930-4990-8436-e1c21f83e8eb</event_id>
      <submission_id>24</submission_id>
      <title>Vision: The Next 700 Language Workbenches</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>10:05</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:13</end_time>
      <description>Language workbenches (LWBs) are tools to define software languages together with tailored Integrated Development Environments for them. A comprehensive review of language workbenches by Erdweg et al. (Comput. Lang. Syst. Struct. 44, 2015) presented a feature model of functionality of LWBs from the point of view of the ``languages that can be defined with a language workbench, and not the definition mechanism of the language workbench itself''. In this vision paper, we discuss possible functionality of LWBs with regard to the language definition process. We have identified five groups of such functionality, related to: \emph{meta-definitions}, \emph{meta-modifications}, \emph{meta-process}, a \emph{language workbench itself}, and \emph{programs} written in languages defined in a workbench. We give an example of how one of the suggested features—\emph{specification of explicit dependencies between language concerns}—can be designed based on our vision.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Barash</last_name>
          <affiliation>University of Bergen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dsl-course.org/mikbar/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mikhailbarash/d876d731-3779-4e11-8aee-de2bcef5e938/small.jpg</picture_url>
          <person_id>mikhailbarash</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>ce4e4e82-e96c-4625-97c9-e7d89feb6e11</slot_id>
      <event_id>21568ac1-7430-4de5-9a10-38cf12009509</event_id>
      <title>Discussion, Questions, Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>10:13</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f825f7db-6ffe-4866-add1-7e368a9593d4</slot_id>
      <event_id>a97ec605-a47a-416a-8145-2f81ace21eaa</event_id>
      <title>SLE Keynote - Integrating Usability into Programming Language Design</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>09:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>09:50</end_time>
      <description>Programming language design research has traditionally focused primarily on theoretical properties and performance considerations. But programming languages are interfaces that programmers use to write programs. Recent work has begun to explore how to integrate interdisciplinary methods, including qualitative and quantitative user studies, into the language design process. I’ll describe how we applied such methods in two different designs, Obsidian and Glacier, some of the insights we gained, and discuss the larger impact these emerging methods can have on the field.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8af2e32c-d107-45c5-b2a4-d264a3b07530</subevent_id>
    <title>GPCE: GPCE/SLE Session 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/gpce-2021</url>
    <url_link_display>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</url_link_display>
    <tracks>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      <track>SLE (Software Language Engineering) 2021</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>5368203e-cdf2-4091-87b7-cdd3a1ea3e6c</slot_id>
      <title>Session: GPCE - GPCE/SLE Session 1</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Kolovos</last_name>
          <affiliation>University of York</affiliation>
          <bio>Dimitris Kolovos is a Professor of Software Engineering in the Department of Computer Science at the University of York, where he researches and teaches automated and model-based software engineering. He is also an Eclipse Foundation committer, leading the development of the open-source Epsilon model-based software engineering platform, and an associate editor of the IET Software journal. Prof. Kolovos has co-authored more than 150 peer-reviewed papers and his research has been supported by the European Commission, UK’s Engineering and Physical Sciences Research Council (EPSRC), InnovateUK and by companies such as Rolls-Royce and IBM.</bio>
          <homepage_url>https://www-users.cs.york.ac.uk/~dkolovos</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dimitriskolovos/729a514e-e3bb-43e2-9944-6f6ef33dcaa1/small.jpg</picture_url>
          <person_id>dimitriskolovos</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>3b8ecd57-0b13-448c-a852-ca7c1b76d191</slot_id>
      <event_id>a97ec605-a47a-416a-8145-2f81ace21eaa</event_id>
      <title>SLE Keynote - Integrating Usability into Programming Language Design</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>17:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>17:50</end_time>
      <description>Programming language design research has traditionally focused primarily on theoretical properties and performance considerations. But programming languages are interfaces that programmers use to write programs. Recent work has begun to explore how to integrate interdisciplinary methods, including qualitative and quantitative user studies, into the language design process. I’ll describe how we applied such methods in two different designs, Obsidian and Glacier, some of the insights we gained, and discuss the larger impact these emerging methods can have on the field.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
        <badge>Keynote</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>42a0c8f9-ae61-4255-8a01-54fc33d6a2cb</slot_id>
      <event_id>1953b8e6-dbc4-41de-82f3-767184e4791d</event_id>
      <title>SLE/GPCE Joint Welcome</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>17:20</end_time>
      <description>Joint welcome by the SLE and GPCE Program Chairs</description>
      <persons>
        <person>
          <role>Program Chair</role>
          <sort_key>1</sort_key>
          <first_name>Coen</first_name>
          <last_name>De Roover</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~cderoove/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/coenderoover/ef3a26a6-56c3-420e-b1ce-b4a0e6cd653e/small.jpg</picture_url>
          <person_id>coenderoover</person_id>
        </person>
        <person>
          <role>Program Chair</role>
          <sort_key>2</sort_key>
          <first_name>Emma</first_name>
          <last_name>Söderberg</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/emmasoderberg/2edc9865-4e98-41ee-a89e-1568465852e0/small.jpg</picture_url>
          <person_id>emmasoderberg</person_id>
        </person>
        <person>
          <role>Program Chair</role>
          <sort_key>3</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Kolovos</last_name>
          <affiliation>University of York</affiliation>
          <bio>Dimitris Kolovos is a Professor of Software Engineering in the Department of Computer Science at the University of York, where he researches and teaches automated and model-based software engineering. He is also an Eclipse Foundation committer, leading the development of the open-source Epsilon model-based software engineering platform, and an associate editor of the IET Software journal. Prof. Kolovos has co-authored more than 150 peer-reviewed papers and his research has been supported by the European Commission, UK’s Engineering and Physical Sciences Research Council (EPSRC), InnovateUK and by companies such as Rolls-Royce and IBM.</bio>
          <homepage_url>https://www-users.cs.york.ac.uk/~dkolovos</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dimitriskolovos/729a514e-e3bb-43e2-9944-6f6ef33dcaa1/small.jpg</picture_url>
          <person_id>dimitriskolovos</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>85d0f65a-6499-4e9b-bd86-675b89e603cf</slot_id>
      <event_id>3b6843f6-c930-4990-8436-e1c21f83e8eb</event_id>
      <submission_id>24</submission_id>
      <title>Vision: The Next 700 Language Workbenches</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>18:05</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>18:13</end_time>
      <description>Language workbenches (LWBs) are tools to define software languages together with tailored Integrated Development Environments for them. A comprehensive review of language workbenches by Erdweg et al. (Comput. Lang. Syst. Struct. 44, 2015) presented a feature model of functionality of LWBs from the point of view of the ``languages that can be defined with a language workbench, and not the definition mechanism of the language workbench itself''. In this vision paper, we discuss possible functionality of LWBs with regard to the language definition process. We have identified five groups of such functionality, related to: \emph{meta-definitions}, \emph{meta-modifications}, \emph{meta-process}, a \emph{language workbench itself}, and \emph{programs} written in languages defined in a workbench. We give an example of how one of the suggested features—\emph{specification of explicit dependencies between language concerns}—can be designed based on our vision.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mikhail</first_name>
          <last_name>Barash</last_name>
          <affiliation>University of Bergen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dsl-course.org/mikbar/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mikhailbarash/d876d731-3779-4e11-8aee-de2bcef5e938/small.jpg</picture_url>
          <person_id>mikhailbarash</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>9aa66e54-33a3-4c38-9bc1-9a0ab464daf6</slot_id>
      <event_id>266304e3-dcf6-42bc-a743-4dca7cdb3e2c</event_id>
      <submission_id>21</submission_id>
      <title>Monilogging for Executable Domain-Specific Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>17:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>18:05</end_time>
      <description>Runtime monitoring and logging are fundamental techniques for analyzing and supervising the behavior of computer programs. However, supporting these techniques for a given language induces significant development costs that can hold language engineers back from providing adequate logging and monitoring tooling for new domain-specific modeling languages. Moreover, runtime monitoring and logging are generally considered as two different techniques: they are thus implemented separately which makes users prone to overlooking their potentially beneficial mutual interactions. We propose a language-agnostic, unifying framework for runtime monitoring and logging and demonstrate how it can be used to define loggers, runtime monitors and combinations of the two, aka. moniloggers. We provide an implementation of the framework that can be used with Java-based executable languages, and we evaluate it on 2 implementations of the NabLab interpreter, leveraging in turn the instrumentation facilities offered by Truffle, or those offered by AspectJ.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dorian</first_name>
          <last_name>Leroy</last_name>
          <affiliation>University of Rennes 1, Inria, France</affiliation>
          <bio>undefined</bio>
          <person_id>dorianleroy1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benoît</first_name>
          <last_name>Lelandais</last_name>
          <affiliation>CEA/DAM/DIF, France</affiliation>
          <bio>undefined</bio>
          <person_id>benoitlelandais</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marie-Pierre</first_name>
          <last_name>Oudot</last_name>
          <affiliation>CEA/DAM/DIF, France</affiliation>
          <bio>undefined</bio>
          <person_id>mariepierreoudot</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Combemale</last_name>
          <affiliation>University of Rennes 1, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://combemale.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitcombemale/46a774c3-cec1-410d-99c2-c9c9d10b3bda/small.jpg</picture_url>
          <person_id>benoitcombemale</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>ab261385-64cb-432e-bc86-1c2295bd5cef</slot_id>
      <event_id>21568ac1-7430-4de5-9a10-38cf12009509</event_id>
      <title>Discussion, Questions, Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>18:13</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>18:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6904e391-91c8-4ef2-9057-7abd4ba2e987</subevent_id>
    <title>SLE: SLE/GPCE Session 8</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sle-2021</url>
    <url_link_display>SLE (Software Language Engineering) 2021</url_link_display>
    <tracks>
      <track>SLE (Software Language Engineering) 2021</track>
      <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>0159b319-5a47-4a94-ab90-eccc45ec1bc5</slot_id>
      <title>Session: SLE - SLE/GPCE Session 8</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Coen</first_name>
          <last_name>De Roover</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~cderoove/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/coenderoover/ef3a26a6-56c3-420e-b1ce-b4a0e6cd653e/small.jpg</picture_url>
          <person_id>coenderoover</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>36ccd1dd-5d66-48b1-a0cc-21bcd6abbc43</slot_id>
      <event_id>cbec2229-545a-457e-8f6a-da00c5321161</event_id>
      <submission_id>20</submission_id>
      <title>Lifted Termination Analysis by Abstract Interpretation and its Applications</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>08:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>08:25</end_time>
      <description>This paper is focused on proving termination for program families with numerical features by using abstract interpretation. Furthermore, we present an interesting application of the above lifted termination analysis for resolving ``sketches'', i.e. partial programs with missing numerical parameters (holes), such that the resulting complete programs always terminate. To successfully address the above problems, we employ an abstract interpretation-based framework for inferring sufficient preconditions for termination of single programs that synthesizes piecewise-defined ranking functions. 
We introduce a novel lifted decision tree domain for termination, in which decision nodes contain linear constraints defined over numerical features and leaf nodes contain piecewise ranking functions defined over program variables. Moreover, we encode a program sketch as a program family, thereby allowing the use of the lifted termination analysis as a program sketcher. In particular, we aim to find the variants (family members) that terminate under all possible inputs, which represent the correct sketch realizations. 
We have implemented an experimental lifted termination analyzer, called SPLFuncTion, for proving termination of $\texttt{#if}$-based C program families and for termination-directed resolving of C program sketches. We have evaluated our approach by a set of loop benchmarks from SV-COMP, and experimental results show that our approach is effective and efficient.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>S. Dimovski</last_name>
          <affiliation>Mother Teresa University, Skopje</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://aleksdimovski.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aleksandarsdimovski1/302de1d2-ceed-47e9-9987-41b7d778ee8d/small.jpg</picture_url>
          <person_id>aleksandarsdimovski1</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>48503f8c-e803-423d-b180-df35a4b3af0f</slot_id>
      <event_id>afd13fea-31e6-4de2-b33f-1adcdb690eae</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>6243d4df-aa9c-4bb5-8768-171ebe4193dc</slot_id>
      <event_id>2b702965-d312-4316-8d55-39a1e0d157f4</event_id>
      <submission_id>44</submission_id>
      <title>FIDDLR: Streamlining Reuse with Concern-Specific Modelling Languages</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>07:55</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>08:10</end_time>
      <description>Model-Driven Engineering (MDE) reduces complexity, improves Separation of Concerns and promotes reuse by structuring software development as a process of model production and model refinement. Domain-Specific Modelling Languages and Aspect-Oriented Modelling techniques can reduce complexity and improve modularization of crosscutting concerns in situations where the features of general purpose modelling languages are not well aligned with the subject of study. In this article we present FIDDLR, a novel approach that integrates the ideas of Domain-Specific Modelling Languages, Concern-Oriented Reuse and MDE to modularize software development concerns that cross-cut multiple levels of abstraction of the software development process and streamline the reuse process. It also prescribes the integration of the different tooling and transformation infrastructure, i.e., model transformations, model composition and code generation. We demonstrate the effectiveness of our framework and the potential for reduced complexity and leveraged reuse by building a reusable concern that can be used to expose the services a system offers through a custom REST interface.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maximilian</first_name>
          <last_name>Schiedermeier</last_name>
          <affiliation>McGill University</affiliation>
          <bio>undefined</bio>
          <person_id>maximilianschiedermeier</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jörg</first_name>
          <last_name>Kienzle</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.mcgill.ca/~joerg/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgkienzle/5833ba8f-2294-444c-8f6a-54007a388e34/small.jpg</picture_url>
          <person_id>jorgkienzle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bettina</first_name>
          <last_name>Kemme</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>bettinakemme</person_id>
        </person>
      </persons>
      <tracks>
        <track>SLE (Software Language Engineering) 2021</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>88e16e34-33f0-4e8c-ab01-39ff29aa8942</slot_id>
      <event_id>04f49794-5679-4653-af38-5b6b995e0cd3</event_id>
      <submission_id>32</submission_id>
      <title>Leveraging Relational Concept Analysis for Automated Feature Location in Software Product Lines</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>07:55</end_time>
      <description>Formal Concept Analysis (FCA) has been introduced for almost a decade as a suitable method for Feature Location (FL) on a collection of product variants. Even though FCA-based FL techniques allow to locate the core of a feature implementation, they do not propose a solution to trace feature interactions to their implementation. Thus, the extracted traceability links (traces) are too inaccurate, and, in the context of SPL extraction, cannot be used to generate complete products. 
In this paper, we propose to complement FCA-based FL techniques. Our proposed technique is capable of extracting the feature implementation and the implementation of the feature interaction. This process leverages the power of Relational Concept Analysis, an extension of FCA to multi-relational data. Moreover, our technique can be applied to fine-grained artefacts, which permits it to have more accurate traces that better capture the features’ implementation and interactions. Finally, we also propose a method to reduce the size of the traces (number of features) for a better comprehension of each trace. We have applied our FL technique to five case studies of product variants. The results show that our technique produces valid traces, from which we were able to completely rebuild the set of artefacts for each initial product. Our results also show that our trace reduction removes, on average, between 31% and 85% of unnecessary features from the traces.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Hlad</last_name>
          <affiliation>LIRMM, CNRS</affiliation>
          <bio>undefined</bio>
          <person_id>nicolashlad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bérénice</first_name>
          <last_name>Lemoine</last_name>
          <affiliation>LIRMM, CNRS</affiliation>
          <bio>undefined</bio>
          <person_id>berenicelemoine</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marianne</first_name>
          <last_name>Huchard</last_name>
          <affiliation>LIRMM</affiliation>
          <bio>Marianne Huchard is Full Professor of Computer Science at the University of Montpellier since 2004, where she teaches courses in software engineering and knowledge engineering. She develops her research at LIRMM (Laboratory of Informatics, Robotics and Microelectronics at Montpellier). She obtained a PhD in computer Science in 1992, during which she investigated algorithmic questions connected to the management of multiple inheritance in various object-oriented programming languages. She conducts research in two areas: in Formal Concept Analysis (FCA), where she studies theoretical and applied aspects, and in Software Engineering, where she contributes to model-driven engineering, component-based and service-based software development, as well as migration towards software product lines. She has been deputy director of the LIRMM, and she also participated to the creation and supervision of the Master degree in Software Engineering at the University of Montpellier, where she is currently responsible for the Doctoral studies in Computer Science. She recently served as the program chair of the 13th International Conference on Concept Lattices and their Applications (CLA 2016), as the general conference chair of the 27th European Conference on Object-Oriented Programming edition, the 9th European Conference on Modelling Foundations and Applications edition and the 7th European Conference on Software Architecture (ECMFA, ECOOP, ECSA 2013), and as the general chair of the 33rd IEEE/ACM International Conference on Automated Software Engineering (ASE 2018).</bio>
          <homepage_url>https://www.lirmm.fr/users/utilisateurs-lirmm/marianne-huchard</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mariannehuchard/54809086-6157-4f7d-b8f1-aa82671b27b3/small.jpg</picture_url>
          <person_id>mariannehuchard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Abdelhak</first_name>
          <last_name>Seriai</last_name>
          <affiliation>LIRMM, CNRS and University of Montpellier</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lirmm.fr/~seriai/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/abdelhakseriai/d85a802d-c34f-468b-9d76-5adb4adea766/small.jpg</picture_url>
          <person_id>abdelhakseriai</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>f45875bd-5516-4283-bc8e-9b4375f84e9c</slot_id>
      <event_id>52a219ce-0523-4856-a126-3b25b9f6063c</event_id>
      <submission_id>16</submission_id>
      <title>Delta-based Verification of Software Product Families</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>08:25</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>08:40</end_time>
      <description>The quest for feature- and family-oriented deductive verification of software product lines resulted in several proposals. In this paper we look at delta-oriented modeling of product lines and combine two new ideas: first, we extend Hähnle &amp;amp; Schaefer’s delta-oriented version of Liskov’s substitution principle for behavioral subtyping to work also for overridden behavior in benign cases. For this to succeed, programs need to be in a certain normal form. The required normal form turns out to be achievable in many cases by a set of program transformations, whose correctness is ensured by the recent technique of abstract execution. This is a generalization of symbolic execution that permits reasoning about abstract code elements. It is needed, because code deltas contain partially unknown code contexts in terms of “original” calls. Second, we devise a modular verification procedure for deltas based on abstract execution, representing deltas as abstract programs calling into unknown contexts. The result is a “delta-based” verification approach, where each modification of a method in a code delta is verified in isolation, but which overcomes the strict limitations of behavioral subtyping and works for many practical programs. The latter claim is substantiated with case studies and benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marco</first_name>
          <last_name>Scaletta</last_name>
          <affiliation>Technische Universität Darmstadt</affiliation>
          <bio>undefined</bio>
          <person_id>marcoscaletta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Reiner</first_name>
          <last_name>Hähnle</last_name>
          <affiliation>Technical University of Darmstadt</affiliation>
          <bio>I am Professor of Computer Science at TU Darmstadt, Germany. I received a PhD from University of Karlsruhe (now KIT) and a Habilitation from TU Vienna. From 2000 to 2011 I worked as an Associate, then Full Professor at Chalmers University of Technology.</bio>
          <homepage_url>https://www.se.tu-darmstadt.de/se/group-members/reiner-haehnle/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/reinerhahnle/1e50ca51-79fe-43ab-934f-2a13a2992f75/small.jpg</picture_url>
          <person_id>reinerhahnle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dominic</first_name>
          <last_name>Steinhöfel</last_name>
          <affiliation>CISPA Helmholtz Center for Information Security</affiliation>
          <bio>undefined</bio>
          <person_id>dominicsteinhofel1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Richard</first_name>
          <last_name>Bubel</last_name>
          <affiliation>Technische Universität Darmstadt</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/richardbubel/1dd0f6cd-cb8c-442c-a38f-cfcc98298a85/small.jpg</picture_url>
          <person_id>richardbubel</person_id>
        </person>
      </persons>
      <tracks>
        <track>GPCE 2021 - 20th International Conference on Generative Programming: Concepts &amp; Experiences</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>73a2139a-6e8e-4e57-a154-7510d98deba1</subevent_id>
    <title>APLAS Research Papers: Language Design (mirror)</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>393de962-dd29-41b6-a150-f22b304d5bf2</slot_id>
      <title>Session: APLAS Research Papers - Language Design (mirror)</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Andreea</first_name>
          <last_name>Costea</last_name>
          <affiliation>School of Computing, National University Of Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.comp.nus.edu.sg/~andreeac/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/andreeacostea/af4ebde7-b40f-4b5c-b2d4-9fd115bf7072/small.jpg</picture_url>
          <person_id>andreeacostea</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>38036427-4020-404e-be5b-21f9e5a8859b</slot_id>
      <event_id>5e8f5b7a-f99e-4413-9421-293ae8506852</event_id>
      <submission_id>25</submission_id>
      <title>Latent Effects for Reusable Language Components</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>19:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:35</end_time>
      <description>The development of programming languages can be quite complicated and costly. Hence, much effort has been devoted to the modular definition of language features that can be reused in various combinations to define new languages and experiment with their semantics. A notable outcome of these efforts is the algebra-based “datatypes à la carte” (DTC) approach. When combined with algebraic effects, DTC can model a wide range of common language features. Unfortunately, the current state of the art does not cover modular definitions of advanced control-flow mechanisms that defer execution to an appropriate point, such as call-by-name and call-by-need evaluation, as well as (multi-)staging. 
This paper defines latent effects, a generic class of such control-flow mechanisms. We demonstrate how function abstractions, lazy computations and a MetaML-like staging can all be expressed in a modular fashion using latent effects, and how they can be combined in various ways to obtain complex semantics. We provide a full Haskell implementation of our effects and handlers with a range of examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Birthe</first_name>
          <last_name>van den Berg</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/birthevandenberg/21e3094e-6010-4629-bfe1-8490394a9f9d/small.jpg</picture_url>
          <person_id>birthevandenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Casper</first_name>
          <last_name>Bach Poulsen</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://casperbp.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/casperbachpoulsen/2cddd6a9-d920-4f73-9fcf-f4d9462eb0e3/small.jpg</picture_url>
          <person_id>casperbachpoulsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Wu</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://zenzike.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nicolaswu/16dfcd93-2531-4de2-baee-d5a8d1a95a47/small.jpg</picture_url>
          <person_id>nicolaswu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>7230183f-cf51-4ff6-b7c5-bd9e8c0f8878</slot_id>
      <event_id>c504fd73-31ce-4375-a74d-fa36f0c6d31b</event_id>
      <submission_id>58</submission_id>
      <title>A Typed Programmatic Interface to Contracts on the Blockchain</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:05</end_time>
      <description>Smart contract applications on the blockchain can only reach their full potential if they integrate seamlessly with traditional software systems via a programmatic interface. This interface should provide for originating and invoking contracts as well as observing the state of the blockchain. We propose a typed API for this purpose and establish some properties of the combined system. Specifically, we provide an execution model that enables us to prove type-safe interaction between programs and the blockchain. We establish further properties of the model that give rise to requirements on the API. A prototype of the interface is implemented in OCaml for the Tezos blockchain.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thi Thu Ha</first_name>
          <last_name>Doan</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <person_id>thithuhadoan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Peter</first_name>
          <last_name>Thiemann</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/peterthiemann/43fc0175-1745-4b3a-b626-86e10da76b86/small.jpg</picture_url>
          <person_id>peterthiemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a3d87e33-0445-4645-9c2c-a0c2af26ea90</slot_id>
      <event_id>ac9913d2-431f-4244-aa49-c54872343cd9</event_id>
      <title>Q&amp;A and discussion</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>d96e6bc0-33b3-4d53-82cc-c4fb724bc5ae</slot_id>
      <event_id>d75f138f-18d6-4382-9e30-3bf9e3b517f9</event_id>
      <submission_id>16</submission_id>
      <title>The Choice Construct in the Soufflé Language</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>19:35</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:50</end_time>
      <description>Datalog has become a popular implementation language for solving large-scale, real world problems, including bug finders, network analysis tools, and disassemblers. These applications express complex behaviour with hundreds of relations and rules that often require a non-deterministic choice for tuples in relations to express worklist algorithms. 
This work is an experience report that describes the implementation of a \textit{choice} construct in the Datalog engine Soufflé. With the choice construct we can express worklist algorithms such as spanning trees in a few lines of code. We highlight the differences between rule-based choice as described in prior work, and relation-based choice introduced by this work. We show that a choice construct enables certain worklist algorithms to be computed up to 10k$\times$ faster than having no choice construct.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaowen</first_name>
          <last_name>Hu</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>xiaowenhu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Karp</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>joshuakarp</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Zhao</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>davidzhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Abdul</first_name>
          <last_name>Zreika</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>abdulzreika</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Xi</first_name>
          <last_name>Wu</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>xiwu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Bernhard</first_name>
          <last_name>Scholz</last_name>
          <affiliation>University of Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sydney.edu.au/engineering/people/bernhard.scholz.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bernhardscholz1/2ad1b16f-f423-4db2-bfce-56e86799d860/small.jpg</picture_url>
          <person_id>bernhardscholz1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>dd879fdd-d529-4ea7-b6b5-02f40cc3fb73</slot_id>
      <event_id>eaee7960-f7b4-427d-8c7b-7bc3df70bc41</event_id>
      <submission_id>54</submission_id>
      <title>Adaptable Traces for Program Explanations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>19:05</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:20</end_time>
      <description>Program traces are a sound basis for explaining the dynamic behavior of programs. Alas, program traces can grow big very quickly, even for small programs, which diminishes their value as explanations. 
In this paper we demonstrate how the systematic simplification of traces can yield succinct program explanations. Specifically, we introduce operations for transforming traces that facilitate the abstraction of details. The operations are the basis of a query language for the definition of trace filters that can adapt and simplify traces in a variety of ways. 
The generation of traces is governed by a variant of Call-By-Value semantics which specifically supports parsimony in trace representations. We show that our semantics is a conservative extension of Call-By-Value that can produce smaller traces and that the evaluation traces preserve the explanatory content of proof trees at a much smaller footprint.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Divya</first_name>
          <last_name>Bajaj</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>divyabajaj</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Erwig</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.engr.oregonstate.edu/~erwig/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinerwig/8fd12ecd-2d70-44d3-a670-d5ef12393f9c/small.jpg</picture_url>
          <person_id>martinerwig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Danila</first_name>
          <last_name>Fedorin</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>danilafedorin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kai</first_name>
          <last_name>Gay</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>kaigay</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fbd8eaf9-c5b9-49b0-9893-5592794a9438</subevent_id>
    <title>APLAS Research Papers: Language Design</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>9adf3337-ceca-40d2-a028-a1ce7395d715</slot_id>
      <title>Session: APLAS Research Papers - Language Design</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Sergio</first_name>
          <last_name>Mover</last_name>
          <affiliation>Ecole Polytechnique</affiliation>
          <bio>I am interested in formal methods for Cyber-Physical Systems (CPSs), embedded systems, and mobile systems. I worked on model checking techniques for CPSs and embedded software using Satisfiability Modulo Theories (SMT), and on program analysis techniques for mobile apps (in particular for Android). 
I am also interested in synthesis, “Big Code” (i.e., automatically learning from existing code to solve tasks like program synthesis or repair), model-based safety assessment, and planning (e.g., for hybrid domains).</bio>
          <homepage_url>http://www.sergiomover.eu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sergiomover/28d591ac-c437-40c7-bcbd-e3a4c1225fd2/small.jpg</picture_url>
          <person_id>sergiomover</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>118482de-4c35-4761-8cf2-e6c66deb0fa0</slot_id>
      <event_id>d75f138f-18d6-4382-9e30-3bf9e3b517f9</event_id>
      <submission_id>16</submission_id>
      <title>The Choice Construct in the Soufflé Language</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:50</end_time>
      <description>Datalog has become a popular implementation language for solving large-scale, real world problems, including bug finders, network analysis tools, and disassemblers. These applications express complex behaviour with hundreds of relations and rules that often require a non-deterministic choice for tuples in relations to express worklist algorithms. 
This work is an experience report that describes the implementation of a \textit{choice} construct in the Datalog engine Soufflé. With the choice construct we can express worklist algorithms such as spanning trees in a few lines of code. We highlight the differences between rule-based choice as described in prior work, and relation-based choice introduced by this work. We show that a choice construct enables certain worklist algorithms to be computed up to 10k$\times$ faster than having no choice construct.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaowen</first_name>
          <last_name>Hu</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>xiaowenhu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Karp</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>joshuakarp</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Zhao</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>davidzhao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Abdul</first_name>
          <last_name>Zreika</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>abdulzreika</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Xi</first_name>
          <last_name>Wu</last_name>
          <affiliation>The University of Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>xiwu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Bernhard</first_name>
          <last_name>Scholz</last_name>
          <affiliation>University of Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sydney.edu.au/engineering/people/bernhard.scholz.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bernhardscholz1/2ad1b16f-f423-4db2-bfce-56e86799d860/small.jpg</picture_url>
          <person_id>bernhardscholz1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>12a38d1c-066a-4400-96bb-cc6a445f2ed9</slot_id>
      <event_id>5e8f5b7a-f99e-4413-9421-293ae8506852</event_id>
      <submission_id>25</submission_id>
      <title>Latent Effects for Reusable Language Components</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:35</end_time>
      <description>The development of programming languages can be quite complicated and costly. Hence, much effort has been devoted to the modular definition of language features that can be reused in various combinations to define new languages and experiment with their semantics. A notable outcome of these efforts is the algebra-based “datatypes à la carte” (DTC) approach. When combined with algebraic effects, DTC can model a wide range of common language features. Unfortunately, the current state of the art does not cover modular definitions of advanced control-flow mechanisms that defer execution to an appropriate point, such as call-by-name and call-by-need evaluation, as well as (multi-)staging. 
This paper defines latent effects, a generic class of such control-flow mechanisms. We demonstrate how function abstractions, lazy computations and a MetaML-like staging can all be expressed in a modular fashion using latent effects, and how they can be combined in various ways to obtain complex semantics. We provide a full Haskell implementation of our effects and handlers with a range of examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Birthe</first_name>
          <last_name>van den Berg</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/birthevandenberg/21e3094e-6010-4629-bfe1-8490394a9f9d/small.jpg</picture_url>
          <person_id>birthevandenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Casper</first_name>
          <last_name>Bach Poulsen</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://casperbp.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/casperbachpoulsen/2cddd6a9-d920-4f73-9fcf-f4d9462eb0e3/small.jpg</picture_url>
          <person_id>casperbachpoulsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Wu</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://zenzike.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nicolaswu/16dfcd93-2531-4de2-baee-d5a8d1a95a47/small.jpg</picture_url>
          <person_id>nicolaswu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>1bb13709-47a1-40dc-b267-8cc31fda1179</slot_id>
      <event_id>eaee7960-f7b4-427d-8c7b-7bc3df70bc41</event_id>
      <submission_id>54</submission_id>
      <title>Adaptable Traces for Program Explanations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:20</end_time>
      <description>Program traces are a sound basis for explaining the dynamic behavior of programs. Alas, program traces can grow big very quickly, even for small programs, which diminishes their value as explanations. 
In this paper we demonstrate how the systematic simplification of traces can yield succinct program explanations. Specifically, we introduce operations for transforming traces that facilitate the abstraction of details. The operations are the basis of a query language for the definition of trace filters that can adapt and simplify traces in a variety of ways. 
The generation of traces is governed by a variant of Call-By-Value semantics which specifically supports parsimony in trace representations. We show that our semantics is a conservative extension of Call-By-Value that can produce smaller traces and that the evaluation traces preserve the explanatory content of proof trees at a much smaller footprint.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Divya</first_name>
          <last_name>Bajaj</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>divyabajaj</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Erwig</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.engr.oregonstate.edu/~erwig/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinerwig/8fd12ecd-2d70-44d3-a670-d5ef12393f9c/small.jpg</picture_url>
          <person_id>martinerwig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Danila</first_name>
          <last_name>Fedorin</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>danilafedorin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kai</first_name>
          <last_name>Gay</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <person_id>kaigay</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>e514d52b-8b16-47fd-8663-016a3615abe3</slot_id>
      <event_id>ac9913d2-431f-4244-aa49-c54872343cd9</event_id>
      <title>Q&amp;A and discussion</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>f102028a-74fc-4bef-8707-7015d201c6b7</slot_id>
      <event_id>c504fd73-31ce-4375-a74d-fa36f0c6d31b</event_id>
      <submission_id>58</submission_id>
      <title>A Typed Programmatic Interface to Contracts on the Blockchain</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:05</end_time>
      <description>Smart contract applications on the blockchain can only reach their full potential if they integrate seamlessly with traditional software systems via a programmatic interface. This interface should provide for originating and invoking contracts as well as observing the state of the blockchain. We propose a typed API for this purpose and establish some properties of the combined system. Specifically, we provide an execution model that enables us to prove type-safe interaction between programs and the blockchain. We establish further properties of the model that give rise to requirements on the API. A prototype of the interface is implemented in OCaml for the Tezos blockchain.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thi Thu Ha</first_name>
          <last_name>Doan</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <person_id>thithuhadoan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Peter</first_name>
          <last_name>Thiemann</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/peterthiemann/43fc0175-1745-4b3a-b626-86e10da76b86/small.jpg</picture_url>
          <person_id>peterthiemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>81d93fbf-00c1-4651-82fa-64e98ae6a545</subevent_id>
    <title>APLAS Research Papers: Compilation / Transformation</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>ee53eeba-812e-45c4-8490-3d711511fbe2</slot_id>
      <title>Session: APLAS Research Papers - Compilation / Transformation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Sam</first_name>
          <last_name>Lindley</last_name>
          <affiliation>The University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/slindley</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/samlindley/144f1f69-c839-48e3-8ba4-58a84018aa48/small.jpg</picture_url>
          <person_id>samlindley</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>484b5a33-7865-41f5-b79d-9591166b3f77</slot_id>
      <event_id>e1a791fb-2102-4026-9fc8-3a9400cbe9c4</event_id>
      <submission_id>80</submission_id>
      <title>A Dictionary-Passing Translation of Featherweight Go</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:05</end_time>
      <description>The Go programming language is an increasingly popular language but some of its features lack a formal investigation. This article explains Go’s resolution mechanism for overloaded methods and its support for structural subtyping by means of translation from Featherweight Go to a simple target language. The translation employs a form of dictionary passing known from type classes in Haskell and preserves the dynamic behavior of Featherweight Go programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Sulzmann</last_name>
          <affiliation>Karlsruhe University of Applied Sciences, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>martinsulzmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Wehr</last_name>
          <affiliation>Offenburg University of Applied Sciences</affiliation>
          <bio>undefined</bio>
          <person_id>stefanwehr</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>68d4f23f-cb8d-4650-8ed3-4cab2cd98771</slot_id>
      <event_id>0eb87a5c-311b-4a3b-b4b2-cf9a7aa967da</event_id>
      <submission_id>24</submission_id>
      <title>Hybrid quantum-classical circuit simplification with the ZX-calculus</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:50</end_time>
      <description>We present a complete optimization procedure for hybrid quantum-classical circuits with classical parity logic. While common optimization techniques for quantum algorithms focus on rewriting solely the pure quantum segments, there is interest in applying a global optimization process for applications such as quantum error correction and quantum assertions. 
This work, based on the pure-quantum circuit optimization procedure by Duncan et al., uses an extension of the formal graphical ZX-calculus called ZX⏚ as an intermediary representation of the hybrid circuits to allow for granular optimizations below the quantum-gate level. We define a translation from hybrid circuits into diagrams that admit the graph-theoretical focused-gFlow property, needed for the final extraction back into a circuit. We then derive a number of gFlow-preserving optimization rules for ZX⏚ diagrams that reduce the size of the graph, and devise an strategy to find optimization opportunities by rewriting the diagram guided by a Gauss elimination process. Then, after extracting the circuit, we present a general procedure for detecting segments of circuit-like ZX⏚ diagrams which can be implemented with classical gates in the extracted circuit. We have implemented our optimization procedure as an extension to the open-source python library PyZX.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Agustín</first_name>
          <last_name>Borgna</last_name>
          <affiliation>Université de Lorraine, CNRS, Inria, LORIA F 54000 Nancy, France and Université Paris-Saclay, CNRS, Laboratoire Méthodes Formelles, 91405, Orsay, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://lmf.cnrs.fr/Perso/Agustin_Borgna</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/agustinborgna/54b0204f-16fa-459a-9354-1561aef2b474/small.jpg</picture_url>
          <person_id>agustinborgna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Perdrix</last_name>
          <affiliation>Université de Lorraine, CNRS, Inria, LORIA F 54000 Nancy, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://perdrix.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/simonperdrix/5f59b569-aef7-4704-9441-90a45a7981d4/small.jpg</picture_url>
          <person_id>simonperdrix</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Valiron</last_name>
          <affiliation>LRI, CentraleSupelec, Univ. Paris Saclay</affiliation>
          <bio>Assistant professor at CentraleSupelec.</bio>
          <homepage_url>http://www.monoidal.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitvaliron/ec85a2e3-534a-4377-8852-46bfe159b870/small.jpg</picture_url>
          <person_id>benoitvaliron</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>7c6e6bef-8fd4-4460-8024-e058434e40df</slot_id>
      <event_id>9325b9d3-7399-47b6-a12b-9bdf3c315ab7</event_id>
      <submission_id>45</submission_id>
      <title>A compilation method for dynamic typing in ML</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:20</end_time>
      <description>This paper develops a systematic method for extending a polymorphic type system of ML with dynamic typing, and implements the extension in SML#, a full-scale native code compiler of Standard ML. The core of the extension consists of an adaptation of the type-directed compilation method for non-parametric polymorphism to type tag abstraction and type tag generation guided by type abstraction and type application. To support existentially bound type variables in dynamic value elimination and user-level manipulation of dynamic values, the conventional type-directed compilation framework is extended with existential types and a mechanism to reify dynamic values to user-level datatypes. The resulting language achieves orthogonal integration of dynamic typing in ML; it supports all the standard features of ML, including polymorphic type inference, user-defined datatypes and pattern matching in programming with dynamic typing. The implementation readily provides various practical features, including polymorphic first-class pretty-printer, polymorphic deserialization, type-safe interface to database systems, and type-safe meta-programming. The paper demonstrates its practical usefulness through programming examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Ohori</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/atsushiohori/fb4f797b-bbfe-4073-8141-60f3fe8b2371/small.jpg</picture_url>
          <person_id>atsushiohori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Katsuhiro</first_name>
          <last_name>Ueno</last_name>
          <affiliation>Tohoku University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/katsuhiroueno/bd849dfa-47a5-43cd-92ef-8fe3a5fc7902/small.jpg</picture_url>
          <person_id>katsuhiroueno</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>cb567c09-1019-48a2-9b12-26aa4b2447e0</slot_id>
      <event_id>1888d977-be71-4fae-b1d1-e7a23822c901</event_id>
      <submission_id>28</submission_id>
      <title>Fully Abstract and Robust Compilation and How to Reconcile the Two, Abstractly</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:35</end_time>
      <description>The most prominent formal criterion for secure compilation is full abstraction, the preservation and reflection of contextual equivalence. Recent work introduced robust compilation, defined as the preservation of robust satisfaction of hyperproperties, i.e., their satisfaction against arbitrary attackers. In this paper, we initially set out to compare these two approaches to secure compilation. To that end, we provide an exact description of the hyperproperties that are robustly satisfied by programs compiled with a fully abstract compiler, and show that they can be meaningless or trivial. We then propose a novel criterion for secure compilation formulated in the framework of Mathematical Operational Semantics (MOS), guaranteeing both full abstraction and the preservation of robust satisfaction of hyperproperties in a more sensible manner.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Carmine</first_name>
          <last_name>Abate</last_name>
          <affiliation>Max Planck Institute for Security and Privacy, Bochum, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>carmineabate1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Busi</last_name>
          <affiliation>Università di Pisa - Dipartimento di Informatica</affiliation>
          <bio>undefined</bio>
          <person_id>matteobusi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stelios</first_name>
          <last_name>Tsampas</last_name>
          <affiliation>FAU Erlangen-Nuremberg, INF 8</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://distrinet.cs.kuleuven.be/people/SteliosTsampas</homepage_url>
          <person_id>steliostsampas</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>d337ef5d-cc9c-43bd-ab70-cf426d0cad91</slot_id>
      <event_id>ac9913d2-431f-4244-aa49-c54872343cd9</event_id>
      <title>Q&amp;A and discussion</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>efb54a3b-1ae4-46f9-bd58-03beef710999</subevent_id>
    <title>APLAS Research Papers: Analysis / Synthesis </title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>e50cd301-b400-4076-826b-40c5f13b76bf</slot_id>
      <title>Session: APLAS Research Papers - Analysis / Synthesis </title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Jiasi</first_name>
          <last_name>Shen</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://shenjiasi.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jiasishen/26f75637-316f-444d-adf2-bdd38a6c30a6/small.jpg</picture_url>
          <person_id>jiasishen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>13bae0bd-98d7-4f31-a34d-8c7fcaa203ab</slot_id>
      <event_id>f4797ec2-3f39-4e93-87f9-3efc30cb9952</event_id>
      <submission_id>33</submission_id>
      <title>Scalable and Modular Robustness Analysis of Deep Neural Networks</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:05</end_time>
      <description>As neural networks are trained to be deeper and larger, the scalability of neural network analyzer is urgently required. The main technical insight of our method is modularly analyzing neural networks by segmenting a network into blocks and conduct the analysis for each block. In particular, we propose the network block summarization technique to capture the behaviors within a network block using a block summary and leverage the summary to speed up the analysis process. We instantiate our method in the context of a CPU-version of the state-of-the-art analyzer DeepPoly and name our system as Bounded-Block Poly (BBPoly). We evaluate BBPoly extensively on various experiment settings. The experimental result indicates that our method yields comparable precision as DeepPoly but runs faster and requires less computational resources. For example, BBPoly can analyze really large neural networks like SkipNet or ResNet which contain up to one million neurons in less than around 1 hour per input image, while DeepPoly needs to spend even 40 hours to analyze one image.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuyi</first_name>
          <last_name>Zhong</last_name>
          <affiliation>School of Computing, National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>yuyizhong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Quang-Trung</first_name>
          <last_name>Ta</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>quangtrungta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tianzuo</first_name>
          <last_name>Luo</last_name>
          <affiliation>School of Computing, National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>tianzuoluo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fanlong</first_name>
          <last_name>ZHANG</last_name>
          <affiliation>School of Computer, Guangdong University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>fanlongzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Siau-Cheng</first_name>
          <last_name>Khoo</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~khoosc/</homepage_url>
          <person_id>siauchengkhoo</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>53ae5dbf-b7f9-499f-a830-58574682bac5</slot_id>
      <event_id>907e9700-9131-4487-bb17-c947fd91adb2</event_id>
      <submission_id>20</submission_id>
      <title>Program Synthesis for Musicians: A Usability Testbed for Temporal Logic Specifications</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:40</end_time>
      <description>In recent years, program synthesis research has made significant progress in creating user-friendly tools for Programming by example (PBE) and Programming by demonstration (PBD) environments. However, program synthesis from logical specifications, such as reactive synthesis, still faces large challenges in widespread adoption. In order to bring reactive synthesis to a wider audience, more research is necessary to explore different interface options. We present The SynthSynthesizer, a music-based tool for designing and testing specification interfaces. The tool enables researchers to prototype different interfaces for reactive synthesis and run user studies on them. The tool is accessible to both researchers and users by running on a browser on top of a docker-containerized synthesis toolchain. We show sample implementations with the tool by creating dropdown interfaces, and by running a user study with 21 users.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wonhyuk</first_name>
          <last_name>Choi</last_name>
          <affiliation>Columbia University</affiliation>
          <bio>undefined</bio>
          <person_id>wonhyukchoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michel</first_name>
          <last_name>Vazirani</last_name>
          <affiliation>Columbia University</affiliation>
          <bio>undefined</bio>
          <person_id>michelvazirani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mark</first_name>
          <last_name>Santolucito</last_name>
          <affiliation>Barnard College, Columbia University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.marksantolucito.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marksantolucito/51821284-64c1-46e0-b979-96e8324079bf/small.jpg</picture_url>
          <person_id>marksantolucito</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>58ac6bd6-8550-452f-bd59-6eb9ebb936ad</slot_id>
      <event_id>764db38c-a04e-4c02-b590-2c2572e8c133</event_id>
      <submission_id>37</submission_id>
      <title>Server-Side Computation of Package Dependencies in Package-Management Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:20</end_time>
      <description>Package managers are often used in recent software development to obtain directly-dependent packages recursively. Typically, package managers make requests to the package registry more than once when computing indirect dependencies. Moreover, much amount of computations are duplicated by clients of package managers. This duplication can be avoided by computing indirect dependencies in advance on the server-side of package-management systems. Therefore, we propose two algorithms functioning in parallel on the server-side: one to compute the indirect dependencies when copying all packages in existing package managers to the server and one to add packages to the server. Based on these parallelized algorithms, we implement a server {\tt fpms-server} and a client {\tt fpms} for npm packages. By our experiments, our client obtains dependencies of some package more than two times faster than clients in existing npm and yarn systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nobuhiro</first_name>
          <last_name>Kasai</last_name>
          <affiliation>Shibaura Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>nobuhirokasai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isao</first_name>
          <last_name>Sasano</last_name>
          <affiliation>Shibaura Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.sic.shibaura-it.ac.jp/~sasano/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/isaosasano/b77a139b-e948-4f6c-ad81-8afe7cb17d0e/small.jpg</picture_url>
          <person_id>isaosasano</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>923bbf0b-29a6-4487-8cc6-61fe53e5da3e</slot_id>
      <event_id>47844a39-78c0-49b3-8e9b-cfa59c9eb1d2</event_id>
      <submission_id>10</submission_id>
      <title>Function Pointer Eliminator for C Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>11:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:50</end_time>
      <description>Verification of memory safety such as absence of null pointer dereferences and memory leaks in system software is important in practice. O’Hearn’s group proposed a new method of memory safety analysis/verification by modular abstract interpretation with separation logic and biabduction. To realize this method, one has to construct a call graph before the modular abstract interpretation. This paper aims to analyze/verify memory safety of system software written in C programming language by this method, and as the first step this paper provides a function pointer eliminator tool to eliminate function pointer calls in order to construct a call graph. The tool uses SVF for pointer analysis. First C programs are translated into LLVM programs by Clang and then SVF analyses the LLVM programs. The tool given in this paper finds correspondence between function pointer calls in C programs and those in LLVM programs, and transforms the C programs into C programs with the same functionality and without any function pointer calls. The experimental results for gzip, git, and OpenSSL using this function pointer eliminator are presented and they show that this tool is sufficiently efficient and precise for the purpose.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daisuke</first_name>
          <last_name>Kimura</last_name>
          <affiliation>Toho University	</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/daisukekimura/6b912400-e3bf-44b2-b9c9-9d6412dee364/small.jpg</picture_url>
          <person_id>daisukekimura</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mahmudul Faisal Al</first_name>
          <last_name>Ameen</last_name>
          <affiliation>University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>mahmudulfaisalalameen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Makoto</first_name>
          <last_name>Tatsuta</last_name>
          <affiliation>National Institute of Informatics</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.nii.ac.jp/~tatsuta/index-e.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/makototatsuta/a8798f89-7cfc-4ef4-af83-3c5b65ffa4df/small.jpg</picture_url>
          <person_id>makototatsuta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Koji</first_name>
          <last_name>Nakazawa</last_name>
          <affiliation>Nagoya University</affiliation>
          <bio>undefined</bio>
          <person_id>kojinakazawa1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>ab5c4cd4-c583-4d0a-82be-00a8b202df09</slot_id>
      <event_id>2cf3b543-8892-48b1-956b-60a7954965d1</event_id>
      <submission_id>76</submission_id>
      <title>PyCT: A Python Concolic Tester</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>11:30</end_time>
      <description>Concolic testing is a software testing technique for generating concrete inputs of programs to increase code coverage and has been developed for years. For programming languages such as C, JAVA, x86 binary code, and JavaScript, there are already plenty of available concolic testers. However, the concolic testers for Python are relatively less. Since Python is a popular programming language, we believe there is a strong need to develop a good one. 
Among the existing testers for Python, PyExZ3 is the most well-known and advanced. However, we found some issues of PyExZ3: (1) it implements only a limited number of base types’ (e.g., integer, string) member functions and(2) it automatically downcasts concolic objects and discards related symbolic information as it encounters built-in types’ constructors. 
Based on the concept of PyExZ3, we develop a new tool called PyCT to alleviate these two issues. PyCT supports a more complete set of member functions of data types including integer, string, and range. We also proposes a new method to upcast constants to concolic ones to prevent unnecessary downcasting. Our evaluation shows that with more member functions being supported, the coverage rate is raised to (80.20%) from (71.55%). It continues to go up to (85.68%) as constant upcasting is also implemented.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wei-Lun</first_name>
          <last_name>Tsai</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>weiluntsai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wei-Cheng</first_name>
          <last_name>Wu</last_name>
          <affiliation>University of Southern California, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://steel.isi.edu/members/weicheng</homepage_url>
          <person_id>weichengwu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Di-De</first_name>
          <last_name>Yen</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>dideyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fang</first_name>
          <last_name>Yu</last_name>
          <affiliation>National Chengchi University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/fangyu/4400f412-1da9-4bf0-80c5-3011774ce2cc/small.jpg</picture_url>
          <person_id>fangyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yu-Fang</first_name>
          <last_name>Chen</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iis.sinica.edu.tw/~yfc/doku.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yufangchen/87eecff2-df03-4022-9c4e-7d96872d36c4/small.jpg</picture_url>
          <person_id>yufangchen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>cde97176-2957-4c4b-8866-57ac5c0f3900</slot_id>
      <event_id>ac9913d2-431f-4244-aa49-c54872343cd9</event_id>
      <title>Q&amp;A and discussion</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>764c79f2-6419-4ad8-b498-890becb2043c</subevent_id>
    <title>APLAS Research Papers: Compilation / Transformation (mirror)</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>347f705b-85eb-477f-b22f-4bb7bd7aad04</slot_id>
      <title>Session: APLAS Research Papers - Compilation / Transformation (mirror)</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Xin</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Xin Zhang is an Assistant Professor at the Department of Computer Science and Technology, the School of Electronics Engineering and Computer Science, Peking University. While he is broadly interested in topics related to programming languages (PL) and software engineering (SE), his current focus is on program analysis and its interplay with machine learning (ML) and artificial intelligence (AI). On one hand, he leverages ideas from ML/AI to build better program analyses. On the other hand, he develops program analyses and languages for improving intepretability, fairness, robustness, and safety of ML/AI systems.</bio>
          <homepage_url>http://xinpl.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xinzhang/a4dbba61-3d43-4702-818f-94cad593fbec/small.jpg</picture_url>
          <person_id>xinzhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>00ae502d-8b2f-4101-8527-d08896109105</slot_id>
      <event_id>9325b9d3-7399-47b6-a12b-9bdf3c315ab7</event_id>
      <submission_id>45</submission_id>
      <title>A compilation method for dynamic typing in ML</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>22:05</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:20</end_time>
      <description>This paper develops a systematic method for extending a polymorphic type system of ML with dynamic typing, and implements the extension in SML#, a full-scale native code compiler of Standard ML. The core of the extension consists of an adaptation of the type-directed compilation method for non-parametric polymorphism to type tag abstraction and type tag generation guided by type abstraction and type application. To support existentially bound type variables in dynamic value elimination and user-level manipulation of dynamic values, the conventional type-directed compilation framework is extended with existential types and a mechanism to reify dynamic values to user-level datatypes. The resulting language achieves orthogonal integration of dynamic typing in ML; it supports all the standard features of ML, including polymorphic type inference, user-defined datatypes and pattern matching in programming with dynamic typing. The implementation readily provides various practical features, including polymorphic first-class pretty-printer, polymorphic deserialization, type-safe interface to database systems, and type-safe meta-programming. The paper demonstrates its practical usefulness through programming examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Ohori</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/atsushiohori/fb4f797b-bbfe-4073-8141-60f3fe8b2371/small.jpg</picture_url>
          <person_id>atsushiohori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Katsuhiro</first_name>
          <last_name>Ueno</last_name>
          <affiliation>Tohoku University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/katsuhiroueno/bd849dfa-47a5-43cd-92ef-8fe3a5fc7902/small.jpg</picture_url>
          <person_id>katsuhiroueno</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>250b93a6-7a2e-48b6-aba8-78872dc6b685</slot_id>
      <event_id>1888d977-be71-4fae-b1d1-e7a23822c901</event_id>
      <submission_id>28</submission_id>
      <title>Fully Abstract and Robust Compilation and How to Reconcile the Two, Abstractly</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>22:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:35</end_time>
      <description>The most prominent formal criterion for secure compilation is full abstraction, the preservation and reflection of contextual equivalence. Recent work introduced robust compilation, defined as the preservation of robust satisfaction of hyperproperties, i.e., their satisfaction against arbitrary attackers. In this paper, we initially set out to compare these two approaches to secure compilation. To that end, we provide an exact description of the hyperproperties that are robustly satisfied by programs compiled with a fully abstract compiler, and show that they can be meaningless or trivial. We then propose a novel criterion for secure compilation formulated in the framework of Mathematical Operational Semantics (MOS), guaranteeing both full abstraction and the preservation of robust satisfaction of hyperproperties in a more sensible manner.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Carmine</first_name>
          <last_name>Abate</last_name>
          <affiliation>Max Planck Institute for Security and Privacy, Bochum, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>carmineabate1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Busi</last_name>
          <affiliation>Università di Pisa - Dipartimento di Informatica</affiliation>
          <bio>undefined</bio>
          <person_id>matteobusi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stelios</first_name>
          <last_name>Tsampas</last_name>
          <affiliation>FAU Erlangen-Nuremberg, INF 8</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://distrinet.cs.kuleuven.be/people/SteliosTsampas</homepage_url>
          <person_id>steliostsampas</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>3525d3d5-573a-4945-8d75-9e84c3731549</slot_id>
      <event_id>e1a791fb-2102-4026-9fc8-3a9400cbe9c4</event_id>
      <submission_id>80</submission_id>
      <title>A Dictionary-Passing Translation of Featherweight Go</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:05</end_time>
      <description>The Go programming language is an increasingly popular language but some of its features lack a formal investigation. This article explains Go’s resolution mechanism for overloaded methods and its support for structural subtyping by means of translation from Featherweight Go to a simple target language. The translation employs a form of dictionary passing known from type classes in Haskell and preserves the dynamic behavior of Featherweight Go programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Sulzmann</last_name>
          <affiliation>Karlsruhe University of Applied Sciences, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>martinsulzmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Wehr</last_name>
          <affiliation>Offenburg University of Applied Sciences</affiliation>
          <bio>undefined</bio>
          <person_id>stefanwehr</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>5f7442b6-b112-4750-bd3a-1c4b286b18dd</slot_id>
      <event_id>0eb87a5c-311b-4a3b-b4b2-cf9a7aa967da</event_id>
      <submission_id>24</submission_id>
      <title>Hybrid quantum-classical circuit simplification with the ZX-calculus</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>22:35</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:50</end_time>
      <description>We present a complete optimization procedure for hybrid quantum-classical circuits with classical parity logic. While common optimization techniques for quantum algorithms focus on rewriting solely the pure quantum segments, there is interest in applying a global optimization process for applications such as quantum error correction and quantum assertions. 
This work, based on the pure-quantum circuit optimization procedure by Duncan et al., uses an extension of the formal graphical ZX-calculus called ZX⏚ as an intermediary representation of the hybrid circuits to allow for granular optimizations below the quantum-gate level. We define a translation from hybrid circuits into diagrams that admit the graph-theoretical focused-gFlow property, needed for the final extraction back into a circuit. We then derive a number of gFlow-preserving optimization rules for ZX⏚ diagrams that reduce the size of the graph, and devise an strategy to find optimization opportunities by rewriting the diagram guided by a Gauss elimination process. Then, after extracting the circuit, we present a general procedure for detecting segments of circuit-like ZX⏚ diagrams which can be implemented with classical gates in the extracted circuit. We have implemented our optimization procedure as an extension to the open-source python library PyZX.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Agustín</first_name>
          <last_name>Borgna</last_name>
          <affiliation>Université de Lorraine, CNRS, Inria, LORIA F 54000 Nancy, France and Université Paris-Saclay, CNRS, Laboratoire Méthodes Formelles, 91405, Orsay, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://lmf.cnrs.fr/Perso/Agustin_Borgna</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/agustinborgna/54b0204f-16fa-459a-9354-1561aef2b474/small.jpg</picture_url>
          <person_id>agustinborgna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Perdrix</last_name>
          <affiliation>Université de Lorraine, CNRS, Inria, LORIA F 54000 Nancy, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://perdrix.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/simonperdrix/5f59b569-aef7-4704-9441-90a45a7981d4/small.jpg</picture_url>
          <person_id>simonperdrix</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Valiron</last_name>
          <affiliation>LRI, CentraleSupelec, Univ. Paris Saclay</affiliation>
          <bio>Assistant professor at CentraleSupelec.</bio>
          <homepage_url>http://www.monoidal.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benoitvaliron/ec85a2e3-534a-4377-8852-46bfe159b870/small.jpg</picture_url>
          <person_id>benoitvaliron</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>fa3b73ef-d576-4172-8c0f-050147bbd587</slot_id>
      <event_id>ac9913d2-431f-4244-aa49-c54872343cd9</event_id>
      <title>Q&amp;A and discussion</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1f150c98-7f85-40e1-8b01-1912bf3c6cf8</subevent_id>
    <title>APLAS Research Papers: Analysis / Synthesis (mirror)</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>c73123c7-03b5-428d-aafa-6869e065fc65</slot_id>
      <title>Session: APLAS Research Papers - Analysis / Synthesis (mirror)</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Kihong</first_name>
          <last_name>Heo</last_name>
          <affiliation>KAIST</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kihongheo.kaist.ac.kr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kihongheo/0f30d10c-fca6-4c67-99ea-14a80af4118b/small.jpg</picture_url>
          <person_id>kihongheo</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>16a8f5b4-de1e-48fb-97b6-cbb0b8cd914f</slot_id>
      <event_id>ac9913d2-431f-4244-aa49-c54872343cd9</event_id>
      <title>Q&amp;A and discussion</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>36854ace-68ad-4b9d-9206-43bedbb3685c</slot_id>
      <event_id>907e9700-9131-4487-bb17-c947fd91adb2</event_id>
      <submission_id>20</submission_id>
      <title>Program Synthesis for Musicians: A Usability Testbed for Temporal Logic Specifications</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>19:30</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:40</end_time>
      <description>In recent years, program synthesis research has made significant progress in creating user-friendly tools for Programming by example (PBE) and Programming by demonstration (PBD) environments. However, program synthesis from logical specifications, such as reactive synthesis, still faces large challenges in widespread adoption. In order to bring reactive synthesis to a wider audience, more research is necessary to explore different interface options. We present The SynthSynthesizer, a music-based tool for designing and testing specification interfaces. The tool enables researchers to prototype different interfaces for reactive synthesis and run user studies on them. The tool is accessible to both researchers and users by running on a browser on top of a docker-containerized synthesis toolchain. We show sample implementations with the tool by creating dropdown interfaces, and by running a user study with 21 users.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wonhyuk</first_name>
          <last_name>Choi</last_name>
          <affiliation>Columbia University</affiliation>
          <bio>undefined</bio>
          <person_id>wonhyukchoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michel</first_name>
          <last_name>Vazirani</last_name>
          <affiliation>Columbia University</affiliation>
          <bio>undefined</bio>
          <person_id>michelvazirani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mark</first_name>
          <last_name>Santolucito</last_name>
          <affiliation>Barnard College, Columbia University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.marksantolucito.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marksantolucito/51821284-64c1-46e0-b979-96e8324079bf/small.jpg</picture_url>
          <person_id>marksantolucito</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>533d993a-6f5c-488f-b9d8-83560ade1bbc</slot_id>
      <event_id>2cf3b543-8892-48b1-956b-60a7954965d1</event_id>
      <submission_id>76</submission_id>
      <title>PyCT: A Python Concolic Tester</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>19:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:30</end_time>
      <description>Concolic testing is a software testing technique for generating concrete inputs of programs to increase code coverage and has been developed for years. For programming languages such as C, JAVA, x86 binary code, and JavaScript, there are already plenty of available concolic testers. However, the concolic testers for Python are relatively less. Since Python is a popular programming language, we believe there is a strong need to develop a good one. 
Among the existing testers for Python, PyExZ3 is the most well-known and advanced. However, we found some issues of PyExZ3: (1) it implements only a limited number of base types’ (e.g., integer, string) member functions and(2) it automatically downcasts concolic objects and discards related symbolic information as it encounters built-in types’ constructors. 
Based on the concept of PyExZ3, we develop a new tool called PyCT to alleviate these two issues. PyCT supports a more complete set of member functions of data types including integer, string, and range. We also proposes a new method to upcast constants to concolic ones to prevent unnecessary downcasting. Our evaluation shows that with more member functions being supported, the coverage rate is raised to (80.20%) from (71.55%). It continues to go up to (85.68%) as constant upcasting is also implemented.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wei-Lun</first_name>
          <last_name>Tsai</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>weiluntsai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wei-Cheng</first_name>
          <last_name>Wu</last_name>
          <affiliation>University of Southern California, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://steel.isi.edu/members/weicheng</homepage_url>
          <person_id>weichengwu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Di-De</first_name>
          <last_name>Yen</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>dideyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fang</first_name>
          <last_name>Yu</last_name>
          <affiliation>National Chengchi University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/fangyu/4400f412-1da9-4bf0-80c5-3011774ce2cc/small.jpg</picture_url>
          <person_id>fangyu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yu-Fang</first_name>
          <last_name>Chen</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iis.sinica.edu.tw/~yfc/doku.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yufangchen/87eecff2-df03-4022-9c4e-7d96872d36c4/small.jpg</picture_url>
          <person_id>yufangchen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>7e7848f4-a1a5-469c-836f-a3dd298bddf6</slot_id>
      <event_id>f4797ec2-3f39-4e93-87f9-3efc30cb9952</event_id>
      <submission_id>33</submission_id>
      <title>Scalable and Modular Robustness Analysis of Deep Neural Networks</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:05</end_time>
      <description>As neural networks are trained to be deeper and larger, the scalability of neural network analyzer is urgently required. The main technical insight of our method is modularly analyzing neural networks by segmenting a network into blocks and conduct the analysis for each block. In particular, we propose the network block summarization technique to capture the behaviors within a network block using a block summary and leverage the summary to speed up the analysis process. We instantiate our method in the context of a CPU-version of the state-of-the-art analyzer DeepPoly and name our system as Bounded-Block Poly (BBPoly). We evaluate BBPoly extensively on various experiment settings. The experimental result indicates that our method yields comparable precision as DeepPoly but runs faster and requires less computational resources. For example, BBPoly can analyze really large neural networks like SkipNet or ResNet which contain up to one million neurons in less than around 1 hour per input image, while DeepPoly needs to spend even 40 hours to analyze one image.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuyi</first_name>
          <last_name>Zhong</last_name>
          <affiliation>School of Computing, National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>yuyizhong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Quang-Trung</first_name>
          <last_name>Ta</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>quangtrungta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tianzuo</first_name>
          <last_name>Luo</last_name>
          <affiliation>School of Computing, National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>tianzuoluo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fanlong</first_name>
          <last_name>ZHANG</last_name>
          <affiliation>School of Computer, Guangdong University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>fanlongzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Siau-Cheng</first_name>
          <last_name>Khoo</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~khoosc/</homepage_url>
          <person_id>siauchengkhoo</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>b0ac3866-f7af-4c56-9f8d-1c232a7bc1ff</slot_id>
      <event_id>47844a39-78c0-49b3-8e9b-cfa59c9eb1d2</event_id>
      <submission_id>10</submission_id>
      <title>Function Pointer Eliminator for C Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>19:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:50</end_time>
      <description>Verification of memory safety such as absence of null pointer dereferences and memory leaks in system software is important in practice. O’Hearn’s group proposed a new method of memory safety analysis/verification by modular abstract interpretation with separation logic and biabduction. To realize this method, one has to construct a call graph before the modular abstract interpretation. This paper aims to analyze/verify memory safety of system software written in C programming language by this method, and as the first step this paper provides a function pointer eliminator tool to eliminate function pointer calls in order to construct a call graph. The tool uses SVF for pointer analysis. First C programs are translated into LLVM programs by Clang and then SVF analyses the LLVM programs. The tool given in this paper finds correspondence between function pointer calls in C programs and those in LLVM programs, and transforms the C programs into C programs with the same functionality and without any function pointer calls. The experimental results for gzip, git, and OpenSSL using this function pointer eliminator are presented and they show that this tool is sufficiently efficient and precise for the purpose.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daisuke</first_name>
          <last_name>Kimura</last_name>
          <affiliation>Toho University	</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/daisukekimura/6b912400-e3bf-44b2-b9c9-9d6412dee364/small.jpg</picture_url>
          <person_id>daisukekimura</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mahmudul Faisal Al</first_name>
          <last_name>Ameen</last_name>
          <affiliation>University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>mahmudulfaisalalameen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Makoto</first_name>
          <last_name>Tatsuta</last_name>
          <affiliation>National Institute of Informatics</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.nii.ac.jp/~tatsuta/index-e.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/makototatsuta/a8798f89-7cfc-4ef4-af83-3c5b65ffa4df/small.jpg</picture_url>
          <person_id>makototatsuta</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Koji</first_name>
          <last_name>Nakazawa</last_name>
          <affiliation>Nagoya University</affiliation>
          <bio>undefined</bio>
          <person_id>kojinakazawa1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>c458ef6a-1a93-4a39-a71d-7b47b6471619</slot_id>
      <event_id>764db38c-a04e-4c02-b590-2c2572e8c133</event_id>
      <submission_id>37</submission_id>
      <title>Server-Side Computation of Package Dependencies in Package-Management Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/17</date>
      <start_time>19:05</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>19:20</end_time>
      <description>Package managers are often used in recent software development to obtain directly-dependent packages recursively. Typically, package managers make requests to the package registry more than once when computing indirect dependencies. Moreover, much amount of computations are duplicated by clients of package managers. This duplication can be avoided by computing indirect dependencies in advance on the server-side of package-management systems. Therefore, we propose two algorithms functioning in parallel on the server-side: one to compute the indirect dependencies when copying all packages in existing package managers to the server and one to add packages to the server. Based on these parallelized algorithms, we implement a server {\tt fpms-server} and a client {\tt fpms} for npm packages. By our experiments, our client obtains dependencies of some package more than two times faster than clients in existing npm and yarn systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nobuhiro</first_name>
          <last_name>Kasai</last_name>
          <affiliation>Shibaura Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>nobuhirokasai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isao</first_name>
          <last_name>Sasano</last_name>
          <affiliation>Shibaura Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.sic.shibaura-it.ac.jp/~sasano/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/isaosasano/b77a139b-e948-4f6c-ad81-8afe7cb17d0e/small.jpg</picture_url>
          <person_id>isaosasano</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0d862d47-34b5-4845-8874-2ffdda2bcb0f</subevent_id>
    <title>APLAS Research Papers: Verification / Theory (mirror)</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>a108d5af-3c9a-48bb-9fcb-dea304d1825c</slot_id>
      <title>Session: APLAS Research Papers - Verification / Theory (mirror)</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Yue</first_name>
          <last_name>Li</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuelee.bitbucket.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yueli/c0b3b5ef-ffac-472c-9a05-5b9c8f165d7d/small.jpg</picture_url>
          <person_id>yueli</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>68ebb151-afc6-45a1-92e2-a3cbbf414e04</slot_id>
      <event_id>3b8750a2-df2f-4f69-b8bc-4984930a61a6</event_id>
      <submission_id>7</submission_id>
      <title>Termination Analysis for the $\pi$-Calculus by Reduction to Sequential Program Termination</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>22:35</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:50</end_time>
      <description>We propose an automated method for proving termination of $\pi$-calculus processes, based on a reduction to termination of sequential programs: we translate a $\pi$-calculus process to a sequential program, so that the termination of the latter implies that of the former. We can then use an off-the-shelf termination verification tool to check termination of the sequential program. Our approach has been partially inspired by Deng and Sangiorgi’s termination analysis for the $\pi$-calculus, and checks that there is no infinite chain of communications on replicated input channels, by converting such a chain of communications to a chain of recursive function calls in the target sequential program. We have implemented an automated tool based on the proposed method and confirmed its effectiveness.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tsubasa</first_name>
          <last_name>Shoshi</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>tsubasashoshi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Takuma</first_name>
          <last_name>Ishikawa</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>takumaishikawa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ken</first_name>
          <last_name>Sakayori</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>kensakayori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ryosuke</first_name>
          <last_name>Sato</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-kb.is.s.u-tokyo.ac.jp/~ryosuke/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ryosukesato/dde2fccf-e07f-48f8-9dc9-277cb124e664/small.jpg</picture_url>
          <person_id>ryosukesato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Takeshi</first_name>
          <last_name>Tsukada</last_name>
          <affiliation>Chiba University, Japan</affiliation>
          <bio>undefined</bio>
          <person_id>takeshitsukada</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>84cfe53e-7afa-4e29-9744-5d6539440746</slot_id>
      <event_id>ac9913d2-431f-4244-aa49-c54872343cd9</event_id>
      <title>Q&amp;A and discussion</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>c2f27777-02f8-449a-87d3-b5edbd3fa066</slot_id>
      <event_id>b9215798-f744-4c16-93b2-8d43afb864c8</event_id>
      <submission_id>40</submission_id>
      <title>Preprocessing of Alternating Automata for Language Emptiness Testing</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:05</end_time>
      <description>We propose preprocessing techniques that improve efficiency of testing language emptiness of alternating automata. We target mainly automata that come from practical application such as string solving or processing of LTL formulae. Such automata often have large alphabets and transition relations represented by succinct and complex Boolean formulae that are more or less unrestricted and may even mix symbols with states. Our main contribution are simplification methods that can be seen as originating from a limited form determinisation, and we also use some simple Boolean transformations of the transition formulae. Our transformations simplify the transition formulae and decrease the number of states. We evaluate experimentally that our preprocessing is beneficial when used together with most of the existing algorithms. It generally improves running times and even allows to solve examples that could not be solved before within a reasonable timeout.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pavol</first_name>
          <last_name>Vargovčík</last_name>
          <affiliation>Brno University of Technology, Czech Republic</affiliation>
          <bio>undefined</bio>
          <person_id>pavolvargovcik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>c4666271-e3f6-4ec5-80f3-95f130046a99</slot_id>
      <event_id>a4646d88-3a99-4d96-b6af-bf0af08c54cc</event_id>
      <submission_id>77</submission_id>
      <title>Proving LTL Properties of Bitvector Programs and Decompiled Binaries</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>22:05</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:20</end_time>
      <description>There is increasing interest in applying verification tools to programs that have bitvector operations. SMT solvers, which serve as a foundation for these tools, have thus increased support for bitvector reasoning through bit-blasting and linear arithmetic approximations. In this paper we show that similar linear arithmetic approximation of bitvector operations can be done at the source level through transformations. Specifically, we introduce new paths that over-approximate bitvector operations with linear conditions/constraints, increasing branching but allowing us to better exploit the well-developed integer reasoning and interpolation of verification tools. We show that, for reachability of bitvector programs, increased branching incurs negligible overhead yet, when combined with integer interpolation optimizations, enables more programs to be verified. We further show this exploitation of integer interpolation in the common case also enables competitive termination verification of bitvector programs and leads to the first effective technique for LTL verification of bitvector programs. Finally, we provide an in-depth case study of decompiled (“lifted”) binary programs, which emulate X86 execution through frequent use of bitvector operations. We present a new tool DarkSea, the first tool capable of verifying reachability, termination, and LTL of lifted binaries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Liu</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/cyrusliu/73881ecf-5211-4146-9424-7f9670e3f77b/small.jpg</picture_url>
          <person_id>cyrusliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chengbin</first_name>
          <last_name>Pang</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>chengbinpang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Dietsch</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://swt.informatik.uni-freiburg.de/staff/dietsch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danieldietsch/965245d6-e31d-4645-94f0-10a113edfe53/small.jpg</picture_url>
          <person_id>danieldietsch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eric</first_name>
          <last_name>Koskinen</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.stevens.edu/~ejk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/erickoskinen/3413fc94-5f0f-4855-af65-da2309d2632f/small.jpg</picture_url>
          <person_id>erickoskinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ton Chanh</first_name>
          <last_name>Le</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://letonchanh.github.io/</homepage_url>
          <person_id>tonchanhle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Portokalidis</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>georgiosportokalidis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Jun</first_name>
          <last_name>Xu</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>junxu2</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>d6394635-f865-4612-94cf-0fc6ea1f5c7b</slot_id>
      <event_id>098ed30d-d2aa-4c91-bf58-0f28a84ad9b2</event_id>
      <submission_id>91</submission_id>
      <title>Solving Not-Substring with Flat Abstraction</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>22:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>22:35</end_time>
      <description>Not-substring is currently among the least supported types of string constraints, and existing solvers use only relatively crude heuristics. Yet, not-substring occurs relatively often in practical examples and is useful in encoding other types of constraints. In this paper, we propose a systematic way to solve not-substring using the Counter-Example Guided Abstraction Refinement (CEGAR) framework based on flat abstraction. In such a framework, the domain of string variables is restricted to flat languages and subsequently, the whole constraints can be expressed as linear arithmetic formulae. We show that non-substring constraints can be flattened efficiently, and provide experimental evidence that the proposed solution for not-substring is competitive with the state-of-the-art string solvers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Parosh Aziz</first_name>
          <last_name>Abdulla</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://user.it.uu.se/~parosh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/paroshazizabdulla/342a7738-db1c-42a1-91cc-3b9467086b87/small.jpg</picture_url>
          <person_id>paroshazizabdulla</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mohamed Faouzi</first_name>
          <last_name>Atig</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>Mohamed Faouzi Atig is a senior lecturer at the Department of Information Technology, Uppsala University. Previously, he was a Post-doctoral researcher at Uppsala University from July 2010 to March 2012. He obtained his doctoral degree in Computer Science from the University of Paris Diderot- Paris 7 (France) in 2010. His research interests broadly span model checking, verification of infinite state systems, weak memory models, and automata theory.</bio>
          <homepage_url>http://www.it.uu.se/katalog/mohat117</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mohamedfaouziatig/5061fc57-1b58-42f4-965d-a1c64ca186dd/small.jpg</picture_url>
          <person_id>mohamedfaouziatig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yu-Fang</first_name>
          <last_name>Chen</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iis.sinica.edu.tw/~yfc/doku.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yufangchen/87eecff2-df03-4022-9c4e-7d96872d36c4/small.jpg</picture_url>
          <person_id>yufangchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bui Phi</first_name>
          <last_name>Diep</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://diepbp.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/phidiepbui/04bc8805-8f6c-407b-be9a-d693717be6b3/small.jpg</picture_url>
          <person_id>phidiepbui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Denghang</first_name>
          <last_name>Hu</last_name>
          <affiliation>State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
          <person_id>denghanghu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Wei-Lun</first_name>
          <last_name>Tsai</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>weiluntsai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Zhilin</first_name>
          <last_name>Wu</last_name>
          <affiliation>State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
          <person_id>zhilinwu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Di-De</first_name>
          <last_name>Yen</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>dideyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cfc9ddc3-7f06-429a-b968-74bacf458b17</subevent_id>
    <title>APLAS Research Papers: Verification / Theory</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/track/aplas-2021/aplas-2021-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>785ac9f1-7973-4855-98c6-5e3607fc6665</slot_id>
      <title>Session: APLAS Research Papers - Verification / Theory</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Xiaokang</first_name>
          <last_name>Qiu</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>I am an assistant professor with the School of Electrical and Computer Engineering at Purdue University.</bio>
          <homepage_url>https://engineering.purdue.edu/~xqiu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaokangqiu/be55b21e-fb5d-4540-a2c2-1110cac11fc6/small.jpg</picture_url>
          <person_id>xiaokangqiu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>066dde5b-5e0a-44f8-a0ba-07ac6068b237</slot_id>
      <event_id>098ed30d-d2aa-4c91-bf58-0f28a84ad9b2</event_id>
      <submission_id>91</submission_id>
      <title>Solving Not-Substring with Flat Abstraction</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:35</end_time>
      <description>Not-substring is currently among the least supported types of string constraints, and existing solvers use only relatively crude heuristics. Yet, not-substring occurs relatively often in practical examples and is useful in encoding other types of constraints. In this paper, we propose a systematic way to solve not-substring using the Counter-Example Guided Abstraction Refinement (CEGAR) framework based on flat abstraction. In such a framework, the domain of string variables is restricted to flat languages and subsequently, the whole constraints can be expressed as linear arithmetic formulae. We show that non-substring constraints can be flattened efficiently, and provide experimental evidence that the proposed solution for not-substring is competitive with the state-of-the-art string solvers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Parosh Aziz</first_name>
          <last_name>Abdulla</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://user.it.uu.se/~parosh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/paroshazizabdulla/342a7738-db1c-42a1-91cc-3b9467086b87/small.jpg</picture_url>
          <person_id>paroshazizabdulla</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mohamed Faouzi</first_name>
          <last_name>Atig</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>Mohamed Faouzi Atig is a senior lecturer at the Department of Information Technology, Uppsala University. Previously, he was a Post-doctoral researcher at Uppsala University from July 2010 to March 2012. He obtained his doctoral degree in Computer Science from the University of Paris Diderot- Paris 7 (France) in 2010. His research interests broadly span model checking, verification of infinite state systems, weak memory models, and automata theory.</bio>
          <homepage_url>http://www.it.uu.se/katalog/mohat117</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mohamedfaouziatig/5061fc57-1b58-42f4-965d-a1c64ca186dd/small.jpg</picture_url>
          <person_id>mohamedfaouziatig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yu-Fang</first_name>
          <last_name>Chen</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iis.sinica.edu.tw/~yfc/doku.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yufangchen/87eecff2-df03-4022-9c4e-7d96872d36c4/small.jpg</picture_url>
          <person_id>yufangchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bui Phi</first_name>
          <last_name>Diep</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://diepbp.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/phidiepbui/04bc8805-8f6c-407b-be9a-d693717be6b3/small.jpg</picture_url>
          <person_id>phidiepbui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Denghang</first_name>
          <last_name>Hu</last_name>
          <affiliation>State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
          <person_id>denghanghu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Wei-Lun</first_name>
          <last_name>Tsai</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>weiluntsai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Zhilin</first_name>
          <last_name>Wu</last_name>
          <affiliation>State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
          <person_id>zhilinwu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Di-De</first_name>
          <last_name>Yen</last_name>
          <affiliation>Academia Sinica</affiliation>
          <bio>undefined</bio>
          <person_id>dideyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>200a79d1-d5bd-4453-8573-40e0e42da25a</slot_id>
      <event_id>ac9913d2-431f-4244-aa49-c54872343cd9</event_id>
      <title>Q&amp;A and discussion</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>4133b75a-5d64-4cb8-a00c-bbddc9c9b193</slot_id>
      <event_id>3b8750a2-df2f-4f69-b8bc-4984930a61a6</event_id>
      <submission_id>7</submission_id>
      <title>Termination Analysis for the $\pi$-Calculus by Reduction to Sequential Program Termination</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:50</end_time>
      <description>We propose an automated method for proving termination of $\pi$-calculus processes, based on a reduction to termination of sequential programs: we translate a $\pi$-calculus process to a sequential program, so that the termination of the latter implies that of the former. We can then use an off-the-shelf termination verification tool to check termination of the sequential program. Our approach has been partially inspired by Deng and Sangiorgi’s termination analysis for the $\pi$-calculus, and checks that there is no infinite chain of communications on replicated input channels, by converting such a chain of communications to a chain of recursive function calls in the target sequential program. We have implemented an automated tool based on the proposed method and confirmed its effectiveness.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tsubasa</first_name>
          <last_name>Shoshi</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>tsubasashoshi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Takuma</first_name>
          <last_name>Ishikawa</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>takumaishikawa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ken</first_name>
          <last_name>Sakayori</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>kensakayori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ryosuke</first_name>
          <last_name>Sato</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-kb.is.s.u-tokyo.ac.jp/~ryosuke/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ryosukesato/dde2fccf-e07f-48f8-9dc9-277cb124e664/small.jpg</picture_url>
          <person_id>ryosukesato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Takeshi</first_name>
          <last_name>Tsukada</last_name>
          <affiliation>Chiba University, Japan</affiliation>
          <bio>undefined</bio>
          <person_id>takeshitsukada</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>788c9e95-95bc-4d21-bf52-c42804302dd8</slot_id>
      <event_id>a4646d88-3a99-4d96-b6af-bf0af08c54cc</event_id>
      <submission_id>77</submission_id>
      <title>Proving LTL Properties of Bitvector Programs and Decompiled Binaries</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:20</end_time>
      <description>There is increasing interest in applying verification tools to programs that have bitvector operations. SMT solvers, which serve as a foundation for these tools, have thus increased support for bitvector reasoning through bit-blasting and linear arithmetic approximations. In this paper we show that similar linear arithmetic approximation of bitvector operations can be done at the source level through transformations. Specifically, we introduce new paths that over-approximate bitvector operations with linear conditions/constraints, increasing branching but allowing us to better exploit the well-developed integer reasoning and interpolation of verification tools. We show that, for reachability of bitvector programs, increased branching incurs negligible overhead yet, when combined with integer interpolation optimizations, enables more programs to be verified. We further show this exploitation of integer interpolation in the common case also enables competitive termination verification of bitvector programs and leads to the first effective technique for LTL verification of bitvector programs. Finally, we provide an in-depth case study of decompiled (“lifted”) binary programs, which emulate X86 execution through frequent use of bitvector operations. We present a new tool DarkSea, the first tool capable of verifying reachability, termination, and LTL of lifted binaries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Liu</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/cyrusliu/73881ecf-5211-4146-9424-7f9670e3f77b/small.jpg</picture_url>
          <person_id>cyrusliu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chengbin</first_name>
          <last_name>Pang</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>chengbinpang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Dietsch</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://swt.informatik.uni-freiburg.de/staff/dietsch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danieldietsch/965245d6-e31d-4645-94f0-10a113edfe53/small.jpg</picture_url>
          <person_id>danieldietsch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eric</first_name>
          <last_name>Koskinen</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.stevens.edu/~ejk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/erickoskinen/3413fc94-5f0f-4855-af65-da2309d2632f/small.jpg</picture_url>
          <person_id>erickoskinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ton Chanh</first_name>
          <last_name>Le</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://letonchanh.github.io/</homepage_url>
          <person_id>tonchanhle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Portokalidis</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>georgiosportokalidis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Jun</first_name>
          <last_name>Xu</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>junxu2</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>9cc241da-919a-44d5-ba36-2ad2db5a67bb</slot_id>
      <event_id>b9215798-f744-4c16-93b2-8d43afb864c8</event_id>
      <submission_id>40</submission_id>
      <title>Preprocessing of Alternating Automata for Language Emptiness Testing</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>14:05</end_time>
      <description>We propose preprocessing techniques that improve efficiency of testing language emptiness of alternating automata. We target mainly automata that come from practical application such as string solving or processing of LTL formulae. Such automata often have large alphabets and transition relations represented by succinct and complex Boolean formulae that are more or less unrestricted and may even mix symbols with states. Our main contribution are simplification methods that can be seen as originating from a limited form determinisation, and we also use some simple Boolean transformations of the transition formulae. Our transformations simplify the transition formulae and decrease the number of states. We evaluate experimentally that our preprocessing is beneficial when used together with most of the existing algorithms. It generally improves running times and even allows to solve examples that could not be solved before within a reasonable timeout.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pavol</first_name>
          <last_name>Vargovčík</last_name>
          <affiliation>Brno University of Technology, Czech Republic</affiliation>
          <bio>undefined</bio>
          <person_id>pavolvargovcik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>78264d05-989e-4eac-a748-8f4a0b751ef0</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2021 Papers 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>904fbd8a-9e47-4ca4-90ec-79cbf838ba20</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2021 Papers 2</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Michael D.</first_name>
          <last_name>Bond</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ohio-state.edu/~mikebond</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelbond/92c528d2-84b3-4369-8b57-6555f1016a8e/small.jpg</picture_url>
          <person_id>michaelbond</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>24cfbbfd-4ad2-4486-97a3-3b4b9a05a12c</slot_id>
      <event_id>6e3b43aa-a419-4f7a-8c92-059c79283fec</event_id>
      <submission_id>180</submission_id>
      <title>Concurrent Deferred Reference Counting for Non-garbage-collected Languages</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:05</end_time>
      <description>We present a safe automatic memory reclamation approach for non garbage-collected languages, and show that it is both theoretically and practically efficient. The approach combines ideas from referencing counting with ideas related to hazard pointers. It overcomes the limitations of previous approaches by significantly reducing modifications to, and hence contention on, the reference counts. The approach is much safer and easier to use than manual approaches such as direct usage of hazard pointers, epoch based reclamation, RCU, or interval-based reclamation. One of the key ideas is a generalization of hazard pointers that allows the same handle to be retired multiple times, which we call acquire-retire. This technique is then used to protect the reference counter of an object, which allows our method to defer decrements on the counter until no other process could be incrementing it. Another key idea is to defer or elide increments of reference counters for short-lived references by temporarily protecting the counter instead of eagerly incrementing it. 
We have implemented the approach as a C++ library, which is as simple to use as conventional C++ reference-counted pointers. We run experiments on the library, comparing it to several other methods including state-of-the-art atomic reference-counted pointers, and four manual techniques: hazard-pointers, epochs, hazard-eras and interval-based reclamation. Our results indicate that our technique is faster than existing reference-counted pointer implementations, and competitive with manual memory reclamation techniques. On a variety of data structures and workloads, it achieves throughput rates within a factor of $2$ of the fastest manual approaches, while using a small fraction of the memory. Perhaps most importantly, it is significantly safer since objects are reclaimed automatically.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Anderson</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>danielanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guy E.</first_name>
          <last_name>Blelloch</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>guyeblelloch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yuanhao</first_name>
          <last_name>Wei</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yuanhaowei</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3e8fe1b6-a1f4-41a6-9b30-7a6ed36c5551</slot_id>
      <event_id>d9f49557-d7b0-445f-aecb-398d265bd188</event_id>
      <submission_id>522</submission_id>
      <title>Vectorized Secure Evaluation of Decision Forests</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:50</end_time>
      <description>As the demand for machine learning–based inference increases in tandem with concerns about privacy, there is a growing recognition of the need for secure machine learning, in which secret models can be used to classify private data without the model or data being leaked. Fully Homomorphic Encryption (FHE) allows arbitrary computation to be done over encrypted data, providing an attractive approach to providing such secure inference. While such computation is often orders of magnitude slower than its plaintext counterpart, the ability of FHE cryptosystems to do ciphertext packing—that is, encrypting an entire vector of plaintexts such that operations are evaluated elementwise on the vector—helps ameliorate this overhead, effectively creating a SIMD architecture where computation can be vectorized for more efficient evaluation. Most recent research in this area has targeted regular, easily vectorizable neural network models. Applying similar techniques to irregular ML models such as decision forests remains unexplored, due to their complex, hard-to-vectorize structures. 
In this paper we present COPSE, the first system that exploits ciphertext packing to perform decision-forest inference. COPSE consists of a staging compiler that automatically restructures and compiles decision forest models down to a new set of vectorizable primitives for secure inference.
We find that COPSE's compiled models outperform the state of the art across a range of decision forest models, often by more than an order of magnitude, while still scaling well.
</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raghav</first_name>
          <last_name>Malik</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/raghavmalik/772f3505-7946-4766-99b3-f6b6c97192cc/small.jpg</picture_url>
          <person_id>raghavmalik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vidush</first_name>
          <last_name>Singhal</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>vidushsinghal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Gottfried</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>benjamingottfried</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University. 
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures. 
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University. I received an NSF CAREER Award in 2012, a Department of Energy Early Career Research Award in 2013, and the Presidential Early Career Award for Scientists and Engineers in 2016.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
          <person_id>milindkulkarni</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>81a7acc6-29dd-44f7-b0b3-b8250fb3a0fd</slot_id>
      <event_id>3d57c41e-4d41-4f68-84cb-1db1cd1975da</event_id>
      <submission_id>404</submission_id>
      <title>SyRust: Automatic Testing of Rust Libraries with Semantic-Aware Program Synthesis</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:35</end_time>
      <description>Rust’s type system ensures the safety of Rust programs; however, programmers can side-step some of the strict typing rules by using the unsafe keyword. A common use of unsafe Rust is by libraries. Bugs in these libraries undermine the safety of the entire Rust program. Therefore, it is crucial to thoroughly test library APIs to rule out bugs. Unfortunately, such testing relies on programmers to manually construct test cases, which is an inefficient and ineffective process. 
The goal of this paper is to develop a methodology for automatically generating Rust programs to effectively test Rust library APIs. The main challenge is to synthesize \emph{well-typed} Rust programs to account for proper chaining of API calls and Rust’s ownership type system and polymorphic types. We develop a program synthesis technique for Rust library API testing, which relies on a novel logical encoding of typing constraints from Rust’s ownership type system. We implement SyRust, a testing framework for Rust libraries that automatically synthesizes semantically valid test cases. Our experiments on 30 popular open-source Rust libraries found 4 new bugs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yoshiki</first_name>
          <last_name>Takashima</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/yoshikitakashima/fd8f57b7-f306-4991-83ff-450e9003622b/small.jpg</picture_url>
          <person_id>yoshikitakashima</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ruben</first_name>
          <last_name>Martins</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Ruben Martins is a Systems Scientist at the Carnegie Mellon University. Prior to joining CMU, he was a postdoctoral researcher at UT Austin where he pushed the frontiers of program synthesis and security with constraint solving. Before UT Austin, he was a postdoctoral researcher at the University of Oxford, UK where he worked on CBMC for software verification. He received his PhD with honors from the University of Lisbon, Portugal in 2013. His research aims to improve constraint solvers and broaden their applicability in program analysis, synthesis, and security. Dr. Martins has developed several award winning solvers and has consistently improved the state-of-the-art in MaxSAT solving. He is currently the main developer of Open-WBO: an open source MaxSAT solver that won several awards in the MaxSAT competitions.</bio>
          <homepage_url>https://sat-group.github.io/ruben/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rubenmartins/6cfee429-6785-4395-bcf6-ddb6dd674d58/small.jpg</picture_url>
          <person_id>rubenmartins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Limin</first_name>
          <last_name>Jia</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.andrew.cmu.edu/user/liminjia/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/liminjia/6bc50ee1-2333-4b59-bc4f-3bf74d1e3b64/small.jpg</picture_url>
          <person_id>liminjia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Corina S.</first_name>
          <last_name>Păsăreanu</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ti.arc.nasa.gov/profile/pcorina/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/corinaspasareanu1/1b534631-bd17-43e5-bc5e-335cef045e87/small.jpg</picture_url>
          <person_id>corinaspasareanu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d40122de-9111-40a9-9642-7acfbe9a4817</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e43f6701-151f-4f9a-9b8b-1812c4360f5d</slot_id>
      <event_id>f70cd23a-f34d-43a0-bbf4-244ede98baa6</event_id>
      <submission_id>465</submission_id>
      <title>Snapshot-Free, Transparent, and Robust Memory Reclamation for Lock-Free Data Structures</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:20</end_time>
      <description>We present a family of new safe memory reclamation schemes, Hyaline, which are fast, scalable, and transparent to the underlying lock-free data structures. Hyaline is based on reference counting – considered impractical for memory reclamation in the past due to high overheads. Hyaline uses reference counters only during reclamation, but not while accessing individual objects, which reduces overheads for object accesses. Since with reference counters, an arbitrary thread ends up freeing memory, Hyaline’s reclamation workload is (almost) balanced across all threads, unlike most prior reclamation schemes such as epoch-based reclamation (EBR) or hazard pointers (HP). Hyaline often yields (excellent) EBR-grade performance with (good) HP-grade memory efficiency, which is a challenging trade-off with all existing schemes. 
Hyaline schemes offer the following properties: (i) high \emph{performance}; (ii) good memory \emph{efficiency}; (iii) \emph{robustness}: guaranteeing bounded memory usage even in the presence of stalled threads, a well-known problem with EBR; (iv) \emph{transparency}: supporting virtually unbounded number of threads (or any concurrent entities) that can be created and deleted dynamically, and effortlessly join existent workload; (v) \emph{autonomy}: are neither intrusive to runtime or compiler environments nor rely on OS mechanisms; (vi) \emph{simplicity}: API enables easy integration into unmanaged C/C++ code, while not causing any undue burden on programmers, making the entire process fully automatic through smart pointers; and (vii) \emph{generality}: supporting many data structures. All existing schemes lack one or more properties. 
We have implemented and tested Hyaline on x86(-64), ARM32/64, PowerPC, and MIPS. The general approach requires LL/SC or double-width CAS, while a specialized version also works with single-width CAS. Our evaluation reveals that Hyaline’s throughput is very high – it steadily outperforms EBR by 10% in one test and yields \textbf{2x} gains in oversubscribed scenarios. Hyaline’s superior memory efficiency is especially evident in read-dominated workloads.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruslan</first_name>
          <last_name>Nikolaev</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <person_id>ruslannikolaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Binoy</first_name>
          <last_name>Ravindran</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
          <person_id>binoyravindran</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>70dbe155-4648-49c1-9f60-afae30287250</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2020 Papers 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>ec394dae-02cb-4372-9ef8-f26b8d6815e6</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2020 Papers 1</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Manu</first_name>
          <last_name>Sridharan</last_name>
          <affiliation>University of California at Riverside</affiliation>
          <bio>I’m an associate professor at the University of California, Riverside. Previously I worked at IBM Research, Samsung Research, and Uber. My research focuses on developing tools and techniques to make large-scale software more reliable, performant, secure, and maintainable. For more details, see my homepage.</bio>
          <homepage_url>http://manu.sridharan.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
          <person_id>manusridharan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>333f8122-62fb-4de4-870f-db0761268b9e</slot_id>
      <event_id>54b900fa-94bc-4a6b-82fe-3382c71b2921</event_id>
      <title>Armada: Low-Effort Verification of High-Performance Concurrent Programs</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:05</end_time>
      <description>Safely writing high-performance concurrent programs is notoriously difficult. To aid developers, we introduce Armada, a language and tool designed to formally verify such programs with relatively little effort. Via a C-like language and a small-step, state-machine-based semantics, Armada gives developers the flexibility to choose arbitrary memory layout and synchronization primitives so they are never constrained in their pursuit of performance. To reduce developer effort, Armada leverages SMT-powered automation and a library of powerful reasoning techniques, including rely-guarantee, TSO elimination, reduction, and alias analysis. All these techniques are proven sound, and Armada can be soundly extended with additional strategies over time. Using Armada, we verify four concurrent case studies and show that we can achieve performance equivalent to that of unverified code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jacob R.</first_name>
          <last_name>Lorch</last_name>
          <affiliation>Microsoft Research, n.n.</affiliation>
          <bio>undefined</bio>
          <person_id>jacobrlorch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yixuan</first_name>
          <last_name>Chen</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://me.xlk.me</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yixuanchen1/cdfb8d9e-938f-4baf-86de-6607de5acc18/small.jpg</picture_url>
          <person_id>yixuanchen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Manos</first_name>
          <last_name>Kapritsos</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <person_id>manoskapritsos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bryan</first_name>
          <last_name>Parno</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.andrew.cmu.edu/user/bparno/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bryanparno/ee485e0e-04ea-44b0-9a83-816825899e78/small.jpg</picture_url>
          <person_id>bryanparno</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Shaz</first_name>
          <last_name>Qadeer</last_name>
          <affiliation>Novi, USA</affiliation>
          <bio>Shaz Qadeer has worked at Facebook, Microsoft, HP, and Compaq. He has studied at the University of California at Berkeley and the Indian Institute of Technology at Kanpur.</bio>
          <homepage_url>https://scholar.google.com/citations?user=EqIVfYcAAAAJ&amp;hl=en</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shazqadeer1/f224e8bb-da8c-4512-b63b-d56831c9f712/small.jpg</picture_url>
          <person_id>shazqadeer1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Upamanyu</first_name>
          <last_name>Sharma</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <person_id>upamanyusharma</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>James R.</first_name>
          <last_name>Wilcox</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>I am a lecturer in the Paul G. Allen School of Computer Science &amp;amp; Engineering at the University of Washington. My research interests are in programming languages and applications of PL techniques to systems. I also work on formal verification in industry at Certora.</bio>
          <homepage_url>https://jamesrwilcox.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesrwilcox/92dfd071-3ff1-4a52-8f23-86215aca7f43/small.jpg</picture_url>
          <person_id>jamesrwilcox</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Xueyuan</first_name>
          <last_name>Zhao</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>xueyuanzhao</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3fb0f598-bba4-43fe-9f1f-56e8e3db75a9</slot_id>
      <event_id>19ed4d1b-8452-44ad-a9b4-5f5a98a20491</event_id>
      <title>Verifying Concurrent Search Structure Templates</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:50</end_time>
      <description>Concurrent separation logics have had great success reasoning about concurrent data structures. This success stems from their application of modularity on multiple levels, leading to proofs that are decomposed according to program structure, program state, and individual threads. Despite these advances, it remains difficult to achieve proof reuse across different data structure implementations. For the large class of \emph{search structures}, we demonstrate how one can achieve further proof modularity by decoupling the proof of thread safety from the proof of structural integrity. We base our work on the \emph{template} algorithms of Shasha and Goodman that dictate how threads interact but abstract from the concrete layout of nodes in memory. Building on the recently proposed flow framework of compositional abstractions and the separation logic Iris, we show how to prove correctness of template algorithms, and how to instantiate them to obtain multiple verified implementations. 
We demonstrate our approach by mechanizing the proofs of three concurrent search structure templates, based on link, give-up, and lock-coupling synchronization, and deriving verified implementations based on B-trees, hash tables, and linked lists. These case studies include algorithms used in real-world file systems and databases, which have been beyond the capability of prior automated or mechanized verification techniques. In addition, our approach reduces proof complexity and is able to achieve significant proof reuse.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Siddharth</first_name>
          <last_name>Krishna</last_name>
          <affiliation>Microsoft Research, Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.nyu.edu/~siddharth/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/siddharthkrishna/fb064b85-b50f-4fba-9626-67ed7a75b358/small.jpg</picture_url>
          <person_id>siddharthkrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nisarg</first_name>
          <last_name>Patel</last_name>
          <affiliation>New York University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>nisargpatel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dennis</first_name>
          <last_name>Shasha</last_name>
          <affiliation>New York University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dennisshasha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Wies</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.nyu.edu/wies/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thomaswies/e43dd6b5-97dc-433f-9708-836bd6364a01/small.jpg</picture_url>
          <person_id>thomaswies</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>547b0884-7ccc-417b-924d-72c14f0c67dd</slot_id>
      <event_id>9cbe048a-668b-4d5a-ad1c-7baf24aec489</event_id>
      <title>Decidable Verification under a Causally Consistent Shared Memory</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:20</end_time>
      <description>Causal consistency is one of the most fundamental and widely used consistency models weaker than sequential consistency. In this paper, we study the verification of safety properties for finite-state concurrent programs running under a causally consistent shared memory model. We establish the decidability of this problem for a standard model of causal consistency (called also "Causal Convergence" and "Strong-Release-Acquire"). Our proof proceeds by developing an alternative operational semantics, based on the notion of a thread potential, that is equivalent to the existing declarative semantics and constitutes a well-structured transition system. In particular, our result allows for the verification of a large family of programs in the Release/Acquire fragment of C/C++11 (RA). Indeed, while verification under RA was recently shown to be undecidable for general programs, since RA coincides with the model we study here for write/write-race-free programs, the decidability of verification under RA for this widely used class of programs follows from our result. The novel operational semantics may also be of independent use in the investigation of weakly consistent shared memory models and their verification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Udi</first_name>
          <last_name>Boker</last_name>
          <affiliation>IDC Herzliya, Israel</affiliation>
          <bio>undefined</bio>
          <person_id>udiboker</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5fe29d49-79d4-442a-a9f7-e27a15a04c92</slot_id>
      <event_id>1c6fea5c-98b9-4bed-90d9-cedf21a3e095</event_id>
      <title>Efficient Handling of String-Number Conversion</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:35</end_time>
      <description>String-number conversion is an important class of constraints needed for the symbolic execution of string-manipulating programs. In particular solving string constraints with string-number conversion is necessary for the analysis of scripting languages such as JavaScript and Python, where string-number conversion is a part of the definition of the core semantics of these languages. However, solving this type of constraint is very challenging for the state-of-the-art solvers. We propose in this paper an approach that can efficiently support both string-number conversion and other common types of string constraints. Experimental results show that it significantly outperforms other state-of-the-art tools on benchmarks that involves string-number conversion.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Parosh Aziz</first_name>
          <last_name>Abdulla</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://user.it.uu.se/~parosh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/paroshazizabdulla/342a7738-db1c-42a1-91cc-3b9467086b87/small.jpg</picture_url>
          <person_id>paroshazizabdulla</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mohamed Faouzi</first_name>
          <last_name>Atig</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>Mohamed Faouzi Atig is a senior lecturer at the Department of Information Technology, Uppsala University. Previously, he was a Post-doctoral researcher at Uppsala University from July 2010 to March 2012. He obtained his doctoral degree in Computer Science from the University of Paris Diderot- Paris 7 (France) in 2010. His research interests broadly span model checking, verification of infinite state systems, weak memory models, and automata theory.</bio>
          <homepage_url>http://www.it.uu.se/katalog/mohat117</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mohamedfaouziatig/5061fc57-1b58-42f4-965d-a1c64ca186dd/small.jpg</picture_url>
          <person_id>mohamedfaouziatig</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yu-Fang</first_name>
          <last_name>Chen</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iis.sinica.edu.tw/~yfc/doku.php</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yufangchen/87eecff2-df03-4022-9c4e-7d96872d36c4/small.jpg</picture_url>
          <person_id>yufangchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bui Phi</first_name>
          <last_name>Diep</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://diepbp.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/phidiepbui/04bc8805-8f6c-407b-be9a-d693717be6b3/small.jpg</picture_url>
          <person_id>phidiepbui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
          <person_id>juliandolby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Petr</first_name>
          <last_name>Janků</last_name>
          <affiliation>Brno University of Technology, Czechia</affiliation>
          <bio>undefined</bio>
          <person_id>petrjanku</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Hsin-Hung</first_name>
          <last_name>Lin</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <person_id>hsinhunglin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Wei-Cheng</first_name>
          <last_name>Wu</last_name>
          <affiliation>University of Southern California, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://steel.isi.edu/members/weicheng</homepage_url>
          <person_id>weichengwu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ac0940ba-f707-4a3d-8ada-948dc34143a2</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b3fe0e57-fe30-4edd-86e7-cfa59855a845</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2020 Papers 4</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>d4e83b59-2d48-41c8-8333-f62af0756e1b</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2020 Papers 4</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Muhammad</first_name>
          <last_name>Usman</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>muhammadusman2</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>05c21d14-eaa0-4f91-98d4-264c14625eb2</slot_id>
      <event_id>c089d48c-138d-455e-9764-41a12be6f673</event_id>
      <title>SCAF: A Speculation-Aware Collaborative Dependence Analysis Framework</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:35</end_time>
      <description>Program analysis determines the potential dataflow and control flow relationships among instructions so that compiler optimizations can respect these relationships to transform code correctly. Since many of these relationships rarely or never occur, speculative optimizations assert they do not exist while optimizing the code. To preserve correctness, speculative optimizations add validation checks to activate recovery code when these assertions prove untrue. This approach results in many missed opportunities because program analysis and thus other optimizations remain unaware of the full impact of these dynamically-enforced speculative assertions. To address this problem, this paper presents SCAF, a Speculation-aware Collaborative dependence Analysis Framework. SCAF learns of available speculative assertions via profiling, computes their full impact on memory dependence analysis, and makes this resulting information available for all code optimizations. SCAF is modular (adding new analysis modules is easy) and collaborative (modules cooperate to produce a result more precise than the confluence of all individual results). Relative to the best prior speculation-aware dependence analysis technique, by computing the full impact of speculation on memory dependence analysis, SCAF dramatically reduces the need for expensive-to-validate memory speculation in the hot loops of all 16 evaluated C/C++ SPEC benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sotiris</first_name>
          <last_name>Apostolakis</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sapostolakis.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sotirisapostolakis/538416ca-ec5a-4441-b330-832a65a0bac2/small.jpg</picture_url>
          <person_id>sotirisapostolakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ziyang</first_name>
          <last_name>Xu</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.princeton.edu/~ziyangx/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ziyangxu/4d095217-b7d0-4159-9508-7cae73aa6bf5/small.jpg</picture_url>
          <person_id>ziyangxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zujun</first_name>
          <last_name>Tan</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/zujuntan/ad30ef1a-77e1-4829-b5c8-d969eac74289/small.jpg</picture_url>
          <person_id>zujuntan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Greg</first_name>
          <last_name>Chan</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>gregchan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Simone</first_name>
          <last_name>Campanoni</last_name>
          <affiliation>Northwestern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.northwestern.edu/~simonec</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/simonecampanoni/7b306233-75f2-4593-bd85-6774e1e27797/small.jpg</picture_url>
          <person_id>simonecampanoni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>David I.</first_name>
          <last_name>August</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>davidiaugust</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>255f94e6-2587-4e8f-9d93-e3b45f80af86</slot_id>
      <event_id>8bfe5d3b-1e01-4f72-acf3-fce8afee84a2</event_id>
      <title>BlankIt Library Debloating: Getting What You Want Instead of Cutting What You Don’t</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:05</end_time>
      <description>Modern software systems make extensive use of libraries derived from C and C++. Because of the lack of memory safety in these languages, however, the libraries may suffer from vulnerabilities, which can expose the applications to potential attacks. For example, a very large number of return-oriented programming gadgets exist in glibc that allow stitching together semantically valid but malicious Turing-complete and -incomplete programs. While CVEs get discovered and often patched and remedied, such gadgets serve as building blocks of future undiscovered attacks, opening an ever-growing set of possibilities for generating malicious programs. Thus, significant reduction in the quantity and expressiveness (utility) of such gadgets for libraries is an important problem. 
In this work, we propose a new approach for handling an application's library functions that focuses on the principle of getting only what you want.&amp;amp;#39;&amp;amp;#39; This is a significant departure from the current approaches that focus oncutting what is unwanted.'' Our approach focuses on activating/deactivating library functions on demand in order to reduce the dynamically linked code surface, so that the possibilities of constructing malicious programs diminishes substantially. The key idea is to load only the set of library functions that will be used at each library call site within the application at runtime. This approach of demand-driven loading relies on an input-aware oracle that predicts a near-exact set of library functions needed at a given call site during the execution. The predicted functions are loaded just in time and unloaded on return. 
We present a decision-tree based predictor, which acts as an oracle, and an optimized runtime system, which works directly with library binaries like GNU libc and libstdc++. We show that on average, the proposed scheme cuts the exposed code surface of libraries by 97.2%, reduces ROP gadgets present in linked libraries by 97.9%, achieves a prediction accuracy in most cases of at least 97%, and adds a runtime overhead of 18% on all libraries (16% for glibc, 2% for others) across all benchmarks of SPEC 2006. Further, we demonstrate BlankIt on two real-world applications, sshd and nginx, with a high amount of debloating and low overheads.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chris</first_name>
          <last_name>Porter</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>chrisporter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Girish</first_name>
          <last_name>Mururu</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>girishmururu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Prithayan</first_name>
          <last_name>Barua</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>prithayanbarua</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Santosh</first_name>
          <last_name>Pande</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>Santosh Pande is a Professor of Computer Science at Georgia Tech working in the general areas of program analysis, software security and compiler optimizations. His recent work involves piece-wise loading and linking of functions to reduce attack surface of software, proposing new metrics and tools for measuring security strength of applications,tradeoffs between compiler optimizations and vulnerabilities they introduce on the security side. He is also working in the area of compiler-OS interactions. Modern high performance applications involving analytics, machine learning co-execute in a data-center or cloud environment sharing key resources such as caches. Determining their co-execution and scheduling them appropriately is the key to their performance. Application phases determine such co-execution which means that this problem can be efficiently solved by determining dynamic properties of co-execution which is a hard problem. Fortunately, such a problem can be solved through a collaboration between compiler and OS. The results of this research show that significant (2x to 4x) improvements in throughput for batch oriented execution of important and diverse modern workloads. 
Santosh Pande’s research is supported by NSF, ONR, DARPA, Air Force and several industiries such as Sony, Toshiba IBM, Motorola, Infineon and holds a patent on smartcards jointly with Infineon. He is always looking for smart and motivated PhD students..</bio>
          <homepage_url>https://www.cc.gatech.edu/people/santosh-pande</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/santoshpande1/3200a8e1-7ee4-4160-9889-f1504c0e80e5/small.jpg</picture_url>
          <person_id>santoshpande1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>465931e5-d076-4775-a217-fe45f86bbce9</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d6f505a8-eb2f-4662-8378-47e6cba03a4e</slot_id>
      <event_id>a481aefe-edfe-4d18-97b2-b3a5c9e59b3b</event_id>
      <title>Towards a Verified Range Analysis for JavaScript JITs</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:50</end_time>
      <description>We present VeRA, a system for verifying the range analysis pass in browser just-in-time (JIT) compilers. Browser developers write range analysis routines in a subset of C++, and verification developers write infrastructure to verify custom analysis properties. Then, VeRA automatically verifies the range analysis routines, which browser developers can integrate directly into the JIT. We use VeRA to translate and verify Firefox range analysis routines, and it detects a new, confirmed bug that has existed in the browser for six years.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fraser</first_name>
          <last_name>Brown</last_name>
          <affiliation>Stanford University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/fraserbrown/bbe0a77f-703c-4bc8-bd43-4fac9c0a93b1/small.jpg</picture_url>
          <person_id>fraserbrown</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>John</first_name>
          <last_name>Renner</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnrenner/ee473e3c-537b-4d92-afc9-8cb18e611337/small.jpg</picture_url>
          <person_id>johnrenner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andres</first_name>
          <last_name>Nötzli</last_name>
          <affiliation>Stanford University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>andresnoetzli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sorin</first_name>
          <last_name>Lerner</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/users/lerner/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sorinlerner/3d3b1a70-e2f8-4d3a-a1bc-9c4e17dad80b/small.jpg</picture_url>
          <person_id>sorinlerner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hovav</first_name>
          <last_name>Shacham</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>hovavshacham</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Deian</first_name>
          <last_name>Stefan</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~dstefan/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/deianstefan/55e73d29-9671-4740-9ef2-3b45f485fc24/small.jpg</picture_url>
          <person_id>deianstefan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fd89a05c-590f-4303-8f6d-c9e8911ad42c</slot_id>
      <event_id>e14c3aaf-48a4-413c-abd5-69d222c5ad50</event_id>
      <title>Crafty: Efficient, HTM-Compatible Persistent Transactions</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:20</end_time>
      <description>Byte-addressable persistent memory, such as Intel/Micron 3D XPoint, is an emerging technology that bridges the gap between volatile memory and persistent storage. Data in persistent memory survives crashes and restarts; however, it is challenging to ensure that this data is consistent after failures. Existing approaches incur significant performance costs to ensure crash consistency. 
This paper introduces &amp;lt;em&amp;gt;Crafty&amp;lt;/em&amp;gt;, a new approach for ensuring consistency and atomicity on persistent memory operations using &amp;lt;em&amp;gt;commodity hardware&amp;lt;/em&amp;gt; with existing hardware transactional memory (HTM) capabilities, while incurring low overhead. Crafty employs a novel technique called &amp;lt;em&amp;gt;nondestructive undo logging&amp;lt;/em&amp;gt; that leverages commodity HTM to control persist ordering. Our evaluation shows that Crafty outperforms state-of-the-art prior work under low contention, and performs competitively under high contention.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kaan</first_name>
          <last_name>Genç</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/kaangenc/8f0ac613-3bf5-4300-bc95-157afd5fe4ad/small.jpg</picture_url>
          <person_id>kaangenc</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael D.</first_name>
          <last_name>Bond</last_name>
          <affiliation>Ohio State University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ohio-state.edu/~mikebond</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelbond/92c528d2-84b3-4369-8b57-6555f1016a8e/small.jpg</picture_url>
          <person_id>michaelbond</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Guoqing Harry</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of California at Los Angeles</affiliation>
          <bio>I am an Associate Professor of Computer Science at University of California, Los Angeles (UCLA). I am interested broadly in software and hardware systems — including programming languages, compilers, big data analytics, distributed systems, and computer architecture.</bio>
          <homepage_url>http://web.cs.ucla.edu/~harryxu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/harryxu/5d680c47-2b02-4f5f-a2fb-55c72b5d63ed/small.jpg</picture_url>
          <person_id>harryxu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>17c4e639-d36c-4ff8-a7ed-fdc61a430b08</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>17698125-68bf-41fd-8ae3-b016e25a3f27</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>13:20</start_time>
      <end_time>13:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f07065f3-d345-43f8-896b-49d6efbe8f38</slot_id>
      <event_id>4bda0a91-c4ff-4741-932e-621e3a3b2efd</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>13:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>13:50</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>37322521-775a-4171-92ed-60addb060b56</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>515b5b25-2ee3-4f32-924c-e4c283850a33</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>13:20</start_time>
      <end_time>13:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5e5f63ba-cfc9-42e5-a396-8e44f04e1c7c</slot_id>
      <event_id>2ac090ba-a3e5-4393-bb28-b315e6984c98</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>13:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>13:50</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c9cc821e-eab8-4b33-8fea-5911f1ec7ccf</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>d916d405-2921-47d0-a40b-da71b56c1c59</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>13:20</start_time>
      <end_time>13:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Paulette</first_name>
          <last_name>Koronkevich</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://koronkevi.ch</homepage_url>
          <person_id>paulettekoronkevich</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f5fc1ec0-979f-4a2d-a494-6cbb24711a73</slot_id>
      <event_id>3501a012-9b8c-473f-a5f6-44096ab55fa3</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>13:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>13:50</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5707c8d1-8c2b-4095-be94-be4db9122730</subevent_id>
    <title>SPLASH SIGPLAN Papers: OOPSLA 2020 Papers 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>e31020bc-48da-4705-a191-5a99e8d1a705</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - OOPSLA 2020 Papers 1</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Renner</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnrenner/ee473e3c-537b-4d92-afc9-8cb18e611337/small.jpg</picture_url>
          <person_id>johnrenner</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>21545e2a-3b98-4cd2-bf7f-d6a55ad0ed2e</slot_id>
      <event_id>2df18741-5ff8-441b-aca8-1dce4e59560c</event_id>
      <submission_id>225</submission_id>
      <title>Designing Types for R, Empirically</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:20</end_time>
      <description>The R programming language is widely used in a variety of domains. It was designed to favor an interactive style of programming with minimal syntactic and conceptual overhead. This design is well suited to interactive data analysis, but a bad fit for tools such as compilers or program analyzers which must generate native code or catch programming errors. In particular, R has no type annotations, all operations are dynamically checked at run-time. The starting point for our work are the twin questions, \emph{what expressive power is needed to accurately type R code?} and \emph{which type system is the R community willing to adopt?} Both questions are difficult to answer without actually experimenting with a type system. The goal of this paper is to provide data that can feed into that design process. To this end, we perform a large corpus analysis to gain insights in the degree of polymorphism exhibited by idiomatic R code and explore potential benefits that the R community could accrue from a simple type system. As a starting point, we infer type signatures for 20214 functions from 412 packages among the most widely used open source R libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexi</first_name>
          <last_name>Turcotte</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://reallytg.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexiturcotte/6881a0a0-5145-40cb-aab4-ff41754a0640/small.jpg</picture_url>
          <person_id>alexiturcotte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Filip</first_name>
          <last_name>Křikava</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fikovnik.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/filipkrikava/12cc1e57-732c-4b7e-880e-ca7b51a07d77/small.jpg</picture_url>
          <person_id>filipkrikava</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4b29f0b3-8dbb-48f5-851c-530ff8f2823e</slot_id>
      <event_id>e0dc810f-1fc6-49e8-b5fb-daf967847ac9</event_id>
      <submission_id>23</submission_id>
      <title>Can Advanced Type Systems Be Usable? An Empirical Study of Ownership, Assets, and Typestate in Obsidian</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:05</end_time>
      <description>Some blockchain programs (smart contracts) have included serious security vulnerabilities. Obsidian is a new typestate-oriented programming language that uses a strong type system to rule out some of these vulnerabilities. Although Obsidian was designed to promote usability to make it as easy as possible to write programs, strong type systems can cause a language to be difficult to use. In particular, ownership, typestate, and assets, which Obsidian uses to provide safety guarantees, have not seen broad adoption in popular languages and result in significant usability challenges. We performed an empirical study with 20 participants comparing Obsidian to Solidity, which is the language most commonly used for writing smart contracts today. We observed that Obsidian participants were able to successfully complete more of the programming tasks than the Solidity participants. We also found that asset-related bugs, which Obsidian detects at compile time, were commonly accidentally inserted by the Solidity participants.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>University of Maryland at College Park</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umd.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brad A.</first_name>
          <last_name>Myers</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~bam/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/bradmyers/7d93ede9-5674-40e8-9ba5-f9dfab4873e1/small.jpg</picture_url>
          <person_id>bradmyers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>I am a Senior Research Fellow in the Institute for Software Research at Carnegie Mellon University. I have broad research interests at the intersection of programming languages and human-computer interaction. I am particularly interested in better understanding of the factors that influence the usability of reusable software components.</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>771e0ff6-479c-4524-9500-fd9c8fa35475</slot_id>
      <event_id>a24306c7-71e8-4345-8ecd-4a83171c21d8</event_id>
      <submission_id>342</submission_id>
      <title>Digging for Fold: Synthesis-Aided API Discovery for Haskell</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:50</end_time>
      <description>We present Hoogle+, a component-based synthesizer for Haskell that takes as input a specification in the form of a type, a set of input-output tests, or both, and returns a list of candidate programs composed of functions from popular Haskell libraries. Hoogle+ focuses on the end-to-end usability of synthesis: i.e., how to help programmers solve their tasks faster. Usability depends crucially on whether and how the programmer can specify their own intent and comprehend the tools results. Hoogle+ addresses the specification problem by allowing the user to specify goals via tests from which it automatically infers type signatures that facilitate rapid synthesis. Hoogle+ uses property based testing to ensure the user only sees _useful and _unique candidates, and generates example usages to illustrate the _functionality of each candidate to help the user comprehend their semantics in order to choose the right result. We evaluate the usability of Hoogle+, with a user study with 30 participants of varying Haskell proficiency,that shows that programmers generally solve tasks faster with Hoogle+, and that they were able to solve 50% more tasks when equipped with Hoogle+.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael B.</first_name>
          <last_name>James</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Michael James is a 3rd year PhD student at University of California, San Diego studying programming languages and program synthesis under Nadia Polikarpova. He worked as a software engineer for three years before starting his degree. His experience has guided him to research topics that will ultimately flow back to help other engineers and make programming easier for all.</bio>
          <homepage_url>http://michaelbjames.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelbjames/8360df32-2f8d-4f7c-99c1-523f1f811bec/small.jpg</picture_url>
          <person_id>michaelbjames</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zheng</first_name>
          <last_name>Guo</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~zhg069</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhengguo1/cf77f323-ab54-4b33-8d59-36608178b41e/small.jpg</picture_url>
          <person_id>zhengguo1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziteng</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wzt.me/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zitengwang/bf349a37-8935-4553-bcf7-c78094e369c5/small.jpg</picture_url>
          <person_id>zitengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shivani</first_name>
          <last_name>Doshi</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Current Cornell Tech MEng Student, UC San Diego 2020 BS in CS graduate.</bio>
          <homepage_url>https://shivanidoshi26.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shivanidoshi/a3bdf8b0-e4df-4be6-8c43-1cd1aee38f69/small.jpg</picture_url>
          <person_id>shivanidoshi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.technion.ac.il/~hilap</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Ranjit</first_name>
          <last_name>Jhala</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nom nom. Chomp. Burp.</bio>
          <homepage_url>http://ranjitjhala.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
          <person_id>ranjitjhala</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of 2020 Intel Rising Stars Award and the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cc4608db-358d-42a5-8fe2-eb57414eca13</slot_id>
      <event_id>b7de8362-c8f6-4916-a31f-43dd240bf2d2</event_id>
      <submission_id>171</submission_id>
      <title>Deductive Optimization of Relational Data Storage</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:35</end_time>
      <description>Optimizing the physical data storage and retrieval of data are two key database management problems. In this paper, we propose a language that can express both a relational query and the layout of its data. Our language can express a wide range of physical database layouts, going well beyond the row- and column-based methods that are widely used in database management systems. We use deductive program synthesis to turn a high-level relational representation of a database query into a highly optimized low-level implementation which operates on a specialized layout of the dataset. We build an optimizing compiler for this language and conduct experiments using a popular database benchmark, which shows that the performance of our specialized queries is better than a state-of-the-art in memory compiled database system while achieving an order-of-magnitude reduction in memory use.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Feser</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>John Feser is a PhD student in the Computer Science and Artificial Intelligence Laboratory at MIT, advised by Armando Solar-Lezama. He is interested in program synthesis and databases.</bio>
          <homepage_url>http://people.csail.mit.edu/feser/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnfeser/edee5cf7-267b-4a87-90ca-94f278378c37/small.jpg</picture_url>
          <person_id>johnfeser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Madden</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>sammadden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nan</first_name>
          <last_name>Tang</last_name>
          <affiliation>QCRI HBKU</affiliation>
          <bio>undefined</bio>
          <person_id>nantang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Armando</first_name>
          <last_name>Solar-Lezama</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Armando Solar-Lezama is an associate professor at MIT where he leads the Computer Aided Programming Group. His research interests include software synthesis and its applications in diverse areas such as high-performance computing, information flow security and probabilistic programming.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/armandosolarlezama/7befe52d-6968-4786-9841-408800f80c71/small.jpg</picture_url>
          <person_id>armandosolarlezama</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d44a8ab2-1277-435b-92e8-eaeb177c85ea</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a22c4dd4-569a-4938-a1df-9a25935a8c8f</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>30e91d5b-359e-472e-910f-81d8aa9109a4</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>10:20</start_time>
      <end_time>10:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f3ffadd8-21c3-429e-bcb2-95c3c07ae96d</slot_id>
      <event_id>c5bca3c3-9de0-4d8d-a920-a82ee46e85a8</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>10:50</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e19487bf-4614-4370-825a-c5ccbe5aa3af</subevent_id>
    <title>SPLASH SIGPLAN Papers: OOPSLA 2020 Papers 3</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>824d69d5-bcc4-4182-a0cc-28af28d2fb51</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - OOPSLA 2020 Papers 3</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Miltner</last_name>
          <affiliation>The University of Texas at Austin, Texas, USA</affiliation>
          <bio>Postdoctoral Fellow at UT Austin. PhD from Princeton University.</bio>
          <homepage_url>https://www.cs.utexas.edu/~amiltner/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/andersmiltner1/2ea1a602-4b63-48e5-b479-32936848075f/small.jpg</picture_url>
          <person_id>andersmiltner1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>069a8f68-af8d-4705-8efc-726d9ef26505</slot_id>
      <event_id>7f0f7e60-d8f2-4530-9c09-3df6e57fc9cc</event_id>
      <submission_id>256</submission_id>
      <title>DynamiTe: Dynamic Termination and Non-termination Proofs</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:55</end_time>
      <description>There is growing interest in termination reasoning for non-linear programs and, meanwhile, recent dynamic strategies have shown they are able to infer invariants for such challenging programs. These advances led us to hypothesize that perhaps such dynamic strategies for non-linear invariants could be adapted to learn recurrent sets (for non-termination) and/or ranking functions (for termination). 
In this paper, we exploit dynamic analysis and draw termination and non-termination as well as static and dynamic strategies closer together in order to tackle non-linear programs. For termination, our algorithm infers ranking functions from concrete transitive closures, and, for non-termination, the algorithm iteratively collects executions and dynamically learns conditions to refine recurrent sets. Finally, we describe an integrated algorithm that allows these algorithms to mutually inform each other, taking counterexamples from a failed validation in one endeavor and crossing both the static/dynamic and term./non-term.~ lines, to create new execution samples for the other one. 
We have implemented these algorithms in a new tool called DynamiTe. For non-linear programs, there are currently no SV-COMP termination benchmarks so we created new sets of 37 terminating and 37 non-terminating programs. Our empirical evaluation shows that we can effectively guess (and sometimes even validate) ranking functions and recurrent sets for programs with non-linear behaviors. Furthermore, we show that counterexamples from one failed validation can be used to generate executions for a dynamic analysis of the opposite property. Although we are focused on non-linear programs, as a point of comparison, we compare DynamiTe’s performance on linear programs with that of the state-of-the-art tool, Ultimate. Although DynamiTe is an order of magnitude slower it is nonetheless somewhat competitive and sometimes finds ranking functions where Ultimate was unable to. Ultimate cannot, however, handle the non-linear programs in our new benchmark suite.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ton Chanh</first_name>
          <last_name>Le</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://letonchanh.github.io/</homepage_url>
          <person_id>tonchanhle</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Timos</first_name>
          <last_name>Antonopoulos</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <person_id>timosantonopoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Parisa</first_name>
          <last_name>Fathololumi</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>parisafathololumi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eric</first_name>
          <last_name>Koskinen</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.stevens.edu/~ejk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/erickoskinen/3413fc94-5f0f-4855-af65-da2309d2632f/small.jpg</picture_url>
          <person_id>erickoskinen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>ThanhVu</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>George Mason University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nguyenthanhvuh.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thanhvunguyen/db337089-c863-4086-ad33-88d7dbfeb025/small.jpg</picture_url>
          <person_id>thanhvunguyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>62cbf0e1-db93-40e4-a357-c5f9c219c8e0</slot_id>
      <event_id>cc230051-4fa5-4060-bf31-ac34561cfdb6</event_id>
      <submission_id>136</submission_id>
      <title>Towards A Unified Proof Framework for Automated Fixpoint Reasoning Using Matching Logic</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>16:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:25</end_time>
      <description>Automation of fixpoint reasoning has been extensively studied for various mathematical structures, logical formalisms, and computational domains, resulting in specialized fixpoint provers for heaps, for streams, for term algebras, for temporal properties, for program correctness, and for many other formal systems and inductive and coinductive properties. However, in spite of great theoretical and practical interest, there is no unified framework for automated fixpoint reasoning. Although several attempts have been made, there is no evidence that such a unified framework is possible, or practical. In this paper, we propose a candidate based on matching logic, a formalism that is recently shown to theoretically unify the above mentioned formal systems. Unfortunately, the Knaster-Tarski proof rule of matching logic, which enables inductive reasoning, is not syntax-driven. Worse, it can be applied at any step during a proof, making automation seem hopeless. Inspired by recent advances in automation of inductive proofs in separation logic, we propose an alternative proof system for matching logic, which is amenable for automation. We then discuss our implementation of it, which although not superior to specialized state-of-the-art automated provers for specific domains, we believe brings some evidence and hope that a unified framework for automated reasoning is not out of reach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaohong</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/~xchen</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaohongchen1/e982c014-9fda-495c-93d6-b5fdc8158320/small.jpg</picture_url>
          <person_id>xiaohongchen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Minh-Thai</first_name>
          <last_name>Trinh</last_name>
          <affiliation>Advanced Digital Sciences Center</affiliation>
          <bio>undefined</bio>
          <person_id>thaitrinh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nishant</first_name>
          <last_name>Rodrigues</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>nishantrodrigues</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Peña</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>lucaspena</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Grigore</first_name>
          <last_name>Roşu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/index.php/Grigore_Rosu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/grigorerosu/5b147c13-0a15-45fe-bbf0-3ce641260478/small.jpg</picture_url>
          <person_id>grigorerosu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>694250b4-cd61-4182-9242-1ea5e0d1bd31</slot_id>
      <event_id>903d1eb4-6ac1-41bf-bd02-7e9fb4f1d045</event_id>
      <submission_id>148</submission_id>
      <title>Verifying and Improving Halide’s Term Rewriting System with Program Synthesis</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>16:25</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:40</end_time>
      <description>Halide is a domain-specific language for high-performance image processing and tensor computations, widely adopted in industry. Internally, the Halide compiler relies on a term rewriting system to prove properties of code required for efficient and correct compilation. This rewrite system is a collection of handwritten transformation rules that incrementally rewrite expressions into simpler forms; the system requires high performance in both time and memory usage to keep compile times low. In this work, we apply formal techniques to prove the correctness of existing rewrite rules and provide a guarantee of termination. Then, we build an automatic program synthesis system that operates over the undecidable theory of integers in order to craft new, provably correct rules from failure cases where the compiler was unable to prove properties. We identify and fix 5 incorrect rules as well as 8 rules which could give rise to infinite rewriting loops. We demonstrate that the synthesizer can produce better rules than hand-authored ones in five bug fixes, and describe four cases in which it has served as an assistant to a human compiler engineer. We further show that it can proactively improve weaknesses in the compiler by synthesizing a large number of rules without human supervision and showing that the enhanced ruleset lowers peak memory usage of compiled code without appreciably increasing compilation times.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julie L.</first_name>
          <last_name>Newcomb</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jn80842.github.io/</homepage_url>
          <person_id>julielnewcomb</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Adams</last_name>
          <affiliation>Adobe</affiliation>
          <bio>undefined</bio>
          <person_id>andrewadams</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Steven</first_name>
          <last_name>Johnson</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <person_id>stevenjohnson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rastislav</first_name>
          <last_name>Bodik</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://homes.cs.washington.edu/~bodik</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rastislavbodik/ae16ae8e-9d00-41c4-9067-0c37da65dde7/small.jpg</picture_url>
          <person_id>rastislavbodik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a9c1007c-4438-41ba-b0cb-d4b03f6cf589</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f90e8367-f739-424a-ba13-6917f3f7e3c5</slot_id>
      <event_id>99f34b89-8833-47df-bf8e-7144361d659e</event_id>
      <submission_id>664</submission_id>
      <title>TacTok: Semantics-Aware Proof Synthesis</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>15:55</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:10</end_time>
      <description>Formally verifying software correctness is a highly manual process. However, because verification proofs often share structure, it is possible to learn from existing proofs to fully automate some formal verification. The goal of this paper is to improve proof synthesis and enable fully automating more verification. Interactive theorem provers, such as the Coq proof assistant, allow developers to write partial proofs, observe the semantics of the proof state thus far, and then attempt more progress. Knowing the proof state semantics is a significant aid. Recent research has shown that the proof state can help predict the next step. In this paper, we present TacTok, the first technique that attempts to fully automate proof synthesis by modeling proofs using both the partial proof written thus far and the semantics of the proof state. Thus, TacTok more completely models the information the developer has access to when writing proofs manually. TacTok is open-source. We evaluate TacTok on a benchmark of 26 software projects in Coq, consisting of over 10 thousand theorems. We compare our approach to two tools, CoqHammer, the state-of-the-art proof synthesis technique, and ASTactic, a proof synthesis technique that models proof state. We find that TacTok is complementary to CoqHammer and ASTactic: for 24 out of the 26 projects, TacTok can synthesize proofs for some theorems prior tools cannot. Together with TacTok, 11.5% more theorems can be proven automatically than by CoqHammer alone, and 20.0% than by ASTactic alone. Compared to a combination of CoqHammer and ASTactic, TacTok can prove an additional 3.6% more theorems, proving 115 theorems no tool could previously prove. Overall, our experiments provide evidence that partial proof and proof state semantics, together, provide useful information for proof modeling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Emily</first_name>
          <last_name>First</last_name>
          <affiliation>University of Massachusetts at Amherst</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/emilyfirst/76db7ede-1a2f-4b56-9974-9bb109e78ed1/small.jpg</picture_url>
          <person_id>emilyfirst</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yuriy</first_name>
          <last_name>Brun</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>My research is in software engineering. I am interested in improving our ability to build systems that are smart, and self-adapt to their environment. I am particularly interested in ensuring fairness in software systems. Watch a video describing my latest work on software fairness testing here: http://tinyurl.com/FairnessVideo</bio>
          <homepage_url>http://people.cs.umass.edu/~brun/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuriybrun/15eff225-fb71-4b2c-9925-a0d731136238/small.jpg</picture_url>
          <person_id>yuriybrun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>564d2adf-edcc-4f26-b3a3-773d0fe4f0bf</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>aad49b19-2a42-40bc-b846-866fd826cc75</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>15:10</start_time>
      <end_time>15:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b5e44770-b170-42dd-b8ba-230142186f2b</slot_id>
      <event_id>394cd4be-af20-429a-8a99-3e7aefd3e6a8</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>15:10</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>15:40</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4cffdf85-839c-4f50-b3b8-d25f29938f53</subevent_id>
    <title>SPLASH SIGPLAN Papers: ICFP 2021 Papers</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>7e766bbc-4b28-42ee-b851-5710d6736c9f</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - ICFP 2021 Papers</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Omar</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>https://fplab.mplse.org/</bio>
          <homepage_url>https://web.eecs.umich.edu/~comar</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/cyrusomar/6f85cfe7-5130-42cf-9976-450725051201/small.jpg</picture_url>
          <person_id>cyrusomar</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2921fe2d-65f6-40bf-afe8-48acb0cff134</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4c1ca292-20e3-492a-ac73-da288870b66e</slot_id>
      <event_id>13ad6230-f0bf-48bf-8970-e4cee488a606</event_id>
      <submission_id>icfp21main-p128-p</submission_id>
      <title>Compositional Optimizations for CertiCoq</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>15:55</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:10</end_time>
      <description>Compositional compiler verification is a difficult problem that focuses on separate compilation of program components with possibly different verified compilers. Logical relations are widely used in proving correctness of program transformations in higher-order languages; however, they do not scale to compositional verification of multi-pass compilers due to their lack of transitivity. The only known technique to apply to compositional verification of multi-pass compilers for higher-order languages is parametric inter-language simulations (PILS), which is however significantly more complicated than traditional proof techniques for compiler correctness. In this paper, we present a novel verification framework for \emph{lightweight compositional compiler correctness}. We demonstrate that by imposing the additional restriction that program components are compiled by pipelines that go through \emph{the same sequence of intermediate representations}, logical relation proofs can be transitively composed in order to derive an end-to-end compositional specification for multi-pass compiler pipelines. Unlike traditional logical-relation frameworks, our framework supports divergence preservation—even when transformations reduce the number of program steps. We achieve this by parameterizing our logical relations with a pair of \emph{relational invariants}. 
We apply this technique to verify a multi-pass, optimizing middle-end pipeline for CertiCoq, a compiler from Gallina (Coq's specification language) to C. The pipeline optimizes and closure-converts an untyped functional intermediate language (ANF or CPS) to a subset of that language without nested functions, which can be easily code-generated to low-level languages. Notably, our pipeline performs more complex closure-allocation optimizations than the state of the art in verified compilation. Using our novel verification framework, we prove an end-to-end theorem for our pipeline that covers both termination and divergence and applies to whole-program and separate compilation, even when different modules are compiled with different optimizations. Our results are mechanized in the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zoe</first_name>
          <last_name>Paraskevopoulou</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zoep.github.io/</homepage_url>
          <person_id>zoeparaskevopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>John M.</first_name>
          <last_name>Li</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>johnmli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Appel</last_name>
          <affiliation>Princeton</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.Princeton.EDU/~appel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/andrewappel/b75d69e5-5153-4248-8233-8018bb878e67/small.jpg</picture_url>
          <person_id>andrewappel</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>69524df3-9ef1-494b-b26d-bed050fa05d8</slot_id>
      <event_id>05712618-e38b-459d-9eb5-3ca6de2baae1</event_id>
      <submission_id>icfp21main-p99-p</submission_id>
      <title>Reasoning about the Garden of Forking Paths</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>16:25</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:40</end_time>
      <description>Lazy evaluation is a powerful tool for functional programmers. It enables the concise expression of on-demand computation and a form of compositionality not available under other evaluation strategies. However, the stateful nature of lazy evaluation makes it hard to analyze a program's computational cost, either informally or formally. In this work, we present a novel and simple framework for formally reasoning about lazy computation costs based on a recent model of lazy evaluation: clairvoyant call-by-value. The key feature of our framework is its simplicity, as expressed by our definition of the clairvoyance monad. This monad is both simple to define (around 20 lines of Coq) and simple to reason about. We show that this monad can be effectively used to mechanically reason about the computational cost of lazy functional programs written in Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yao</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lastland.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yaoli/ac58cfa1-acf7-454b-a4fc-cbdf519f65fb/small.jpg</picture_url>
          <person_id>yaoli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Li-yao</first_name>
          <last_name>Xia</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <person_id>liyaoxia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stephanie</first_name>
          <last_name>Weirich</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cis.upenn.edu/~sweirich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stephanieweirich/1f63ace9-e52a-4efc-b20b-ee75b5d7d091/small.jpg</picture_url>
          <person_id>stephanieweirich</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>92ebdc9d-da55-444b-b253-98d1444f4925</slot_id>
      <event_id>957aebb0-7295-437f-93f4-e39983dc8e82</event_id>
      <submission_id>icfp21main-p20-p</submission_id>
      <title>An Order-Aware Dataflow Model for Parallel Unix Pipelines</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:55</end_time>
      <description>We present a dataflow model for modelling parallel Unix shell pipelines. To accurately capture the semantics of complex Unix pipelines, the dataflow model is order-aware, i.e., the order in which a node in the dataflow graph consumes inputs from different edges plays a central role in the semantics of the computation and therefore in the resulting parallelization. We use this model to capture the semantics of transformations that exploit data parallelism available in Unix shell computations and prove their correctness. We additionally formalize the translations from the Unix shell to the dataflow model and from the dataflow model back to a parallel shell script. We implement our model and transformations as the compiler and optimization passes of a system parallelizing shell pipelines, and use it to evaluate the speedup achieved on 47 pipelines.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shivam</first_name>
          <last_name>Handa</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/shivamhanda/b10bc167-83fa-447d-b76b-628e90c9eaa9/small.jpg</picture_url>
          <person_id>shivamhanda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Kallas</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://angelhof.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/konstantinoskallas/532ec21f-35f9-482a-afc9-d7c8b7118a65/small.jpg</picture_url>
          <person_id>konstantinoskallas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nikos</first_name>
          <last_name>Vasilakis</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>I am a Research Scientist at the Computer Science &amp;amp; Artificial Intelligence Laboratory of the Massachusetts Institute of Technology. I work on parallel and distributed systems, programming languages, and computer security—with recent focus on program analysis, transformation, and synthesis for automated parallelization, distribution, compartmentalization, and regeneration of computer programs or program fragments.</bio>
          <homepage_url>http://nikos.vasilak.is</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nikosvasilakis/822e63da-c64c-4f56-b9ed-54d49ce5bc0d/small.jpg</picture_url>
          <person_id>nikosvasilakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Martin C.</first_name>
          <last_name>Rinard</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.csail.mit.edu/rinard/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinrinard/cc4278df-192e-490f-87e5-a0649c420584/small.jpg</picture_url>
          <person_id>martinrinard</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e35c25fa-264a-438f-84cc-565310534aa9</slot_id>
      <event_id>3a3de5ec-71c8-4ec4-b17f-ce869d94710c</event_id>
      <submission_id>icfp21main-p158-p</submission_id>
      <title>Efficient Tree-Traversals: Reconciling Parallelism and Dense Data Representations</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>16:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:25</end_time>
      <description>Recent work showed that compiling functional programs to use dense, serialized memory representations for recursive algebraic datatypes can yield significant constant-factor speedups for sequential programs. But serializing data in a maximally dense format consequently serializes the processing of that data, yielding a tension between density and parallelism. This paper shows that a disciplined, practical compromise is possible. We present Parallel Gibbon, a compiler that obtains the benefits of dense data formats and parallelism. We formalize the semantics of the parallel location calculus underpinning this novel implementation strategy, and show that it is type-safe. Parallel Gibbon exceeds the parallel performance of existing compilers for purely functional programs that use recursive algebraic datatypes, including, notably, abstract-syntax-tree traversals as in compilers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chaitanya</first_name>
          <last_name>Koparkar</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/chaitanyakoparkar/139d8599-0098-4c4a-b576-f472f5309d6d/small.jpg</picture_url>
          <person_id>chaitanyakoparkar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mike</first_name>
          <last_name>Rainey</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mike-rainey.site</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mikerainey/1a4d7530-303c-4513-aa1f-c897cfe8556e/small.jpg</picture_url>
          <person_id>mikerainey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Vollmer</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelvollmer2/a2e0bce9-52e0-47f8-a385-d93681e01165/small.jpg</picture_url>
          <person_id>michaelvollmer2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University. 
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures. 
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University. I received an NSF CAREER Award in 2012, a Department of Energy Early Career Research Award in 2013, and the Presidential Early Career Award for Scientists and Engineers in 2016.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
          <person_id>milindkulkarni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ryan R.</first_name>
          <last_name>Newton</last_name>
          <affiliation>Facebook</affiliation>
          <bio>From South Florida. Ph.D. 2009 at MIT.</bio>
          <homepage_url>https://www.linkedin.com/in/rrnewton/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ryanrnewton/4dff7d06-8ca4-46f3-981b-52049bc71c54/small.jpg</picture_url>
          <person_id>ryanrnewton</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e5dc0a97-9798-4e31-8efe-116378d9b8f5</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>30a03084-5ea2-494b-8107-04ed5681190b</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>15:10</start_time>
      <end_time>15:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Paulette</first_name>
          <last_name>Koronkevich</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://koronkevi.ch</homepage_url>
          <person_id>paulettekoronkevich</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dff31217-ec80-4f13-8cba-09c720b4c51c</slot_id>
      <event_id>81fcb6f6-a65b-49f0-b6ae-36412ac644a9</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>15:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:40</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9a203d7a-17db-46fb-9341-562a24a5d725</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2020 Papers 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>3787d486-5439-4470-91b6-242f06024564</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2020 Papers 2</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>University of California at Santa Cruz</affiliation>
          <bio>I am a Post Doc researcher at Princeton University working in Margaret Martonosi’s group. My research interests are in concurrency: programming, modeling, testing, and architecture. In particular, I am interested in exploring new heterogeneous architectures and how programming models can enable development of secure and efficient applications. 
I received my PhD from the Multicore Programming Group at Imperial College London supervised by Alastair Donaldson. Previously, I worked with Ganesh Gopalakrishnan and Zvonimir Rakamaric at University of Utah.</bio>
          <homepage_url>https://www.cs.princeton.edu/~ts20/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tylersorensen1/e6c9c5cc-65e1-4a42-87c2-5e4a7d347b0d/small.jpg</picture_url>
          <person_id>tylersorensen1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>199618d2-4728-48f8-b150-87d50e1b9a93</slot_id>
      <event_id>0030b6c0-b9bf-4381-abfd-88608ddffd0d</event_id>
      <title>Automated Derivation of Parametric Data Movement Lower Bounds for Affine Programs</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:05</end_time>
      <description>Researchers and practitioners have for long worked on improving the computational complexity of algorithms, focusing on reducing the number of operations needed to perform a computation. However the hardware trend nowadays clearly shows a higher performance and energy cost for data movements than computations: quality algorithms have to minimize data movements as much as possible. 
The theoretical operational complexity of an algorithm is a function of the total number of operations that must be executed, regardless of the order in which they will actually be executed. But theoretical data movement (or, I/O) complexity is fundamentally different: one must consider all possible legal schedules of the operations to determine the minimal number of data movements achievable, a major theoretical challenge. I/O complexity has been studied via complex manual proofs, e.g., refined from $\Omega(n^3/\sqrt{S})$ for matrix-multiply on a cache size $S$ by Hong &amp;amp;#38; Kung to $2n^3/\sqrt{S}$ by Smith et al. While asymptotic complexity may be sufficient to compare I/O potential between broadly different algorithms, the accuracy of the reasoning depends on the tightness of these I/O lower bounds. Precisely, exposing constants is essential to enable precise comparison between different algorithms: for example the $2n^3/\sqrt{S}$ lower bound allows to demonstrate the optimality of panel-panel tiling for matrix-multiplication. 
\emph{We present the first static analysis to automatically derive non-asymptotic parametric expressions of data movement lower bounds with scaling constants, for arbitrary affine computations}. Our approach is fully automatic, assisting algorithm designers to reason about I/O complexity and make educated decisions about algorithmic alternatives.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Auguste</first_name>
          <last_name>Olivry</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <person_id>augusteolivry</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julien</first_name>
          <last_name>Langou</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julienlangou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Louis-Noël</first_name>
          <last_name>Pouchet</last_name>
          <affiliation>Colorado State University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/louisnoelpouchet/d72d9a63-a296-4c80-bb9e-201cf64a0294/small.jpg</picture_url>
          <person_id>louisnoelpouchet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Saday</first_name>
          <last_name>Sadayappan</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <person_id>psadayappan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Fabrice</first_name>
          <last_name>Rastello</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://team.inria.fr/corse/team-members/fabrice-rastello/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fabricerastello/5aa67b58-1ce2-4d43-b1c7-b102214c546b/small.jpg</picture_url>
          <person_id>fabricerastello</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>41454608-b2a9-4985-ab9c-e240ceff760e</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>50981510-d245-464a-86ad-dc7a9e64b654</slot_id>
      <event_id>5d69dcb0-f1ea-412a-8a82-74d531f2c6d7</event_id>
      <title>The Essence of Bluespec: A Core Language for Rule-Based Hardware Design</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:35</end_time>
      <description>The Bluespec hardware-description language presents a significantly higher-level view than hardware engineers are used to, exposing a simpler concurrency model that promotes formal proof, without compromising on performance of compiled circuits. Unfortunately, the cost model of Bluespec has been unclear, with performance details depending on a mix of user hints and opaque static analysis of potential concurrency conflicts within a design. In this paper we present Koika, a derivative of Bluespec that preserves its desirable properties and yet gives direct control over the \emph{scheduling} decisions that determine performance. Koika has a novel and deterministic operational semantics that uses dynamic analysis to avoid concurrency anomalies. Our implementation includes Coq definitions of syntax, semantics, key metatheorems, and a verified compiler to circuits. We argue that most of the extra circuitry required for dynamic analysis can be eliminated by compile-time BSV-style static analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Bourgeat</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>thomasbourgeat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Clément</first_name>
          <last_name>Pit-Claudel</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>I’m a PhD candidate at MIT, working in Adam Chlipala’s lab. My research focuses on proof assistants, extensible compilers, and programming languages; my broader interests include hardware design languages, optimization, databases, and type theory. I work on end-to-end verified compilation pipelines from high-level specifications to assembly language, verified compilers and fast simulation for rule-based hardware design languages with EHRs, and Coq tooling. And I’m applying for faculty positions this year!</bio>
          <homepage_url>http://pit-claudel.fr/clement/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/clementpitclaudel/4a4c3ccf-6680-4f0b-a87f-056c4d081fc2/small.jpg</picture_url>
          <person_id>clementpitclaudel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adam</first_name>
          <last_name>Chlipala</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Started hacking on compilers &amp;amp; web-development tools in the late 1990s. Finished CS undergrad at Carnegie Mellon in 2003 and CS PhD at Berkeley in 2007, picking up mechanized proof of executable, decently practical systems with Coq as a main focus in between. Postdoc at Harvard through 2011, then faculty at MIT since. Author of Certified Programming with Dependent Types, a popular online &amp;amp; in-print introduction to using Coq at scale. Lately into building practical but clean-slate hardware-software stacks with end-to-end Coq proofs of everything digital, at the same time as developing a startup-company idea to trick ordinary people into using dependent types (with Ur/Web) to generate their business applications.</bio>
          <homepage_url>http://adam.chlipala.net/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/adamchlipala/def72d03-2975-4c5a-a726-e8a944b77dc9/small.jpg</picture_url>
          <person_id>adamchlipala</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>undefined</first_name>
          <last_name>Arvind</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>arvind</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>59443d2c-313a-478e-8ac2-b209804019c5</slot_id>
      <event_id>43894d59-6f1c-429c-a793-3ace5507be1b</event_id>
      <title>Responsive Parallelism with Futures and State</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:20</end_time>
      <description>Motivated by the increasing shift to multicore computers, recent work has developed language support for responsive parallel applications that mix compute-intensive tasks with latency-sensitive, usually interactive, tasks. These developments include calculi that allow assigning priorities to threads, type systems that can rule out priority inversions, and accompanying cost models for predicting responsiveness. These advances share one important limitation: all of this work assumes purely functional programming. This is a significant restriction, because many realistic interactive applications, from games to robots to web servers, use mutable state, e.g., for communication between threads. 
In this paper, we lift the restriction concerning the use of state. We present $\lambda_i^4$, a calculus with implicit parallelism in the form of prioritized futures and mutable state in the form of references. Because both futures and references are first-class values, $\lambda_i^4$ programs can exhibit complex dependencies, including interaction between threads and with the external world (users, network, etc). To reason about the responsiveness of $\lambda_i^4$ programs, we extend traditional graph-based cost models for parallelism to account for dependencies created via mutable state, and we present a type system to outlaw priority inversions that can lead to unbounded blocking. We show that these techniques are practical by implementing them in C++ and present an empirical evaluation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefan K.</first_name>
          <last_name>Muller</last_name>
          <affiliation>Illinois Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.iit.edu/~smuller/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefankmuller/db0c31ad-55ec-4010-948d-d405e6483cde/small.jpg</picture_url>
          <person_id>stefankmuller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kyle</first_name>
          <last_name>Singer</last_name>
          <affiliation>Washington University in St. Louis, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/kylesinger/f1f462b8-279e-492d-aba1-6490429a7eeb/small.jpg</picture_url>
          <person_id>kylesinger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Noah</first_name>
          <last_name>Goldstein</last_name>
          <affiliation>Washington University in St. Louis, USA</affiliation>
          <bio>undefined</bio>
          <person_id>noahgoldstein</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Umut A.</first_name>
          <last_name>Acar</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/umutacar/645140f1-714c-4def-ab34-8c78d85a50bf/small.jpg</picture_url>
          <person_id>umutacar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Kunal</first_name>
          <last_name>Agrawal</last_name>
          <affiliation>Washington University in St. Louis, USA</affiliation>
          <bio>undefined</bio>
          <person_id>kunalagrawal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>I-Ting Angelina</first_name>
          <last_name>Lee</last_name>
          <affiliation>Washington University in St. Louis, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.wustl.edu/~angelee/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/itingangelinalee/00a1b413-75df-4051-b7ad-c3a5842e8ab9/small.jpg</picture_url>
          <person_id>itingangelinalee</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9ea85798-50f7-4713-9184-382b7a67040f</slot_id>
      <event_id>366d35dc-942b-47d8-8265-57ac4d99f64a</event_id>
      <title>Semantic Code Search via Equational Reasoning</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:50</end_time>
      <description>We present a new approach to semantic code search based on equational reasoning, and the Yogo tool implementing this approach. Our approach works by considering not only the dataflow graph of a function, but also the dataflow graphs of all equivalent functions reachable via a set of rewrite rules. In doing so, it can recognize an operation even if it uses alternate APIs, is in a different but mathematically-equivalent form, is split apart with temporary variables, or is interleaved with other code. Furthermore, it can recognize when code is an instance of some higher-level concept such as iterating through a file. Because of this, from a single query, Yogo can find equivalent code in multiple languages. Our evaluation further shows the utility of Yogo beyond code search: encoding a buggy pattern as a Yogo query, we found a bug in Oracle’s Graal compiler which had been missed by a hand-written static analyzer designed for that exact kind of bug. Yogo is built on the Cubix multi-language infrastructure, and currently supports Java and Python.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Varot</first_name>
          <last_name>Premtoon</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>varotpremtoon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>Koppel</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.jameskoppel.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jameskoppel/f035f7b6-1f8a-4de8-874c-79b850c2a779/small.jpg</picture_url>
          <person_id>jameskoppel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Armando</first_name>
          <last_name>Solar-Lezama</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Armando Solar-Lezama is an associate professor at MIT where he leads the Computer Aided Programming Group. His research interests include software synthesis and its applications in diverse areas such as high-performance computing, information flow security and probabilistic programming.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/armandosolarlezama/7befe52d-6968-4786-9841-408800f80c71/small.jpg</picture_url>
          <person_id>armandosolarlezama</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7cd88ad6-8e45-4cf7-8103-ae56f2eda722</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>728106df-1db1-45e0-8fdf-ac7149eecf99</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>20:10</start_time>
      <end_time>20:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b80a683c-963c-4205-bb76-eae079164712</slot_id>
      <event_id>8b936996-b682-4e46-81de-1cb37374102b</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>20:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>20:40</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1ba05941-2dce-4e4b-8579-d5eaf5314474</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>c9cd3065-ad91-4084-b1c2-1f4108017fe6</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>15:10</start_time>
      <end_time>15:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5c897077-779c-4c17-a7bf-8b35f438fe73</slot_id>
      <event_id>ce035f8b-dab1-460c-a041-9554203ee618</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>15:10</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>15:40</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cc2763d8-8575-40b0-a417-37e5e7fd632d</subevent_id>
    <title>SPLASH SIGPLAN Papers: OOPSLA and Onward! 2020 Papers 2</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>510c9da7-51b8-45e7-8649-90589644457c</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - OOPSLA and Onward! 2020 Papers 2</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Coblenz</last_name>
          <affiliation>University of Maryland at College Park</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umd.edu/~mcoblenz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcoblenz/aa74b306-529b-44d4-987f-a5e4fd6d3ca2/small.jpg</picture_url>
          <person_id>michaelcoblenz</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>47230911-0cda-457a-bc85-4eb73f8428d6</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8beb9ec6-a3d3-4f76-b8d8-70d0db1c4590</slot_id>
      <event_id>3e4d4392-b927-476a-8548-8e90e3372d98</event_id>
      <submission_id>286</submission_id>
      <title>Pomsets with Preconditions: A Simple Model of Relaxed Memory</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:20</end_time>
      <description>Relaxed memory models must simultaneously achieve efficient implementability and thread-compositional reasoning. Is that why they have become so complicated? We argue that the answer is no: It is possible to achieve these goals by combining an idea from the 60s (preconditions) with an idea from the 80s (pomsets), at least for X64 and ARMv8. We show that the resulting model (1) supports compositional reasoning for temporal safety properties, (2) supports all reasonable sequential compiler optimizations, (3) satisfies the DRF-SC criterion, and (4) compiles to X64 and ARMv8 microprocessors without requiring extra fences on relaxed accesses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Radha</first_name>
          <last_name>Jagadeesan</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
          <person_id>radhajagadeesan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alan</first_name>
          <last_name>Jeffrey</last_name>
          <affiliation>Roblox</affiliation>
          <bio>Software Engineer at Roblox, working on gradual typing and type inference for the Luau programming language.</bio>
          <homepage_url>http://asaj.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alanjeffrey1/85292841-a6a7-416c-8808-fc36002bf1bd/small.jpg</picture_url>
          <person_id>alanjeffrey1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Riely</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesriely/3e1c46e0-9695-4c0f-aa5e-63f6577a3720/small.jpg</picture_url>
          <person_id>jamesriely</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8ef95b5a-5959-4949-a35a-4d0d66932460</slot_id>
      <event_id>72bc5829-c8cb-4bda-9b42-09147bcb08ab</event_id>
      <submission_id>675</submission_id>
      <title>Koord: a language for programming and verifying distributed robotics applications</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:35</end_time>
      <description>A robot’s code needs to sense the environment, control the hardware, and communicate with other robots. Cur- rent programming languages do not provide the necessary hardware platform-independent abstractions, and therefore, developing robot applications require detailed knowledge of signal processing, control, path plan- ning, network protocols, and various platform-specific details. Further, porting applications across hardware platforms becomes tedious. We present Koord—a domain specific language for distributed robotics—which abstracts platform-specific functions for sensing, communication, and low-level control. Koord makes the platform-independent control and coordination code portable and modularly verifiable. It raises the level of abstraction in programming by providing distributed shared memory for coordination and port interfaces for sensing and control. We have developed the formal executable semantics of Koord in the K framework. With this symbolic execution engine, we can identify assumptions (proof obligations) needed for gaining high assurance from Koord applications. We illustrate the power of Koord through three applications: formation flight, distributed delivery, and distributed mapping. We also use the formation flight and distributed delivery applications to demonstrate how platform-independent proof obligations can be discharged using the Koord Prover while platform-specific proof obligations can be checked by verifying the obligations using physics-based models and hybrid verification tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ritwika</first_name>
          <last_name>Ghosh</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>ritwikaghosh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chiao</first_name>
          <last_name>Hsieh</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>chiaohsieh</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sasa</first_name>
          <last_name>Misailovic</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://misailo.cs.illinois.edu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sasamisailovic/6e3299c7-e0f5-4e78-a5f3-7ea49e488545/small.jpg</picture_url>
          <person_id>sasamisailovic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sayan</first_name>
          <last_name>Mitra</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>Sayan Mitra is a Professor of Electrical and Computer Engineering at the University of Illinois at Urbana-Champaign. His research interests are in formal verification, autonomous systems, and robotics. He holds a PhD from MIT, MSc from the Indian Institute of Science, Bangalore, and an undergraduate degree in Electrical Engineering from Jadavpur University, Kolkata. He was a postdoctoral fellow at the Center for Mathematics of Information of CalTech, and held visiting faculty positions at Oxford University and Kirtland Air Force Research Laboratory. Sayan received the National Science Foundation’s CAREER Award in 2011, AFOSR Young Investigator Research Program Award in 2012, IEEE-HKN C. Holmes MacDonald Outstanding Teaching Award (2013), a RiSE Fellowship from TU Vienna, and several best paper awards.</bio>
          <homepage_url>http://mitras.ece.illinois.edu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sayanmitra/62982710-8e2c-4be7-98f8-068227c8a067/small.jpg</picture_url>
          <person_id>sayanmitra</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>be15501e-5886-4f06-b86a-f8387d135728</slot_id>
      <event_id>e2ce6b38-f65e-4b51-8b17-c477f9e5245c</event_id>
      <submission_id>304</submission_id>
      <title>Programming and Reasoning with Partial Observability</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:05</end_time>
      <description>Computer programs are increasingly being deployed in partially-observable environments. A partially observable environment is an environment whose state is not completely visible to the program, but from which the program receives partial information in the form of observations. Developers typically deal with partial observability by writing a state estimator that, given observations, attempts to deduce the hidden state of the environment. In safety-critical domains, to formally verify safety properties developers may write an environment model. The model captures the relationship between observations and hidden states and is used to prove the software correct. 
In this paper, we present a new methodology for writing and verifying programs in partially observable environments. We present belief programming, a programming methodology where developers write an environment model that the program runtime automatically uses to perform state estimation. A belief program dynamically updates and queries a belief state that captures the possible states the environment could be in. To enable verification, we present epistemic Hoare logic that reasons about the possible belief states of a belief program the same way that classical Hoare logic reasons about the possible states of a program. We develop these concepts by defining a semantics and a program logic for a simple core language called BLIMP. In a case study, we show how belief programming could be used to write and verify a controller for the Mars Polar Lander in BLIMP.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d5d49426-f52d-4267-b279-fb8e34ea5663</slot_id>
      <event_id>deed14e8-741f-421b-89c1-18c5a1596228</event_id>
      <title>Demystifying Dependence</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/20</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:50</end_time>
      <description>Programmers are told “depend on interfaces, not implementations.” But, given a program, is it possible even to assess objectively whether such advice has been followed? 
Programmers frequently talk in ways like this about dependence, but the very term, like many used in software engineering, has hitherto eluded precise definition. In this work, we resolve a variety of confusions about dependence, and present a formal definition unifying multiple varieties of software dependence, grounded in Halpern and Pearl’s theory of actual causation. This definition is parameterized by the formal system characterizing the property of interest, and by constraints on “reasonable changes” to the program. By picking different choices of formal system, one can specialize our definition to characterize several notions of dependence, including build, correctness, and performance dependences. Overall, our work provides a path to making conversations about software dependence fully objective, and might serve as a basis for future work that automatically checks forms of dependence that were previously too abstract or high-level to be candidates for tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Koppel</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.jameskoppel.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jameskoppel/f035f7b6-1f8a-4de8-874c-79b850c2a779/small.jpg</picture_url>
          <person_id>jameskoppel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Jackson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/dnj/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danieljackson/af0a2e34-3659-427b-849e-054c1508ff9e/small.jpg</picture_url>
          <person_id>danieljackson</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4e296277-ea6c-4a71-8e9b-112d83fe5b34</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2021 Papers 4</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>8a57f9e4-0fcf-4906-ba24-7de7065a8113</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2021 Papers 4</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>169f96a1-ff99-4149-ad87-08f9df717353</slot_id>
      <event_id>69c80d5e-4a47-4aff-92c5-b752b120ae6f</event_id>
      <submission_id>337</submission_id>
      <title>SPPL: A Probabilistic Programming System with Exact and Scalable Symbolic Inference</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:35</end_time>
      <description>We present the Sum-Product Probabilistic Language (SPPL), a new system that automatically delivers exact solutions to a broad range of probabilistic inference queries. SPPL uses a new class of symbolic expressions to represent the distribution on execution traces of a probabilistic program that generalize sum-product networks by handling mixed-type distributions, numeric transformations, logical formulas, and pointwise and set-valued constraints. We formalize SPPL in terms of a novel translation strategy from probabilistic programs to sum-product expressions and present new and sound algorithms for exactly conditioning on and computing probabilities of events. We present new techniques for improving the scalability of translation and inference by automatically exploiting conditional independences and repeated structure in SPPL programs. We implement a prototype of SPPL with a modular architecture and evaluate it on a suite of benchmarks that the system is designed to solve, which establish that SPPL is up to 3500x faster than state-of-the-art systems for fairness verification; up to 1000x faster than state-of-the-art symbolic algebra techniques; and can compute exact probabilities of rare events in milliseconds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Feras</first_name>
          <last_name>Saad</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsaad.mit.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ferassaad/b74984fe-f070-4ab4-a808-a34ad2982d6f/small.jpg</picture_url>
          <person_id>ferassaad</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin C.</first_name>
          <last_name>Rinard</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.csail.mit.edu/rinard/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinrinard/cc4278df-192e-490f-87e5-a0649c420584/small.jpg</picture_url>
          <person_id>martinrinard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vikash K.</first_name>
          <last_name>Mansinghka</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>vikashmansinghka1</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1a7054e9-7793-4ed4-ad84-8cf5bff2102e</slot_id>
      <event_id>88f04613-2e4f-4d20-b0f1-57778d79d7e6</event_id>
      <title>Cyclic Program Synthesis</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:50</end_time>
      <description>We describe the first approach to automatically synthesizing heap-manipulating programs with auxiliary recursive procedures. Such procedures occur routinely in data structure transformations (e.g., flattening a tree into a list) or traversals of composite structures (e.g., n-ary trees). Our approach, dubbed cyclic program synthesis, enhances deductive program synthesis with a novel application of cyclic proofs. Specifically, we observe that the machinery used to form cycles in cyclic proofs can be reused to systematically and efficiently abduce recursive auxiliary procedures. 
We develop the theory of cyclic program synthesis by extending Synthetic Separation Logic (SSL), a logical framework for deductive synthesis of heap-manipulating programs from Separation Logic specifications. We implement our approach as a tool called Cypress, and showcase it by automatically synthesizing a number of programs manipulating linked data structures using recursive auxiliary procedures and mutual recursion, many of which were beyond the reach of existing program synthesis tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shachar</first_name>
          <last_name>Itzhaky</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~shachari</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shacharitzhaky/649d5921-4057-4ac3-8fc7-75471ee8527b/small.jpg</picture_url>
          <person_id>shacharitzhaky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.technion.ac.il/~hilap</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of 2020 Intel Rising Stars Award and the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Reuben N. S.</first_name>
          <last_name>Rowe</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>BA Cambridge University (Fitzwilliam) 2001-2004 MSc/PhD Imperial College London, 2007-2012 Teaching Fellow, Imperial College London, 2012-2014 Postdoc, University College London, 2014-2016 Postdoc, University of Kent, 2016-2019 Lecturer, Royal Holloway, 2019-</bio>
          <homepage_url>https://www.cs.kent.ac.uk/people/staff/rnsr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/reubennsrowe/33d179dc-b2b1-42f6-8d09-a2bf6bdd60c6/small.jpg</picture_url>
          <person_id>reubennsrowe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ilya</first_name>
          <last_name>Sergey</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>I am a tenured Associate Professor at National University of Singapore and Yale-NUS College. I do research in programming language design and implementation, software verification, distributed systems, program synthesis and repair. I am the recipient of the AITO Dahl-Nygaard Junior Prize 2019. I designed and co-developed Scilla, a programming language for safe smart contracts, used by Zilliqa. I organised the ICFP Programming Contest 2019. 
Before moving to Singapore, I was a faculty at University College London in 2015-2018. Prior to that, I was a postdoc at IMDEA Software Institute. I hold a PhD in Computer Science from KU Leuven, and an MSc in mathematics from St Petersburg University. Before joining academia I worked as a software engineer at JetBrains.</bio>
          <homepage_url>http://ilyasergey.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ilyasergey/b2941c89-4843-4194-852a-81c8a30814fa/small.jpg</picture_url>
          <person_id>ilyasergey</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ab69c552-c9a5-4793-9ade-26f7e4c6ce33</slot_id>
      <event_id>e986eee5-f6d7-4fd8-baeb-ec2c599c71b6</event_id>
      <submission_id>853</submission_id>
      <title>On Probabilistic Termination of Functional Programs with Continuous Distributions</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:20</end_time>
      <description>We study termination of higher-order probabilistic functional programs with recursion, stochastic conditioning and sampling from continuous distributions. 
Reasoning about the termination probability of programs with continuous distributions is hard, because the enumeration of terminating executions cannot provide any non-trivial bounds. We present a new operational semantics based on traces of intervals, which is sound and complete with respect to the standard sampling-based semantics, in which (countable) enumeration can provide arbitrarily tight lower bounds. Consequently we obtain the first proof that deciding almost-sure termination (AST) for programs with continuous distributions is $\Pi^0_2$-complete. We also provide a compositional representation of our semantics in terms of an intersection type system. 
In the second part, we present a method of proving AST for non-affine programs, i.e., recursive programs that can, during the evaluation of the recursive body, make multiple recursive calls (of a first-order function) from distinct call sites. Unlike in a deterministic language, the number of recursion call sites has direct consequences on the termination probability. Our framework supports a proof system that can verify AST for programs that are well beyond the scope of existing methods. 
We have constructed prototype implementations of our method of computing lower bounds of termination probability, and AST verification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raven</first_name>
          <last_name>Beutner</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <person_id>ravenbeutner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>C.-H. Luke</first_name>
          <last_name>Ong</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/luke.ong/personal</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lukeong/c257d95e-8eb2-4f79-a47b-c6c31c4a4db4/small.jpg</picture_url>
          <person_id>lukeong</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ae0150bf-b799-45d9-8d6a-0e251d5ec77d</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f06b9549-e666-4263-ab09-418946d7611b</slot_id>
      <event_id>47b14b22-75f2-4b34-b637-a94e5222130d</event_id>
      <submission_id>166</submission_id>
      <title>Compiling Stan to Generative Probabilistic Languages and Extension to Deep Probabilistic Programming</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:05</end_time>
      <description>Stan is a probabilistic programming language that is popular in the statistics community, with a high-level syntax for expressing probabilistic models. Stan differs by nature from generative probabilistic programming languages like Church, Anglican, or Pyro. This paper presents a comprehensive compilation scheme to compile any Stan model to a generative language and proves its correctness. 
We use our compilation scheme to build two new backends for the Stanc3 compiler targeting Pyro and NumPyro. Experimental results show that the NumPyro backend yields a 3.7x speedup in geometric mean compared to Stan on 27 existing benchmarks. 
Building on Pyro we extend Stan with support for explicit variational inference guides and deep probabilistic models. That way, users familiar with Stan get access to new features without having to learn a fundamentally new language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Baudart</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <person_id>guillaumebaudart1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Javier</first_name>
          <last_name>Burroni</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/javierburroni/dc65c155-74c5-40ce-b81f-e638faeff433/small.jpg</picture_url>
          <person_id>javierburroni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Hirzel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hirzels.com/martin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinhirzel/8ffffeeb-b25c-4f90-b2e3-4949c2871a2a/small.jpg</picture_url>
          <person_id>martinhirzel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Avraham</first_name>
          <last_name>Shinnar</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <person_id>avrahamshinnar</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>36496a6f-9639-409e-ba51-85d115e590c7</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/17</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>845324be-9931-4a15-a88f-b78805dab716</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>10:20</start_time>
      <end_time>10:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2fab9413-3dce-430f-9de0-432e7bd1fbfe</slot_id>
      <event_id>02db72ea-7f9f-4447-a330-0107c6748b8a</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:50</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4dc23d63-37d3-47ce-ab7d-24bb7572acbb</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>d61e0efd-49e3-4d85-9cad-6ba5dcdc3545</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>20:10</start_time>
      <end_time>20:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f8b5a6fd-5584-44e2-9875-ae6527bf563a</slot_id>
      <event_id>63aacc51-66c4-4c49-9a3d-188916fc2919</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>20:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>20:40</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d73ad546-c2b7-4829-9d5b-94c5fa36d0c4</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>ad72a27a-28b6-4194-9692-a0c7cfd851f6</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>10:20</start_time>
      <end_time>10:50</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Paulette</first_name>
          <last_name>Koronkevich</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://koronkevi.ch</homepage_url>
          <person_id>paulettekoronkevich</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d5467bc9-e13e-4972-9086-5c7a1c3c89a5</slot_id>
      <event_id>7fee4c9c-0d73-4675-9379-4add4d1c57bb</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>10:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>10:50</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a2eb2603-3f45-4583-ad54-e1aaa1403067</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/17</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>f8b6b730-4488-4e58-ad15-d80aa4df4efd</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>20:10</start_time>
      <end_time>20:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4a9bc79-b0b6-4b3b-8217-ddd389249d5f</slot_id>
      <event_id>1f36c585-a7a7-45b6-9293-3e19877da623</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>20:10</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>20:40</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1a20a341-5615-406f-bf12-bae72e8fabce</subevent_id>
    <title>SPLASH SIGPLAN Papers: ICFP 2020 Papers</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>89cc4f6b-ce66-4a9f-b8f3-bc5b5cad14d8</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - ICFP 2020 Papers</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Stefan K.</first_name>
          <last_name>Muller</last_name>
          <affiliation>Illinois Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.iit.edu/~smuller/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefankmuller/db0c31ad-55ec-4010-948d-d405e6483cde/small.jpg</picture_url>
          <person_id>stefankmuller</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>45bffb55-9788-4104-8594-4171bd548c38</slot_id>
      <event_id>31f15d44-24f8-43b8-a197-500c0327e88a</event_id>
      <submission_id>icfp20main-p104-p</submission_id>
      <title>Program Sketching with Live Bidirectional Evaluation</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:35</end_time>
      <description>We present a system called Smyth for program sketching in a typed functional language whereby the concrete evaluation of ordinary assertions gives rise to input-output examples, which are then used to guide the search to complete the holes. The key innovation, called live bidirectional evaluation, propagates examples "backward" through partially evaluated sketches. Live bidirectional evaluation enables Smyth to (a) synthesize recursive functions without trace-complete sets of examples and (b) specify and solve interdependent synthesis goals. Eliminating the trace-completeness requirement resolves a significant limitation faced by prior synthesis techniques when given partial specifications in the form of input-output examples. 
To assess the practical implications of our techniques, we ran several experiments on benchmarks used to evaluate Myth, a state-of-the-art example-based synthesis tool. First, given expert examples (and no partial implementations), we find that Smyth requires on average 66% of the number of expert examples required by Myth. Second, we find that Smyth is robust to randomly-generated examples, synthesizing many tasks with relatively few more random examples than those provided by an expert. Third, we create a suite of small sketching tasks by systematically employing a simple sketching strategy to the Myth benchmarks; we find that user-provided sketches in Smyth often further reduce the total specification burden (i.e. the combination of partial implementations and examples). Lastly, we find that Leon and Synquid, two state-of-the-art logic-based synthesis tools, fail to complete several tasks on which Smyth succeeds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Justin</first_name>
          <last_name>Lubin</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jlubin.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/justinlubin1/20ea84ad-9355-48d7-924c-af6d84fdb568/small.jpg</picture_url>
          <person_id>justinlubin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nick</first_name>
          <last_name>Collins</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>undefined</bio>
          <person_id>nickcollins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Omar</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>https://fplab.mplse.org/</bio>
          <homepage_url>https://web.eecs.umich.edu/~comar</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/cyrusomar/6f85cfe7-5130-42cf-9976-450725051201/small.jpg</picture_url>
          <person_id>cyrusomar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ravi</first_name>
          <last_name>Chugh</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>Associate Professor at the University of Chicago, longing for more user-friendly programming languages and more programmable user interfaces</bio>
          <homepage_url>http://people.cs.uchicago.edu/~rchugh</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ravichugh/2d96c4d6-6a97-418a-870b-b217c5ad5401/small.jpg</picture_url>
          <person_id>ravichugh</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b2f5d200-4868-4cb0-a1bf-0c23c75f627b</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dac796d2-6e1e-489f-8cee-67d7f0627e56</slot_id>
      <event_id>15d2cc8c-7389-41fa-9ce3-ec96ee968493</event_id>
      <submission_id>icfp20main-p7-p</submission_id>
      <title>Denotational Recurrence Extraction for Amortized Analysis</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:20</end_time>
      <description>A typical way of analyzing the time complexity of functional programs is to extract a recurrence expressing the running time of the program in terms of the size of its input, and then to solve the recurrence to obtain a big-O bound. For recurrence extraction to be compositional, it is also necessary to extract recurrences for the size of outputs of helper functions. Previous work has developed techniques for using logical relations to state a formal correctness theorem for a general recurrence extraction translation: a program is bounded by a recurrence when the operational cost is bounded by the extracted cost, and the output value is bounded, according to a value bounding relation defined by induction on types, by the extracted size. This previous work supports higher-order functions by viewing recurrences as programs in a lambda-calculus, or as mathematical entities in a denotational semantics thereof. In this paper, we extend these techniques to support amortized analysis, where costs are rearranged from one portion of a program to another to achieve more precise bounds. We give an intermediate language in which programs can be annotated according to the banker's method of amortized analysis; this language has an affine type system to ensure credits are not spent more than once. We give a recurrence extraction translation of this language into a recurrence language, a simply-typed lambda-calculus with a cost type, and state and prove a bounding logical relation expressing the correctness of this translation. The recurrence language has a denotational semantics in preorders, and we use this semantics to solve recurrences, e.g analyzing binary counters and splay trees.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joseph W.</first_name>
          <last_name>Cutler</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cis.upenn.edu/~jwc</homepage_url>
          <person_id>josephwcutler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dan</first_name>
          <last_name>Licata</last_name>
          <affiliation>Wesleyan University</affiliation>
          <bio>I am an assistant professor at Wesleyan University. I received my PhD from Carnegie Mellon University in 2011, and was a postdoc at the Institute for Advanced Study in 2012-2013.</bio>
          <homepage_url>http://dlicata.web.wesleyan.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danlicata/0b1942ed-7b74-4b6b-b624-03ded7f26a62/small.jpg</picture_url>
          <person_id>danlicata</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Norman</first_name>
          <last_name>Danner</last_name>
          <affiliation>Wesleyan University</affiliation>
          <bio>undefined</bio>
          <person_id>normandanner</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f1a5c5dc-a06a-47e2-bf00-fb8121ee42e6</slot_id>
      <event_id>296dae82-e37b-40dd-9cf5-68d4f84b5e78</event_id>
      <title>Liquid Information Flow Control</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:50</end_time>
      <description>We present Lifty, a domain-specific language for data-centric applications that manipulate sensitive data. A Lifty programmer annotates the sources of sensitive data with declarative security policies, and the language statically and automatically verifies that the application handles the data according to the policies. Moreover, if verification fails, Lifty suggests a provably correct repair, thereby easing the programmer burden of implementing policy enforcing code throughout the application. 
The main insight behind Lifty is to encode information flow control using liquid types, an expressive yet decidable type system. Liquid types enable fully automatic checking of complex, data dependent policies, and power our repair mechanism via type-driven error localization and patch synthesis. Our experience using Lifty to implement three case studies from the literature shows that (1) the Lifty policy language is sufficiently expressive to specify many real-world policies, (2) the Lifty type checker is able to verify secure programs and find leaks in insecure programs quickly, and (3) even if the programmer leaves out all policy enforcing code, the Lifty repair engine is able to patch all leaks automatically within a reasonable time.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of 2020 Intel Rising Stars Award and the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Deian</first_name>
          <last_name>Stefan</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~dstefan/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/deianstefan/55e73d29-9671-4740-9ef2-3b45f485fc24/small.jpg</picture_url>
          <person_id>deianstefan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean</first_name>
          <last_name>Yang</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>jeanyang@csail.mit.edu </homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeanyang/728ddfd8-02f1-426b-9006-87ba458c369f/small.jpg</picture_url>
          <person_id>jeanyang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Shachar</first_name>
          <last_name>Itzhaky</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~shachari</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shacharitzhaky/649d5921-4057-4ac3-8fc7-75471ee8527b/small.jpg</picture_url>
          <person_id>shacharitzhaky</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Travis</first_name>
          <last_name>Hance</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>travishance1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Armando</first_name>
          <last_name>Solar-Lezama</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Armando Solar-Lezama is an associate professor at MIT where he leads the Computer Aided Programming Group. His research interests include software synthesis and its applications in diverse areas such as high-performance computing, information flow security and probabilistic programming.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/armandosolarlezama/7befe52d-6968-4786-9841-408800f80c71/small.jpg</picture_url>
          <person_id>armandosolarlezama</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fd59d852-5270-42a9-95e2-234b68308b7f</slot_id>
      <event_id>2766c230-ddb4-4cb5-b03a-2dedcef1e8e3</event_id>
      <submission_id>icfp20main-p5-p</submission_id>
      <title>A General Approach to Define Binders using Matching Logic</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:05</end_time>
      <description>We propose a novel definition of binders using matching logic, where the binding behavior of object-level binders is directly inherited from the built-in exists binder of matching logic. We show that the behavior of binders in various logical systems such as lambda-calculus, System F, pi-calculus, pure type systems, can be axiomatically defined in matching logic as notations and logical theories. We show the correctness of our definitions by proving conservative extension theorems, which state that a sequent/judgment is provable in the original system if and only if it is provable in matching logic, in the corresponding theory. Our matching logic definition of binders also yields models to all binders, which are deductively complete with respect to formal reasoning in the original systems. For lambda-calculus, we further show that the yielded models are representationally complete, a desired property that is not enjoyed by many existing lambda-calculus semantics. This work is part of a larger effort to develop a logical foundation for the programming language semantics framework K (http://kframework.org).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaohong</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/~xchen</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaohongchen1/e982c014-9fda-495c-93d6-b5fdc8158320/small.jpg</picture_url>
          <person_id>xiaohongchen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Grigore</first_name>
          <last_name>Roşu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/index.php/Grigore_Rosu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/grigorerosu/5b147c13-0a15-45fe-bbf0-3ce641260478/small.jpg</picture_url>
          <person_id>grigorerosu</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1bf45ed3-5deb-4f5f-a1e6-62e291e02ef8</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2021 Papers 5</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>aec54e3f-d029-4fe5-8a36-7484e2df1df9</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2021 Papers 5</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Feras</first_name>
          <last_name>Saad</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsaad.mit.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ferassaad/b74984fe-f070-4ab4-a808-a34ad2982d6f/small.jpg</picture_url>
          <person_id>ferassaad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5e3a5e4b-c145-4b2e-8091-f88ed7649981</slot_id>
      <event_id>5759aea9-c9ab-452b-a4a6-733a2dd07329</event_id>
      <submission_id>249</submission_id>
      <title>Symbolic Boolean Derivatives for Efficiently Solving Extended Regular Expression Constraints</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:35</end_time>
      <description>The manipulation of raw string data is ubiquitous in security-critical software, and verification of such software relies on efficiently solving string and regular expression constraints via SMT. However, the typical case of Boolean combinations of regular expression constraints exposes blowup in existing techniques. To address solvability of such constraints, we propose a new theory of derivatives of symbolic extended regular expressions (extended meaning that complement and intersection are incorporated), and show how to apply this theory to obtain more efficient decision procedures. Our implementation of these ideas, built on top of Z3, matches or outperforms state-of-the-art solvers on standard and handwritten benchmarks, showing particular benefits on examples with Boolean combinations. 
Our work is the first formalization of derivatives of regular expressions which both handles intersection and complement and works symbolically over an arbitrary character theory. It unifies existing approaches involving derivatives of extended regular expressions, alternating automata and Boolean automata by lifting them to a common symbolic platform. It relies on a parsimonious augmentation of regular expressions: a construct for symbolic conditionals is shown to be sufficient to obtain relevant closure properties for derivatives over extended regular expressions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Caleb</first_name>
          <last_name>Stanford</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cis.upenn.edu/~castan/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/calebstanford/ecc7c13b-42ab-49e9-a867-dd26542ae449/small.jpg</picture_url>
          <person_id>calebstanford</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Margus</first_name>
          <last_name>Veanes</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/margusveanes/a5174253-0401-46f7-aff1-e92a3a3ace77/small.jpg</picture_url>
          <person_id>margusveanes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nikolaj</first_name>
          <last_name>Bjørner</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/nikolajbjrner/63324744-c6ad-450e-b412-3472986a6ca0/small.jpg</picture_url>
          <person_id>nikolajbjrner</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>601b2b92-8931-4138-99d7-e8b19f6e8cdf</slot_id>
      <event_id>ba7fc024-d6b8-4ba2-8214-c9e5972f224b</event_id>
      <submission_id>25</submission_id>
      <title>Repairing Serializability Bugs in Distributed Database Programs via Automated Schema Refactoring</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:05</end_time>
      <description>Serializability is a well-understood concurrency control mechanism that eases reasoning about highly-concurrent database programs. Unfortunately, enforcing serializability has a high performance cost, especially on geographically distributed database clusters. Consequently, many databases allow programmers to choose when a transaction must be executed under serializability, with the expectation that transactions would only be so marked when necessary to avoid serious concurrency bugs. However, this is a significant burden to impose on developers, requiring them to (a) reason about subtle concurrent interactions among potentially interfering transactions, (b) determine when such interactions would violate desired invariants, and (c) then identify the minimum number of transactions whose executions should be serialized to prevent these violations. To mitigate this burden, this paper presents a sound fully-automated schema refactoring procedure that refactors a program’s data layout – rather than its concurrency control logic – to eliminate statically identified concurrency bugs, allowing more transactions to be safely executed under weaker and more performant database guarantees. Experimental results over a range of realistic database benchmarks indicate that our approach is highly effective in eliminating concurrency bugs, with safe refactored programs showing an average of 120% higher throughput and 45% lower latency compared to a serialized baseline.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kia</first_name>
          <last_name>Rahmani</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am a PhD candidate of computer science at Purdue University. I am a member of the programming languages group, working under the supervision of Professor Suresh Jagannathan and Professor Benjamin Delaware. 
My PhD thesis is focused around compilation, synthesis, and testing of modern database-backed programs. More broadly, I am interested in all formal methods for modeling and analysis of (classical or quantum) computer programs. 
I was previously a research intern at Microsoft, working on a new program synthesis technique based on pre-trained language models. My work was supervised by Dr. Mohammad Raza and Dr. Sumit Gulwani.</bio>
          <homepage_url>https://kiarahmani.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kiarahmani/745190a9-35f0-49e9-b5a9-f8831bce9162/small.jpg</picture_url>
          <person_id>kiarahmani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kartik</first_name>
          <last_name>Nagar</last_name>
          <affiliation>IIT Madras</affiliation>
          <bio>undefined</bio>
          <person_id>kartiknagar1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Delaware</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/bendy/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benjamindelaware/39bbf6b3-d145-435c-8956-8acf8cfcaffa/small.jpg</picture_url>
          <person_id>benjamindelaware</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Suresh</first_name>
          <last_name>Jagannathan</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/suresh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sureshjagannathan/70e51299-573f-4211-a895-b2028c19c585/small.jpg</picture_url>
          <person_id>sureshjagannathan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b1bb01a6-1e59-465b-9387-67c8c3e6368c</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b3822e0a-546a-48aa-89ef-d3b1559a441a</slot_id>
      <event_id>bb08d2d8-7696-45ce-925a-a534dae46006</event_id>
      <submission_id>174</submission_id>
      <title>Filling Typed Holes with Live GUIs</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:50</end_time>
      <description>Although text editing is powerful, some types of expressions are more naturally represented and manipulated graphically. This paper introduces live literals, or livelits, which allow clients to fill holes of these types by directly manipulating a provider-defined GUI embedded persistently into otherwise symbolic code. Uniquely, livelits are compositional: the GUI can itself contain spliced expressions, which have full editor support and can in turn contain other livelits. Splices are typed and the system ensures that livelits treat splices hygienically. Livelits are also uniquely live: they can offer immediate feedback about the run-time implications of the client’s choices even when splices mention bound variables, because the system continuously gathers closures associated with the hole that the livelit is tasked with filling. This paper introduces livelits with case studies that exercise these novel capabilities. We implement livelits in Hazel, a live programming environment able to typecheck and run programs with holes. We then define a typed lambda calculus that captures the essence of livelits as live graphical macros. The macro expansion process has been mechanized in Agda.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Omar</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>https://fplab.mplse.org/</bio>
          <homepage_url>https://web.eecs.umich.edu/~comar</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/cyrusomar/6f85cfe7-5130-42cf-9976-450725051201/small.jpg</picture_url>
          <person_id>cyrusomar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Moon</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidmoon/07fbf417-4cfe-4fd0-93b2-05c3dbeb61ec/small.jpg</picture_url>
          <person_id>davidmoon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Blinn</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://andrewblinn.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/andrewblinn1/28b227e5-162d-4b3e-913d-39d8506402f8/small.jpg</picture_url>
          <person_id>andrewblinn1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ian</first_name>
          <last_name>Voysey</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~iev</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ianvoysey/74b47e65-ac6a-44b1-94cb-217c6fecdeb5/small.jpg</picture_url>
          <person_id>ianvoysey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nick</first_name>
          <last_name>Collins</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>undefined</bio>
          <person_id>nickcollins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Ravi</first_name>
          <last_name>Chugh</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>Associate Professor at the University of Chicago, longing for more user-friendly programming languages and more programmable user interfaces</bio>
          <homepage_url>http://people.cs.uchicago.edu/~rchugh</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ravichugh/2d96c4d6-6a97-418a-870b-b217c5ad5401/small.jpg</picture_url>
          <person_id>ravichugh</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e052cb9b-a4f8-4f8b-b204-0880b4132cda</slot_id>
      <event_id>dbc12cea-10ed-407c-9f83-0d9fa6119085</event_id>
      <submission_id>299</submission_id>
      <title>Scooter &amp; Sidecar: A domain-specific approach to writing secure migrations</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/22</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:20</end_time>
      <description>Web applications often handle large amounts of sensitive user data. Modern secure web frameworks protect this data by (1) using declarative languages to specify security policies alongside database schemas and (2) automatically enforcing these policies at runtime. Unfortunately, these frameworks do not handle the very common situation in which the schemas or the policies need to evolve over time—and updates to schemas and policies need to be performed in a carefully coordinated way. Mistakes during schema or policy migrations can unintentionally leak sensitive data or introduce privilege escalation bugs. In this work, we present a domain-specific language (Scooter) for expressing schema and policy migrations, and an associated SMT-based verifier (Sidecar) which ensures that migrations are secure as the application evolves. We describe the design of Scooter and Sidecar and show that our framework can be used to express realistic schemas, policies, and migrations, without giving up on runtime or verification performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Renner</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnrenner/ee473e3c-537b-4d92-afc9-8cb18e611337/small.jpg</picture_url>
          <person_id>johnrenner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alex</first_name>
          <last_name>Sanchez-Stern</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/~alexss/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexsanchezstern/8f8df577-1227-40b6-86e8-2b553ee0c66d/small.jpg</picture_url>
          <person_id>alexsanchezstern</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fraser</first_name>
          <last_name>Brown</last_name>
          <affiliation>Stanford University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/fraserbrown/bbe0a77f-703c-4bc8-bd43-4fac9c0a93b1/small.jpg</picture_url>
          <person_id>fraserbrown</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sorin</first_name>
          <last_name>Lerner</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/users/lerner/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sorinlerner/3d3b1a70-e2f8-4d3a-a1bc-9c4e17dad80b/small.jpg</picture_url>
          <person_id>sorinlerner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Deian</first_name>
          <last_name>Stefan</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~dstefan/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/deianstefan/55e73d29-9671-4740-9ef2-3b45f485fc24/small.jpg</picture_url>
          <person_id>deianstefan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5b755f5c-b324-4bb0-82a0-0f2a207f550e</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2021 Papers 3</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>ba6b7ca6-8d90-4a9e-a5c2-7c61a698f817</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2021 Papers 3</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18a55322-731a-4a94-9d4f-65f1d6ddf760</slot_id>
      <event_id>b5a23572-33f6-4325-abeb-9044c22287b6</event_id>
      <submission_id>244</submission_id>
      <title>Integration Verification Across Software and Hardware for a Simple Embedded System</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>16:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:25</end_time>
      <description>The interfaces between layers of a system are susceptible to bugs if developers of adjacent layers proceed under subtly different assumptions. Formal verification of two layers against the same formal model of the interface between them can be used to shake out these bugs. Doing so for every interface in the system can, in principle, yield unparalleled assurance of the correctness and security of the system as a whole. However, there have been remarkably few efforts that carry out this exercise, and all of them have simplified the task by restricting interactivity of the application, inventing new simplified instruction sets, and using unrealistic input and output mechanisms. We report on the first verification of a realistic embedded system, with its application software, device drivers, compiler, and RISC-V processor represented inside the Coq proof assistant as one mathematical object, with a machine-checked proof of functional correctness. A key challenge is structuring the proof modularly, so that further refinement of the components or expansion of the system can proceed without revisiting the rest of the system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andres</first_name>
          <last_name>Erbsen</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/andreserbsen/31e6ebcb-eb52-4e58-bdbc-34cfbf74952e/small.jpg</picture_url>
          <person_id>andreserbsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Samuel</first_name>
          <last_name>Gruetter</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/samgruetter/6a0b8f86-7d75-4dee-8238-fc3f483b8edd/small.jpg</picture_url>
          <person_id>samgruetter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Joonwon</first_name>
          <last_name>Choi</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://joonwon.net/c</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/joonwonchoi/e47297a8-182a-4ed5-99ab-0c070f982299/small.jpg</picture_url>
          <person_id>joonwonchoi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Clark</first_name>
          <last_name>Wood</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>clarkwood</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Adam</first_name>
          <last_name>Chlipala</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Started hacking on compilers &amp;amp; web-development tools in the late 1990s. Finished CS undergrad at Carnegie Mellon in 2003 and CS PhD at Berkeley in 2007, picking up mechanized proof of executable, decently practical systems with Coq as a main focus in between. Postdoc at Harvard through 2011, then faculty at MIT since. Author of Certified Programming with Dependent Types, a popular online &amp;amp; in-print introduction to using Coq at scale. Lately into building practical but clean-slate hardware-software stacks with end-to-end Coq proofs of everything digital, at the same time as developing a startup-company idea to trick ordinary people into using dependent types (with Ur/Web) to generate their business applications.</bio>
          <homepage_url>http://adam.chlipala.net/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/adamchlipala/def72d03-2975-4c5a-a726-e8a944b77dc9/small.jpg</picture_url>
          <person_id>adamchlipala</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>35402944-f107-4d1b-8539-f12b42196ba4</slot_id>
      <event_id>9c1e1ce9-514f-4879-9a20-f5ec85774d13</event_id>
      <submission_id>363</submission_id>
      <title>Automatically Enforcing Fresh and Consistent Inputs in Intermittent Systems</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:55</end_time>
      <description>Intermittently powered energy-harvesting devices enable new applications in inaccessible environments. Program executions must be robust to unpredictable power failures, introducing new challenges in programmability and correctness. One hard problem is that input operations have implicit constraints, embedded in the behavior of continuously powered executions, on when input values can be collected and used. We identify two key properties—freshness (i.e., uses of inputs must satisfy the same time constraints as in continuous executions) and temporal consistency (i.e., the collection of a set of inputs must satisfy the same time constraints as in continuous executions). We show that these properties can be enforced using atomic regions. We develop Ocelot, an LLVM-based analysis and transformation tool targeting Rust, to automatically enforce these properties. Ocelot provides the programmer with annotations to express these constraints and infers atomic region placement in a program to satisfy them. We formalize these properties and Ocelot’s design and show that Ocelot enables correct execution at little performance cost and low programmer effort.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milijana</first_name>
          <last_name>Surbatovich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>milijanasurbatovich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Limin</first_name>
          <last_name>Jia</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.andrew.cmu.edu/user/liminjia/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/liminjia/6bc50ee1-2333-4b59-bc4f-3bf74d1e3b64/small.jpg</picture_url>
          <person_id>liminjia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brandon</first_name>
          <last_name>Lucia</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://brandonlucia.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/brandonlucia/16fdd4eb-8f38-4c24-b29c-fa7ed8a15fb8/small.jpg</picture_url>
          <person_id>brandonlucia</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>70d252fe-7827-41c8-9359-6f60b5969da7</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>abb8512f-7ef1-49f9-a022-5d62e3dba28e</slot_id>
      <event_id>bcf40f70-def3-4d71-b41e-9ae586b0b12f</event_id>
      <submission_id>618</submission_id>
      <title>Execution reconstruction: Harnessing failure reoccurrences for failure reproduction</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>16:25</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:40</end_time>
      <description>Reproducing production failures is crucial for software reliability. Alas, existing bug reproduction systems do not simultaneously provide properties such as efficiency, effectiveness, and accuracy for production uses. In this work, we argue this is because existing approaches over-prioritize a subset of these properties, which hurts the remaining properties. 
We propose Execution Reconstruction (ER), a technique that strikes a good balance between efficiency, effectiveness and accuracy for reproducing production failures. ER uses hardware-assisted control and data tracing to shepherd symbolic execution and reproduce failures. As a key novelty, ER continuously analyzes the constraints generated by symbolic execution to identify constraint solving bottlenecks and steer runtime recording accordingly to reproduce failures. 
ER reproduces failures in executions that are more than two orders of magnitude longer than what the state-of-the-art production failure reproduction systems can handle. Unlike any production failure reproduction system we are aware of, ER can reproduce fully replayable executions that can power a variety of debugging and reliabilty use cases. ER incurs on average 0.3% (up to 1.1%) runtime monitoring overhead for a broad range of real-world systems, making itpractical for real-world deployment.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gefei</first_name>
          <last_name>Zuo</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <person_id>gefeizuo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jiacheng</first_name>
          <last_name>Ma</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <person_id>jiachengma1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Quinn</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>undefined</bio>
          <person_id>andrewquinn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Pramod</first_name>
          <last_name>Bhatotia</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/pbhatoti/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/pramodbhatotia/ec5f1655-1bc6-4194-aee7-c66a8332e516/small.jpg</picture_url>
          <person_id>pramodbhatotia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Pedro</first_name>
          <last_name>Fonseca</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>pedrofonseca</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Baris</first_name>
          <last_name>Kasikci</last_name>
          <affiliation>University of Michigan, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/bariskasikci/5cddda04-d175-4a54-8b16-ee1938e4885d/small.jpg</picture_url>
          <person_id>bariskasikci</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e80be6ad-5a4a-43fb-b6e4-77df55b589b2</slot_id>
      <event_id>8b16b550-72bf-4b35-aa21-8d02458d1a64</event_id>
      <submission_id>650</submission_id>
      <title>IOOpt- Automatic Derivation of I/O complexity bounds for affine programs</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>15:55</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:10</end_time>
      <description>Evaluating the complexity of an algorithm is an important step when developing applications as it highly impact both its time and energy performance. The arithmetic complexity which is the number of operations, regardless of the execution order, is, for neural networks (or more generally affine programs), easy to characterize. The data-movement (or, I/O) complexity characterization is way more complex as it refers to the minimum required number of I/O between a slow (e.g. main memory) and a fast (e.g. local scratchpad) storage location when considering all possible valid schedules. 
This paper presents \IOOpt, a fully automated tool that automatically bounds the data movement of an affine (tilable) program. Given a tilable program described in a DSL, it automatically computes: 1.~a lower bound of the I/O complexity as a symbolic expression of the cache size and program parameters; 2.~an upper bound that allows to assess the tightness of the lower bound; 3.~a tiling recommendation (loop permutation and tile’s sizes) that matches the upper bound. While the associated algorithms for computing lower bound (and the associated implementations) that are described in this paper can be applied to any affine programs, a substantial effort has been made to provide bounds that are as tight as possible for neural networks. In particular, it extends the previous work of Olivry et al. so as to handle multi-dimensional reductions and expose the constraints associated to small dimensions that are both present in convolutions. As for the upper bound algorithm, if the input can be a general tilable affine program (e.g. output of a polyhedral compiler such as PluTo), the involved algebraic computations are tuned to behave well on tensor computations such as direct tensor contractions or direct convolutions. As a bonus, the upper bound algorithm that has been extended to multi-level cache can provide a useful tiling recommendation to the programmer. 
We demonstrate the effectiveness of our tool by deriving the symbolic lower and upper bounds for several tensor contraction and convolution kernels. Then, we evaluate numerically the tightness of our bound using Yolo9000 convolution layer sizes and representative tensor contractions from the TCCG benchmark suite. Finally, we show the pertinence of our I/O complexity model by reporting the run-time of the recommended tiled code for the convolution layers from Yolo9000.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Auguste</first_name>
          <last_name>Olivry</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <person_id>augusteolivry</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Iooss</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <person_id>guillaumeiooss</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Tollenaere</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <person_id>nicolastollenaere</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Atanas</first_name>
          <last_name>Rountev</last_name>
          <affiliation>Ohio State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ohio-state.edu/~rountev</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/atanasrountev/57ea0ee0-eebe-48f0-91fe-1ed3a28b5d92/small.jpg</picture_url>
          <person_id>atanasrountev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Saday</first_name>
          <last_name>Sadayappan</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
          <person_id>psadayappan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Fabrice</first_name>
          <last_name>Rastello</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://team.inria.fr/corse/team-members/fabrice-rastello/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fabricerastello/5aa67b58-1ce2-4d43-b1c7-b102214c546b/small.jpg</picture_url>
          <person_id>fabricerastello</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fa007ee4-8cc8-4578-a2f1-712e82ab381e</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2021, PLDI 2020, and OOPSLA 2020 Papers 1</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>a30f0bae-e35e-4c9d-aa87-1ccbcb8509a0</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2021, PLDI 2020, and OOPSLA 2020 Papers 1</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Koppel</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.jameskoppel.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jameskoppel/f035f7b6-1f8a-4de8-874c-79b850c2a779/small.jpg</picture_url>
          <person_id>jameskoppel</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0e927f4c-ba2d-4fe5-a92c-3413f41ee4f9</slot_id>
      <event_id>c039b113-8d8d-4924-844c-4d00bc24d92d</event_id>
      <submission_id>599</submission_id>
      <title>Example-Guided Synthesis of Relational Queries</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:05</end_time>
      <description>Program synthesis tasks are commonly specified via input-output examples. Existing techniques for such tasks are primarily guided by program syntax and only make indirect use of the examples. We present a new approach called example-guided synthesis, or EGS, which exploits data patterns in the examples to construct the desired program. We demonstrate EGS for the synthesis of relational queries and evaluate it on 86 tasks from three application domains: knowledge discovery, program analysis, and database querying. Our evaluation shows that EGS outperforms state-of-the-art synthesizers based on enumerative search, constraint solving, and hybrid techniques in terms of synthesis time, quality of synthesized programs, and ability to prove unrealizability.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aalok</first_name>
          <last_name>Thakkar</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <person_id>aalokthakkar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aaditya</first_name>
          <last_name>Naik</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <person_id>aadityanaik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nathaniel</first_name>
          <last_name>Sands</last_name>
          <affiliation>University of Southern California</affiliation>
          <bio>undefined</bio>
          <person_id>nathanielsands</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Mukund</first_name>
          <last_name>Raghothaman</last_name>
          <affiliation>University of Southern California</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://r-mukund.github.io</homepage_url>
          <person_id>mukundraghothaman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mayur</first_name>
          <last_name>Naik</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.seas.upenn.edu/~mhnaik/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mayurnaik/681e8d43-e5b6-4a09-a8a5-11053f830db6/small.jpg</picture_url>
          <person_id>mayurnaik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Rajeev</first_name>
          <last_name>Alur</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~alur/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rajeevalur/3b3a4dca-8d4b-4db9-9986-376b2352a264/small.jpg</picture_url>
          <person_id>rajeevalur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>96908754-ff89-4d1b-9176-510782231d75</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b04b0f2c-c02f-4e64-adff-2a0837a4fc21</slot_id>
      <event_id>ba8a4a58-19f2-460f-8f54-3af24617738f</event_id>
      <title>Reactive Probabilistic Programming</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:35</end_time>
      <description>Synchronous modeling is at the heart of programming languages like Lustre, Esterel, or Scade used routinely for implementing safety critical control software, e.g., fly-by-wire and engine control in planes. However, to date these languages have had limited modern support for modeling uncertainty — probabilistic aspects of the software's environment or behavior — even though modeling uncertainty is a primary activity when designing a control system. 
In this paper we present ProbZelus the first synchronous probabilistic programming language. ProbZelus conservatively provides the facilities of a synchronous language to write control software, with probabilistic constructs to model uncertainties and perform inference-in-the-loop. 
We present the design and implementation of the language. We propose a measure-theoretic semantics of probabilistic stream functions and a simple type discipline to separate deterministic and probabilistic expressions. We demonstrate a semantics-preserving compilation into a first-order functional language that lends itself to a simple presentation of inference algorithms for streaming models. We also redesign the delayed sampling inference algorithm to provide efficient streaming inference. Together with an evaluation on several reactive applications, our results demonstrate that ProbZelus enables the design of reactive probabilistic applications and efficient, bounded memory inference.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Baudart</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://guillaume.baudart.eu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guillaumebaudart/0ef21d31-ea41-4cfc-8df8-a62b2f483c64/small.jpg</picture_url>
          <person_id>guillaumebaudart</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Sherman</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ben-sherman.net</homepage_url>
          <person_id>benjaminsherman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Marc</first_name>
          <last_name>Pouzet</last_name>
          <affiliation>École normale supérieure</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.ens.fr/~pouzet</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marcpouzet/c783c4e5-a8e9-491d-9534-7a5e138e6a39/small.jpg</picture_url>
          <person_id>marcpouzet</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2988127-ddf6-4069-9497-d1509177103c</slot_id>
      <event_id>0a97a00b-29f7-420a-9275-2d100ec5a606</event_id>
      <submission_id>121</submission_id>
      <title>Web Question Answering with Neurosymbolic Program Synthesis</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:20</end_time>
      <description>In this paper, we propose a new technique based on program synthesis for extracting information from webpages. Given a natural language query and a few labeled webpages, our method synthesizes a program that can be used to extract similar types of information from other unlabeled webpages. To handle websites with diverse structure, our approach employs a neurosymbolic DSL that incorporates both neural NLP models as well as standard language constructs for tree navigation and string manipulation. We also propose an optimal synthesis algorithm that generates all DSL programs that achieve optimal $F_1$ score on the training examples. Our synthesis technique is compositional, prunes the search space by exploiting a monotonicity property of the DSL, and uses self-supervision to select programs with good generalization power. We have implemented these ideas in a new tool called WebQA and evaluate it on 25 different tasks across multiple domains. Our experiments show that WebQA significantly outperforms existing tools such as state-of-the-art question answering models and wrapper induction systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qiaochu</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>qiaochuchen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Lamoreaux</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>aaronlamoreaux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xinyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>I’m an assistant professor in the Computer Science and Engineering Department at the University of Michigan, Ann Arbor.</bio>
          <homepage_url>https://web.eecs.umich.edu/~xwangsd/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xinyuwang/ccbe37b1-293c-4205-8386-295e20bce0d7/small.jpg</picture_url>
          <person_id>xinyuwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Greg</first_name>
          <last_name>Durrett</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>gregdurrett</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Osbert</first_name>
          <last_name>Bastani</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://obastani.github.io</homepage_url>
          <person_id>osbertbastani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
          <person_id>isildillig</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ccd83cd6-0d8f-4235-82de-81daed882cc6</slot_id>
      <event_id>439d0e01-844a-4ab2-b493-0fc5220f4dcb</event_id>
      <submission_id>119</submission_id>
      <title>A Sparse Iteration Space Transformation Framework for Sparse Tensor Algebra</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/21</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:50</end_time>
      <description>We address the problem of optimizing sparse tensor algebra in a compiler and show how to define standard loop transformations (such as splitting, collapsing, and reordering) for sparse iteration spaces. The key idea is that these transformations map sparse iteration spaces into \textit{derived} iteration spaces. This results in a new iteration order that respects the constraints inherent in sparse data structures. We further demonstrate that derived iteration spaces can be used to tile over both the indexes (coordinates) and the nonzeros; the former is equivalent to tiling dense iteration spaces, while the latter tiles sparse iteration spaces into statically load-balanced blocks of nonzeros. Tiling the space of nonzeros lets the compiler efficiently exploit heterogeneous compute resources such as threads, vector units, and GPUs. 
We implemented these concepts and an associated scheduling API on top of the open-source TACO system. The scheduling API can be used manually by performance engineers or be the target of an automatic scheduling system. We outline a heuristics-based autoscheduling system in this paper, but many other systems are possible and enabled by our API. Using the scheduling API, we show how to optimize sparse and mixed sparse-dense tensor algebra expressions on both CPUs and GPUs. Our results show that the sparse transformations are sufficient to generate code with competitive performance to hand-optimized implementations from the literature, while generalizing to all of the tensor algebra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Senanayake</last_name>
          <affiliation>Reservoir Labs</affiliation>
          <bio>undefined</bio>
          <person_id>ryansenanayake</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Changwan</first_name>
          <last_name>Hong</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>changwanhong2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ziheng</first_name>
          <last_name>Wang</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>zihengwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Amalee</first_name>
          <last_name>Wilson</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>amaleewilson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Shoaib</first_name>
          <last_name>Kamil</last_name>
          <affiliation>Adobe Research</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/shoaibkamil/2bc60aee-bda5-437e-9e74-e00f5a55c9ef/small.jpg</picture_url>
          <person_id>shoaibkamil</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>samanamarsinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7c9aacb5-2322-4b11-a6d0-95615a1d6c2a</subevent_id>
    <title>SPLASH SIGPLAN Papers: SLE and DLS 2020</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich G</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>f03dab73-d93b-4402-89b4-1ddb9433d134</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - SLE and DLS 2020</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Riely</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesriely/3e1c46e0-9695-4c0f-aa5e-63f6577a3720/small.jpg</picture_url>
          <person_id>jamesriely</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cf6785a3-a044-4528-9a99-ea9de10812ba</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d769844f-d94f-4555-8714-16be40765345</slot_id>
      <event_id>1455e7bd-8900-4e9d-8b8e-9b87fa22a5e9</event_id>
      <title>Python 3 Types in the Wild: A Tale of Two Type Systems</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:35</end_time>
      <description>Python 3 is a highly dynamic language, but it has introduced a syntax for expressing types with PEP484. This paper explores how developers use these type annotations, the type system semantics provided by type checking and inference tools, and the performance of these tools. We evaluate the types and tools on a corpus of public GitHub repositories. We review MyPy and PyType, two canonical static type checking and inference tools, and their distinct approaches to type analysis. We then address three research questions: (i) How often and in what ways do developers use Python 3 types? (ii) Which type errors do developers make? (iii) How do type errors from different tools compare? 
Surprisingly, when developers use static types, the code rarely type-checks with either of the tools. MyPy and PyType exhibit false positives, due to their static nature, but also flag many useful errors in our corpus. Lastly, MyPy and PyType embody two distinct type systems, flagging different errors in many cases. Understanding the usage of Python types can help guide tool-builders and researchers. Understanding the performance of popular tools can help increase the adoption of static types and tools by practitioners, ultimately leading to more correct and more robust Python code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ingkarat</first_name>
          <last_name>Rak-amnouykit</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <person_id>ingkaratrakamnouykit</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>McCrevan</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <person_id>danielmccrevan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ana</first_name>
          <last_name>Milanova</last_name>
          <affiliation>Rensselaer Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.rpi.edu/~milanova/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/anamilanova/4fa9038c-d0e6-44ca-b1b7-2420329714f4/small.jpg</picture_url>
          <person_id>anamilanova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Martin</first_name>
          <last_name>Hirzel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hirzels.com/martin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinhirzel/8ffffeeb-b25c-4f90-b2e3-4949c2871a2a/small.jpg</picture_url>
          <person_id>martinhirzel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
          <person_id>juliandolby</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dba9d88e-0968-4b9b-8d6c-db3ed3b11b99</slot_id>
      <event_id>81ccef4d-def2-49ff-91df-e565d0aabb4d</event_id>
      <title>Untangling mechanized proofs</title>
      <room>Swissotel Chicago | Zurich G</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:05</end_time>
      <description>Proof assistants like Coq, Lean, or HOL4 rely heavily on stateful meta-programs called scripts to assemble proofs. Unlike pen-and-paper proofs, proof scripts only describe the steps to take (induct on x, apply a theorem, …), not the states that these steps lead to; as a result, plain proof scripts are essentially incomprehensible without the assistance of an interactive user interface able to run the script and show the corresponding proof states. 
Until now, the standard process to communicate a proof without forcing readers to execute its script was to manually copy-paste intermediate proof states into the script, as source code comments — a tedious and error-prone exercise. Additional prose (such as for a book or tutorial) was likewise embedded in comments, preserving executability at the cost of a mediocre text-editing experience. 
This paper describes a new approach to the development and dissemination of literate proof scripts, with a focus on the Coq proof assistant. Specifically, we describe two contributions: a compiler that interleaves Coq’s output with the original proof script to produce interactive webpages that are complete, self-contained presentations of Coq proofs; and a new literate programming toolkit that allows authors to switch seamlessly between prose- and code-oriented views of the same sources, by translating back and forth between reStructuredText documents and literate Coq source files. In combination, these tools offer a new way to write, communicate, and preserve proofs, combining the flexibility of procedural proof scripts and the intelligibility of declarative proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Clément</first_name>
          <last_name>Pit-Claudel</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>I’m a PhD candidate at MIT, working in Adam Chlipala’s lab. My research focuses on proof assistants, extensible compilers, and programming languages; my broader interests include hardware design languages, optimization, databases, and type theory. I work on end-to-end verified compilation pipelines from high-level specifications to assembly language, verified compilers and fast simulation for rule-based hardware design languages with EHRs, and Coq tooling. And I’m applying for faculty positions this year!</bio>
          <homepage_url>http://pit-claudel.fr/clement/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/clementpitclaudel/4a4c3ccf-6680-4f0b-a87f-056c4d081fc2/small.jpg</picture_url>
          <person_id>clementpitclaudel</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7835b3e0-b9cb-4310-8e40-4fbe5951dec2</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/17</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>9bbfc574-f9a7-4ff3-992e-a600b2fa663c</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>15:10</start_time>
      <end_time>15:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cf03a868-dd1b-4a99-9093-b0f6e50a53e4</slot_id>
      <event_id>1427f8bb-7742-4935-82cf-ae8794966ba5</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/17</date>
      <start_time>15:10</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>15:40</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fe2cfb10-2e6f-4c92-8207-682bee41843a</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>750dcd8d-5db3-41ea-8d09-2f78c9243002</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>15:10</start_time>
      <end_time>15:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2f13f6b2-601d-4099-990e-b5148f5578c2</slot_id>
      <event_id>2b68ac11-de3a-4514-9aab-1d569dc4be5c</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>15:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>15:40</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a1aeb248-f730-43a1-b350-8bfac771cc46</subevent_id>
    <title>SPLASH SIGPLAN Papers: OOPSLA 2020 Papers 4</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>20f259bb-b992-4f48-945d-546a9acdbac3</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - OOPSLA 2020 Papers 4</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Clément</first_name>
          <last_name>Pit-Claudel</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>I’m a PhD candidate at MIT, working in Adam Chlipala’s lab. My research focuses on proof assistants, extensible compilers, and programming languages; my broader interests include hardware design languages, optimization, databases, and type theory. I work on end-to-end verified compilation pipelines from high-level specifications to assembly language, verified compilers and fast simulation for rule-based hardware design languages with EHRs, and Coq tooling. And I’m applying for faculty positions this year!</bio>
          <homepage_url>http://pit-claudel.fr/clement/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/clementpitclaudel/4a4c3ccf-6680-4f0b-a87f-056c4d081fc2/small.jpg</picture_url>
          <person_id>clementpitclaudel</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>563371f3-6b70-456d-a3d1-ebd5bf2ed689</slot_id>
      <event_id>8a697ca3-0fe2-459e-88d0-2dc6969bd0ee</event_id>
      <submission_id>96</submission_id>
      <title>DiffStream: Differential Output Testing for Stream Processing Programs</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:05</end_time>
      <description>High performance architectures for processing distributed data streams, such as Flink, Spark, and Storm, are increasingly deployed in emerging data-driven computing systems. Exploiting the parallelism afforded by such platforms, while preserving the semantics of the desired computation, is prone to errors, and motivates the development of tools for specification, testing, and verification. We focus on the problem of differential output testing for distributed stream processing systems, that is, checking whether two implementations produce equivalent output streams in response to a given input stream. The notion of equivalence allows reordering of logically independent data items, and the main technical contribution of the paper is an optimal online algorithm for checking this equivalence. Our testing framework is implemented as a library called \library in Flink. We present four case studies to illustrate how our framework can be used to (1) correctly identify bugs in a set of benchmark MapReduce programs, (2) facilitate the development of difficult-to-parallelize high performance applications, and (3) monitor an application for a long period of time using minimal computational resources.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Kallas</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://angelhof.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/konstantinoskallas/532ec21f-35f9-482a-afc9-d7c8b7118a65/small.jpg</picture_url>
          <person_id>konstantinoskallas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://fniksic.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/filipniksic/404f7660-8944-48cb-b97d-7b25a191367c/small.jpg</picture_url>
          <person_id>filipniksic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Caleb</first_name>
          <last_name>Stanford</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cis.upenn.edu/~castan/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/calebstanford/ecc7c13b-42ab-49e9-a867-dd26542ae449/small.jpg</picture_url>
          <person_id>calebstanford</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rajeev</first_name>
          <last_name>Alur</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~alur/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rajeevalur/3b3a4dca-8d4b-4db9-9986-376b2352a264/small.jpg</picture_url>
          <person_id>rajeevalur</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>650d332d-b3e1-447b-bab9-5c07108837fa</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a4dc7a98-c7bb-4c43-b243-6052b5315866</slot_id>
      <event_id>fa613957-c680-4b57-b5f6-2ba3b3c3910b</event_id>
      <submission_id>480</submission_id>
      <title>Regex Matching with Counting-Set Automata</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:35</end_time>
      <description>We propose a solution to the problem of efficient matching regular expressions (regexes) with bounded repetition, such as $\mathtt{(ab){1,100}}$, using deterministic automata. For this, we introduce novel \emph{counting set automata (CsAs)}, automata with registers that can hold sets of bounded integers and can be manipulated by a limited portfolio of constant-time operations. We present an algorithm that compiles a large sub-class of regexes to deterministic CsAs. This includes (1) a novel Antimirov-style translation of regexes with counting to \emph{counting automata (CAs)}, nondeterministic automata with bounded counters, and (2) our main technical contribution, a determinization of CAs that outputs CsAs. The main advantage of this workflow is that the size of the produced CsAs does not depend on the repetition bounds used in the regex (while the size of the DFA is exponential to them). Our experimental results confirm that deterministic CsAs produced from practical regexes with repetition are indeed vastly smaller than the corresponding DFAs. More importantly, our prototype matcher based on CsA simulation handles practical regexes with repetition regardless of sizes of counter bounds. It easily copes with regexes with repetition where state-of-the-art matchers struggle.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukáš</first_name>
          <last_name>Holík</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lukasholik</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lengál</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>Ph.D. (2015) Brno University of Technology</bio>
          <homepage_url>http://www.fit.vutbr.cz/~lengal</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ondrejlengal/3f99d935-777e-4b43-9494-5cfc0fe8894b/small.jpg</picture_url>
          <person_id>ondrejlengal</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Olli</first_name>
          <last_name>Saarikivi</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/ollisaarikivi2/3e6d3eb8-2ea9-456c-9c3d-76fe37bd855c/small.jpg</picture_url>
          <person_id>ollisaarikivi2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lenka</first_name>
          <last_name>Turoňová</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>lenkatoronova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Margus</first_name>
          <last_name>Veanes</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/margusveanes/a5174253-0401-46f7-aff1-e92a3a3ace77/small.jpg</picture_url>
          <person_id>margusveanes</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tomáš</first_name>
          <last_name>Vojnar</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fit.vutbr.cz/~vojnar</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomasvojnar/6b1ea9ee-acf7-413d-be4d-431c460af426/small.jpg</picture_url>
          <person_id>tomasvojnar</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c6f11027-4d3d-402b-97cb-ef02b89d6d04</slot_id>
      <event_id>e2b697be-04ac-4b14-adc9-8b9725358b0d</event_id>
      <submission_id>80</submission_id>
      <title>Guided Linking: Dynamic Linking Without the Costs</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:20</end_time>
      <description>Dynamic linking is extremely common in modern software systems, thanks to the flexibility and space savings it offers. However, this flexibility comes at a cost: every library call has an extra layer of indirection, and it’s impossible to perform interprocedural optimizations that involve calls to a dynamic library. The basic problem is that the run-time behavior of the dynamic linker can’t be predicted at compile time, so the compiler can make no assumptions about how external calls will behave. 
This paper introduces guided linking, a technique for optimizing dynamically linked software when some information about the dynamic linker’s behavior is known in advance. The developer provides an arbitrary set of programs, libraries, and plugins to our tool, along with constraints that limit the possible dynamic linking behavior of the software. Given a software set and a list of constraints, our tool takes advantage of the constraints to optimize the software for speed and size. For example, the “no dynamic redefinitions” constraint can be applied to a function when the developer knows the function will never be unexpectedly overridden with a different definition at run time; this constraint allows dynamic references between libraries in the set to be resolved to static references, which can then be optimized with standard link-time optimizations. As an additional optimization, we deduplicate identical functions that appear anywhere in the software set. 
By applying guided linking to a dynamically linked distribution of Clang and LLVM, and using the constraint that no other software will use the LLVM libraries, we can increase speed by 6% and reduce file size by 11%. If we relax the constraint to allow other software to use the LLVM libraries, we can still increase speed by 5.5% and reduce file size by 3%. If we apply guided linking to the Python interpreter and a set of loadable Python modules, applying the constraint that no other programs or modules will be used, we can increase speed by an average of 6.6%. If we use guided linking to combine 11 different versions of the Boost library, applying minimal constraints, we can reduce the total library size by 57%.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sean</first_name>
          <last_name>Bartell</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/seanbartell/89708f48-99e9-4d26-ab38-f63e749c298b/small.jpg</picture_url>
          <person_id>seanbartell</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Will</first_name>
          <last_name>Dietz</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wdtz.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/willdietz/f5b6948e-d200-44b1-ba05-8d21549414f8/small.jpg</picture_url>
          <person_id>willdietz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vikram S.</first_name>
          <last_name>Adve</last_name>
          <affiliation>University of Illinois at Urbana-Champaign, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://vikram.cs.illinois.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vikramadve/35b054ac-a4c0-4aef-a0b7-70b5234fbda8/small.jpg</picture_url>
          <person_id>vikramadve</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1427512d-5ca4-47b5-a201-c82a1cf44e2d</subevent_id>
    <title>SPLASH SIGPLAN Papers: OOPSLA 2020 Papers 5</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich E</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>e7337a09-be54-4585-84ba-adff4f99538b</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - OOPSLA 2020 Papers 5</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Yao</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lastland.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yaoli/ac58cfa1-acf7-454b-a4fc-cbdf519f65fb/small.jpg</picture_url>
          <person_id>yaoli</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>086bcd83-4658-4918-aaf9-f5103e38fdc0</slot_id>
      <event_id>a48af140-c6dd-4af5-892a-69f685efa99d</event_id>
      <submission_id>141</submission_id>
      <title>Compiling Symbolic Execution with Staging and Algebraic Effects</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:35</end_time>
      <description>Building effective symbolic execution engines is challenging in multiple dimensions: an engine must \emph{correctly} model the program semantics, provide \emph{flexibility} in terms of various symbolic execution strategies, and execute these strategies \emph{efficiently}. 
This paper proposes a principled approach to building \emph{correct}, \emph{flexible}, and \emph{efficient} symbolic execution engines, directly rooted in the semantics of the underlying language expressed as a high-level definitional interpreter. Starting from this definitional interpreter, we use algebraic effects to model the semantics of symbolic execution, e.g., collecting path conditions as a state effect, and exploring multiple paths as a nondeterminism effect. Different handlers of these effects give rise to different symbolic execution strategies which make execution strategies orthogonal to the symbolic semantics, thus improving flexibility. Furthermore, by annotating the symbolic definitional interpreter with binding-times and specializing it to the input program via the first Futamura projection, we obtain a ``symbolic compiler,'' generating efficient code that is instrumented with the symbolic execution semantics. This staging approach reconciles the interpretation- and instrumentation-based approaches to building symbolic execution engines in a uniform framework. 
We illustrate the approach for a simple imperative language step-by-step, and then scale up to a significant subset of LLVM IR. We also show effect handlers for a number of common path selection strategies. We evaluate the performance of our prototype and compare with KLEE, showing that the compiled symbolic execution is an order of magnitude faster than the pure interpretation-based counterpart, as well as being on par with KLEE on single execution path traversal.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guannan</first_name>
          <last_name>Wei</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://continuation.passing.style</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guannanwei/e1971b4b-ebd3-429b-b28c-0c2cfb0f0289/small.jpg</picture_url>
          <person_id>guannanwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Bračevac</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://bracevac.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/oliverbracevac/17c0ac71-a156-4868-8df9-d4ae4cd669e7/small.jpg</picture_url>
          <person_id>oliverbracevac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shangyin</first_name>
          <last_name>Tan</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/shangyintan/05c3151d-071e-451a-9863-639fc66108ca/small.jpg</picture_url>
          <person_id>shangyintan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1fcda129-a0a2-46e6-b7ff-a649fc33bbc6</slot_id>
      <event_id>a4868989-67f1-4ae4-915e-0ff8d0bbd08d</event_id>
      <submission_id>605</submission_id>
      <title>Gradual Verification of Recursive Heap Data Structures</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:05</end_time>
      <description>Current static verification techniques do not provide good support for incrementality, making it difficult for developers to focus their limited effort on specifying and verifying the properties and components that are most important. Dynamic verification approaches support incrementality, but cannot provide static guarantees. To bridge this gap, prior work proposed gradual verification, which supports incrementality by allowing every assertion to be complete, partial, or omitted, and provides sound verification that smoothly scales from dynamic to static checking. The prior approach to gradual verification, however, was limited to toy programs without recursive data structures. This paper extends gradual verification to realistic programs that manipulate recursive, mutable data structures on the heap. We solve key technical challenges, semantically connecting iso- and equi-recursive interpretations of abstract predicates as well as gradual verification of heap ownership. Our work thus lays the foundation for future tools that work on realistic programs and support verification within an engineering process in which cost-benefit trade-offs can be made.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jenna</first_name>
          <last_name>Wise</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~jlwise/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jennawise/614a00d0-d8ab-4b2f-8ec7-96abcb5c3d5b/small.jpg</picture_url>
          <person_id>jennawise</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Bader</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.johannes-bader.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johannesbader/0b7e635c-fba7-4113-a53d-4451edd44ca5/small.jpg</picture_url>
          <person_id>johannesbader</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cameron</first_name>
          <last_name>Wong</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>Wannabe type theorist.</bio>
          <homepage_url>https://camdar.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/cameronwong/1e4412d3-e79b-4f6a-8465-6b756986e1d0/small.jpg</picture_url>
          <person_id>cameronwong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Sunshine</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>I am a Senior Research Fellow in the Institute for Software Research at Carnegie Mellon University. I have broad research interests at the intersection of programming languages and human-computer interaction. I am particularly interested in better understanding of the factors that influence the usability of reusable software components.</bio>
          <homepage_url>http://www.cs.cmu.edu/~jssunshi/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/joshuasunshine/474067e5-86e8-476c-9622-5c89be145f4b/small.jpg</picture_url>
          <person_id>joshuasunshine</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>421aca2e-efb6-46c2-a6e2-bc413be7d349</slot_id>
      <event_id>73dd1774-0e95-40c6-b867-d06562e4cda9</event_id>
      <submission_id>65</submission_id>
      <title>Formulog: Datalog for SMT-based Static Analysis</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:20</end_time>
      <description>Satisfiability modulo theories (SMT) solving has become a critical part of many static analyses, including symbolic execution, refinement type checking, and model checking. We propose Formulog, a domain-specific language that makes it possible to write a range of SMT-based static analyses in a way that is both close to their formal specifications and amenable to high-level optimizations and efficient evaluation. 
Formulog extends the logic programming language Datalog with a first-order functional language and mechanisms for representing and reasoning about SMT formulas; a novel type system supports the construction of expressive formulas, while ensuring that neither normal evaluation nor SMT solving goes wrong. Our case studies demonstrate that a range of SMT-based analyses can naturally and concisely be encoded in Formulog, and that — thanks to this encoding — high-level Datalog-style optimizations can be automatically and advantageously applied to these analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Bembenek</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Aaron Bembenek is currently a computer science PhD candidate at Harvard University working under Stephen Chong. He previously earned an undergraduate degree in classics from Princeton University.</bio>
          <homepage_url>http://people.seas.harvard.edu/~bembenek/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aaronbembenek/def526d3-8049-43ee-a891-2437ec903da6/small.jpg</picture_url>
          <person_id>aaronbembenek</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mgree.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chong</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>Stephen Chong is a Gordon McKay Professor of Computer Science in the Harvard John A. Paulson School of Engineering and Applied Sciences. Steve’s research focuses on programming languages, information security, and the intersection of these two areas. He is the recipient of an NSF CAREER award, an AFOSR Young Investigator award, and a Sloan Research Fellowship. He received a PhD from Cornell University, and a bachelor’s degree from Victoria University of Wellington, New Zealand.</bio>
          <homepage_url>https://people.seas.harvard.edu/~chong/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stephenchong/91e43651-bcd6-40dc-b231-4c92711b0e95/small.jpg</picture_url>
          <person_id>stephenchong</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>60b2bcae-8282-4c03-8ca7-b93f2f2165b1</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9bd5298c-327f-4196-acce-9aa4664dd9a9</slot_id>
      <event_id>588c09ed-48d8-4dff-bdd2-eadca4f32699</event_id>
      <submission_id>228</submission_id>
      <title>Automated Policy Synthesis for System Call Sandboxing</title>
      <room>Swissotel Chicago | Zurich E</room>
      <date>2021/10/22</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:50</end_time>
      <description>System call whitelisting is a powerful sandboxing approach that can significantly reduce the capabilities of an attacker if an application is compromised. Given a policy that specifies which system calls can be invoked with what arguments, a sandboxing framework terminates any execution that violates the policy. While this mechanism greatly reduces the attack surface of a system, manually constructing these policies is time-consuming and error-prone. As a result, many applications —including those that take untrusted user input— opt not to use a system call sandbox. 
Motivated by this problem, we propose a technique for automatically constructing system call whitelisting policies for a given application and policy DSL. Our method combines static code analysis and program synthesis to construct sound and precise policies that never erroneously terminate the application, while restricting the program’s system call usage as much as possible. We have implemented our approach in a tool called Abhayaand experimentally evaluate it 493 Linux and OpenBSD applications by automatically synthesizing Seccomp-bpfand Pledgepolicies. Our experimental results indicate that Abhayacan efficiently generate useful and precise sandboxes for real-world applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shankara</first_name>
          <last_name>Pailoor</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>shankarapailoor</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xinyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Michigan</affiliation>
          <bio>I’m an assistant professor in the Computer Science and Engineering Department at the University of Michigan, Ann Arbor.</bio>
          <homepage_url>https://web.eecs.umich.edu/~xwangsd/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xinyuwang/ccbe37b1-293c-4205-8386-295e20bce0d7/small.jpg</picture_url>
          <person_id>xinyuwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hovav</first_name>
          <last_name>Shacham</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>hovavshacham</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
          <person_id>isildillig</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>970fe175-25e5-4897-8f2a-198bb95a150b</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>526a1b17-13f3-4886-b858-a0769066c581</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>15:10</start_time>
      <end_time>15:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2ed18a76-15cc-4cd4-8b90-89a3bf7c9a61</slot_id>
      <event_id>537712ee-dc1b-4f78-8bb9-4746922b1661</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>15:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:40</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>11490c57-3488-4410-8a25-3d2e89464fd4</subevent_id>
    <title>SPLASH SIGPLAN Papers: PLDI 2020 Papers 3</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich F</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-recent-sigplan</url>
    <url_link_display>Recent SIGPLAN Conference Paper Presentations</url_link_display>
    <tracks>
      <track>Recent SIGPLAN Conference Paper Presentations</track>
    </tracks>
    <timeslot>
      <slot_id>5d57197e-397f-4510-810e-495d7131f6e6</slot_id>
      <title>Session: SPLASH SIGPLAN Papers - PLDI 2020 Papers 3</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Suresh</first_name>
          <last_name>Jagannathan</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/suresh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sureshjagannathan/70e51299-573f-4211-a895-b2028c19c585/small.jpg</picture_url>
          <person_id>sureshjagannathan</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>262e700b-cfb0-4d5d-9160-af8fd647923c</slot_id>
      <event_id>2d610d51-4409-4a06-be5a-71baf0e93984</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>385f21ca-90c0-40ad-a28f-4fe2d14588a3</slot_id>
      <event_id>1386bc54-3b1b-4f9b-8417-a8afe021eafb</event_id>
      <title>Synthesizing Structured CAD Models with Equality Saturation and Inverse Transformations</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>16:25</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:40</end_time>
      <description>Recent program synthesis techniques help users customize CAD models(e.g., for 3D printing) by decompiling low-level triangle meshes to Constructive Solid Geometry (CSG) expressions. Without loops or functions, editing CSG can require many coordinated changes, and existing mesh decompilers use heuristics that can obfuscate high-level structure. 
This paper proposes a second decompilation stage to robustly "shrink" unstructured CSG expressions into more editable programs with map and fold operators. We present Szalinski, a tool that uses Equality Saturation with semantics-preserving CAD rewrites to efficiently search for smaller equivalent programs. Szalinski relies on inverse transformations, a novel way for solvers to speculatively add equivalences to an E-graph. We qualitatively evaluate Szalinski in case studies, show how it composes with an existing mesh decompiler, and demonstrate that Szalinski can shrink large models in seconds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chandrakana</first_name>
          <last_name>Nandi</last_name>
          <affiliation>Certora, inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cnandi.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chandrakananandi/a90ad233-62bb-4a90-8e9d-9afd969ef245/small.jpg</picture_url>
          <person_id>chandrakananandi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Max</first_name>
          <last_name>Willsey</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.mwillsey.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/maxwillsey/ff552459-e263-42a5-b17b-1301d482943d/small.jpg</picture_url>
          <person_id>maxwillsey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adam</first_name>
          <last_name>Anderson</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <person_id>adamanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>James R.</first_name>
          <last_name>Wilcox</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>I am a lecturer in the Paul G. Allen School of Computer Science &amp;amp; Engineering at the University of Washington. My research interests are in programming languages and applications of PL techniques to systems. I also work on formal verification in industry at Certora.</bio>
          <homepage_url>https://jamesrwilcox.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamesrwilcox/92dfd071-3ff1-4a52-8f23-86215aca7f43/small.jpg</picture_url>
          <person_id>jamesrwilcox</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Eva</first_name>
          <last_name>Darulova</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mpi-sws.org/~eva/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/evadarulova/0d98744b-ec94-4a27-b1c0-0d728d54bdb7/small.jpg</picture_url>
          <person_id>evadarulova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Dan</first_name>
          <last_name>Grossman</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~djg/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dangrossman/941e0321-e962-4f03-9027-ba9f0448e7df/small.jpg</picture_url>
          <person_id>dangrossman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Tatlock</last_name>
          <affiliation>University of Washington, Seattle</affiliation>
          <bio>Associate Professor at the University of Washington</bio>
          <homepage_url>https://ztatlock.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zacharytatlock/87af1196-2d8d-4bd5-a692-018d3939a00f/small.jpg</picture_url>
          <person_id>zacharytatlock</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7707b5ce-ed6d-4a2b-b59e-de689e4fbcf1</slot_id>
      <event_id>22f0395c-ef67-4027-80a3-4216f1272ae0</event_id>
      <title>Reconciling Enumerative and Deductive Program Synthesis</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>16:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:25</end_time>
      <description>Syntax-guided synthesis (SyGuS) aims to find a program satisfying semantic specification as well as user-provided structural hypotheses. There are two main synthesis approaches: enumerative synthesis, which repeatedly enumerates possible candidate programs and checks their correctness, and deductive synthesis, which leverages a symbolic procedure to construct implementations from specifications. Neither approach is strictly better than the other: automated deductive synthesis is usually very efficient but only works for special grammars or applications; enumerative synthesis is very generally applicable but limited in scalability. 
In this paper, we propose a cooperative synthesis technique for SyGuS problems with the conditional linear integer arithmetic (CLIA) background theory, as a novel integration of the two approaches, combining the best of the two worlds. The technique exploits several novel divide-and-conquer strategies to split a large synthesis problem to smaller subproblems. The subproblems are solved separately and their solutions are combined to form a final solution. The technique integrates two synthesis engines: a pure deductive component that can efficiently solve some problems, and a height-based enumeration algorithm that can handle arbitrary grammar. We implemented the cooperative synthesis technique, and evaluated it on a wide range of benchmarks. Experiments showed that our technique can solve many challenging synthesis problems not possible before, and tends to be more scalable than state-of-the-art synthesis algorithms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kangjing</first_name>
          <last_name>Huang</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>kangjinghuang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xiaokang</first_name>
          <last_name>Qiu</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>I am an assistant professor with the School of Electrical and Computer Engineering at Purdue University.</bio>
          <homepage_url>https://engineering.purdue.edu/~xqiu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaokangqiu/be55b21e-fb5d-4540-a2c2-1110cac11fc6/small.jpg</picture_url>
          <person_id>xiaokangqiu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peiyuan</first_name>
          <last_name>Shen</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>peiyuanshen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yanjun</first_name>
          <last_name>Wang</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>yanjunwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8c63853b-05ca-4f06-a585-c413db7d7df8</slot_id>
      <event_id>2b9c125a-05d7-4740-b12a-c49da95ee7dc</event_id>
      <title>Data-Driven Inference of Representation Invariants</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>15:55</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:10</end_time>
      <description>A representation invariant is a property that holds of all values of abstract type produced by a module. Representation invariants play important roles in software engineering and program verification. In this paper, we develop a counterexample-driven algorithm for inferring a representation invariant that is sufficient to imply a desired specification for a module. The key novelty is a type-directed notion of visible inductiveness, which ensures that the algorithm makes progress toward its goal as it alternates between weakening and strengthening candidate invariants. The algorithm is parameterized by an example-based synthesis engine and a verifier, and we prove that it is sound and complete for first-order modules over finite types, assuming that the synthesizer and verifier are as well. We implement these ideas in a tool called Hanoi, which synthesizes representation invariants for recursive data types. Hanoi not only handles invariants for first-order code, but higher-order code as well. In its back end, Hanoi uses an enumerative synthesizer called Myth and an enumerative testing tool as a verifier. Because Hanoi uses testing for verification, it is not sound, though our empirical evaluation shows that it is successful on the benchmarks we investigated.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Miltner</last_name>
          <affiliation>The University of Texas at Austin, Texas, USA</affiliation>
          <bio>Postdoctoral Fellow at UT Austin. PhD from Princeton University.</bio>
          <homepage_url>https://www.cs.utexas.edu/~amiltner/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/andersmiltner1/2ea1a602-4b63-48e5-b479-32936848075f/small.jpg</picture_url>
          <person_id>andersmiltner1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Saswat</first_name>
          <last_name>Padhi</last_name>
          <affiliation>Amazon Web Services, USA</affiliation>
          <bio>I am an Applied Scientist within the Automated Reasoning Group (ARG) at AWS. I work on program verification and synthesis technologies.</bio>
          <homepage_url>https://saswat.padhi.me</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/saswatpadhi/bb633be0-bbe7-4e77-9f5b-e0c8841ae7cf/small.jpg</picture_url>
          <person_id>saswatpadhi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/toddmillstein1/a55642b6-6fa2-40f6-99ba-8b9003ee61d9/small.jpg</picture_url>
          <person_id>toddmillstein1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>David</first_name>
          <last_name>Walker</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~dpw/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidwalker/8763137a-03a5-4963-8639-e9f2a3cc8ac9/small.jpg</picture_url>
          <person_id>davidwalker</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f6e5d620-7506-46e5-9150-46402ae07c8b</slot_id>
      <event_id>222e7ceb-2f63-4135-89da-77264de73a2d</event_id>
      <title>A Study of the Learnability of Relational Properties: Model Counting Meets Machine Learning (MCML)</title>
      <room>Swissotel Chicago | Zurich F</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:55</end_time>
      <description>This paper introduces the MCML approach for empirically studying the learnability of relational properties that can be expressed in the well-known software design language Alloy. A key novelty of MCML is quantification of the performance of and semantic differences among trained machine learning (ML) models, specifically decision trees, with respect to entire (bounded) input spaces, and not just for given training and test datasets (as is the common practice). MCML reduces the quantification problems to the classic complexity theory problem of model counting, and employs state-of-the-art model counters. The results show that relatively simple ML models can achieve surprisingly high performance (accuracy and F1-score) when evaluated in the common setting of using training and test datasets – even when the training dataset is much smaller than the test dataset – indicating the seeming simplicity of learning relational properties. However, MCML metrics based on model counting show that the performance can degrade substantially when tested against the entire (bounded) input space, indicating the high complexity of precisely learning these properties, and the usefulness of model counting in quantifying the true performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Muhammad</first_name>
          <last_name>Usman</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>muhammadusman2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wenxi</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wenxiwang.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wenxiwang/f8f4edcf-6e85-436c-8285-4b07c04ae265/small.jpg</picture_url>
          <person_id>wenxiwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marko</first_name>
          <last_name>Vasic</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://marko-vasic.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/markovasic/18058c03-9483-411f-aec5-77907a350e73/small.jpg</picture_url>
          <person_id>markovasic</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kaiyuan</first_name>
          <last_name>Wang</last_name>
          <affiliation>Google, Inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kaiyuanw.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kaiyuanwang/031824e1-c711-4674-9d66-a9d89e055192/small.jpg</picture_url>
          <person_id>kaiyuanwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Haris</first_name>
          <last_name>Vikalo</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <person_id>harisvikalo</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Sarfraz</first_name>
          <last_name>Khurshid</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/sarfrazkhurshid/b998e03f-4c99-458b-a9f9-b6c470511e3b/small.jpg</picture_url>
          <person_id>sarfrazkhurshid</person_id>
        </person>
      </persons>
      <tracks>
        <track>Recent SIGPLAN Conference Paper Presentations</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ba6425f5-c83d-4d86-b295-b56ae8175a40</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/18</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>a41a8911-3e3f-4b80-9f2b-94b8491195e6</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>20:10</start_time>
      <end_time>20:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6c1aca9f-d3f3-496e-a939-441b59b83f7b</slot_id>
      <event_id>314ee87d-573b-4837-a83c-59eaab087a9f</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/18</date>
      <start_time>20:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>20:40</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>080213cc-7cba-4e3b-ad8f-e38829347a2c</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>598717f9-7cd0-4d41-bd98-b75038d3ce26</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>20:10</start_time>
      <end_time>20:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>69a83a14-5187-4159-a75d-3f5249ed009b</slot_id>
      <event_id>d36c97a7-ae66-4f50-96db-35c8e14d37d5</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>20:10</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>20:40</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>47b41cda-29af-41b6-836b-60167c19834e</subevent_id>
    <title>SPLASH PLTea: PLTea</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/19</date>
    <url>https://2021.splashcon.org/track/splash-2021-pltea</url>
    <url_link_display>PLTea</url_link_display>
    <tracks>
      <track>PLTea</track>
    </tracks>
    <timeslot>
      <slot_id>41c3c573-766b-4e3e-a569-205bc989a382</slot_id>
      <title>Session: SPLASH PLTea - PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>20:10</start_time>
      <end_time>20:40</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
      </persons>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3d1bbf13-60a2-4a7c-9cdb-92248361323d</slot_id>
      <event_id>42fce42d-8032-40d0-a0e3-73300b5fdd70</event_id>
      <title>PLTea</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/19</date>
      <start_time>20:10</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>20:40</end_time>
      <description>We’re delighted to bring PLTea to OOPSLA. Drop-in, meet the PLTea moderators and other attendees and then chat in randomly assigned Zoom breakout rooms that are shuffled every 15 minutes. Stay for just a couple of minutes, or as long as you like. All welcome!</description>
      <tracks>
        <track>PLTea</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>60e521c2-ef60-49c5-995a-8ab8b5078b88</subevent_id>
    <title>SAS: Session 2B</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>abc1935c-11d4-4978-adcf-872da2d5182d</slot_id>
      <title>Session: SAS - Session 2B</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4f198fdf-940d-458c-8ea5-744d8b2837bc</slot_id>
      <event_id>b08a178c-7f0c-4bc7-b0f8-680f11280a67</event_id>
      <title>Thread-modular Analysis of Release-Acquire Concurrency</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>11:30</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:50</end_time>
      <description>We present a thread-modular abstract interpretation(TMAI) technique to verify programs under the release-acquire (RA) memory model for safety property violations. The main contributions of our work are: we capture the execution order of program statements as an abstract domain, and propose a sound upper approximation over this domain to efficiently reason over RA concurrency. The proposed domain is general in its application and captures the ordering relations as a first-class feature in the abstract interpretation theory. In particular, the domain represents a set of sequences of modifications of a global variable in concurrent programs as a partially ordered set. Under this approximation, older sequenced-before stores of a global variable are forgotten and only the latest stores per variable are preserved. We establish the soundness of our proposed abstractions and implement them in a prototype abstract interpreter called PRIORI. The evaluations of PRIORI on existing and challenging RA benchmarks demonstrate that the proposed technique is not only competitive in refutation, but also in verification. PRIORI shows significantly fast analysis runtimes with higher precision compared to recent state-of-the-art tools for RA concurrency.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Divyanjali</first_name>
          <last_name>Sharma</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cse.iitd.ac.in/~divyanjali/</homepage_url>
          <person_id>divyanjalisharma</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Subodh</first_name>
          <last_name>Sharma</last_name>
          <affiliation>IIT Delhi</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://subodhvsharma.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/subodhsharma/fd4e07cc-8466-455b-ad82-3d85138da23f/small.jpg</picture_url>
          <person_id>subodhsharma</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>9efad856-91d3-4b1a-8ff4-e9920c8cb9cd</slot_id>
      <event_id>1bce6dfa-6838-46f2-a5a1-5ef566fa1b5f</event_id>
      <title>Compositional Verification of Smart Contracts Through Communication Abstraction</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:10</end_time>
      <description>Solidity smart contracts are programs that manage up to 2^160 users on a blockchain. Verifying a smart contract relative to all users is intractable due to state explosion. Existing solutions either restrict the number of users to under-approximate behaviour, or rely on manual proofs. In this paper, we present local bundles that reduce contracts with arbitrarily many users to sequential programs with a few representative users. Each representative user abstracts concrete users that are locally symmetric to each other relative to the contract and the property. Our abstraction is semi-automated. The representatives depend on communication patterns, and are computed via static analysis. A summary for the behaviour of each representative is provided manually, but a default summary is often sufficient. Once obtained, a local bundle is amenable to sequential static analysis. We show that local bundles are relatively complete for parameterized safety verification, under moderate assumptions. We implement local bundle abstraction in Tool, and show order-of-magnitude speedups compared to a state-of-the-art verifier.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Scott</first_name>
          <last_name>Wesley</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>scottwesley</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maria</first_name>
          <last_name>Christakis</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mariachris.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mariachristakis/b7bf39cc-368b-44aa-bbcb-c83734e1e8fa/small.jpg</picture_url>
          <person_id>mariachristakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arie</first_name>
          <last_name>Gurfinkel</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ece.uwaterloo.ca/~agurfink</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ariegurfinkel/afd05be2-69c7-40dd-990c-230fef4cacf9/small.jpg</picture_url>
          <person_id>ariegurfinkel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Navas</last_name>
          <affiliation>SRI International</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jorgenavas.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgeanavas/662b4942-5460-4898-98cd-2c4e2c701960/small.jpg</picture_url>
          <person_id>jorgeanavas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Richard</first_name>
          <last_name>Trefler</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>richardtrefler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Valentin</first_name>
          <last_name>Wüstholz</last_name>
          <affiliation>ConsenSys</affiliation>
          <bio>Valentin is a software security researcher at ConsenSys Diligence and has held positions both in academia (at ETH Zürich and UT Austin) and in industry (at Microsoft and Google). He is passionate about developing tools and techniques that allow us to produce more reliable and correct software.</bio>
          <homepage_url>http://www.wuestholz.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/valentinwustholz/c6ff5691-4f3e-472c-8454-168eaaebb7eb/small.jpg</picture_url>
          <person_id>valentinwustholz</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>be7e435f-d27d-4295-8f39-24c5ebf1124e</slot_id>
      <event_id>978b8bed-74af-46a6-b73a-7bc39813dbc5</event_id>
      <title>Selectively-Amortized Resource Bounding</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>11:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>11:30</end_time>
      <description>We consider the problem of automatically proving resource bounds. That is, we study how to prove that an integer-valued resource variable is bounded by a given program expression. Automatic resource-bound analysis has recently received significant attention because of a number of important applications (e.g., detecting performance bugs, preventing algorithmic-complexity attacks, identifying side-channel vulnerabilities), where the focus has often been on developing precise amortized reasoning techniques to infer the most exact resource usage. While such innovations remain critical, we observe that fully precise amortization is not always necessary to prove a bound of interest. And in fact, by amortizing selectively, the needed supporting invariants can be simpler, We present a framework for selectively-amortized analysis that mixes worst-case and amortized reasoning via a property decomposition and a program transformation. We show that proving bounds in any such decomposition yields a sound resource bound in the original program, and we give an algorithm for selecting a reasonable decomposition.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tianhan</first_name>
          <last_name>Lu</last_name>
          <affiliation>University of Colorado Boulder</affiliation>
          <bio>undefined</bio>
          <person_id>tianhanlu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bor-Yuh Evan</first_name>
          <last_name>Chang</last_name>
          <affiliation>University of Colorado Boulder &amp; Amazon</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.colorado.edu/~bec/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/boryuhevanchang/0cbe7e94-aaf8-458b-9670-3892350bc209/small.jpg</picture_url>
          <person_id>boryuhevanchang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ashutosh</first_name>
          <last_name>Trivedi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>ashutoshtrivedi</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7c4994a3-9a96-496b-b555-3a003828de5e</subevent_id>
    <title>SAS: Session 2B</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>5759cb83-4e50-46f3-abb4-853effc1c162</slot_id>
      <title>Session: SAS - Session 2B</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>0f93dbdd-a387-4915-90c3-42899a732050</slot_id>
      <event_id>978b8bed-74af-46a6-b73a-7bc39813dbc5</event_id>
      <title>Selectively-Amortized Resource Bounding</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>19:10</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:30</end_time>
      <description>We consider the problem of automatically proving resource bounds. That is, we study how to prove that an integer-valued resource variable is bounded by a given program expression. Automatic resource-bound analysis has recently received significant attention because of a number of important applications (e.g., detecting performance bugs, preventing algorithmic-complexity attacks, identifying side-channel vulnerabilities), where the focus has often been on developing precise amortized reasoning techniques to infer the most exact resource usage. While such innovations remain critical, we observe that fully precise amortization is not always necessary to prove a bound of interest. And in fact, by amortizing selectively, the needed supporting invariants can be simpler, We present a framework for selectively-amortized analysis that mixes worst-case and amortized reasoning via a property decomposition and a program transformation. We show that proving bounds in any such decomposition yields a sound resource bound in the original program, and we give an algorithm for selecting a reasonable decomposition.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tianhan</first_name>
          <last_name>Lu</last_name>
          <affiliation>University of Colorado Boulder</affiliation>
          <bio>undefined</bio>
          <person_id>tianhanlu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bor-Yuh Evan</first_name>
          <last_name>Chang</last_name>
          <affiliation>University of Colorado Boulder &amp; Amazon</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.colorado.edu/~bec/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/boryuhevanchang/0cbe7e94-aaf8-458b-9670-3892350bc209/small.jpg</picture_url>
          <person_id>boryuhevanchang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ashutosh</first_name>
          <last_name>Trivedi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>ashutoshtrivedi</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>c3fd5da2-3755-4db2-a26c-b3da047f40a1</slot_id>
      <event_id>1bce6dfa-6838-46f2-a5a1-5ef566fa1b5f</event_id>
      <title>Compositional Verification of Smart Contracts Through Communication Abstraction</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:10</end_time>
      <description>Solidity smart contracts are programs that manage up to 2^160 users on a blockchain. Verifying a smart contract relative to all users is intractable due to state explosion. Existing solutions either restrict the number of users to under-approximate behaviour, or rely on manual proofs. In this paper, we present local bundles that reduce contracts with arbitrarily many users to sequential programs with a few representative users. Each representative user abstracts concrete users that are locally symmetric to each other relative to the contract and the property. Our abstraction is semi-automated. The representatives depend on communication patterns, and are computed via static analysis. A summary for the behaviour of each representative is provided manually, but a default summary is often sufficient. Once obtained, a local bundle is amenable to sequential static analysis. We show that local bundles are relatively complete for parameterized safety verification, under moderate assumptions. We implement local bundle abstraction in Tool, and show order-of-magnitude speedups compared to a state-of-the-art verifier.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Scott</first_name>
          <last_name>Wesley</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>scottwesley</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maria</first_name>
          <last_name>Christakis</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mariachris.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mariachristakis/b7bf39cc-368b-44aa-bbcb-c83734e1e8fa/small.jpg</picture_url>
          <person_id>mariachristakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arie</first_name>
          <last_name>Gurfinkel</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ece.uwaterloo.ca/~agurfink</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ariegurfinkel/afd05be2-69c7-40dd-990c-230fef4cacf9/small.jpg</picture_url>
          <person_id>ariegurfinkel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Navas</last_name>
          <affiliation>SRI International</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jorgenavas.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgeanavas/662b4942-5460-4898-98cd-2c4e2c701960/small.jpg</picture_url>
          <person_id>jorgeanavas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Richard</first_name>
          <last_name>Trefler</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <person_id>richardtrefler</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Valentin</first_name>
          <last_name>Wüstholz</last_name>
          <affiliation>ConsenSys</affiliation>
          <bio>Valentin is a software security researcher at ConsenSys Diligence and has held positions both in academia (at ETH Zürich and UT Austin) and in industry (at Microsoft and Google). He is passionate about developing tools and techniques that allow us to produce more reliable and correct software.</bio>
          <homepage_url>http://www.wuestholz.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/valentinwustholz/c6ff5691-4f3e-472c-8454-168eaaebb7eb/small.jpg</picture_url>
          <person_id>valentinwustholz</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>e6a6a3e3-66ab-49cf-b85e-1e928e465b7f</slot_id>
      <event_id>b08a178c-7f0c-4bc7-b0f8-680f11280a67</event_id>
      <title>Thread-modular Analysis of Release-Acquire Concurrency</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>19:30</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>19:50</end_time>
      <description>We present a thread-modular abstract interpretation(TMAI) technique to verify programs under the release-acquire (RA) memory model for safety property violations. The main contributions of our work are: we capture the execution order of program statements as an abstract domain, and propose a sound upper approximation over this domain to efficiently reason over RA concurrency. The proposed domain is general in its application and captures the ordering relations as a first-class feature in the abstract interpretation theory. In particular, the domain represents a set of sequences of modifications of a global variable in concurrent programs as a partially ordered set. Under this approximation, older sequenced-before stores of a global variable are forgotten and only the latest stores per variable are preserved. We establish the soundness of our proposed abstractions and implement them in a prototype abstract interpreter called PRIORI. The evaluations of PRIORI on existing and challenging RA benchmarks demonstrate that the proposed technique is not only competitive in refutation, but also in verification. PRIORI shows significantly fast analysis runtimes with higher precision compared to recent state-of-the-art tools for RA concurrency.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Divyanjali</first_name>
          <last_name>Sharma</last_name>
          <affiliation>IIT Delhi, India</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cse.iitd.ac.in/~divyanjali/</homepage_url>
          <person_id>divyanjalisharma</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Subodh</first_name>
          <last_name>Sharma</last_name>
          <affiliation>IIT Delhi</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://subodhvsharma.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/subodhsharma/fd4e07cc-8466-455b-ad82-3d85138da23f/small.jpg</picture_url>
          <person_id>subodhsharma</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>599baa9f-41d8-4e44-96b7-917974a2be69</subevent_id>
    <title>SAS: Session 2C</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>689ae573-f2b7-488d-9763-325932967822</slot_id>
      <title>Session: SAS - Session 2C</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6b9b1fdf-a599-41cf-9028-a9af0e5b966e</slot_id>
      <event_id>5b184311-60b5-4fbb-8372-ab77441e91d5</event_id>
      <title>Pointer Analysis of Bytecode Programs for Effective Formal Verification of Smart Contracts</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>12:10</end_time>
      <description>Low-level bytecode programs are difficult to handle by formal reasoning, particularly in the case of sound and precise reasoning about memory operations. There is often no distinguished allocation operation: high-level object allocations are affected via pointer arithmetic. Type information is lost in the compilation: the abstraction of memory is simply an unstructured array of bytes. To recover high-level information, a sound pointer analysis is an invaluable resource. Such an analysis enables optimizations and elucidates program behavior that would otherwise be obscured in a low-level setting. This talk describes a new static analysis algorithm we have developed for sound pointer analysis for low-level bytecode. We make this broad problem tractable by first restricting our focus to bytecode programs that manage memory via a bump allocator that operates on a distinguished free pointer. In other words, we target bytecode programs where memory is divided into disjoint regions, each of which corresponds to an “object”. Our analysis algorithm uses a novel technique for mapping updates of a distinguished free pointer to provably non-aliased abstract addresses, which enables standard pointer analysis techniques. Our static pointer analysis uses a “trust but verify” approach: we build our analysis on the expectation that the compiler has properly managed memory via the free pointer/bump allocator, but at each step, we verify that regions of memory allocated via the bump allocator are properly disjoint, i.e., every read/write of memory provably accesses only one, distinct region. This talk discusses our practical experience using this analysis in verifying smart contracts that run on the Ethereum Virtual Machine. In particular, we outline multiple high-profile memory management bugs uncovered by our analysis, and the downstream optimizations and precision improvements unlocked by our pointer analysis results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mooly</first_name>
          <last_name>Sagiv</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>My research focuses on easing the task of developing reliable and efficient software systems. I am particularly interested in static program analysis which combines two disciplines: automated theorem proving and abstract interpretation. In the next decade, I am hoping to develop useful techniques in order to change the ways modern software is built. I am particularly interested in proof automation, given a program and a requirement, automatically prove or disprove that all executions of the program satisfy the requirements. This problem is in general undecidable and untractable. I am interested in developing practical solutions to proof-automation by: (i) exploring modularity of the system and (ii) relying on semi-automatic and interactive process, where the user manually and interactively guides the proof automation, and (iii) simplifying the verification task by using domain-specific abstractions expressed in a decidable logic. I am applying these techniques to verify safety of liveness of distributed systems.</bio>
          <homepage_url>http://www.cs.tau.ac.il/~msagiv/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/moolysagiv/5ff34ce2-4812-410c-aa6d-e1457fc2f1ac/small.jpg</picture_url>
          <person_id>moolysagiv</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge>Invited Talk</badge>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bc5fbd62-1bc1-4dc3-95cc-25b4a29d9f2d</subevent_id>
    <title>SAS: Session 4B</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>b969e594-b9fa-4246-87d4-9ebb473611bb</slot_id>
      <title>Session: SAS - Session 4B</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1662f861-dedb-4734-9776-ea407f5dabe7</slot_id>
      <event_id>e9f054af-c0e2-4c0e-9e9d-3e223f756061</event_id>
      <title>Backward Symbolic Execution with Loop Folding</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>16:20</end_time>
      <description>Symbolic execution is an established program analysis technique that aims to search all possible execution paths starting in the initial program location. Due to the so-called path explosion problem, symbolic execution is usually unable to analyze all execution paths and thus it is not convenient for program verification as a standalone method. This paper focuses on backward symbolic execution (BSE), which searches program paths backward from the error location whose reachability should be proven or refuted. We show that this technique is equivalent to performing k-induction on control-flow paths. While standard BSE simply unwinds all program loops, we present an extension called loop folding that aims to derive loop invariants during BSE that are sufficient to prove the unreachability of the error location. The resulting technique called backward symbolic execution with loop folding (BSELF) can infer disjunctive loop invariants that are hard to derive for current techniques. Indeed, our experiments show that BESLF can verify some standard benchmarks that cannot be verified by state-of-the-art tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marek</first_name>
          <last_name>Chalupa</last_name>
          <affiliation>Masaryk University</affiliation>
          <bio>undefined</bio>
          <person_id>marekchalupa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Strejcek</last_name>
          <affiliation>Masaryk University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.fi.muni.cz/~xstrejc/</homepage_url>
          <person_id>janstrejcek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>1d9044be-9c54-4a17-9c75-5d0ed33ab459</slot_id>
      <event_id>60f4fa55-a96f-4db6-9954-a94ad5243bcc</event_id>
      <title>Automated Verification of the Parallel Bellman--Ford Algorithm</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>16:00</end_time>
      <description>Many real-world problems such as internet routing are actually graph problems. To develop efficient solutions to such problems, more and more parallel graph algorithms are proposed. This paper discusses the mechanized verification of a commonly used parallel graph algorithm, namely the Bellman–Ford algorithm, which provides an inherently parallel solution to the Single-Source Shortest Path problem. Concretely, we verify an unoptimized GPU version of the Bellman–Ford algorithm, using the VerCors verifier. The main challenge that we had to address was to find suitable global invariants of the graph-based properties for automated verification. This case study is the first deductive verification to prove functional correctness of the parallel Bellman–Ford algorithm. It provides the basis to verify other, optimized implementations of the algorithm. Moreover, it may also provide a good starting point to verify other parallel graph-based algorithms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohsen</first_name>
          <last_name>Safari</last_name>
          <affiliation>University of Twente, The Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.utwente.nl/m.safari</homepage_url>
          <person_id>mohsensafari</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wytse</first_name>
          <last_name>Oortwijn</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wwwhome.ewi.utwente.nl/~oortwijnwhm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wytseoortwijn/079f1ba3-77ed-4f76-93e5-136adc3b291e/small.jpg</picture_url>
          <person_id>wytseoortwijn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marieke</first_name>
          <last_name>Huisman</last_name>
          <affiliation>University of Twente</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wwwhome.cs.utwente.nl/~marieke/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mariekehuisman/22505ee7-e6f4-4999-abda-0c8325ff501f/small.jpg</picture_url>
          <person_id>mariekehuisman</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>74bf08e7-cb5e-43ca-8a26-ef1df78b60f2</slot_id>
      <event_id>6086e00a-20aa-4a82-b0ff-a48a99c3a839</event_id>
      <title>Improving Thread-Modular Abstract Interpretation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>16:40</end_time>
      <description>We give thread-modular non-relational value analyses as abstractions of a local trace semantics. The semantics as well as the analyses are formulated by means of global invariants and side-effecting constraint systems. We show that a generalization of the analysis provided by the static analyzer Goblint as well as a natural improvement of Antoine Miné’s approach can be obtained as instances of this general scheme. We show that these two analyses are incomparable w.r.t. precision and provide a refinement which improves on both precision-wise. We also report on a preliminary experimental comparison of the given analyses on a meaningful suite of benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Schwarz</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.in.tum.de/i02/personen/michael-schwarz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelschwarz/d579481e-b407-434d-9f91-04548d70b912/small.jpg</picture_url>
          <person_id>michaelschwarz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Saan</last_name>
          <affiliation>University of Tartu, Estonia</affiliation>
          <bio>undefined</bio>
          <person_id>simonsaan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kalmer</first_name>
          <last_name>Apinis</last_name>
          <affiliation>University of Tartu, Estonia</affiliation>
          <bio>undefined</bio>
          <person_id>kalmerapinis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Julian</first_name>
          <last_name>Erhard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julianerhard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Vesal</first_name>
          <last_name>Vojdani</last_name>
          <affiliation>University of Tartu</affiliation>
          <bio>undefined</bio>
          <person_id>vesalvojdani</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>c3a6bde5-925f-4f2a-96c7-d8ed9f4a6a5c</slot_id>
      <event_id>64e069c6-2609-4d24-a969-3dc6d81d48fe</event_id>
      <title>Symbolic Automatic Relations and Their Applications to SMT and CHC Solving</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>17:00</end_time>
      <description>Despite the recent advance of automated program verification, reasoning about recursive data structures remains as a challenge for verification tools and their backends such as SMT and CHC solvers. To address the challenge, we introduce the notion of symbolic automatic relations (SARs), which combines symbolic automata and automatic relations, and inherits their good properties such as the closure under Boolean operations. We consider the satisfiability problem for SARs, and show that it is undecidable in general, but that we can construct a sound (but incomplete) and automated satisfiability checker by a reduction to CHC solving. We discuss applications to SMT and CHC solving on data structures, and show the effectiveness of our approach through experiments.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Takumi</first_name>
          <last_name>Shimoda</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>takumishimoda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ken</first_name>
          <last_name>Sakayori</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>kensakayori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ryosuke</first_name>
          <last_name>Sato</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-kb.is.s.u-tokyo.ac.jp/~ryosuke/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ryosukesato/dde2fccf-e07f-48f8-9dc9-277cb124e664/small.jpg</picture_url>
          <person_id>ryosukesato</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bda4e8f6-ba6d-4fa8-8bf6-ec23cc601cdc</subevent_id>
    <title>SAS: Session 1A</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>b6e90b1f-ac7a-409f-a3f3-111ce5410e1b</slot_id>
      <title>Session: SAS - Session 1A</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>17:00</start_time>
      <end_time>18:20</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>18b96aef-d776-4ec0-8743-6aba7ad5b5db</slot_id>
      <event_id>95da4eb7-6b2a-4e6b-849d-03f3c2019e40</event_id>
      <title>Accelerating Program Analyses in Datalog by Merging Library Facts</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>17:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>17:20</end_time>
      <description>Static program analysis uses sensitivity to balance between precision and scalability. However, finer sensitivity does not necessar- ily lead to more precise results but may reduce scalability. Recently, a number of approaches have been proposed to finely tune the sensitivity of different program parts. However, these approaches are usually de- signed for specific program analyses, and their abstraction adjustments are coarse-grained as they directly drop sensitivity elements. 
In this paper, we propose a new technique, 4DM, to tune abstractions for program analyses in Datalog. 4DM merges values in a domain, allowing fine-grained sensitivity tuning. 4DM uses a data-driven algorithm for automatically learning a merging strategy for a library from a training set of programs. Unlike existing approaches that rely on the properties of a certain analysis, our learning algorithm works for a wide range of Datalog analyses. We have evaluated our approach on a points-to analysis and a liveness analysis, on the DaCapo benchmark suite. Our evaluation results suggest that our technique achieves a significant speedup and negligible precision loss, reaching a good balance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yifan</first_name>
          <last_name>Chen</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>yifanchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chenyang</first_name>
          <last_name>Yang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>chenyangyang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xin</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Xin Zhang is an Assistant Professor at the Department of Computer Science and Technology, the School of Electronics Engineering and Computer Science, Peking University. While he is broadly interested in topics related to programming languages (PL) and software engineering (SE), his current focus is on program analysis and its interplay with machine learning (ML) and artificial intelligence (AI). On one hand, he leverages ideas from ML/AI to build better program analyses. On the other hand, he develops program analyses and languages for improving intepretability, fairness, robustness, and safety of ML/AI systems.</bio>
          <homepage_url>http://xinpl.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xinzhang/a4dbba61-3d43-4702-818f-94cad593fbec/small.jpg</picture_url>
          <person_id>xinzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hao</first_name>
          <last_name>Tang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>haotang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Xiaoyin</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Texas at San Antonio</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.utsa.edu/~xwang/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaoyinwang/cb4e92d4-fdd0-4b49-8bd5-f3d867af9188/small.jpg</picture_url>
          <person_id>xiaoyinwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Lu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~zhanglu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/luzhang/bd50fc81-b47a-415a-a9ac-6c041db44562/small.jpg</picture_url>
          <person_id>luzhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>6bcf1752-cb31-4ef8-9043-468d50d7df81</slot_id>
      <event_id>07d7e99b-7049-483c-bfc8-b77b31d2e4b4</event_id>
      <title>Verifying Low-dimensional Input Neural Networks via Input Quantization</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>17:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>18:00</end_time>
      <description>Deep neural networks are an attractive tool for compressing the control policy lookup tables in systems such as the Airborne Collision Avoidance System (ACAS). It is vital to ensure the safety of such neural controllers via verification techniques. The problem of analyzing ACAS Xu networks has motivated many successful neural network verifiers. These verifiers typically analyze the internal computation of neural networks to decide whether a property regarding the input/output holds. The intrinsic complexity of neural network computation renders such verifiers slow to run and vulnerable to floating-point error. 
This paper revisits the original problem of verifying ACAS Xu networks. The networks take low-dimensional sensory inputs with training data extracted from a lookup table. We propose to prepend an input quantization layer to the network. Quantization allows efficient verification via input state enumeration, whose complexity is bounded by the size of the quantization space. Quantization is equivalent to nearest-neighbor interpolation at run time, which has been shown to provide acceptable accuracy for ACAS in simulation. Moreover, our technique can deliver exact verification results immune to floating-point error if we directly enumerate the network outputs on the target inference implementation or on an accurate simulation of the target implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kai</first_name>
          <last_name>Jia</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jiakai.xyz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kaijia/2d2aaec8-97ea-4bfd-9541-f4d09d994f2e/small.jpg</picture_url>
          <person_id>kaijia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin C.</first_name>
          <last_name>Rinard</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.csail.mit.edu/rinard/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinrinard/cc4278df-192e-490f-87e5-a0649c420584/small.jpg</picture_url>
          <person_id>martinrinard</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>7a62d34a-dba1-4d05-aacd-619ea77539a6</slot_id>
      <event_id>f90ffbc6-0cc9-4f1a-9361-fb6dc9e9dc39</event_id>
      <title>Exploiting Verified Neural Networks via Floating Point Numerical Error</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>17:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>17:40</end_time>
      <description>Motivated by the need to reliably characterize the robustness of deep neural networks, researchers have developed neural network verification algorithms. The verifiers aspire to answer whether certain properties are guaranteed with respect to all inputs in a space for a neural network. However, many verifiers inaccurately model floating point arithmetic but do not fully discuss the consequences. 
We show that the negligence of floating point error leads to unsound verification that can be systematically exploited in practice. For a pretrained neural network, we present a method that efficiently searches inputs as witnesses for the incorrectness of robustness claims made by a complete verifier. We also present a method to construct neural network architectures and weights that induce wrong results of an incomplete verifier. Our results highlight that, to achieve practically reliable verification of neural networks, any verification system must accurately (or conservatively) model the effects of any floating point computations in the network inference or verification system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kai</first_name>
          <last_name>Jia</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jiakai.xyz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kaijia/2d2aaec8-97ea-4bfd-9541-f4d09d994f2e/small.jpg</picture_url>
          <person_id>kaijia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin C.</first_name>
          <last_name>Rinard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>martincrinard</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>c8813a87-933e-45fb-a21a-88287f1cbebe</slot_id>
      <event_id>6e4c887f-ca9b-4171-a7bf-d5cdf413503e</event_id>
      <title>A Multi-Language Static Analysis of Python Programs with Native C Extensions</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>18:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>18:20</end_time>
      <description>Modern programs are increasingly multilanguage, to benefit from each programming language’s advantages and to reuse libraries. For example, developers may want to combine high-level Python code with low-level, performance-oriented C code. In fact one in five of the 200 most-downloaded Python libraries available on GitHub contains C code. Static analyzers tend to focus on a single language, and may use stubs to model the behavior of foreign function calls. However, stubs are costly to implement and undermine soundness of analyzers. In this work we design a static analyzer by abstract interpretation that can handle Python programs calling C extensions. It analyses directly and fully automatically both the Python and the C source codes. It reports runtime errors that may happen in Python, in C, and at the interface. We implemented our analysis in a modular fashion: it reuses off-the-shelf C and Python analyses written in the same analyzer. This approach allows sharing between abstract domains of different languages. Our analyzer can tackle tests of real-world libraries a few thousand lines of C and Python long.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raphaël</first_name>
          <last_name>Monat</last_name>
          <affiliation>Sorbonne Université  — LIP6</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://rmonat.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/raphaelmonat/2405755c-6e69-4ac2-a6af-8231b7b11c81/small.jpg</picture_url>
          <person_id>raphaelmonat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>211eab7c-8126-4543-ae59-ebff96e6db7a</subevent_id>
    <title>SAS: Session 1A</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>4cf6e2de-d79e-4955-98d2-7a2a871bf9c2</slot_id>
      <title>Session: SAS - Session 1A</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_time>10:20</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5472b8cc-c2f1-4ff3-a867-c0b19095ae0b</slot_id>
      <event_id>f90ffbc6-0cc9-4f1a-9361-fb6dc9e9dc39</event_id>
      <title>Exploiting Verified Neural Networks via Floating Point Numerical Error</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>09:20</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>09:40</end_time>
      <description>Motivated by the need to reliably characterize the robustness of deep neural networks, researchers have developed neural network verification algorithms. The verifiers aspire to answer whether certain properties are guaranteed with respect to all inputs in a space for a neural network. However, many verifiers inaccurately model floating point arithmetic but do not fully discuss the consequences. 
We show that the negligence of floating point error leads to unsound verification that can be systematically exploited in practice. For a pretrained neural network, we present a method that efficiently searches inputs as witnesses for the incorrectness of robustness claims made by a complete verifier. We also present a method to construct neural network architectures and weights that induce wrong results of an incomplete verifier. Our results highlight that, to achieve practically reliable verification of neural networks, any verification system must accurately (or conservatively) model the effects of any floating point computations in the network inference or verification system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kai</first_name>
          <last_name>Jia</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jiakai.xyz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kaijia/2d2aaec8-97ea-4bfd-9541-f4d09d994f2e/small.jpg</picture_url>
          <person_id>kaijia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin C.</first_name>
          <last_name>Rinard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>martincrinard</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>caaf9fd3-df60-48fb-86ee-f4f908a30b9a</slot_id>
      <event_id>95da4eb7-6b2a-4e6b-849d-03f3c2019e40</event_id>
      <title>Accelerating Program Analyses in Datalog by Merging Library Facts</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>09:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>09:20</end_time>
      <description>Static program analysis uses sensitivity to balance between precision and scalability. However, finer sensitivity does not necessar- ily lead to more precise results but may reduce scalability. Recently, a number of approaches have been proposed to finely tune the sensitivity of different program parts. However, these approaches are usually de- signed for specific program analyses, and their abstraction adjustments are coarse-grained as they directly drop sensitivity elements. 
In this paper, we propose a new technique, 4DM, to tune abstractions for program analyses in Datalog. 4DM merges values in a domain, allowing fine-grained sensitivity tuning. 4DM uses a data-driven algorithm for automatically learning a merging strategy for a library from a training set of programs. Unlike existing approaches that rely on the properties of a certain analysis, our learning algorithm works for a wide range of Datalog analyses. We have evaluated our approach on a points-to analysis and a liveness analysis, on the DaCapo benchmark suite. Our evaluation results suggest that our technique achieves a significant speedup and negligible precision loss, reaching a good balance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yifan</first_name>
          <last_name>Chen</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>yifanchen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chenyang</first_name>
          <last_name>Yang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>chenyangyang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xin</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Xin Zhang is an Assistant Professor at the Department of Computer Science and Technology, the School of Electronics Engineering and Computer Science, Peking University. While he is broadly interested in topics related to programming languages (PL) and software engineering (SE), his current focus is on program analysis and its interplay with machine learning (ML) and artificial intelligence (AI). On one hand, he leverages ideas from ML/AI to build better program analyses. On the other hand, he develops program analyses and languages for improving intepretability, fairness, robustness, and safety of ML/AI systems.</bio>
          <homepage_url>http://xinpl.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xinzhang/a4dbba61-3d43-4702-818f-94cad593fbec/small.jpg</picture_url>
          <person_id>xinzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hao</first_name>
          <last_name>Tang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>haotang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Xiaoyin</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Texas at San Antonio</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.utsa.edu/~xwang/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaoyinwang/cb4e92d4-fdd0-4b49-8bd5-f3d867af9188/small.jpg</picture_url>
          <person_id>xiaoyinwang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Lu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~zhanglu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/luzhang/bd50fc81-b47a-415a-a9ac-6c041db44562/small.jpg</picture_url>
          <person_id>luzhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>df7a03b2-675c-4228-a1cf-920403d4e540</slot_id>
      <event_id>6e4c887f-ca9b-4171-a7bf-d5cdf413503e</event_id>
      <title>A Multi-Language Static Analysis of Python Programs with Native C Extensions</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>10:00</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:20</end_time>
      <description>Modern programs are increasingly multilanguage, to benefit from each programming language’s advantages and to reuse libraries. For example, developers may want to combine high-level Python code with low-level, performance-oriented C code. In fact one in five of the 200 most-downloaded Python libraries available on GitHub contains C code. Static analyzers tend to focus on a single language, and may use stubs to model the behavior of foreign function calls. However, stubs are costly to implement and undermine soundness of analyzers. In this work we design a static analyzer by abstract interpretation that can handle Python programs calling C extensions. It analyses directly and fully automatically both the Python and the C source codes. It reports runtime errors that may happen in Python, in C, and at the interface. We implemented our analysis in a modular fashion: it reuses off-the-shelf C and Python analyses written in the same analyzer. This approach allows sharing between abstract domains of different languages. Our analyzer can tackle tests of real-world libraries a few thousand lines of C and Python long.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Raphaël</first_name>
          <last_name>Monat</last_name>
          <affiliation>Sorbonne Université  — LIP6</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://rmonat.fr</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/raphaelmonat/2405755c-6e69-4ac2-a6af-8231b7b11c81/small.jpg</picture_url>
          <person_id>raphaelmonat</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>f724a5ac-b4d7-43c6-ad39-34a98127fbba</slot_id>
      <event_id>07d7e99b-7049-483c-bfc8-b77b31d2e4b4</event_id>
      <title>Verifying Low-dimensional Input Neural Networks via Input Quantization</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>09:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>10:00</end_time>
      <description>Deep neural networks are an attractive tool for compressing the control policy lookup tables in systems such as the Airborne Collision Avoidance System (ACAS). It is vital to ensure the safety of such neural controllers via verification techniques. The problem of analyzing ACAS Xu networks has motivated many successful neural network verifiers. These verifiers typically analyze the internal computation of neural networks to decide whether a property regarding the input/output holds. The intrinsic complexity of neural network computation renders such verifiers slow to run and vulnerable to floating-point error. 
This paper revisits the original problem of verifying ACAS Xu networks. The networks take low-dimensional sensory inputs with training data extracted from a lookup table. We propose to prepend an input quantization layer to the network. Quantization allows efficient verification via input state enumeration, whose complexity is bounded by the size of the quantization space. Quantization is equivalent to nearest-neighbor interpolation at run time, which has been shown to provide acceptable accuracy for ACAS in simulation. Moreover, our technique can deliver exact verification results immune to floating-point error if we directly enumerate the network outputs on the target inference implementation or on an accurate simulation of the target implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kai</first_name>
          <last_name>Jia</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jiakai.xyz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kaijia/2d2aaec8-97ea-4bfd-9541-f4d09d994f2e/small.jpg</picture_url>
          <person_id>kaijia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin C.</first_name>
          <last_name>Rinard</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.csail.mit.edu/rinard/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/martinrinard/cc4278df-192e-490f-87e5-a0649c420584/small.jpg</picture_url>
          <person_id>martinrinard</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f929a6a0-2cd1-4aa2-96db-d3b5cb89f4ea</subevent_id>
    <title>SAS: Session 3A</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>18ce5b4f-6097-4a55-b39b-add89d99b656</slot_id>
      <title>Session: SAS - Session 3A</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>56269919-e06e-406f-8398-c137f4e7c665</slot_id>
      <event_id>8ba2c7e3-b473-4cc6-978b-cb5e94764f5e</event_id>
      <title>Verified Functional Programming of an Abstract Interpreter</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:30</end_time>
      <description>Abstract interpreters are complex pieces of software: even if the abstract interpretation theory and companion algorithms are well understood, their implementations are subject to bugs, that might question the soundness of their computations. 
While some formally verified abstract interpreters have been written in the past, writing and understanding them requires expertise in the use of proof assistants, and requires a non-trivial amount of interactive proofs. 
This paper presents a formally verified abstract interpreter fully programmed and proved correct in the F* verified programming environment. Thanks to F* refinement types and SMT prover capabilities we demonstrate a substantial saving in proof effort compared to previous works based on interactive proofs assistants. Almost all the code of our implementation, proofs included, written in a functional style, are presented directly in the paper.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Franceschino</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://lucas.franceschino.fr</homepage_url>
          <person_id>lucasfranceschino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Pichardie</last_name>
          <affiliation>Univ Rennes, ENS Rennes, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/celtique/pichardie/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidpichardie/b0f30e9b-c1d3-4e4f-9923-4cf150989f86/small.jpg</picture_url>
          <person_id>davidpichardie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean-Pierre</first_name>
          <last_name>Talpin</last_name>
          <affiliation>INRIA, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/prive/talpin</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeanpierretalpin/b5285496-0c64-4e5e-8ce5-f162f8f92881/small.jpg</picture_url>
          <person_id>jeanpierretalpin</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>7918caf7-bf98-42c0-86fd-79d49b621305</slot_id>
      <event_id>55890513-6497-44fd-a3a9-838f69361366</event_id>
      <title>Static Analysis of Endian Portability by Abstract Interpretation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:10</end_time>
      <description>We present a static analysis of endian portability for C programs. Our analysis can infer that a given program, or two syntactically close versions thereof, compute the same outputs, when run with the same inputs on platforms with different byte-orders, a.k.a. endiannesses. We target low-level C programs that abuse C pointers and unions, hence rely on implementation-specific behaviors undefined in the C standard. Our method is based on abstract interpretation, and parametric in the choice of a numerical abstract domain. We first present a novel concrete collecting semantics, relating the behaviors of two versions of a program, running on platforms with different endiannesses. We propose a joint memory abstraction, able to infer equivalence relations between little- and big-endian memories. We introduce a novel symbolic predicate domain, to infer relations between individual bytes of the variables in the two programs, which has near-linear cost, and the right amount of relationality to express (bitwise) arithmetic properties relevant to endian portability. We implemented a prototype static analyzer, able to scale to large real-world industrial software, with zero false alarms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Delmas</last_name>
          <affiliation>Airbus &amp; Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.di.ens.fr/~delmas/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/daviddelmas/c73d6e1c-9527-4287-b059-67e4e36354c8/small.jpg</picture_url>
          <person_id>daviddelmas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>c3c71811-563c-476e-8764-c9e9c05275d3</slot_id>
      <event_id>e8cf7f79-77ce-44b2-b4fd-a19e24245cc6</event_id>
      <title>Data Abstraction: A General Framework to Handle Program Verification of Data Structures</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>14:50</end_time>
      <description>Proving properties on programs operating over arrays, or array-like data structures, most often involves universally quantified invariants, e.g., “all elements below index i are nonzero”. In this article, we propose a general data abstraction scheme operating on Horn Formula for which we provide a relative completeness resolution scheme: the generated purely scalar invariant search problem has a solution if and only if the original problem has one expressible by the abstraction.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julien</first_name>
          <last_name>Braine</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julienbraine</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laure</first_name>
          <last_name>Gonnord</last_name>
          <affiliation>University of Lyon &amp; LIP, France</affiliation>
          <bio>Laure Gonnord received her PhD degree in computer science from the University Joseph Fourier (Grenoble, France), in 2007. She currently holds an assistant professor position at University Lyon I/UCBL, France. She got her Habilitation in 2017. 
Her main research interests lie in the design of static analyses, with emphasis on the automatic synthesis of numerical and memory invariants and application in compilation (scheduling) and termination proofs. She belongs to the CASH team of the LIP laboratory (ENS de Lyon, France).</bio>
          <homepage_url>http://laure.gonnord.org/pro</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lauregonnord/6b741986-7933-4cba-9205-8e5e8451d8fa/small.jpg</picture_url>
          <person_id>lauregonnord</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Monniaux</last_name>
          <affiliation>CNRS/VERIMAG</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-verimag.imag.fr/~monniaux/</homepage_url>
          <person_id>davidmonniaux1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>741f52cf-e040-49df-8f27-940f6c33707f</subevent_id>
    <title>SAS: Session 3B</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>6218f22b-a6cd-42e2-9a5e-5823b4a2ebbf</slot_id>
      <title>Session: SAS - Session 3B</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a7f86b96-f291-43f1-8ab6-2792eee4d46a</slot_id>
      <event_id>277b5be0-47ca-44d7-8c34-1f84145614be</event_id>
      <title>Interactive Code Analysis</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>15:10</end_time>
      <description>Static code analyzers have become indispensable especially for safety critical software development. But, they do have a few drawbacks as well. For starters, and for good reason, the commercial tools can be quite slow, and they are certainly not suitable for interactive use. I’ll describe a new tool called Cobra, that I’m currently developing, which can resolve types of queries interactively, even on very large code bases. Queries can be scripted or predefined in libraries. The tool is designed to be easy to use, and is freely available.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Gerard</first_name>
          <last_name>Holzmann</last_name>
          <affiliation>NASA/Caltech Jet Propulsion Laboratory</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://spinroot.com/gerard</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gerardholzmann/c5072b2e-ad04-419b-b08c-1338fb4219d9/small.jpg</picture_url>
          <person_id>gerardholzmann</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge>Invited Talk</badge>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>be1a3916-c86f-4a97-bb70-c5595b9f02dd</subevent_id>
    <title>SAS: Session 3A</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>b25863ac-b766-4816-b3b3-3eb6deef208f</slot_id>
      <title>Session: SAS - Session 3A</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>4c2c99b5-3d0d-4047-ab73-022061aab228</slot_id>
      <event_id>8ba2c7e3-b473-4cc6-978b-cb5e94764f5e</event_id>
      <title>Verified Functional Programming of an Abstract Interpreter</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>22:10</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:30</end_time>
      <description>Abstract interpreters are complex pieces of software: even if the abstract interpretation theory and companion algorithms are well understood, their implementations are subject to bugs, that might question the soundness of their computations. 
While some formally verified abstract interpreters have been written in the past, writing and understanding them requires expertise in the use of proof assistants, and requires a non-trivial amount of interactive proofs. 
This paper presents a formally verified abstract interpreter fully programmed and proved correct in the F* verified programming environment. Thanks to F* refinement types and SMT prover capabilities we demonstrate a substantial saving in proof effort compared to previous works based on interactive proofs assistants. Almost all the code of our implementation, proofs included, written in a functional style, are presented directly in the paper.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Franceschino</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://lucas.franceschino.fr</homepage_url>
          <person_id>lucasfranceschino</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Pichardie</last_name>
          <affiliation>Univ Rennes, ENS Rennes, IRISA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/celtique/pichardie/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidpichardie/b0f30e9b-c1d3-4e4f-9923-4cf150989f86/small.jpg</picture_url>
          <person_id>davidpichardie</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean-Pierre</first_name>
          <last_name>Talpin</last_name>
          <affiliation>INRIA, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/prive/talpin</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeanpierretalpin/b5285496-0c64-4e5e-8ce5-f162f8f92881/small.jpg</picture_url>
          <person_id>jeanpierretalpin</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>b403fcab-8a79-4d94-90b7-6e9b2e784064</slot_id>
      <event_id>e8cf7f79-77ce-44b2-b4fd-a19e24245cc6</event_id>
      <title>Data Abstraction: A General Framework to Handle Program Verification of Data Structures</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>22:30</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:50</end_time>
      <description>Proving properties on programs operating over arrays, or array-like data structures, most often involves universally quantified invariants, e.g., “all elements below index i are nonzero”. In this article, we propose a general data abstraction scheme operating on Horn Formula for which we provide a relative completeness resolution scheme: the generated purely scalar invariant search problem has a solution if and only if the original problem has one expressible by the abstraction.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julien</first_name>
          <last_name>Braine</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julienbraine</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laure</first_name>
          <last_name>Gonnord</last_name>
          <affiliation>University of Lyon &amp; LIP, France</affiliation>
          <bio>Laure Gonnord received her PhD degree in computer science from the University Joseph Fourier (Grenoble, France), in 2007. She currently holds an assistant professor position at University Lyon I/UCBL, France. She got her Habilitation in 2017. 
Her main research interests lie in the design of static analyses, with emphasis on the automatic synthesis of numerical and memory invariants and application in compilation (scheduling) and termination proofs. She belongs to the CASH team of the LIP laboratory (ENS de Lyon, France).</bio>
          <homepage_url>http://laure.gonnord.org/pro</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lauregonnord/6b741986-7933-4cba-9205-8e5e8451d8fa/small.jpg</picture_url>
          <person_id>lauregonnord</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Monniaux</last_name>
          <affiliation>CNRS/VERIMAG</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-verimag.imag.fr/~monniaux/</homepage_url>
          <person_id>davidmonniaux1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>e321d0c3-4d2f-4e30-bcdf-96ffc3f80226</slot_id>
      <event_id>55890513-6497-44fd-a3a9-838f69361366</event_id>
      <title>Static Analysis of Endian Portability by Abstract Interpretation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>22:10</end_time>
      <description>We present a static analysis of endian portability for C programs. Our analysis can infer that a given program, or two syntactically close versions thereof, compute the same outputs, when run with the same inputs on platforms with different byte-orders, a.k.a. endiannesses. We target low-level C programs that abuse C pointers and unions, hence rely on implementation-specific behaviors undefined in the C standard. Our method is based on abstract interpretation, and parametric in the choice of a numerical abstract domain. We first present a novel concrete collecting semantics, relating the behaviors of two versions of a program, running on platforms with different endiannesses. We propose a joint memory abstraction, able to infer equivalence relations between little- and big-endian memories. We introduce a novel symbolic predicate domain, to infer relations between individual bytes of the variables in the two programs, which has near-linear cost, and the right amount of relationality to express (bitwise) arithmetic properties relevant to endian portability. We implemented a prototype static analyzer, able to scale to large real-world industrial software, with zero false alarms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Delmas</last_name>
          <affiliation>Airbus &amp; Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.di.ens.fr/~delmas/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/daviddelmas/c73d6e1c-9527-4287-b059-67e4e36354c8/small.jpg</picture_url>
          <person_id>daviddelmas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Abdelraouf</first_name>
          <last_name>Ouadjaout</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~ouadjaout/</homepage_url>
          <person_id>abdelraoufouadjaout</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Miné</last_name>
          <affiliation>Sorbonne Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www-apr.lip6.fr/~mine/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/antoinemine/77e18473-3b05-4bec-8b27-3e073a24fb34/small.jpg</picture_url>
          <person_id>antoinemine</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c95bd3c4-aa9a-4179-9db6-69d3844a6684</subevent_id>
    <title>SAS: Session 4A</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/17</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>9350c359-a249-4133-ab89-5389e608eb03</slot_id>
      <title>Session: SAS - Session 4A</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cd7dd05e-a07a-4821-b747-2aee6458743a</slot_id>
      <event_id>7e2633f1-97fd-426d-a081-22c7758eefa7</event_id>
      <title>Oracle Parfait: The Flavour of Real-World Vulnerability Detection and Intelligent Configuration</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/17</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/17</end_date>
      <end_time>17:00</end_time>
      <description>The Parfait static code analysis tool focuses on detecting vulnerabilities that matter in C, C++, Java and Python languages. Its focus has been on key items expected out of a commercial tool that lives in a commercial organisation, namely, precision of results (i.e., high true positive rate), scalability (i.e., being able to run quickly over millions of lines of code), incremental analysis (i.e., being able to run over deltas of the code quickly), and usability (i.e., ease of integration into standard build processes, reporting of traces to the vulnerable location, etc). Today, Parfait is used by thousands of developers at Oracle worldwide on a day-to-day basis. In this presentation we’ll sample a flavour of Parfait – we explore some real world challenges faced in the creation of a robust vulnerability detection tool, look into two examples of vulnerabilities that severely affected the Java platform in 2012/2013 and most machines since 2017, and con- clude by recounting what matters to developers for integration into to- days continuous integration and continuous delivery (CI/CD) pipelines. Key to deployment of static code analysis tools is configuration of the tool itself – we present our experiences with use of machine learning to automatically configure the tool, providing users with a better out-of-the-box experience.</description>
      <persons>
        <person>
          <role>Invited Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Cristina</first_name>
          <last_name>Cifuentes</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://labs.oracle.com/people/cristina</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/cristinacifuentes/d6962ceb-c967-49bf-8a95-34899c2d8863/small.jpg</picture_url>
          <person_id>cristinacifuentes</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge>Invited Talk</badge>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9344fa09-2c30-4eb7-a240-a699ef4a6a3a</subevent_id>
    <title>SAS: Session 4B</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/18</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>6dd83f9f-aacc-480c-b680-f6209eec2dfd</slot_id>
      <title>Session: SAS - Session 4B</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>2fc05924-79c8-4da2-8514-bc49c7a85afa</slot_id>
      <event_id>e9f054af-c0e2-4c0e-9e9d-3e223f756061</event_id>
      <title>Backward Symbolic Execution with Loop Folding</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>08:00</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>08:20</end_time>
      <description>Symbolic execution is an established program analysis technique that aims to search all possible execution paths starting in the initial program location. Due to the so-called path explosion problem, symbolic execution is usually unable to analyze all execution paths and thus it is not convenient for program verification as a standalone method. This paper focuses on backward symbolic execution (BSE), which searches program paths backward from the error location whose reachability should be proven or refuted. We show that this technique is equivalent to performing k-induction on control-flow paths. While standard BSE simply unwinds all program loops, we present an extension called loop folding that aims to derive loop invariants during BSE that are sufficient to prove the unreachability of the error location. The resulting technique called backward symbolic execution with loop folding (BSELF) can infer disjunctive loop invariants that are hard to derive for current techniques. Indeed, our experiments show that BESLF can verify some standard benchmarks that cannot be verified by state-of-the-art tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marek</first_name>
          <last_name>Chalupa</last_name>
          <affiliation>Masaryk University</affiliation>
          <bio>undefined</bio>
          <person_id>marekchalupa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Strejcek</last_name>
          <affiliation>Masaryk University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.fi.muni.cz/~xstrejc/</homepage_url>
          <person_id>janstrejcek</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>7ba8b1c7-a7bc-4be9-a0e1-ea022bca2762</slot_id>
      <event_id>6086e00a-20aa-4a82-b0ff-a48a99c3a839</event_id>
      <title>Improving Thread-Modular Abstract Interpretation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>08:20</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>08:40</end_time>
      <description>We give thread-modular non-relational value analyses as abstractions of a local trace semantics. The semantics as well as the analyses are formulated by means of global invariants and side-effecting constraint systems. We show that a generalization of the analysis provided by the static analyzer Goblint as well as a natural improvement of Antoine Miné’s approach can be obtained as instances of this general scheme. We show that these two analyses are incomparable w.r.t. precision and provide a refinement which improves on both precision-wise. We also report on a preliminary experimental comparison of the given analyses on a meaningful suite of benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Schwarz</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.in.tum.de/i02/personen/michael-schwarz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelschwarz/d579481e-b407-434d-9f91-04548d70b912/small.jpg</picture_url>
          <person_id>michaelschwarz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Saan</last_name>
          <affiliation>University of Tartu, Estonia</affiliation>
          <bio>undefined</bio>
          <person_id>simonsaan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Helmut</first_name>
          <last_name>Seidl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.in.tum.de/~seidl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/helmutseidl/2dcd593b-82c2-48ee-b042-87ebd49b4379/small.jpg</picture_url>
          <person_id>helmutseidl</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kalmer</first_name>
          <last_name>Apinis</last_name>
          <affiliation>University of Tartu, Estonia</affiliation>
          <bio>undefined</bio>
          <person_id>kalmerapinis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Julian</first_name>
          <last_name>Erhard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>julianerhard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Vesal</first_name>
          <last_name>Vojdani</last_name>
          <affiliation>University of Tartu</affiliation>
          <bio>undefined</bio>
          <person_id>vesalvojdani</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>b9886349-3eea-44ce-adb1-a4e679dc5a9b</slot_id>
      <event_id>64e069c6-2609-4d24-a969-3dc6d81d48fe</event_id>
      <title>Symbolic Automatic Relations and Their Applications to SMT and CHC Solving</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>09:00</end_time>
      <description>Despite the recent advance of automated program verification, reasoning about recursive data structures remains as a challenge for verification tools and their backends such as SMT and CHC solvers. To address the challenge, we introduce the notion of symbolic automatic relations (SARs), which combines symbolic automata and automatic relations, and inherits their good properties such as the closure under Boolean operations. We consider the satisfiability problem for SARs, and show that it is undecidable in general, but that we can construct a sound (but incomplete) and automated satisfiability checker by a reduction to CHC solving. We discuss applications to SMT and CHC solving on data structures, and show the effectiveness of our approach through experiments.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Takumi</first_name>
          <last_name>Shimoda</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>takumishimoda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ken</first_name>
          <last_name>Sakayori</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>kensakayori</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ryosuke</first_name>
          <last_name>Sato</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-kb.is.s.u-tokyo.ac.jp/~ryosuke/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ryosukesato/dde2fccf-e07f-48f8-9dc9-277cb124e664/small.jpg</picture_url>
          <person_id>ryosukesato</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>d78336cf-4bb1-440f-995d-3ce22cbdca18</slot_id>
      <event_id>60f4fa55-a96f-4db6-9954-a94ad5243bcc</event_id>
      <title>Automated Verification of the Parallel Bellman--Ford Algorithm</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/18</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/18</end_date>
      <end_time>08:00</end_time>
      <description>Many real-world problems such as internet routing are actually graph problems. To develop efficient solutions to such problems, more and more parallel graph algorithms are proposed. This paper discusses the mechanized verification of a commonly used parallel graph algorithm, namely the Bellman–Ford algorithm, which provides an inherently parallel solution to the Single-Source Shortest Path problem. Concretely, we verify an unoptimized GPU version of the Bellman–Ford algorithm, using the VerCors verifier. The main challenge that we had to address was to find suitable global invariants of the graph-based properties for automated verification. This case study is the first deductive verification to prove functional correctness of the parallel Bellman–Ford algorithm. It provides the basis to verify other, optimized implementations of the algorithm. Moreover, it may also provide a good starting point to verify other parallel graph-based algorithms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohsen</first_name>
          <last_name>Safari</last_name>
          <affiliation>University of Twente, The Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.utwente.nl/m.safari</homepage_url>
          <person_id>mohsensafari</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wytse</first_name>
          <last_name>Oortwijn</last_name>
          <affiliation>ETH Zurich, Switzerland</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wwwhome.ewi.utwente.nl/~oortwijnwhm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wytseoortwijn/079f1ba3-77ed-4f76-93e5-136adc3b291e/small.jpg</picture_url>
          <person_id>wytseoortwijn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marieke</first_name>
          <last_name>Huisman</last_name>
          <affiliation>University of Twente</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wwwhome.cs.utwente.nl/~marieke/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mariekehuisman/22505ee7-e6f4-4999-abda-0c8325ff501f/small.jpg</picture_url>
          <person_id>mariekehuisman</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8339f483-572e-4fab-834f-434747ecc851</subevent_id>
    <title>SAS: Session 3C</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>d752c28f-b15a-4cda-9ef4-f75beea4b416</slot_id>
      <title>Session: SAS - Session 3C</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>205d43bf-75dd-4100-bc46-c146fe4e5fac</slot_id>
      <event_id>08c40c54-313a-4b25-88d0-c5d351b1521f</event_id>
      <title>Disjunctive Interval Analysis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>14:10</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:30</end_time>
      <description>We revisit disjunctive interval analysis based on the Boxes abstract domain. We propose the use of what we call range decision diagrams (RDDs) to implement Boxes, and we provide algorithms for the necessary RDD operations. RDDs tend to be more compact than the linear decision diagrams (LDDs) that have traditionally been used for Boxes. Representing information more directly, RDDs also allow for the implementation of more accurate abstract operations. This comes at no cost in terms of analysis efficiency, whether LDDs utilise dynamic variable ordering or not. RDD and LDD implementations are available in the Crab analyzer, and our experiments confirm that RDDs are well suited for disjunctive interval analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Graeme</first_name>
          <last_name>Gange</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>graemegange</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Navas</last_name>
          <affiliation>SRI International</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jorgenavas.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgeanavas/662b4942-5460-4898-98cd-2c4e2c701960/small.jpg</picture_url>
          <person_id>jorgeanavas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Schachte</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>peterschachte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Harald</first_name>
          <last_name>Sondergaard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>haraldsondergaard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Peter J.</first_name>
          <last_name>Stuckey</last_name>
          <affiliation>Monash University</affiliation>
          <bio>undefined</bio>
          <person_id>peterjstuckey</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>3a353b90-3292-4e16-af98-631785a4708a</slot_id>
      <event_id>2c3eebff-50b9-4105-85f2-b8ccbd1eed98</event_id>
      <title>Automatic Synthesis of Data-Flow Analyzers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:10</end_time>
      <description>Data-flow analyzers (DFAs) are widely deployed in many stages of software development, such as compiler optimization, bug detection, and program verification. Automating their synthesis is non-trivial but will be practically beneficial. In this paper, we propose DFASy, a framework for the automatic synthesis of DFAs. Given a specification consisting of a control flow graph and the expected data-flow facts before and after each of its nodes, DFASy automatically synthesizes a DFA that satisfies the specification, including its flow direction, meet operator, and transfer function. DFASy synthesizes transfer functions by working with a domain-specific language that supports rich data-flow fact extraction operations, set operations, and logic operations. To avoid exploding the search space, we introduce an abstraction-guided pruning technique to assess the satisfiability of partially instantiated candidates and drop unsatisfiable ones from further consideration as early as possible. In addition, we also introduce a brevity-guided pruning technique to improve the readability and simplicity of synthesized DFAs and further accelerate the search. We have built a benchmark suite, which consists of seven classic (e.g., live variable analysis and null pointer detection) and seven custom data-flow problems. DFASy has successfully solved all the 14 data-flow problems in 21.8 seconds on average, outperforming significantly the three baselines compared. Both DFASy and its associated benchmark suite will be open-sourced.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xuezheng</first_name>
          <last_name>Xu</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>I am a Ph.D. student (September 2017 - now) at UNSW Sydney (Supervisor: Prof.Jingling Xue, Co-Supervisor: Dr. Yulei Sui).</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~xuezhengxu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xuezhengxu/bcb2bb20-169f-4a68-97d3-c9afd426cd41/small.jpg</picture_url>
          <person_id>xuezhengxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xudong</first_name>
          <last_name>Wang</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/xudongwang3/e554e2c0-70d7-4da6-9d2f-4d3d7607cb66/small.jpg</picture_url>
          <person_id>xudongwang3</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Xue</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~jingling/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jinglingxue/1045ace0-547f-4dc6-b960-79be78997c50/small.jpg</picture_url>
          <person_id>jinglingxue</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>a42f2ceb-a178-429f-ae15-9bd49b9c19d3</slot_id>
      <event_id>0a214e99-fc0c-4b38-ad7b-7b27f94df17b</event_id>
      <title>Hash Consed Points-To Sets</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>14:30</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>14:50</end_time>
      <description>Points-to analysis is a fundamental static analysis, on which many other analyses and optimisations are built. The goal of points-to analysis is to statically approximate the set of abstract objects that a pointer can point to at runtime. Due to the nature of static analysis, points-to analysis introduces much redundancy which can result in duplicate points-to sets and duplicate set union operations, particularly when analysing large programs precisely. To improve performance, there has been extensive effort in mitigating duplication at the algorithmic level through, for example, cycle elimination and variable substitution. 
Unlike previous approaches which make algorithmic changes to points-to analysis, this work aims to improve the underlying data structure, which is less studied. Inspired by hash consing from the functional programming community, this paper introduces the use of hash consed points-to sets to reduce the effects of this duplication on both space and time without any high-level algorithmic change. Hash consing can effectively handle duplicate points-to set by representing points-to sets once, and referring to such representations through references, and can speed up duplicate union operations through efficient memoisation. We have implemented and evaluated our approach using 16 real-world C/C++ programs (more than 9.5 million lines of LLVM instructions). Our results show that our approach speeds up state-of-the-art Andersen’s analysis by 1.86× on average (up to 3.21×) and staged flow-sensitive analysis (SFS) by 1.69× on average (up to 2.23×). We also observe an average ≥4.93× (up to ≥15.52×) memory usage reduction in SFS.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohamad</first_name>
          <last_name>Barbar</last_name>
          <affiliation>University of Technology Sydney, Australia and CSIRO's Data61, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mbarbar.net</homepage_url>
          <person_id>mohamadbarbar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>dbe89066-2d84-4214-83d9-4d6de88e8da5</slot_id>
      <event_id>90b4e2a4-4af7-4e89-aa86-9d042700e863</event_id>
      <title>Selective Context-Sensitivity for k-CFA with CFL-Reachability</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>15:10</end_time>
      <description>k-CFA provides the most well-known context abstraction for program analysis, especially pointer analysis, for a wide range of programming languages. However, its inherent context explosion problem has hindered its applicability. To mitigate this problem, selective context-sensitivity is promising as context-sensitivity is applied only selectively to some parts of the program. This paper introduces a new approach to selective context-sensitivity for supporting k-CFA-based pointer analysis, based on CFL-reachability. Our approach can make k-CFA-based pointer analysis run significantly faster while losing little precision, based on an evaluation using a set of 11 popular Java benchmarks and applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jingbo</first_name>
          <last_name>Lu</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>jingbolu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dongjie</first_name>
          <last_name>He</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>dongjiehe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Xue</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~jingling/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jinglingxue/1045ace0-547f-4dc6-b960-79be78997c50/small.jpg</picture_url>
          <person_id>jinglingxue</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2092679f-60e5-4051-9def-54e2324a0080</subevent_id>
    <title>SAS: Session 3C</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>9bb48f44-48a8-4897-9ff5-6deaeabf6ff4</slot_id>
      <title>Session: SAS - Session 3C</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>251ef49a-a302-4165-9f86-4290fff8f9d9</slot_id>
      <event_id>0a214e99-fc0c-4b38-ad7b-7b27f94df17b</event_id>
      <title>Hash Consed Points-To Sets</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>22:30</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>22:50</end_time>
      <description>Points-to analysis is a fundamental static analysis, on which many other analyses and optimisations are built. The goal of points-to analysis is to statically approximate the set of abstract objects that a pointer can point to at runtime. Due to the nature of static analysis, points-to analysis introduces much redundancy which can result in duplicate points-to sets and duplicate set union operations, particularly when analysing large programs precisely. To improve performance, there has been extensive effort in mitigating duplication at the algorithmic level through, for example, cycle elimination and variable substitution. 
Unlike previous approaches which make algorithmic changes to points-to analysis, this work aims to improve the underlying data structure, which is less studied. Inspired by hash consing from the functional programming community, this paper introduces the use of hash consed points-to sets to reduce the effects of this duplication on both space and time without any high-level algorithmic change. Hash consing can effectively handle duplicate points-to set by representing points-to sets once, and referring to such representations through references, and can speed up duplicate union operations through efficient memoisation. We have implemented and evaluated our approach using 16 real-world C/C++ programs (more than 9.5 million lines of LLVM instructions). Our results show that our approach speeds up state-of-the-art Andersen’s analysis by 1.86× on average (up to 3.21×) and staged flow-sensitive analysis (SFS) by 1.69× on average (up to 2.23×). We also observe an average ≥4.93× (up to ≥15.52×) memory usage reduction in SFS.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohamad</first_name>
          <last_name>Barbar</last_name>
          <affiliation>University of Technology Sydney, Australia and CSIRO's Data61, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mbarbar.net</homepage_url>
          <person_id>mohamadbarbar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>54730bda-14ee-4e3f-8457-71bcb959d2ea</slot_id>
      <event_id>2c3eebff-50b9-4105-85f2-b8ccbd1eed98</event_id>
      <title>Automatic Synthesis of Data-Flow Analyzers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>22:10</end_time>
      <description>Data-flow analyzers (DFAs) are widely deployed in many stages of software development, such as compiler optimization, bug detection, and program verification. Automating their synthesis is non-trivial but will be practically beneficial. In this paper, we propose DFASy, a framework for the automatic synthesis of DFAs. Given a specification consisting of a control flow graph and the expected data-flow facts before and after each of its nodes, DFASy automatically synthesizes a DFA that satisfies the specification, including its flow direction, meet operator, and transfer function. DFASy synthesizes transfer functions by working with a domain-specific language that supports rich data-flow fact extraction operations, set operations, and logic operations. To avoid exploding the search space, we introduce an abstraction-guided pruning technique to assess the satisfiability of partially instantiated candidates and drop unsatisfiable ones from further consideration as early as possible. In addition, we also introduce a brevity-guided pruning technique to improve the readability and simplicity of synthesized DFAs and further accelerate the search. We have built a benchmark suite, which consists of seven classic (e.g., live variable analysis and null pointer detection) and seven custom data-flow problems. DFASy has successfully solved all the 14 data-flow problems in 21.8 seconds on average, outperforming significantly the three baselines compared. Both DFASy and its associated benchmark suite will be open-sourced.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xuezheng</first_name>
          <last_name>Xu</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>I am a Ph.D. student (September 2017 - now) at UNSW Sydney (Supervisor: Prof.Jingling Xue, Co-Supervisor: Dr. Yulei Sui).</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~xuezhengxu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xuezhengxu/bcb2bb20-169f-4a68-97d3-c9afd426cd41/small.jpg</picture_url>
          <person_id>xuezhengxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xudong</first_name>
          <last_name>Wang</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/xudongwang3/e554e2c0-70d7-4da6-9d2f-4d3d7607cb66/small.jpg</picture_url>
          <person_id>xudongwang3</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Xue</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~jingling/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jinglingxue/1045ace0-547f-4dc6-b960-79be78997c50/small.jpg</picture_url>
          <person_id>jinglingxue</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>8889a918-8614-4f1e-a6df-48fbffcf2d62</slot_id>
      <event_id>08c40c54-313a-4b25-88d0-c5d351b1521f</event_id>
      <title>Disjunctive Interval Analysis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>22:10</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>22:30</end_time>
      <description>We revisit disjunctive interval analysis based on the Boxes abstract domain. We propose the use of what we call range decision diagrams (RDDs) to implement Boxes, and we provide algorithms for the necessary RDD operations. RDDs tend to be more compact than the linear decision diagrams (LDDs) that have traditionally been used for Boxes. Representing information more directly, RDDs also allow for the implementation of more accurate abstract operations. This comes at no cost in terms of analysis efficiency, whether LDDs utilise dynamic variable ordering or not. RDD and LDD implementations are available in the Crab analyzer, and our experiments confirm that RDDs are well suited for disjunctive interval analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Graeme</first_name>
          <last_name>Gange</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>graemegange</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Navas</last_name>
          <affiliation>SRI International</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jorgenavas.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jorgeanavas/662b4942-5460-4898-98cd-2c4e2c701960/small.jpg</picture_url>
          <person_id>jorgeanavas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Schachte</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>peterschachte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Harald</first_name>
          <last_name>Sondergaard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>haraldsondergaard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Peter J.</first_name>
          <last_name>Stuckey</last_name>
          <affiliation>Monash University</affiliation>
          <bio>undefined</bio>
          <person_id>peterjstuckey</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>c72a7717-94a5-4923-a5d8-bca70aacf88e</slot_id>
      <event_id>90b4e2a4-4af7-4e89-aa86-9d042700e863</event_id>
      <title>Selective Context-Sensitivity for k-CFA with CFL-Reachability</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>23:10</end_time>
      <description>k-CFA provides the most well-known context abstraction for program analysis, especially pointer analysis, for a wide range of programming languages. However, its inherent context explosion problem has hindered its applicability. To mitigate this problem, selective context-sensitivity is promising as context-sensitivity is applied only selectively to some parts of the program. This paper introduces a new approach to selective context-sensitivity for supporting k-CFA-based pointer analysis, based on CFL-reachability. Our approach can make k-CFA-based pointer analysis run significantly faster while losing little precision, based on an evaluation using a set of 11 popular Java benchmarks and applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jingbo</first_name>
          <last_name>Lu</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>jingbolu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dongjie</first_name>
          <last_name>He</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>undefined</bio>
          <person_id>dongjiehe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Xue</last_name>
          <affiliation>UNSW Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~jingling/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jinglingxue/1045ace0-547f-4dc6-b960-79be78997c50/small.jpg</picture_url>
          <person_id>jinglingxue</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0175770f-85a8-40a2-8563-60075e61515a</subevent_id>
    <title>SAS: Session 4C</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>58fd6cb9-d999-4dfb-8cb6-695ff6d700bc</slot_id>
      <title>Session: SAS - Session 4C</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>2c3b1cae-5b56-41bd-b73a-834db45a08c7</slot_id>
      <event_id>0a69e561-77a5-4b4d-88c5-de8c3a0dd7d2</event_id>
      <title>Fast and Efficient Bit-Level Precision Tuning</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>08:00</end_time>
      <description>In this article, we introduce a new technique for precision tuning. This problem consists of finding the least data types for numerical values such that the result of the computation satisfies some accuracy requirement. State of the art techniques for precision tuning use a try and fail approach. They change the data types of some variables of the program and evaluate the accuracy of the result. Depending on what is obtained, they change more or less data types and repeat the process. Our technique is radically different. Based on semantic equations, we generate an Integer Linear Problem (ILP) from the program source code. Basically, this is done by reasoning on the most significant bit and the number of significant bits of the values which are integer quantities. The integer solution to this problem, computed in polynomial time by a classical linear programming solver, gives the optimal data types at the bit level. A finer set of semantic equations is also proposed which does not reduce directly to an ILP problem. So we use policy iteration to find the solution. Both techniques have been implemented and we show that our results encompass the results of state-of-the-art tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Assalé</first_name>
          <last_name>Adjé</last_name>
          <affiliation>Université de Perpignan Via Domitia</affiliation>
          <bio>undefined</bio>
          <person_id>assaleadje</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dorra</first_name>
          <last_name>Ben Khalifa</last_name>
          <affiliation>Université de Perpignan Via Domitia</affiliation>
          <bio>undefined</bio>
          <person_id>dorrabenkhalifa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Martel</last_name>
          <affiliation>Université de Perpignan Via Domitia</affiliation>
          <bio>undefined</bio>
          <person_id>matthieumartel</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>73600e84-1ade-4172-a0a9-120fd2500442</slot_id>
      <event_id>fb0761d9-16c7-4e3e-93d8-8a386f88a71d</event_id>
      <title>Reduced Products of Abstract Domains for Fairness Certification of Neural Networks</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>08:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>08:20</end_time>
      <description>We present Tool, an open-source abstract interpretation-based static analyzer for certifying fairness of ReLU neural network classifiers for tabular data. Tool combines a sound forward pre-analysis with an exact backward analysis that leverages the polyhedra abstract domain to provide definite fairness guarantees when possible, and to otherwise quantify and describe the biased input space regions. The analysis is configurable in terms of scalability and precision. We equipped Tool with new abstract domains to use in the pre-analysis, including a generic reduced product domain construction, as well as search heuristics to find the best analysis configuration. We additionally set up the backward analysis to allow further parallelization. Our experimental evaluation demonstrates the effectiveness of the approach on neural networks trained on a popular dataset in the fairness literature.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Denis</first_name>
          <last_name>Mazzucato</last_name>
          <affiliation>INRIA &amp; École Normale Supérieure</affiliation>
          <bio>undefined</bio>
          <person_id>denismazzucato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Caterina</first_name>
          <last_name>Urban</last_name>
          <affiliation>INRIA &amp; École Normale Supérieure | Université PSL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://caterinaurban.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/caterinaurban1/a945f9bd-bc13-4fe2-945a-59528d7d7e2a/small.jpg</picture_url>
          <person_id>caterinaurban1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>b7294443-2e99-4c83-9946-50a0c65409ee</slot_id>
      <event_id>4c218694-b052-4c87-9e69-81d7076e6850</event_id>
      <title>Static analysis of ReLU neural networks with tropical polyhedra</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>08:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>08:40</end_time>
      <description>This paper studies the problem of range analysis for feedforward neural networks, which is a basic primitive for applications such as robustness of neural networks, compliance to specifications and reachability analysis of neural-network feedback systems. Our approach focuses on ReLU (rectified linear unit) feedforward neural nets that present specific difficulties: approaches that exploit derivatives do not apply in general, the number of patterns of neuron activations can be quite large even for small networks, and convex approximations are generally too coarse. In this paper, we employ set-based methods and abstract interpretation that have been very successful in coping with similar difficulties in classical program verification. We present an approach that abstracts ReLU feedforward neural networks using tropical polyhedra. We show that tropical polyhedra can efficiently abstract ReLU activation function, while being able to control the loss of precision due to linear computations. We show how the connection between ReLU networks and tropical rational functions can provide approaches for range analysis of ReLU neural networks. We report on a preliminary evaluation of our approach using a prototype implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Goubault</last_name>
          <affiliation>Ecole Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>ericgoubault</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastien</first_name>
          <last_name>Palumby</last_name>
          <affiliation>Ecole Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>sebastienpalumby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sylvie</first_name>
          <last_name>Putot</last_name>
          <affiliation>École Polytechnique</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lix.polytechnique.fr/Labo/Sylvie.Putot/</homepage_url>
          <person_id>sylvieputot</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Louis</first_name>
          <last_name>Rustenholz</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>louisrustenholz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Sankaranarayanan</last_name>
          <affiliation>University of Colorado, Boulder</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.colorado.edu/~srirams/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sriramsankaranarayanan/cc1e5234-6137-4a38-8d5d-3fac7abb93eb/small.jpg</picture_url>
          <person_id>sriramsankaranarayanan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>ba67ac56-3438-4564-ba07-b870def25c47</slot_id>
      <event_id>e6d9543d-594e-4e03-83e7-6464df6cc24e</event_id>
      <title>Toward Neural-Network-Guided Program Synthesis and Verification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>09:00</end_time>
      <description>We propose a novel framework of program and invariant synthesis called neural network-guided synthesis. We first show that, by suitably designing and training neural networks, we can extract logical formulas over integers from the weights and biases of the trained neural networks. Based on the idea, we have implemented a tool to synthesize formulas from positive/negative examples and implication constraints, and obtained promising experimental results. We also discuss an application of our method for improving the qualifier discovery in the framework of ICE-learning-based CHC solving, which can in turn be applied to program verification and inductive invariant synthesis. Another potential application is to a neural-network-guided variation of Solar-Lezama’s program synthesis by sketching.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Taro</first_name>
          <last_name>Sekiyama</last_name>
          <affiliation>National Institute of Informatics</affiliation>
          <bio>I’m an assistant professor at National Institute of Informatics in Japan. I am interested in theory and applications of programming languages, such as type theory, program verification, type inference, program reasoning, and so on.</bio>
          <homepage_url>https://researchmap.jp/t-sekiym/?lang=english</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tarosekiyama/dd6fb4ca-8161-4bbd-9392-01e4b94374e6/small.jpg</picture_url>
          <person_id>tarosekiyama</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Issei</first_name>
          <last_name>Sato</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>isseisato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hiroshi</first_name>
          <last_name>Unno</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tsukuba.ac.jp/~uhiro/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hiroshiunno/c5c1b748-082d-4abd-93f0-dbebf6ab1d98/small.jpg</picture_url>
          <person_id>hiroshiunno</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ee0239b6-cba1-4049-8701-8fea6f98f165</subevent_id>
    <title>SAS: Session 4C</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/19</date>
    <url>https://conf.researchr.org/home/sas-2021</url>
    <url_link_display>SAS 2021 - 28th Static Analysis Symposium</url_link_display>
    <tracks>
      <track>SAS 2021 - 28th Static Analysis Symposium</track>
    </tracks>
    <timeslot>
      <slot_id>de46c75f-0caf-4f97-aa56-ce72c5e02419</slot_id>
      <title>Session: SAS - Session 4C</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>601927dc-aa10-4069-a631-75e2d89cc5c6</slot_id>
      <event_id>fb0761d9-16c7-4e3e-93d8-8a386f88a71d</event_id>
      <title>Reduced Products of Abstract Domains for Fairness Certification of Neural Networks</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>16:00</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:20</end_time>
      <description>We present Tool, an open-source abstract interpretation-based static analyzer for certifying fairness of ReLU neural network classifiers for tabular data. Tool combines a sound forward pre-analysis with an exact backward analysis that leverages the polyhedra abstract domain to provide definite fairness guarantees when possible, and to otherwise quantify and describe the biased input space regions. The analysis is configurable in terms of scalability and precision. We equipped Tool with new abstract domains to use in the pre-analysis, including a generic reduced product domain construction, as well as search heuristics to find the best analysis configuration. We additionally set up the backward analysis to allow further parallelization. Our experimental evaluation demonstrates the effectiveness of the approach on neural networks trained on a popular dataset in the fairness literature.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Denis</first_name>
          <last_name>Mazzucato</last_name>
          <affiliation>INRIA &amp; École Normale Supérieure</affiliation>
          <bio>undefined</bio>
          <person_id>denismazzucato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Caterina</first_name>
          <last_name>Urban</last_name>
          <affiliation>INRIA &amp; École Normale Supérieure | Université PSL</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://caterinaurban.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/caterinaurban1/a945f9bd-bc13-4fe2-945a-59528d7d7e2a/small.jpg</picture_url>
          <person_id>caterinaurban1</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>a072597d-70d3-4843-892d-9870ad6cce6b</slot_id>
      <event_id>e6d9543d-594e-4e03-83e7-6464df6cc24e</event_id>
      <title>Toward Neural-Network-Guided Program Synthesis and Verification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>17:00</end_time>
      <description>We propose a novel framework of program and invariant synthesis called neural network-guided synthesis. We first show that, by suitably designing and training neural networks, we can extract logical formulas over integers from the weights and biases of the trained neural networks. Based on the idea, we have implemented a tool to synthesize formulas from positive/negative examples and implication constraints, and obtained promising experimental results. We also discuss an application of our method for improving the qualifier discovery in the framework of ICE-learning-based CHC solving, which can in turn be applied to program verification and inductive invariant synthesis. Another potential application is to a neural-network-guided variation of Solar-Lezama’s program synthesis by sketching.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.kb.is.s.u-tokyo.ac.jp/~koba/</homepage_url>
          <person_id>naokikobayashi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Taro</first_name>
          <last_name>Sekiyama</last_name>
          <affiliation>National Institute of Informatics</affiliation>
          <bio>I’m an assistant professor at National Institute of Informatics in Japan. I am interested in theory and applications of programming languages, such as type theory, program verification, type inference, program reasoning, and so on.</bio>
          <homepage_url>https://researchmap.jp/t-sekiym/?lang=english</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tarosekiyama/dd6fb4ca-8161-4bbd-9392-01e4b94374e6/small.jpg</picture_url>
          <person_id>tarosekiyama</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Issei</first_name>
          <last_name>Sato</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <person_id>isseisato</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hiroshi</first_name>
          <last_name>Unno</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tsukuba.ac.jp/~uhiro/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hiroshiunno/c5c1b748-082d-4abd-93f0-dbebf6ab1d98/small.jpg</picture_url>
          <person_id>hiroshiunno</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>acd5e4ce-04e5-4485-a3e4-838366c76d16</slot_id>
      <event_id>0a69e561-77a5-4b4d-88c5-de8c3a0dd7d2</event_id>
      <title>Fast and Efficient Bit-Level Precision Tuning</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:00</end_time>
      <description>In this article, we introduce a new technique for precision tuning. This problem consists of finding the least data types for numerical values such that the result of the computation satisfies some accuracy requirement. State of the art techniques for precision tuning use a try and fail approach. They change the data types of some variables of the program and evaluate the accuracy of the result. Depending on what is obtained, they change more or less data types and repeat the process. Our technique is radically different. Based on semantic equations, we generate an Integer Linear Problem (ILP) from the program source code. Basically, this is done by reasoning on the most significant bit and the number of significant bits of the values which are integer quantities. The integer solution to this problem, computed in polynomial time by a classical linear programming solver, gives the optimal data types at the bit level. A finer set of semantic equations is also proposed which does not reduce directly to an ILP problem. So we use policy iteration to find the solution. Both techniques have been implemented and we show that our results encompass the results of state-of-the-art tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Assalé</first_name>
          <last_name>Adjé</last_name>
          <affiliation>Université de Perpignan Via Domitia</affiliation>
          <bio>undefined</bio>
          <person_id>assaleadje</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dorra</first_name>
          <last_name>Ben Khalifa</last_name>
          <affiliation>Université de Perpignan Via Domitia</affiliation>
          <bio>undefined</bio>
          <person_id>dorrabenkhalifa</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Martel</last_name>
          <affiliation>Université de Perpignan Via Domitia</affiliation>
          <bio>undefined</bio>
          <person_id>matthieumartel</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>e9b2cb4b-4d2a-4a3c-8e40-e9b4c2785e3e</slot_id>
      <event_id>4c218694-b052-4c87-9e69-81d7076e6850</event_id>
      <title>Static analysis of ReLU neural networks with tropical polyhedra</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/19</date>
      <start_time>16:20</start_time>
      <end_date>2021/10/19</end_date>
      <end_time>16:40</end_time>
      <description>This paper studies the problem of range analysis for feedforward neural networks, which is a basic primitive for applications such as robustness of neural networks, compliance to specifications and reachability analysis of neural-network feedback systems. Our approach focuses on ReLU (rectified linear unit) feedforward neural nets that present specific difficulties: approaches that exploit derivatives do not apply in general, the number of patterns of neuron activations can be quite large even for small networks, and convex approximations are generally too coarse. In this paper, we employ set-based methods and abstract interpretation that have been very successful in coping with similar difficulties in classical program verification. We present an approach that abstracts ReLU feedforward neural networks using tropical polyhedra. We show that tropical polyhedra can efficiently abstract ReLU activation function, while being able to control the loss of precision due to linear computations. We show how the connection between ReLU networks and tropical rational functions can provide approaches for range analysis of ReLU neural networks. We report on a preliminary evaluation of our approach using a prototype implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Goubault</last_name>
          <affiliation>Ecole Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>ericgoubault</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastien</first_name>
          <last_name>Palumby</last_name>
          <affiliation>Ecole Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>sebastienpalumby</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sylvie</first_name>
          <last_name>Putot</last_name>
          <affiliation>École Polytechnique</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lix.polytechnique.fr/Labo/Sylvie.Putot/</homepage_url>
          <person_id>sylvieputot</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Louis</first_name>
          <last_name>Rustenholz</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>louisrustenholz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Sankaranarayanan</last_name>
          <affiliation>University of Colorado, Boulder</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.colorado.edu/~srirams/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sriramsankaranarayanan/cc1e5234-6137-4a38-8d5d-3fac7abb93eb/small.jpg</picture_url>
          <person_id>sriramsankaranarayanan</person_id>
        </person>
      </persons>
      <tracks>
        <track>SAS 2021 - 28th Static Analysis Symposium</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>36500c80-ba51-44b3-9fcf-f771701a4cce</subevent_id>
    <title>SPLASH OOPSLA: Security - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>5ffde632-68d8-419b-856e-ab6b07b6653c</slot_id>
      <title>Session: SPLASH OOPSLA - Security - mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>1a4e2e8e-4a39-479c-99c4-a42919d24ab9</slot_id>
      <event_id>b8e58c10-44b0-4c96-94ba-19e9d23a0e86</event_id>
      <submission_id>141</submission_id>
      <title>SpecSafe: Detecting Cache Side Channels in a Speculative World</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:05</end_time>
      <description>The high-profile Spectre attack and its variants have revealed that speculative execution may leave secret-dependent footprints in the cache, allowing an attacker to learn confidential data. However, existing static side-channel detectors either ignore speculative execution, leading to false negatives, or lack a precise cache model, leading to false positives. In this paper, somewhat surprisingly, we show that it is challenging to develop a speculation-aware static analysis with precise cache models: a combination of existing works does not necessarily catch all cache side channels. Motivated by this observation, we present a new semantic definition of security against cache-based side-channel attacks, called Speculative-Aware noninterference (SANI), which is applicable to a variety of attacks and cache models. We also develop SpecSafe to detect the violations of SANI. Unlike other speculation-aware symbolic executors, SpecSafe employs a novel program transformation so that SANI can be soundly checked by speculation-unaware side-channel detectors. SpecSafe is shown to be both scalable and accurate on a set of moderately sized benchmarks, including commonly used cryptography libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Brotzman-Smith</last_name>
          <affiliation>Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>robertbrotzmansmith</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Danfeng</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.psu.edu/~dbz5017/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danfengzhang/6eb87743-0994-4ff3-be1e-dbfb34429946/small.jpg</picture_url>
          <person_id>danfengzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mahmut Taylan</first_name>
          <last_name>Kandemir</last_name>
          <affiliation>Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.psu.edu/~kandemir/</homepage_url>
          <person_id>mahmuttaylankandemir</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gang</first_name>
          <last_name>Tan</last_name>
          <affiliation>Penn State University</affiliation>
          <bio>Dr. Gang Tan is the James F. Will Career Development Associate Professor in Computer Science and Engineering at Pennsylvania State University, PA. He leads the Security of Software (SOS) Lab. His research is at the interface between computer security, programming languages, and formal methods. He received his bachelor’s degree in Computer Science with honors from Tsinghua University in 1999 and his Ph.D. degree from Princeton University in 2005. He has received an NSF CAREER award, two Google Research Awards, and a Francis Upton Graduate Fellowship.</bio>
          <homepage_url>http://www.cse.psu.edu/~gxt29/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gangtan/e101adef-54fb-4fcc-bce0-381da3d1aace/small.jpg</picture_url>
          <person_id>gangtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>2043c29b-cfc0-4a4f-a23a-c277bf4b865f</slot_id>
      <event_id>e1451bd2-8368-4f79-bdf9-aa3a7332f14e</event_id>
      <submission_id>190</submission_id>
      <title>Reconciling Optimization With Secure Compilation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>22:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:35</end_time>
      <description>Software protections against side-channel and physical attacks are essential to the development of secure applications. Such protections are meaningful at machine code or micro-architectural level, but they typically do not carry observable semantics at source level. This renders them susceptible to miscompilation, and security engineers embed input/output side-effects to prevent optimizing compilers from altering them. Yet these side-effects are error-prone and compiler-dependent. The current practice involves analyzing the generated machine code to make sure security or privacy properties are still enforced. These side-effects may also be too expensive in fine-grained protections such as control-flow integrity. We introduce observations of the program state that are intrinsic to the correct execution of security protections, along with means to specify and preserve observations across the compilation flow. Such observations complement the input/output semantics-preservation contract of compilers. We introduce an opacification mechanism to preserve and enforce a partial ordering of observations. This approach is compatible with a production compiler and does not incur any modification to its optimization passes. We validate the effectiveness and performance of our approach on a range of benchmarks, expressing the secure compilation of these applications in terms of observations to be made at specific program points.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Son</first_name>
          <last_name>Tuan Vu</last_name>
          <affiliation>ARM</affiliation>
          <bio>undefined</bio>
          <person_id>sontuanvu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Albert</first_name>
          <last_name>Cohen</last_name>
          <affiliation>Google</affiliation>
          <bio>Albert is a research scientist at Google. He has been a research scientist at Inria from 2000 to 2018. He graduated from École Normale Supérieure de Lyon and received his PhD from the University of Versailles in 1999 (awarded two national prizes). He has been a visiting scholar at the University of Illinois, an invited professor at Philips Research, and a visiting scientist at Facebook Artificial Intelligence Research. Albert Cohen works on parallelizing and optimizing compilers, parallel programming languages and systems and synchronous programming for reactive control systems. He served as the general or program chair of major conferences, including PLDI, PPoPP, HiPEAC, CC, the embedded software track of DAC, and as a member of the editorial board of ACM TACO and IJPP. He coauthored more than 180 peer-reviewed papers and has been the advisor for 26 PhD theses. Several research projects initiated by Albert Cohen resulted in effective transfer to production compilers and programming environments in industry.</bio>
          <homepage_url>https://who.rocq.inria.fr/Albert.Cohen</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/albertcohen/3684aca0-5e45-4ea1-bece-82d71228da32/small.jpg</picture_url>
          <person_id>albertcohen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arnaud</first_name>
          <last_name>de Grandmaison</last_name>
          <affiliation>ARM</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/arnauddegrandmaison/e359aaef-874f-472d-9bbd-01eaef90cd1c/small.jpg</picture_url>
          <person_id>arnauddegrandmaison</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Guillon</last_name>
          <affiliation>STMicroelectronics</affiliation>
          <bio>undefined</bio>
          <person_id>christopheguillon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Karine</first_name>
          <last_name>Heydemann</last_name>
          <affiliation>Sorbonne Université, CNRS, Laboratoire d'Informatique de Paris 6, LIP6</affiliation>
          <bio>undefined</bio>
          <person_id>karineheydemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>8a278a8c-eade-4505-a47b-da97400661f2</slot_id>
      <event_id>f767b573-d238-483e-bafc-2f0adec651ed</event_id>
      <submission_id>301</submission_id>
      <title>Not So Fast: Understanding and Mitigating Negative Impacts of Compiler Optimizations on Code Reuse Gadget Sets</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>22:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:50</end_time>
      <description>Despite extensive testing and correctness certification of their functional semantics, a number of compiler optimizations have been shown to violate security guarantees implemented in source code. While prior work has shed light on how such optimizations may introduce semantic security weaknesses into programs, there remains a significant knowledge gap concerning the impacts of compiler optimizations on non-semantic properties with security implications. In particular, little is currently known about how code generation and optimization decisions made by the compiler affect the availability and utility of reusable code segments called gadgets required for implementing code reuse attack methods such as return-oriented programming. 
In this paper, we bridge this gap through a study of the impacts of compiler optimization on code reuse gadget sets. We analyze and compare 1,187 variants of 20 different benchmark programs built with two production compilers (GCC and Clang) to determine how their optimization behaviors affect the code reuse gadget sets present in program variants with respect to both quantitative and qualitative metrics. Our study exposes an important and unexpected problem; compiler optimizations introduce new gadgets at a high rate and produce code containing gadget sets that are generally more useful to an attacker than those in unoptimized code. Using differential binary analysis, we identify several undesirable behaviors at the root of this phenomenon. In turn, we propose and evaluate several strategies to mitigate these behaviors. In particular, we show that post-production binary recompilation can effectively mitigate these behaviors with negligible performance impacts, resulting in optimized code with significantly smaller and less useful gadget sets.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael D.</first_name>
          <last_name>Brown</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>michaeldbrown</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Pruett</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>matthewpruett</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robert</first_name>
          <last_name>Bigelow</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>robertbigelow</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Girish</first_name>
          <last_name>Mururu</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>girishmururu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Santosh</first_name>
          <last_name>Pande</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>Santosh Pande is a Professor of Computer Science at Georgia Tech working in the general areas of program analysis, software security and compiler optimizations. His recent work involves piece-wise loading and linking of functions to reduce attack surface of software, proposing new metrics and tools for measuring security strength of applications,tradeoffs between compiler optimizations and vulnerabilities they introduce on the security side. He is also working in the area of compiler-OS interactions. Modern high performance applications involving analytics, machine learning co-execute in a data-center or cloud environment sharing key resources such as caches. Determining their co-execution and scheduling them appropriately is the key to their performance. Application phases determine such co-execution which means that this problem can be efficiently solved by determining dynamic properties of co-execution which is a hard problem. Fortunately, such a problem can be solved through a collaboration between compiler and OS. The results of this research show that significant (2x to 4x) improvements in throughput for batch oriented execution of important and diverse modern workloads. 
Santosh Pande’s research is supported by NSF, ONR, DARPA, Air Force and several industiries such as Sony, Toshiba IBM, Motorola, Infineon and holds a patent on smartcards jointly with Infineon. He is always looking for smart and motivated PhD students..</bio>
          <homepage_url>https://www.cc.gatech.edu/people/santosh-pande</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/santoshpande1/3200a8e1-7ee4-4160-9889-f1504c0e80e5/small.jpg</picture_url>
          <person_id>santoshpande1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>b26e92f1-4a9f-4087-b52c-b2df8f8cb025</slot_id>
      <event_id>d160658e-2c64-4c8e-9ce6-b2048d30d69c</event_id>
      <submission_id>184</submission_id>
      <title>Interpretable Noninterference Measurement and its Application to Processor Designs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>22:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:20</end_time>
      <description>Noninterference measurement quantifies the secret information that might leak to an adversary from what the adversary can observe and influence about the computation. Static and high-fidelity noninterference measurement has been difficult to scale to complex computations, however. This paper scales a recent framework for noninterference measurement to the open-source RISC-V BOOM core as specified in Verilog, through three key innovations: logically characterizing the core’s execution incrementally, applying specific optimizations between each cycle; permitting information to be declassified, to focus leakage measurement to only secret information that cannot be inferred from the declassified information; and interpreting leakage measurements for the analyst in terms of simple rules that characterize when leakage occurs. Case studies on cache-based side channels generally, and on specific instances including Spectre attacks, show that the resulting toolchain, called DINoMe, effectively scales to this modern processor design.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ziqiao</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <person_id>ziqiaozhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael K.</first_name>
          <last_name>Reiter</last_name>
          <affiliation>Duke University</affiliation>
          <bio>undefined</bio>
          <person_id>michaelkreiter</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>cd19dc75-b4e7-4828-8295-92bf15a306ce</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8b220a19-ec5d-4e9a-b89b-8a85fe4f4703</subevent_id>
    <title>SPLASH OOPSLA: Testing - Mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>c093c87f-86aa-4979-895b-b373efc4b6c3</slot_id>
      <title>Session: SPLASH OOPSLA - Testing - Mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Steve</first_name>
          <last_name>Blackburn</last_name>
          <affiliation>Australian National University</affiliation>
          <bio>My research interests are centered on the challenge of making software run faster and more power-efficiently on modern hardware. My primary interests include: microarchitectural support for managed languages, fast and efficient garbage collection, and the design and implementation of virtual machines. As a backdrop to this I have a longstanding interest in role of sound methodology and infrastructure in successful research innovation.</bio>
          <homepage_url>http://users.cecs.anu.edu.au/~steveb/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/steveblackburn/1deee732-405d-4403-a974-a418751399c2/small.jpg</picture_url>
          <person_id>steveblackburn</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>4199ad4b-84e9-4db0-aafe-fe832f507f75</slot_id>
      <event_id>1f6ab670-2e0d-4713-b59c-0e28fbaea895</event_id>
      <submission_id>532</submission_id>
      <title>Programming and Execution Models for Parallel Bounded Exhaustive Testing</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>19:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:50</end_time>
      <description>Bounded-exhaustive testing (BET), which exercises a program under test for all inputs up to some bounds, is an effective method for detecting software bugs. Systematic property-based testing is a BET approach where developers write test generation programs that describe properties of test inputs. Hybrid test generation programs offer the most expressive way to write desired properties by freely combining declarative filters and imperative generators. However, exploring hybrid test generation programs, to obtain test inputs, is both computationally demanding and challenging to parallelize. We present the first programming and execution models, dubbed Tempo, for parallel exploration of hybrid test generation programs. We describe two different strategies for mapping the computation to parallel hardware and implement them both for GPUs and CPUs. We evaluated Tempo by generating instances of various data structures commonly used for benchmarking in the BET domain. Additionally, we generated CUDA programs to stress test CUDA compilers, finding four bugs confirmed by the developers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nader</first_name>
          <last_name>Al Awar</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>naderalawar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kush</first_name>
          <last_name>Jain</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>kushjain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chris</first_name>
          <last_name>Rossbach</last_name>
          <affiliation>The University of Texas at Austin and VMware Research Group</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.utexas.edu/~rossbach</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chrisrossbach/d36775ec-4ad9-4010-ae6e-ba41c5f9d61d/small.jpg</picture_url>
          <person_id>chrisrossbach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milos</first_name>
          <last_name>Gligoric</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/milosgligoric/4d0671ae-937e-4f08-b499-092379ff7ad3/small.jpg</picture_url>
          <person_id>milosgligoric</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>4d5b8437-7f63-4301-be16-82838d9273c6</slot_id>
      <event_id>26e88f75-7306-434e-afa1-624701a72947</event_id>
      <submission_id>264</submission_id>
      <title>Generative Type-Aware Mutation for Testing SMT Solvers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>19:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:35</end_time>
      <description>We propose Generative Type-Aware Mutation, an effective approach for testing SMT solvers. The key idea is to realize generation through the mutation of expressions with parametric operators from the SMT-LIB specification. Generative Type-Aware Mutation is a hybrid of mutation-based and grammar-based type-ware mutations and features an unbounded mutation space—overcoming a major limitation of OpFuzz, the state-of-the-art fuzzer for SMT solvers. We have realized Generative Type-Aware Mutation in a practical SMT solver bug hunting tool, TypeFuzz. During three months of testing with TypeFuzz, we reported over 70 bugs in the state-of-the-art SMT solvers Z3 and CVC4. Among these, 48 bugs were confirmed and 35 bugs were fixed. Perhaps most notably, we found 9 soundness bugs in CVC4’s default mode alone. CVC4 has proven to be a very stable SMT solver and has resisted several fuzzing campaigns. A third of the soundness bugs in CVC4 (3/9) are at least 2 years latent and pre-date any previous SMT solver fuzzing campaigns.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jiwon</first_name>
          <last_name>Park</last_name>
          <affiliation>École Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>jiwonpark</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wintered.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>6fa9fef5-de7e-4939-abe9-efe57d735fc5</slot_id>
      <event_id>033e9d5c-0599-4e16-95be-bf846cf24376</event_id>
      <submission_id>236</submission_id>
      <title>Permchecker: A Toolchain for Debugging Memory Managers with Typestate</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>19:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:20</end_time>
      <description>Dynamic memory managers are a crucial component of almost every modern software system. In addition to implementing efficient allocation and reclamation, memory managers provide the essential abstraction of memory as distinct objects, which underpins the properties of memory safety and type safety. Bugs in memory managers, while not common, are extremely hard to diagnose and fix. One reason is that their implementations often involve tricky pointer calculations, raw memory manipulation, and complex memory state invariants. While these properties are often documented, they are not specified in any precise, machine-checkable form. A second reason is that memory manager bugs can break the client application in bizarre ways that do not immediately implicate the memory manager at all. A third reason is that existing tools for debugging memory errors, such as Memcheck, cannot help because they rely on correct allocation and deallocation information to work. 
In this paper we present Permchecker, a tool designed specifically to detect and diagnose bugs in memory managers. The key idea in Permchecker is to make the expected structure of the heap explicit by associating \emph{typestates} with each piece of memory. Typestate captures elements of both type (e.g., page, block, or cell) and state (e.g., allocated, free, or forwarded). Memory manager developers annotate their implementation with information about the expected typestates of memory and how heap operations change those typestates. At runtime, our system tracks the typestates and ensures that each memory access is consistent with the expected typestates. This technique detects errors quickly, before they corrupt the application or the memory manager itself, and it often provides accurate information about the reason for the error. 
The implementation of Permchecker uses a combination of compile-time annotation and instrumentation, and dynamic binary instrumention. Because the overhead of DBI is fairly high, Permchecker is suitable for a testing and debugging setting and not for deployment. It works on a wide variety of existing systems, including explict malloc/free memory managers and garbage collectors, such as those found in JikesRVM and OpenJDK. Since bugs in these systems are not numerous, we developed a testing methodology in which we automatically inject bugs into the code using bug patterns derived from real bugs. This technique allows us to test Permchecker on hundreds or thousands of buggy variants of the code. We find that Permchecker effectively detects and localizes errors in the vast majority of cases; without it, these bugs result in strange, incorrect behaviors usually long after the actual error occurs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Karl</first_name>
          <last_name>Cronburg</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.eecs.tufts.edu/~karl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/karlcronburg/1487b759-23be-47d5-adb2-f6e6b4013d52/small.jpg</picture_url>
          <person_id>karlcronburg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Guyer</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/samguyer/94906fdc-2110-48fb-a0cd-afd1464b9262/small.jpg</picture_url>
          <person_id>samguyer</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>70b60540-3a4b-4ae8-b3d8-9482d12a56a4</slot_id>
      <event_id>4e7d7fa2-4fd4-42e1-9e44-961a43dfab85</event_id>
      <submission_id>344</submission_id>
      <title>Fully Automated Functional Fuzzing of Android Apps for Detecting Non-Crashing Logic Bugs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:05</end_time>
      <description>Android apps are GUI-based event-driven software and have become ubiquitous in recent years. Obviously, functional correctness is critical for an app’s success. However, in addition to crash bugs, \emph{non-crashing functional bugs} (in short as “non-crashing bugs” in this work) like inadvertent function failures, silent user data lost and incorrect display information are prevalent, even in popular, well-tested apps. These non-crashing functional bugs are usually caused by program logic errors and manifest themselves on the graphic user interfaces (GUIs). In practice, such bugs pose significant challenges in effectively detecting them because (1) current practices heavily rely on expensive, small-scale manual validation (\emph{the lack of automation}); and (2) modern \emph{fully automated} testing has been limited to crash bugs (\emph{the lack of test oracles}). 
This paper fills this gap by introducing \emph{independent view fuzzing}, \emph{a novel, fully automated approach} for detecting non-crashing functional bugs in Android apps. Inspired by metamorphic testing, our key insight is to leverage the commonly-held \emph{independent view property} of Android apps to manufacture property-preserving mutant tests from a set of seed tests that validate certain app properties. The mutated tests help exercise the tested apps under additional, adverse conditions. Any property violations indicate likely functional bugs for further manual confirmation. We have realized our approach as an automated, end-to-end functional fuzzing tool, Genie. Given an app, (1) Genie automatically detects non-crashing bugs without requiring human-provided tests and oracles (thus \emph{fully automated}); and (2) the detected non-crashing bugs are diverse (thus \emph{general and not limited to specific functional properties}), which set Genie apart from prior work. 
We have evaluated Genie on 12 real-world Android apps and successfully uncovered 34 previously unknown non-crashing bugs in their latest releases — all have been confirmed, and 22 have already been fixed. Most of the detected bugs are nontrivial and have escaped developer (and user) testing for at least one year and affected many app releases, thus clearly demonstrating Genie’s effectiveness. These 34 non-crashing bugs could not been detected by prior fully automated GUI testing tools (as our evaluation confirms). Thus, our work complements and enhances existing manual testing and fully automated testing for crash bugs. 
To facilitate reviewing and replication of our work, we have open-sourced Genie and provided additional information (\emph{fully anonymized}) at https://github.com/functional-fuzzing-android-apps/home.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ting</first_name>
          <last_name>Su</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://tingsu.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tingsu/a7bc2f83-b98a-44ba-954c-da631ab86471/small.jpg</picture_url>
          <person_id>tingsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yichen</first_name>
          <last_name>Yan</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>yichenyan1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jue</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/juewang1/989813f5-0a9c-4617-8f83-9690a0e6b253/small.jpg</picture_url>
          <person_id>juewang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Sun</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>jinglingsun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yiheng</first_name>
          <last_name>Xiong</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>yihengxiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Geguang</first_name>
          <last_name>Pu</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>geguangpu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Ke</first_name>
          <last_name>Wang</last_name>
          <affiliation>Visa Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kbwang.bitbucket.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kewang/37ef656e-ca92-475f-8a51-902dbe44fb72/small.jpg</picture_url>
          <person_id>kewang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a6f27578-93c5-46e6-a572-76294d79f2e3</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>09181b8a-0f35-41e7-ba62-4414da49750b</subevent_id>
    <title>SPLASH OOPSLA: Analysis</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>2880b139-fc29-4c7a-a359-98b7aa016846</slot_id>
      <title>Session: SPLASH OOPSLA - Analysis</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Research, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
          <person_id>juliandolby</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0ef55ecb-b8af-4fcf-abe4-824661856f64</slot_id>
      <event_id>9ea1d9f0-04dc-4462-8e51-cc113731d741</event_id>
      <submission_id>507</submission_id>
      <title>JavaDL: Automatically Incrementalizing Java Bug Pattern Detection</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>16:25</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:40</end_time>
      <description>Static checker frameworks support software developers by automatically discovering bugs that fit general-purpose bug patterns. These frameworks ship with hundreds of detectors for such patterns and allow developers to add custom detectors for their own projects. However, existing frameworks generally encode detectors in imperative specifications, with extensive details of not only what to detect but also how. These details not only add complexity to maintenance and extensibility, but also interfere with the framework’s ability to change how detection is done, for instance, to make the detectors incremental. 
In this paper, we present JavaDL, a Datalog-based declarative specification language for bug pattern detection in Java code. JavaDL seamlessly supports both exhaustive and incremental evaluation from the same detector specification . The system further allows developers to concisely describe bug detectors via syntactic pattern matching for local AST matching, and via Datalog-style logical rules for nonlocal reasoning. We compare our approach against the well-established SpotBugs and Error Prone tools by re-implementing several of their detectors in JavaDL. We find that our implementations are substantially smaller and similarly effective at detecting bugs on the Defects4J benchmark suite, and run with competitive runtime performance. In our experiments, neither incremental nor exhaustive analysis is able to consistently outperform the other analysis mode, which highlights the value of our ability to transparently switch execution modes. We argue that our approach highlights the potential of clear-box static checker frameworks that constrain the bug detector specification language to enable the framework to adapt and enhance the detectors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexandru</first_name>
          <last_name>Dura</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <person_id>alexandrudura1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Reichenbach</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophreichenbach/04687677-a813-459e-8929-d1e4a32627c6/small.jpg</picture_url>
          <person_id>christophreichenbach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Emma</first_name>
          <last_name>Söderberg</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/emmasoderberg/2edc9865-4e98-41ee-a89e-1568465852e0/small.jpg</picture_url>
          <person_id>emmasoderberg</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>12a25626-f473-4e0c-92a7-761099a404bd</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>55a84f52-8a15-4248-8698-be9d3ea174c4</slot_id>
      <event_id>15b825cc-d30b-4dc1-97c4-9068619d905b</event_id>
      <submission_id>223</submission_id>
      <title>Making Pointer Analysis More Precise by Unleashing the Power of Selective Context Sensitivity</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:55</end_time>
      <description>Traditional context-sensitive pointer analysis is hard to scale for large and complex Java programs. To address this issue, a series of selective context-sensitivity approaches have been proposed and exhibit promising results. In this work, we move one step further towards producing highly-precise pointer analyses for hard-to-analyze Java programs by presenting the Unity-Relay framework, which takes selective context sensitivity to the next level. Briefly, Unity-Relay is a one-two punch: given a set of different selective context-sensitivity approaches, say $S = {S_1, \ldots, S_n}$, Unity-Relay first provides a mechanism (called Unity) to combine and maximize the precision of all components of $S$. When Unity fails to scale, Unity-Relay offers a scheme (called Relay) to pass and accumulate the precision from one approach $S_i$ in $S$ to the next, $S_{i+1}$, leading to an analysis that is more precise than all approaches in $S$. 
As a proof-of-concept, we instantiate Unity-Relay into a tool called Baton and extensively evaluate it on a set of hard-to-analyze Java programs, using general precision metrics and popular clients. Compared with the state of the art, Baton achieves the best precision for \emph{all} metrics and clients for \emph{all} evaluated programs. The difference in precision is often dramatic—up to 71% of alias pairs reported by previously-best algorithms are found to be spurious and eliminated.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tian</first_name>
          <last_name>Tan</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://silverbullettt.bitbucket.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiantan/4b1e811e-fce9-4642-92fb-d629f222b572/small.jpg</picture_url>
          <person_id>tiantan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yue</first_name>
          <last_name>Li</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuelee.bitbucket.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yueli/c0b3b5ef-ffac-472c-9a05-5b9c8f165d7d/small.jpg</picture_url>
          <person_id>yueli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xiaoxing</first_name>
          <last_name>Ma</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ics.nju.edu.cn/people/xiaoxingma/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaoxingma1/5add1977-f0a4-458b-b59b-71cf18017400/small.jpg</picture_url>
          <person_id>xiaoxingma1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Chang</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.nju.edu.cn/changxu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/changxu/e28fcdd7-83f6-43c4-9ac8-20a3fa1137d8/small.jpg</picture_url>
          <person_id>changxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>b9b0e90a-8319-42ae-b0a9-20f36ca45f0c</slot_id>
      <event_id>6ff2a930-bcaf-47ae-9930-b8baa0788972</event_id>
      <submission_id>90</submission_id>
      <title>Program Analysis via Efficient Symbolic Abstraction</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>16:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:25</end_time>
      <description>This paper addresses the scalability challenges of symbolic abstraction: given a formula $\varphi$ in a logic $\mathcal{L}$ and an abstract domain $\mathcal{A}$, find a most precise element in the abstract domain that over-approximates the meaning of $\varphi$. Symbolic abstraction is an important point in the space of abstract interpretation, as it allows for automatically synthesizing the best abstract transformers. However, current techniques for symbolic abstraction can have difficulty delivering on its practical strengths, due to performance issues. 
In this work, we introduce two algorithms for the symbolic abstraction of quantifier-free bit-vector formulas, which apply to the bit-vector interval domain and a certain kind of polyhedral domain, respectively. We implement and evaluate the proposed techniques on two machine code analysis clients, static memory corruption analysis and constrained random fuzzing. Using a suite of 57,933 queries from the clients, we compare our approach against a diverse group of state-of-the-art algorithms. The experiments show that our algorithms achieve a substantial speedup over existing techniques, and illustrate significant precision advantages for the clients. Our work presents strong evidence that symbolic abstraction of numeric domains can be efficient and practical for large and realistic programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Peisen</first_name>
          <last_name>Yao</last_name>
          <affiliation>The Hong Kong University of Science and Technology</affiliation>
          <bio>I am broadly interested in topics related to programming languages, software engineering, formal method, and cybersecurity, with an emphasis on using program reasoning techniques to ensure software reliability.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/yaopeisen/afec483a-bef9-4542-b208-b84c15344696/small.jpg</picture_url>
          <person_id>yaopeisen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Qingkai</first_name>
          <last_name>Shi</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Qingkai Shi is a Postdoc Research Associate in the department of computer science, Purdue University. His major research interest is the use of compiler techniques to ensure software reliability. He has published extensively at premium venues of programming languages (PLDI, OOPSLA), software engineering (ICSE, FSE, TSE, ISSTA), and cybersecurity (S&amp;amp;P). His research received many awards including ACM SIGSOFT Distinguished Paper Award and Hong Kong Ph.D. Fellowship. His research has led to the discovery of over a hundred software vulnerabilities in open-source software and has been successfully commercialized in Sourcebrella Inc, a static analysis tool vendor. Qingkai obtained his Ph.D. and B.S. from Nanjing University and the Hong Kong University of Science and Technology, respectively.</bio>
          <homepage_url>https://qingkaishi.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/qingkaishi/99eef1fd-60de-40bf-888f-38d77b3db376/small.jpg</picture_url>
          <person_id>qingkaishi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Heqing</first_name>
          <last_name>Huang</last_name>
          <affiliation>Hong Kong University of Science and Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://5hadowblad3.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/heqinghuang/726be0ec-989d-4ddd-b27c-6559ebc40835/small.jpg</picture_url>
          <person_id>heqinghuang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charles</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Hong Kong University of Science and Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ust.hk/~charlesz</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/charleszhang/d5404cd7-dca8-4033-b79f-500613a981b9/small.jpg</picture_url>
          <person_id>charleszhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>f0a6ce5f-4e88-4231-9eb1-282eb60f0ccb</slot_id>
      <event_id>4f4af528-c989-4120-8b8e-ab1590c33f65</event_id>
      <submission_id>426</submission_id>
      <title>Compacting Points-To Sets Through Object Clustering</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>15:55</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:10</end_time>
      <description>Inclusion-based set constraint solving is the most popular technique for whole-program points-to analysis whereby an analysis is typically formulated as repeatedly resolving constraints between points-to sets of program variables. The set union operation is central to this process. The number and size of points-to sets grow as analyses become more precise and input programs become larger, resulting in more time spent performing unions. Most existing approaches focus on improving scalability of precise points-to analyses from an algorithmic perspective and there has been less research into improving the data structures behind the analyses. 
Bit-vectors as one of the more popular data structures have been used in several mainstream analysis frameworks to represent points-to sets. To store memory objects in bit-vectors, objects need to mapped to integral identifiers. We observe that this object-to-identifier mapping is critical for a compact points-to set representation and the set union operation. If objects in the same points-to sets (co-pointees) are not given numerically close identifiers, points-to resolution can cost significantly more space and time. Without data on the unpredictable points-to relations discovered by the analysis, an ideal mapping is extremely challenging. 
In this paper, we present a new approach to inclusion-based analysis by compacting points-to sets through object clustering. Inspired by recent staged analysis where an auxiliary analysis produces results approximating a more precise main analysis, we formulate points-to set compaction as an optimisation problem solved by integer programming using constraints generated from the auxiliary analysis’s results in order to produce an effective mapping. We then develop a more approximate mapping, yet much more efficiently, using hierarchical clustering to compact bit-vectors. We also develop an improved representation of bit-vectors (called core bit-vectors) to fully take advantage of the newly produced mapping. Our approach requires no algorithmic change to the points-to analysis. We evaluate our object clustering on flow-sensitive points-to analysis using 9 open-source programs (&amp;gt;5.3 millions lines of LLVM instructions) and Our results show that our approach can successfully improve the analysis with an up to 1.75$\times$ speed up and up to 3.25$\times$ reduction in memory usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohamad</first_name>
          <last_name>Barbar</last_name>
          <affiliation>University of Technology Sydney, Australia and CSIRO's Data61, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mbarbar.net</homepage_url>
          <person_id>mohamadbarbar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9d46868a-717c-44c0-8d62-55f627fa3181</subevent_id>
    <title>SPLASH OOPSLA: Security</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>ddc4477d-0047-4bdc-b940-1207905f966c</slot_id>
      <title>Session: SPLASH OOPSLA - Security</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>48bc5cd0-a20c-4590-98d1-9fe51ed2ffdf</slot_id>
      <event_id>d160658e-2c64-4c8e-9ce6-b2048d30d69c</event_id>
      <submission_id>184</submission_id>
      <title>Interpretable Noninterference Measurement and its Application to Processor Designs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:20</end_time>
      <description>Noninterference measurement quantifies the secret information that might leak to an adversary from what the adversary can observe and influence about the computation. Static and high-fidelity noninterference measurement has been difficult to scale to complex computations, however. This paper scales a recent framework for noninterference measurement to the open-source RISC-V BOOM core as specified in Verilog, through three key innovations: logically characterizing the core’s execution incrementally, applying specific optimizations between each cycle; permitting information to be declassified, to focus leakage measurement to only secret information that cannot be inferred from the declassified information; and interpreting leakage measurements for the analyst in terms of simple rules that characterize when leakage occurs. Case studies on cache-based side channels generally, and on specific instances including Spectre attacks, show that the resulting toolchain, called DINoMe, effectively scales to this modern processor design.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ziqiao</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <person_id>ziqiaozhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael K.</first_name>
          <last_name>Reiter</last_name>
          <affiliation>Duke University</affiliation>
          <bio>undefined</bio>
          <person_id>michaelkreiter</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>8bd45038-7c16-43c0-a1c5-17783fd0de28</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9437f010-3597-4b99-9f1e-bf7850d52bf8</slot_id>
      <event_id>e1451bd2-8368-4f79-bdf9-aa3a7332f14e</event_id>
      <submission_id>190</submission_id>
      <title>Reconciling Optimization With Secure Compilation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:35</end_time>
      <description>Software protections against side-channel and physical attacks are essential to the development of secure applications. Such protections are meaningful at machine code or micro-architectural level, but they typically do not carry observable semantics at source level. This renders them susceptible to miscompilation, and security engineers embed input/output side-effects to prevent optimizing compilers from altering them. Yet these side-effects are error-prone and compiler-dependent. The current practice involves analyzing the generated machine code to make sure security or privacy properties are still enforced. These side-effects may also be too expensive in fine-grained protections such as control-flow integrity. We introduce observations of the program state that are intrinsic to the correct execution of security protections, along with means to specify and preserve observations across the compilation flow. Such observations complement the input/output semantics-preservation contract of compilers. We introduce an opacification mechanism to preserve and enforce a partial ordering of observations. This approach is compatible with a production compiler and does not incur any modification to its optimization passes. We validate the effectiveness and performance of our approach on a range of benchmarks, expressing the secure compilation of these applications in terms of observations to be made at specific program points.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Son</first_name>
          <last_name>Tuan Vu</last_name>
          <affiliation>ARM</affiliation>
          <bio>undefined</bio>
          <person_id>sontuanvu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Albert</first_name>
          <last_name>Cohen</last_name>
          <affiliation>Google</affiliation>
          <bio>Albert is a research scientist at Google. He has been a research scientist at Inria from 2000 to 2018. He graduated from École Normale Supérieure de Lyon and received his PhD from the University of Versailles in 1999 (awarded two national prizes). He has been a visiting scholar at the University of Illinois, an invited professor at Philips Research, and a visiting scientist at Facebook Artificial Intelligence Research. Albert Cohen works on parallelizing and optimizing compilers, parallel programming languages and systems and synchronous programming for reactive control systems. He served as the general or program chair of major conferences, including PLDI, PPoPP, HiPEAC, CC, the embedded software track of DAC, and as a member of the editorial board of ACM TACO and IJPP. He coauthored more than 180 peer-reviewed papers and has been the advisor for 26 PhD theses. Several research projects initiated by Albert Cohen resulted in effective transfer to production compilers and programming environments in industry.</bio>
          <homepage_url>https://who.rocq.inria.fr/Albert.Cohen</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/albertcohen/3684aca0-5e45-4ea1-bece-82d71228da32/small.jpg</picture_url>
          <person_id>albertcohen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Arnaud</first_name>
          <last_name>de Grandmaison</last_name>
          <affiliation>ARM</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/arnauddegrandmaison/e359aaef-874f-472d-9bbd-01eaef90cd1c/small.jpg</picture_url>
          <person_id>arnauddegrandmaison</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christophe</first_name>
          <last_name>Guillon</last_name>
          <affiliation>STMicroelectronics</affiliation>
          <bio>undefined</bio>
          <person_id>christopheguillon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Karine</first_name>
          <last_name>Heydemann</last_name>
          <affiliation>Sorbonne Université, CNRS, Laboratoire d'Informatique de Paris 6, LIP6</affiliation>
          <bio>undefined</bio>
          <person_id>karineheydemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>b8b9b365-2144-451c-9572-8459f7d1640d</slot_id>
      <event_id>b8e58c10-44b0-4c96-94ba-19e9d23a0e86</event_id>
      <submission_id>141</submission_id>
      <title>SpecSafe: Detecting Cache Side Channels in a Speculative World</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:05</end_time>
      <description>The high-profile Spectre attack and its variants have revealed that speculative execution may leave secret-dependent footprints in the cache, allowing an attacker to learn confidential data. However, existing static side-channel detectors either ignore speculative execution, leading to false negatives, or lack a precise cache model, leading to false positives. In this paper, somewhat surprisingly, we show that it is challenging to develop a speculation-aware static analysis with precise cache models: a combination of existing works does not necessarily catch all cache side channels. Motivated by this observation, we present a new semantic definition of security against cache-based side-channel attacks, called Speculative-Aware noninterference (SANI), which is applicable to a variety of attacks and cache models. We also develop SpecSafe to detect the violations of SANI. Unlike other speculation-aware symbolic executors, SpecSafe employs a novel program transformation so that SANI can be soundly checked by speculation-unaware side-channel detectors. SpecSafe is shown to be both scalable and accurate on a set of moderately sized benchmarks, including commonly used cryptography libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Brotzman-Smith</last_name>
          <affiliation>Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>robertbrotzmansmith</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Danfeng</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.psu.edu/~dbz5017/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/danfengzhang/6eb87743-0994-4ff3-be1e-dbfb34429946/small.jpg</picture_url>
          <person_id>danfengzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mahmut Taylan</first_name>
          <last_name>Kandemir</last_name>
          <affiliation>Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.psu.edu/~kandemir/</homepage_url>
          <person_id>mahmuttaylankandemir</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Gang</first_name>
          <last_name>Tan</last_name>
          <affiliation>Penn State University</affiliation>
          <bio>Dr. Gang Tan is the James F. Will Career Development Associate Professor in Computer Science and Engineering at Pennsylvania State University, PA. He leads the Security of Software (SOS) Lab. His research is at the interface between computer security, programming languages, and formal methods. He received his bachelor’s degree in Computer Science with honors from Tsinghua University in 1999 and his Ph.D. degree from Princeton University in 2005. He has received an NSF CAREER award, two Google Research Awards, and a Francis Upton Graduate Fellowship.</bio>
          <homepage_url>http://www.cse.psu.edu/~gxt29/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gangtan/e101adef-54fb-4fcc-bce0-381da3d1aace/small.jpg</picture_url>
          <person_id>gangtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>fde29dbd-5aae-45f8-8d09-413180af5530</slot_id>
      <event_id>f767b573-d238-483e-bafc-2f0adec651ed</event_id>
      <submission_id>301</submission_id>
      <title>Not So Fast: Understanding and Mitigating Negative Impacts of Compiler Optimizations on Code Reuse Gadget Sets</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:50</end_time>
      <description>Despite extensive testing and correctness certification of their functional semantics, a number of compiler optimizations have been shown to violate security guarantees implemented in source code. While prior work has shed light on how such optimizations may introduce semantic security weaknesses into programs, there remains a significant knowledge gap concerning the impacts of compiler optimizations on non-semantic properties with security implications. In particular, little is currently known about how code generation and optimization decisions made by the compiler affect the availability and utility of reusable code segments called gadgets required for implementing code reuse attack methods such as return-oriented programming. 
In this paper, we bridge this gap through a study of the impacts of compiler optimization on code reuse gadget sets. We analyze and compare 1,187 variants of 20 different benchmark programs built with two production compilers (GCC and Clang) to determine how their optimization behaviors affect the code reuse gadget sets present in program variants with respect to both quantitative and qualitative metrics. Our study exposes an important and unexpected problem; compiler optimizations introduce new gadgets at a high rate and produce code containing gadget sets that are generally more useful to an attacker than those in unoptimized code. Using differential binary analysis, we identify several undesirable behaviors at the root of this phenomenon. In turn, we propose and evaluate several strategies to mitigate these behaviors. In particular, we show that post-production binary recompilation can effectively mitigate these behaviors with negligible performance impacts, resulting in optimized code with significantly smaller and less useful gadget sets.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael D.</first_name>
          <last_name>Brown</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>michaeldbrown</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Pruett</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>matthewpruett</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robert</first_name>
          <last_name>Bigelow</last_name>
          <affiliation>Georgia Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>robertbigelow</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Girish</first_name>
          <last_name>Mururu</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>girishmururu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Santosh</first_name>
          <last_name>Pande</last_name>
          <affiliation>Georgia Institute of Technology, USA</affiliation>
          <bio>Santosh Pande is a Professor of Computer Science at Georgia Tech working in the general areas of program analysis, software security and compiler optimizations. His recent work involves piece-wise loading and linking of functions to reduce attack surface of software, proposing new metrics and tools for measuring security strength of applications,tradeoffs between compiler optimizations and vulnerabilities they introduce on the security side. He is also working in the area of compiler-OS interactions. Modern high performance applications involving analytics, machine learning co-execute in a data-center or cloud environment sharing key resources such as caches. Determining their co-execution and scheduling them appropriately is the key to their performance. Application phases determine such co-execution which means that this problem can be efficiently solved by determining dynamic properties of co-execution which is a hard problem. Fortunately, such a problem can be solved through a collaboration between compiler and OS. The results of this research show that significant (2x to 4x) improvements in throughput for batch oriented execution of important and diverse modern workloads. 
Santosh Pande’s research is supported by NSF, ONR, DARPA, Air Force and several industiries such as Sony, Toshiba IBM, Motorola, Infineon and holds a patent on smartcards jointly with Infineon. He is always looking for smart and motivated PhD students..</bio>
          <homepage_url>https://www.cc.gatech.edu/people/santosh-pande</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/santoshpande1/3200a8e1-7ee4-4160-9889-f1504c0e80e5/small.jpg</picture_url>
          <person_id>santoshpande1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fcde6341-62c0-4164-b5e5-a72a1b25551b</subevent_id>
    <title>SPLASH OOPSLA: Distributed Programming - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>00e194c2-4376-4112-89f3-73af0ec946b7</slot_id>
      <title>Session: SPLASH OOPSLA - Distributed Programming - mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Shigeru</first_name>
          <last_name>Chiba</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csg.ci.i.u-tokyo.ac.jp/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shigeruchiba/b57db719-4160-4e39-9f41-ef3facc9e449/small.jpg</picture_url>
          <person_id>shigeruchiba</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>03e82f8b-8f60-425c-af89-204e4a7c18ee</slot_id>
      <event_id>62c941e0-1d73-41ab-b192-9220506f2589</event_id>
      <submission_id>119</submission_id>
      <title>A Multiparty Session Typing Discipline for Fault-tolerant Event-driven Distributed Programming</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>07:55</end_time>
      <description>Correctly designing and implementing distributed systems software is notoriously difficult. Multiparty session types (MPSTs) is a typing discipline for concurrent processes that statically ensures properties such as freedom from message reception errors and deadlocks. The existing approaches in MPSTs cannot, however, be applied to a significant class of real-world distributed systems because they do not support practical specification and verification of protocols that handle and recover from partial failures. 
This paper presents the first formulation of MPSTs for practical fault-tolerant distributed programming. We tackle the long-standing challenges faced by session types in this context: bringing structure to communication patterns involving asynchronous and concurrent partial failures, and integrating the range of features required to express fault-tolerant protocols in practice, that involve dynamic replacement of failed parties and retrying failed protocol segments in the presence of imperfect failure detection. Key to our approach is that we develop the first model of event-driven concurrency for multiparty sessions, to unify the session-typed handling of failures and regular I/O events. Moreover, the characteristics of our model allow us to prove a global progress property for well-typed processes engaged in multiple concurrent sessions, which does not hold in traditional MPST systems. To demonstrate its practicality, we implement our approach as a toolchain for Scala, and use it to specify and implement a session-typed version of the cluster manager (CM) system of the widely employed Apache Spark data analytics engine. Our session-typed CM integrates with the other vanilla Spark components to give a functioning Spark runtime; e.g., it can execute existing third-party Spark applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Malte</first_name>
          <last_name>Viering</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>malteviering</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>Queen Mary University London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://eecs.qmul.ac.uk/profiles/huraymond.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/raymondhu2/bc72da42-a3bc-4080-bd1d-9b94d850e254/small.jpg</picture_url>
          <person_id>raymondhu2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Eugster</last_name>
          <affiliation>USI Lugano &amp; Purdue University</affiliation>
          <bio>Patrick Eugster joined USI as a Full Professor of Computer Science in 2017, where he leads the SWYSTEMS (Software Systems) group, and co-founded the Computer Systems Institute in 2020. Prior to that he was a regular faculty member at TU Darmstadt (2014-2017) and Purdue University (2005-2016) where he remains an adjunct faculty member. Patrick holds M.S. (1998) and Ph.D. (2001) degrees from EPFL. 
Patrick is interested in software systems, with a particular focus on distributed systems and programming models/languages, and the intersection between the two. He has co-authored over 150 scientific articles on these topics. His research has been awarded by various funding agencies (e.g., NSF CAREER 2007, DARPA Computer Science Study Group 2011, ERC Consolidator 2014) and companies (e.g., Google Research Award 2003, NetApp Faculty Fellowship 2014, Facebook Research Award 2020). Patrick had the privilege to act as program chair of ACM OOPSLA 2015 and is currently serving as associate editor for IEEE Transactions on Software Engineering.</bio>
          <homepage_url>https://www.inf.usi.ch/faculty/eugstp/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/patrickeugster/bf8c955c-8902-4678-8c57-4b75cbd4f3c0/small.jpg</picture_url>
          <person_id>patrickeugster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lukasz</first_name>
          <last_name>Ziarek</last_name>
          <affiliation>University at Buffalo, SUNY</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.buffalo.edu/~lziarek/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lukaszziarek/78ff4fd0-ef3b-4aed-ba86-2d6e66f85f65/small.jpg</picture_url>
          <person_id>lukaszziarek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>3393a505-4e20-454c-9af1-05039d37e8ca</slot_id>
      <event_id>740c257f-f41f-4619-8c89-49e2da972d1d</event_id>
      <submission_id>446</submission_id>
      <title>Automatic Migration from Synchronous to Asynchronous JavaScript APIs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>08:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:25</end_time>
      <description>The JavaScript ecosystem provides equivalent synchronous and asynchronous Application Programming Interfaces (APIs) for many commonly used I/O operations. Synchronous APIs involve straightforward sequential control flow that makes them easy to use and understand, but their “blocking” behavior may result in poor responsiveness or performance. Asynchronous APIs impose a higher syntactic burden that relies on callbacks, promises, and higher-order functions. On the other hand, their nonblocking behavior enables applications to scale better and remain responsive while I/O requests are being processed. While it is generally understood that asynchronous APIs have better performance characteristics, many applications still rely on synchronous APIs. In this paper, we present a refactoring technique for assisting programmers with the migration from synchronous to asynchronous APIs. The technique relies on static analysis to determine where calls to synchronous API functions can be replaced with their asynchronous counterparts, relying on JavaScript’s async/await feature to minimize disruption to the source code. Since the static analysis is potentially unsound, the proposed refactorings are presented as suggestions that must be reviewed and confirmed by the programmer. The technique was implemented in a tool named Desynchronizer. In an empirical evaluation on 12 subject applications containing 316 synchronous API calls, Desynchronizer identified 256 of these as candidates for refactoring. Of these candidates, 244 were transformed successfully, and only 12 resulted in behavioral changes. Further inspection of these cases revealed that the majority of these issues can be attributed to unsoundness in the call graph.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Satyajit</first_name>
          <last_name>Gokhale</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/satyajitgokhale/0f26246b-3f7c-472b-9c93-a2f169f306e8/small.jpg</picture_url>
          <person_id>satyajitgokhale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexi</first_name>
          <last_name>Turcotte</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://reallytg.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexiturcotte/6881a0a0-5145-40cb-aab4-ff41754a0640/small.jpg</picture_url>
          <person_id>alexiturcotte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Tip</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Frank Tip is a Professor and Associate Dean for Graduate Programs at Northeastern University. Previously, he was a Senior Principal Engineer at Samsung Research America in Mountain View, California (2014-2016), a Professor and Cheriton Research Chair in the David R. Cheriton School of Computer Science at the University of Waterloo (2012-2014), and a Research Staff Member and Manager at the Software Technology Department at the IBM T.J. Watson Research Center (1995-2012). He received his PhD in 1995 from the University of Amsterdam.</bio>
          <homepage_url>http://www.franktip.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/franktip/b4b4c804-cf32-45fa-afc8-3058f718b160/small.jpg</picture_url>
          <person_id>franktip</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>d1d5c082-3275-45e6-91eb-30e9dbfe2c91</slot_id>
      <event_id>2c375f32-8c80-4300-b328-20661ab229e4</event_id>
      <submission_id>2</submission_id>
      <title>Much ADO about Failures: A Fault-Aware Model for Compositional Verification of Strongly Consistent Distributed Systems</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>07:55</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:10</end_time>
      <description>Despite recent advances, guaranteeing the correctness of large-scale distributed applications without compromising performance remains a challenging problem. Network and node failures are inevitable and, for some applications, careful control over how they are handled is essential. Unfortunately, existing approaches either completely hide these failures behind an atomic state machine replication (SMR) interface, or expose all of the network-level details, sacrificing atomicity. We propose a novel, compositional, atomic distributed object (ADO) model for strongly consistent distributed systems that combines the best of both options. The object-oriented API abstracts over protocol-specific details and decouples high-level correctness reasoning from implementation choices. At the same time, it intentionally exposes an abstract view of certain key distributed failure cases, thus allowing for more fine-grained control over them than SMR-like models. We demonstrate that proving properties even of composite distributed systems can be straightforward with our Coq verification framework, Advert, thanks to the ADO model. We also show that a variety of common protocols including multi-Paxos and Chain Replication refine the ADO semantics, which allows one to freely choose among them for an application’s implementation without modifying ADO-level correctness proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wolf</first_name>
          <last_name>Honore</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <person_id>wolfhonore</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jieung</first_name>
          <last_name>Kim</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/jkim</homepage_url>
          <person_id>jieungkim</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ji-Yong</first_name>
          <last_name>Shin</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.jiyongshin.info</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jiyongshin/887e7089-7e73-4b28-8c02-9dc79624fe5d/small.jpg</picture_url>
          <person_id>jiyongshin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
          <person_id>zhongshao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>f312ed4c-cf5d-4b52-8f89-3720ab2ac0de</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>f4f575f7-84e1-422f-93d4-b18b82249cdf</slot_id>
      <event_id>cdc5b0cb-32bc-47df-a54d-5dd5e4516932</event_id>
      <submission_id>364</submission_id>
      <title>QuickSilver: Modeling and Parameterized Verification for Distributed Agreement-Based Systems</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>08:25</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:40</end_time>
      <description>The last decade has sparked several valiant efforts in deductive verification of distributed agreement protocols such as consensus and leader election. Oddly, there have been far fewer verification efforts that go beyond the core protocols and target applications that are built on top of agreement protocols. This is unfortunate, as agreement-based distributed services such as data stores, locks, and ledgers are ubiquitous and potentially permit modular, scalable verification approaches that mimic their modular design. 
We address this need for verification of distributed agreement-based systems through our novel modeling and verification framework, QuickSilver, that is not only modular, but also fully automated. The key enabling feature of QuickSilver is our encoding of abstractions of verified agreement protocols that facilitates modular, decidable, and scalable automated verification. We demonstrate the potential of QuickSilver by modeling and efficiently verifying a series of tricky case studies, adapted from real-world applications, such as a data store, a lock service, a surveillance system, a pathfinding algorithm for mobile robots, and more.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nouraldin</first_name>
          <last_name>Jaber</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/nouraldinjaber/0aeeca1f-ae9b-4220-85ef-02510d406a10/small.jpg</picture_url>
          <person_id>nouraldinjaber</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christopher</first_name>
          <last_name>Wagner</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/christopherwagner/571f9f20-6c46-40bb-a5b5-0ac8ad448fdf/small.jpg</picture_url>
          <person_id>christopherwagner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Swen</first_name>
          <last_name>Jacobs</last_name>
          <affiliation>CISPA Helmholtz Center for Information Security</affiliation>
          <bio>undefined</bio>
          <person_id>swenjacobs1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University. 
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures. 
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University. I received an NSF CAREER Award in 2012, a Department of Energy Early Career Research Award in 2013, and the Presidential Early Career Award for Scientists and Engineers in 2016.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
          <person_id>milindkulkarni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Roopsha</first_name>
          <last_name>Samanta</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/roopsha/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/roopshasamanta/3d74f41a-6adb-447b-8426-4a7fd9079dd4/small.jpg</picture_url>
          <person_id>roopshasamanta</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e79353d8-e431-48ba-9094-ce8ad7c8f57b</subevent_id>
    <title>SPLASH OOPSLA: Algorithms, Libraries and Databases</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>fb99d429-0fe8-478c-8d57-7d29870da0d0</slot_id>
      <title>Session: SPLASH OOPSLA - Algorithms, Libraries and Databases</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Hans-J.</first_name>
          <last_name>Boehm</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hboehm.info</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hansjboehm/cc58482a-75bd-4d4f-85fc-73f60b132d04/small.jpg</picture_url>
          <person_id>hansjboehm</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>004778be-df5e-4a2b-9ed7-7a9507b4a6dd</slot_id>
      <event_id>7a1731c9-53d0-4f27-90c8-227f5a3a717e</event_id>
      <submission_id>70</submission_id>
      <title>Verifying Concurrent Multicopy Search Structures</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:50</end_time>
      <description>Multicopy data structures such as log-structured merge (LSM) trees are optimized for high insert/update/delete (collectively known as upsert) performance. In such search structures, an upsert on key $k$, which adds $(k,v)$ where $v$ can be a value or a tombstone, is added to the root node even if $k$ is already present in other nodes. Thus there may be multiple copies of $k$ in the search structure. A search on $k$ aims to return the value associated with the most recent upsert. We present a general framework for verifying linearizability of concurrent multicopy structures that abstracts from the underlying representation of the data structure in memory, enabling proof-reuse across diverse implementations. Based on our framework, we propose template algorithms for LSM structures forming arbitrary directed acyclic graphs, and formally verify these templates in the concurrent separation logic Iris. We instantiate this template to obtain the first verified concurrent in-memory LSM tree implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nisarg</first_name>
          <last_name>Patel</last_name>
          <affiliation>New York University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>nisargpatel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Siddharth</first_name>
          <last_name>Krishna</last_name>
          <affiliation>Microsoft Research, Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.nyu.edu/~siddharth/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/siddharthkrishna/fb064b85-b50f-4fba-9626-67ed7a75b358/small.jpg</picture_url>
          <person_id>siddharthkrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dennis</first_name>
          <last_name>Shasha</last_name>
          <affiliation>New York University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dennisshasha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Wies</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.nyu.edu/wies/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thomaswies/e43dd6b5-97dc-433f-9708-836bd6364a01/small.jpg</picture_url>
          <person_id>thomaswies</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>03039469-1277-4acc-8a4b-ecb898efd7ed</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>323cafd7-89a0-46db-a176-acec80c9fcf5</slot_id>
      <event_id>e41ff4b0-ba00-4e8f-ba86-28ea4d9821ae</event_id>
      <submission_id>66</submission_id>
      <title>UDF to SQL Translation through Compositional Lazy Inductive Synthesis</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:05</end_time>
      <description>Many data processing systems allow SQL queries that call user-defined functions (UDFs)written in conventional programming languages. While such SQL extensions provide convenience and flexibility to users, queries involving UDFs are not as efficient as their pure SQL counterparts that invoke SQL’s highly-optimized built-in functions. Motivated by this problem, we propose a new technique for translating SQL queries with UDFs to pure SQL expressions. Unlike prior work in this space (Ramachandra et al., 2017a), our method is not based on syntactic rewrite rules and can handle a much more general class of UDFs. At a high-level, our method is based on counterexample-guided inductive synthesis (CEGIS) but employs a novel compositional strategy that decomposes the synthesis task into simpler sub-problems. However, because there is no universal decomposition strategy that works for all UDFs, we propose a novel lazy inductive synthesis approach that generates a sequence of decompositions that correspond to increasingly harder inductive synthesis problems. Because most realistic UDF-to-SQL translation tasks are amenable to a fine-grained decomposition strategy, our lazy inductive synthesis method scales significantly better than traditional CEGIS. 
We have implemented our proposed technique in a tool called CLIS for optimizing Spark SQL programs containing Scala UDFs. To evaluate CLIS, we manually study 100 randomly selected UDFs and find that 63 of them can be expressed in pure SQL. Our evaluation on these 63 UDFs shows that CLIS can automatically synthesize equivalent SQL expressions in 92% of the cases and that it can solve 2.4× more benchmarks compared to a baseline that does not use our compositional approach. We also show that CLIS yields an average speed-up of 4.6× for individual UDFs and 1.3× to 3.1× in terms of end-to-end application performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guoqiang</first_name>
          <last_name>Zhang</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
          <person_id>guoqiangzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yuanchao</first_name>
          <last_name>Xu</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>yuanchaoxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xipeng</first_name>
          <last_name>Shen</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>Xipeng Shen is an associate professor at the Computer Science Department, North Carolina State University (NCSU). He is a receipt of NSF CAREER Award, DOE Early Career Award, and Google Faculty Research Award. He is an ACM Distinguished Speaker, and a senior member of IEEE. Prior to joining NC State in 2014, Shen was the Adina Allen Term Distinguished Associate Professor at The College of William and Mary. He had served as a consultant to Intel Labs and Cisco, and a Visiting Researcher at MIT and Microsoft Research. He received his Ph.D. in Computer Science from University of Rochester in 2006.</bio>
          <homepage_url>http://people.engr.ncsu.edu/xshen5/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xipengshen/7ba54e69-f90a-4cf7-90d2-19fdd5f42e87/small.jpg</picture_url>
          <person_id>xipengshen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
          <person_id>isildillig</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>58024535-f431-46a0-90fa-7321bb44a1b0</slot_id>
      <event_id>c7fcb53f-6c45-46d6-9e4c-be51477a0bbb</event_id>
      <submission_id>469</submission_id>
      <title>FPL: Fast Presburger Arithmetic through Transprecision</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:35</end_time>
      <description>Presburger arithmetic provides the mathematical core for the polyhedral compilation techniques that drive analytical cache models, loop optimization for ML and HPC, formal verification, and even hardware design. Polyhedral compilation is widely regarded as being slow due to the potentially high computational cost of the underlying Presburger libraries. Researchers typically use these libraries as powerful black-box tools, but a lack of internal documentation and decade-old C implementations hold back broader performance-optimization efforts. With FPL, we introduce a new library for Presburger arithmetic built from the ground up in modern C++. We carefully document its internal algorithmic foundations, use lightweight C++ data structures to minimize memory management costs, and deploy transprecision computing across the entire library to effectively exploit machine integers and vector instructions. On a newly-developed comprehensive benchmark suite for Presburger arithmetic, we show a 5.25x speedup in total runtime over the state-of-the-art library isl in its default configuration and 3.14x when over a variant of isl optimized with element-wise transprecision computing. We expect that the availability of a well-documented and fast Presburger library will accelerate the adoption of polyhedral compilation techniques in production compilers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Pitchanathan</last_name>
          <affiliation>IIIT Hyderabad</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunpitchanathan/ad5b4feb-d93b-4bc7-b90b-7250f26856fa/small.jpg</picture_url>
          <person_id>arjunpitchanathan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christian</first_name>
          <last_name>Ulmann</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christianulmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michel</first_name>
          <last_name>Weber</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>michelweber</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Torsten</first_name>
          <last_name>Hoefler</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>torstenhoefler1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Grosser</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.grosser.es</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobiasgrosser/1ee43044-14e9-497e-a230-90f96a8da867/small.jpg</picture_url>
          <person_id>tobiasgrosser</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>e61274ce-6a71-41ca-a9c1-a500f6f9d93e</slot_id>
      <event_id>bbd115c1-8ed3-4aed-a963-aa15387946b3</event_id>
      <submission_id>229</submission_id>
      <title>LXM: Better Splittable Pseudorandom Number Generators (and Almost as Fast)</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:20</end_time>
      <description>In 2014, Steele, Lea, and Flood presented SplitMix, an object-oriented pseudorandom number generator (PRNG) that is quite fast (9 64-bit arithmetic/logical operations per 64 bits generated) and also \emph{splittable}. A conventional PRNG object provides a \emph{generate} method that returns one pseudorandom value and updates the state of the PRNG; a splittable PRNG object also has a second operation, \emph{split}, that replaces the original PRNG object with two (seemingly) independent PRNG objects, by creating and returning a new such object and updating the state of the original object. Splittable PRNG objects make it easy to organize the use of pseudorandom numbers in multithreaded programs structured using fork-join parallelism. This overall strategy still appears to be sound, but the specific arithmetic calculation used for \emph{generate} in the SplitMix algorithm has some detectable weaknesses, and the period of any one generator is limited to $2^{64}$. 
Here we present the LXM \emph{family} of PRNG algorithms. The idea is an old one: combine the outputs of two independent PRNG algorithms, then (optionally) feed the result to a mixing function. An LXM algorithm uses a linear congruential subgenerator and an $\mathbf{F}_2$-linear subgenerator; the examples studied in this paper use an LCG of period $2^{16}$, $2^{32}$, $2^{64}$, or $2^{128}$ with one of the multipliers recommended by L’Ecuyer or by Steele and Vigna, and an $\mathbf{F}_2$-linear generator of the xoshiro family or xoroshiro family as described by Blackman and Vigna. Mixing functions studied in this paper include the MurmurHash3 finalizer function, David Stafford’s variants, Doug Lea’s variants, and the null (identity) mixing function. 
Like SplitMix, LXM provides both a \emph{generate} operation and a \emph{split} operation. Also like SplitMix, LXM requires no locking or other synchronization (other than the usual memory fence after instance initialization), and is suitable for use with SIMD instruction sets because it has no branches or loops. 
We analyze the period and equidistribution properties of LXM generators, and present the results of thorough testing of specific members of this family, using the TestU01 and PractRand test suites, not only on single instances of the algorithm but also for collections of instances, used in parallel, ranging in size from $2$ to $2^{24}$. Single instances of LXM that include a strong mixing function appear to have no major weaknesses, and LXM is significantly more robust than SplitMix against accidental correlation in a multithreaded setting. We believe that LXM is suitable for the same sorts of applications as SplitMix, that is, “everyday” scientific and machine-learning applications (but not cryptographic applications), especially when concurrent threads or distributed processes are involved.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guy L.</first_name>
          <last_name>Steele Jr.</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Guy L. Steele Jr. (A.B., 1975, Harvard College; S.M., 1977, and Ph.D., 1980, MIT) is a Software Architect at Oracle Labs. He has taught at Carnegie-Mellon University, and worked for Tartan Laboratories, Thinking Machines Corporation, and Sun Microsystems. 
He is author or co-author of five books: Common Lisp: The Language, C: A Reference Manual, The Hacker’s Dictionary, The High Performance Fortran Handbook, and The Java Language Specification. He has published more than two dozen papers on the subject of the Lisp language and Lisp implementation, including a series with Gerald Jay Sussman that defined the Scheme dialect of Lisp. His paper “Data Parallel Algorithms” with W. Daniel Hillis (December 1986) has been cited more than 1100 times. 
He has been given the Grace Murray Hopper Award (1988), the ACM SIGPLAN Programming Languages Achievement Award (1996), and the Harry H. Goode Memorial Award (2007). He is an ACM Fellow, IEEE Fellow, Fellow of the American Academy of Arts and Sciences, and a Member of the National Academy of Engineering of the United States of America. 
He has served on accredited standards committees X3J11 (C language) and X3J3 (Fortran), and served as chairman of X3J13 (Common Lisp). He was also a member of the IEEE committee that produced the IEEE Standard for the Scheme Programming Language, IEEE Std 1178-1990. At Thinking Machines Corporation he co-developed the languages Connection Machine Lisp, C*, and Connection Machine Fortran. At Sun Microsystems (and now at Oracle) he has advised the evolution of the Java programming language; he also led the design of Fortress, an object-oriented mathematical language intended to support high-performance computing. He designed the original EMACS command set and was the first person to port TeX. 
He is a member of Tech Squares, the Plus-level Modern Western Square Dance club at MIT, and a square dance caller (currently Mainstream through C3A). At SPLASH 2011 he gave a presentation and demonstration on the structure of square-dance singing calls. 
At Oracle labs, he is responsible for research in language design and implementation strategies, and architectural and software support for programming languages.</bio>
          <homepage_url>https://labs.oracle.com/pls/apex/f?p=labs:bio:0:120</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guylsteelejr/9c36bdda-9de1-43c9-a239-3143cf32ae57/small.jpg</picture_url>
          <person_id>guylsteelejr</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastiano</first_name>
          <last_name>Vigna</last_name>
          <affiliation>Università degli Studi di Milano</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/sebastianovigna/8cd65f59-c0bc-4d72-bd2c-c8f746296fbb/small.jpg</picture_url>
          <person_id>sebastianovigna</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7077477a-48ac-47b5-9afd-07cd438582ca</subevent_id>
    <title>SPLASH OOPSLA: Algorithms, Libraries and Databases - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>c5427d6f-d455-4a9c-864c-832c78628b9a</slot_id>
      <title>Session: SPLASH OOPSLA - Algorithms, Libraries and Databases - mirror</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>1379c8da-fc7e-42c5-b672-d188f52d1edc</slot_id>
      <event_id>bbd115c1-8ed3-4aed-a963-aa15387946b3</event_id>
      <submission_id>229</submission_id>
      <title>LXM: Better Splittable Pseudorandom Number Generators (and Almost as Fast)</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>19:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:20</end_time>
      <description>In 2014, Steele, Lea, and Flood presented SplitMix, an object-oriented pseudorandom number generator (PRNG) that is quite fast (9 64-bit arithmetic/logical operations per 64 bits generated) and also \emph{splittable}. A conventional PRNG object provides a \emph{generate} method that returns one pseudorandom value and updates the state of the PRNG; a splittable PRNG object also has a second operation, \emph{split}, that replaces the original PRNG object with two (seemingly) independent PRNG objects, by creating and returning a new such object and updating the state of the original object. Splittable PRNG objects make it easy to organize the use of pseudorandom numbers in multithreaded programs structured using fork-join parallelism. This overall strategy still appears to be sound, but the specific arithmetic calculation used for \emph{generate} in the SplitMix algorithm has some detectable weaknesses, and the period of any one generator is limited to $2^{64}$. 
Here we present the LXM \emph{family} of PRNG algorithms. The idea is an old one: combine the outputs of two independent PRNG algorithms, then (optionally) feed the result to a mixing function. An LXM algorithm uses a linear congruential subgenerator and an $\mathbf{F}_2$-linear subgenerator; the examples studied in this paper use an LCG of period $2^{16}$, $2^{32}$, $2^{64}$, or $2^{128}$ with one of the multipliers recommended by L’Ecuyer or by Steele and Vigna, and an $\mathbf{F}_2$-linear generator of the xoshiro family or xoroshiro family as described by Blackman and Vigna. Mixing functions studied in this paper include the MurmurHash3 finalizer function, David Stafford’s variants, Doug Lea’s variants, and the null (identity) mixing function. 
Like SplitMix, LXM provides both a \emph{generate} operation and a \emph{split} operation. Also like SplitMix, LXM requires no locking or other synchronization (other than the usual memory fence after instance initialization), and is suitable for use with SIMD instruction sets because it has no branches or loops. 
We analyze the period and equidistribution properties of LXM generators, and present the results of thorough testing of specific members of this family, using the TestU01 and PractRand test suites, not only on single instances of the algorithm but also for collections of instances, used in parallel, ranging in size from $2$ to $2^{24}$. Single instances of LXM that include a strong mixing function appear to have no major weaknesses, and LXM is significantly more robust than SplitMix against accidental correlation in a multithreaded setting. We believe that LXM is suitable for the same sorts of applications as SplitMix, that is, “everyday” scientific and machine-learning applications (but not cryptographic applications), especially when concurrent threads or distributed processes are involved.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guy L.</first_name>
          <last_name>Steele Jr.</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Guy L. Steele Jr. (A.B., 1975, Harvard College; S.M., 1977, and Ph.D., 1980, MIT) is a Software Architect at Oracle Labs. He has taught at Carnegie-Mellon University, and worked for Tartan Laboratories, Thinking Machines Corporation, and Sun Microsystems. 
He is author or co-author of five books: Common Lisp: The Language, C: A Reference Manual, The Hacker’s Dictionary, The High Performance Fortran Handbook, and The Java Language Specification. He has published more than two dozen papers on the subject of the Lisp language and Lisp implementation, including a series with Gerald Jay Sussman that defined the Scheme dialect of Lisp. His paper “Data Parallel Algorithms” with W. Daniel Hillis (December 1986) has been cited more than 1100 times. 
He has been given the Grace Murray Hopper Award (1988), the ACM SIGPLAN Programming Languages Achievement Award (1996), and the Harry H. Goode Memorial Award (2007). He is an ACM Fellow, IEEE Fellow, Fellow of the American Academy of Arts and Sciences, and a Member of the National Academy of Engineering of the United States of America. 
He has served on accredited standards committees X3J11 (C language) and X3J3 (Fortran), and served as chairman of X3J13 (Common Lisp). He was also a member of the IEEE committee that produced the IEEE Standard for the Scheme Programming Language, IEEE Std 1178-1990. At Thinking Machines Corporation he co-developed the languages Connection Machine Lisp, C*, and Connection Machine Fortran. At Sun Microsystems (and now at Oracle) he has advised the evolution of the Java programming language; he also led the design of Fortress, an object-oriented mathematical language intended to support high-performance computing. He designed the original EMACS command set and was the first person to port TeX. 
He is a member of Tech Squares, the Plus-level Modern Western Square Dance club at MIT, and a square dance caller (currently Mainstream through C3A). At SPLASH 2011 he gave a presentation and demonstration on the structure of square-dance singing calls. 
At Oracle labs, he is responsible for research in language design and implementation strategies, and architectural and software support for programming languages.</bio>
          <homepage_url>https://labs.oracle.com/pls/apex/f?p=labs:bio:0:120</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guylsteelejr/9c36bdda-9de1-43c9-a239-3143cf32ae57/small.jpg</picture_url>
          <person_id>guylsteelejr</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastiano</first_name>
          <last_name>Vigna</last_name>
          <affiliation>Università degli Studi di Milano</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/sebastianovigna/8cd65f59-c0bc-4d72-bd2c-c8f746296fbb/small.jpg</picture_url>
          <person_id>sebastianovigna</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>19bbbc59-6d9b-4b51-b372-063e2888c5e6</slot_id>
      <event_id>c7fcb53f-6c45-46d6-9e4c-be51477a0bbb</event_id>
      <submission_id>469</submission_id>
      <title>FPL: Fast Presburger Arithmetic through Transprecision</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>19:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:35</end_time>
      <description>Presburger arithmetic provides the mathematical core for the polyhedral compilation techniques that drive analytical cache models, loop optimization for ML and HPC, formal verification, and even hardware design. Polyhedral compilation is widely regarded as being slow due to the potentially high computational cost of the underlying Presburger libraries. Researchers typically use these libraries as powerful black-box tools, but a lack of internal documentation and decade-old C implementations hold back broader performance-optimization efforts. With FPL, we introduce a new library for Presburger arithmetic built from the ground up in modern C++. We carefully document its internal algorithmic foundations, use lightweight C++ data structures to minimize memory management costs, and deploy transprecision computing across the entire library to effectively exploit machine integers and vector instructions. On a newly-developed comprehensive benchmark suite for Presburger arithmetic, we show a 5.25x speedup in total runtime over the state-of-the-art library isl in its default configuration and 3.14x when over a variant of isl optimized with element-wise transprecision computing. We expect that the availability of a well-documented and fast Presburger library will accelerate the adoption of polyhedral compilation techniques in production compilers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Pitchanathan</last_name>
          <affiliation>IIIT Hyderabad</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunpitchanathan/ad5b4feb-d93b-4bc7-b90b-7250f26856fa/small.jpg</picture_url>
          <person_id>arjunpitchanathan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christian</first_name>
          <last_name>Ulmann</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christianulmann</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michel</first_name>
          <last_name>Weber</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>michelweber</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Torsten</first_name>
          <last_name>Hoefler</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>torstenhoefler1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Grosser</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.grosser.es</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobiasgrosser/1ee43044-14e9-497e-a230-90f96a8da867/small.jpg</picture_url>
          <person_id>tobiasgrosser</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>2cb336ef-2fc3-46cc-a63d-8c3689197567</slot_id>
      <event_id>e41ff4b0-ba00-4e8f-ba86-28ea4d9821ae</event_id>
      <submission_id>66</submission_id>
      <title>UDF to SQL Translation through Compositional Lazy Inductive Synthesis</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:05</end_time>
      <description>Many data processing systems allow SQL queries that call user-defined functions (UDFs)written in conventional programming languages. While such SQL extensions provide convenience and flexibility to users, queries involving UDFs are not as efficient as their pure SQL counterparts that invoke SQL’s highly-optimized built-in functions. Motivated by this problem, we propose a new technique for translating SQL queries with UDFs to pure SQL expressions. Unlike prior work in this space (Ramachandra et al., 2017a), our method is not based on syntactic rewrite rules and can handle a much more general class of UDFs. At a high-level, our method is based on counterexample-guided inductive synthesis (CEGIS) but employs a novel compositional strategy that decomposes the synthesis task into simpler sub-problems. However, because there is no universal decomposition strategy that works for all UDFs, we propose a novel lazy inductive synthesis approach that generates a sequence of decompositions that correspond to increasingly harder inductive synthesis problems. Because most realistic UDF-to-SQL translation tasks are amenable to a fine-grained decomposition strategy, our lazy inductive synthesis method scales significantly better than traditional CEGIS. 
We have implemented our proposed technique in a tool called CLIS for optimizing Spark SQL programs containing Scala UDFs. To evaluate CLIS, we manually study 100 randomly selected UDFs and find that 63 of them can be expressed in pure SQL. Our evaluation on these 63 UDFs shows that CLIS can automatically synthesize equivalent SQL expressions in 92% of the cases and that it can solve 2.4× more benchmarks compared to a baseline that does not use our compositional approach. We also show that CLIS yields an average speed-up of 4.6× for individual UDFs and 1.3× to 3.1× in terms of end-to-end application performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guoqiang</first_name>
          <last_name>Zhang</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
          <person_id>guoqiangzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yuanchao</first_name>
          <last_name>Xu</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>yuanchaoxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xipeng</first_name>
          <last_name>Shen</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>Xipeng Shen is an associate professor at the Computer Science Department, North Carolina State University (NCSU). He is a receipt of NSF CAREER Award, DOE Early Career Award, and Google Faculty Research Award. He is an ACM Distinguished Speaker, and a senior member of IEEE. Prior to joining NC State in 2014, Shen was the Adina Allen Term Distinguished Associate Professor at The College of William and Mary. He had served as a consultant to Intel Labs and Cisco, and a Visiting Researcher at MIT and Microsoft Research. He received his Ph.D. in Computer Science from University of Rochester in 2006.</bio>
          <homepage_url>http://people.engr.ncsu.edu/xshen5/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xipengshen/7ba54e69-f90a-4cf7-90d2-19fdd5f42e87/small.jpg</picture_url>
          <person_id>xipengshen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
          <person_id>isildillig</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>484d7f87-e011-4764-b4fe-44ad2fb95f14</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>9f2c66d6-0ef7-4d0a-b7a0-67631dbe792f</slot_id>
      <event_id>7a1731c9-53d0-4f27-90c8-227f5a3a717e</event_id>
      <submission_id>70</submission_id>
      <title>Verifying Concurrent Multicopy Search Structures</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/22</date>
      <start_time>19:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:50</end_time>
      <description>Multicopy data structures such as log-structured merge (LSM) trees are optimized for high insert/update/delete (collectively known as upsert) performance. In such search structures, an upsert on key $k$, which adds $(k,v)$ where $v$ can be a value or a tombstone, is added to the root node even if $k$ is already present in other nodes. Thus there may be multiple copies of $k$ in the search structure. A search on $k$ aims to return the value associated with the most recent upsert. We present a general framework for verifying linearizability of concurrent multicopy structures that abstracts from the underlying representation of the data structure in memory, enabling proof-reuse across diverse implementations. Based on our framework, we propose template algorithms for LSM structures forming arbitrary directed acyclic graphs, and formally verify these templates in the concurrent separation logic Iris. We instantiate this template to obtain the first verified concurrent in-memory LSM tree implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nisarg</first_name>
          <last_name>Patel</last_name>
          <affiliation>New York University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>nisargpatel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Siddharth</first_name>
          <last_name>Krishna</last_name>
          <affiliation>Microsoft Research, Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.nyu.edu/~siddharth/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/siddharthkrishna/fb064b85-b50f-4fba-9626-67ed7a75b358/small.jpg</picture_url>
          <person_id>siddharthkrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dennis</first_name>
          <last_name>Shasha</last_name>
          <affiliation>New York University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>dennisshasha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Wies</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.nyu.edu/wies/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thomaswies/e43dd6b5-97dc-433f-9708-836bd6364a01/small.jpg</picture_url>
          <person_id>thomaswies</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>768261ce-817a-4a1c-abcb-a4523fbe5a6e</subevent_id>
    <title>SPLASH OOPSLA: Distributed Programming</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>7a9afbef-474e-461c-b42b-1cd532310a47</slot_id>
      <title>Session: SPLASH OOPSLA - Distributed Programming</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Mohsen</first_name>
          <last_name>Lesani</last_name>
          <affiliation>University of California at Riverside</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucr.edu/~lesani/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mohsenlesani/9891c046-f676-41fd-a333-3603988b9484/small.jpg</picture_url>
          <person_id>mohsenlesani</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>02f67968-297b-443a-92e4-76b442960122</slot_id>
      <event_id>740c257f-f41f-4619-8c89-49e2da972d1d</event_id>
      <submission_id>446</submission_id>
      <title>Automatic Migration from Synchronous to Asynchronous JavaScript APIs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>16:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:25</end_time>
      <description>The JavaScript ecosystem provides equivalent synchronous and asynchronous Application Programming Interfaces (APIs) for many commonly used I/O operations. Synchronous APIs involve straightforward sequential control flow that makes them easy to use and understand, but their “blocking” behavior may result in poor responsiveness or performance. Asynchronous APIs impose a higher syntactic burden that relies on callbacks, promises, and higher-order functions. On the other hand, their nonblocking behavior enables applications to scale better and remain responsive while I/O requests are being processed. While it is generally understood that asynchronous APIs have better performance characteristics, many applications still rely on synchronous APIs. In this paper, we present a refactoring technique for assisting programmers with the migration from synchronous to asynchronous APIs. The technique relies on static analysis to determine where calls to synchronous API functions can be replaced with their asynchronous counterparts, relying on JavaScript’s async/await feature to minimize disruption to the source code. Since the static analysis is potentially unsound, the proposed refactorings are presented as suggestions that must be reviewed and confirmed by the programmer. The technique was implemented in a tool named Desynchronizer. In an empirical evaluation on 12 subject applications containing 316 synchronous API calls, Desynchronizer identified 256 of these as candidates for refactoring. Of these candidates, 244 were transformed successfully, and only 12 resulted in behavioral changes. Further inspection of these cases revealed that the majority of these issues can be attributed to unsoundness in the call graph.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Satyajit</first_name>
          <last_name>Gokhale</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/satyajitgokhale/0f26246b-3f7c-472b-9c93-a2f169f306e8/small.jpg</picture_url>
          <person_id>satyajitgokhale</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexi</first_name>
          <last_name>Turcotte</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://reallytg.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexiturcotte/6881a0a0-5145-40cb-aab4-ff41754a0640/small.jpg</picture_url>
          <person_id>alexiturcotte</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Tip</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Frank Tip is a Professor and Associate Dean for Graduate Programs at Northeastern University. Previously, he was a Senior Principal Engineer at Samsung Research America in Mountain View, California (2014-2016), a Professor and Cheriton Research Chair in the David R. Cheriton School of Computer Science at the University of Waterloo (2012-2014), and a Research Staff Member and Manager at the Software Technology Department at the IBM T.J. Watson Research Center (1995-2012). He received his PhD in 1995 from the University of Amsterdam.</bio>
          <homepage_url>http://www.franktip.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/franktip/b4b4c804-cf32-45fa-afc8-3058f718b160/small.jpg</picture_url>
          <person_id>franktip</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>13e72224-47cf-4644-a43c-ac7678d02864</slot_id>
      <event_id>62c941e0-1d73-41ab-b192-9220506f2589</event_id>
      <submission_id>119</submission_id>
      <title>A Multiparty Session Typing Discipline for Fault-tolerant Event-driven Distributed Programming</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:55</end_time>
      <description>Correctly designing and implementing distributed systems software is notoriously difficult. Multiparty session types (MPSTs) is a typing discipline for concurrent processes that statically ensures properties such as freedom from message reception errors and deadlocks. The existing approaches in MPSTs cannot, however, be applied to a significant class of real-world distributed systems because they do not support practical specification and verification of protocols that handle and recover from partial failures. 
This paper presents the first formulation of MPSTs for practical fault-tolerant distributed programming. We tackle the long-standing challenges faced by session types in this context: bringing structure to communication patterns involving asynchronous and concurrent partial failures, and integrating the range of features required to express fault-tolerant protocols in practice, that involve dynamic replacement of failed parties and retrying failed protocol segments in the presence of imperfect failure detection. Key to our approach is that we develop the first model of event-driven concurrency for multiparty sessions, to unify the session-typed handling of failures and regular I/O events. Moreover, the characteristics of our model allow us to prove a global progress property for well-typed processes engaged in multiple concurrent sessions, which does not hold in traditional MPST systems. To demonstrate its practicality, we implement our approach as a toolchain for Scala, and use it to specify and implement a session-typed version of the cluster manager (CM) system of the widely employed Apache Spark data analytics engine. Our session-typed CM integrates with the other vanilla Spark components to give a functioning Spark runtime; e.g., it can execute existing third-party Spark applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Malte</first_name>
          <last_name>Viering</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <person_id>malteviering</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>Queen Mary University London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://eecs.qmul.ac.uk/profiles/huraymond.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/raymondhu2/bc72da42-a3bc-4080-bd1d-9b94d850e254/small.jpg</picture_url>
          <person_id>raymondhu2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Eugster</last_name>
          <affiliation>USI Lugano &amp; Purdue University</affiliation>
          <bio>Patrick Eugster joined USI as a Full Professor of Computer Science in 2017, where he leads the SWYSTEMS (Software Systems) group, and co-founded the Computer Systems Institute in 2020. Prior to that he was a regular faculty member at TU Darmstadt (2014-2017) and Purdue University (2005-2016) where he remains an adjunct faculty member. Patrick holds M.S. (1998) and Ph.D. (2001) degrees from EPFL. 
Patrick is interested in software systems, with a particular focus on distributed systems and programming models/languages, and the intersection between the two. He has co-authored over 150 scientific articles on these topics. His research has been awarded by various funding agencies (e.g., NSF CAREER 2007, DARPA Computer Science Study Group 2011, ERC Consolidator 2014) and companies (e.g., Google Research Award 2003, NetApp Faculty Fellowship 2014, Facebook Research Award 2020). Patrick had the privilege to act as program chair of ACM OOPSLA 2015 and is currently serving as associate editor for IEEE Transactions on Software Engineering.</bio>
          <homepage_url>https://www.inf.usi.ch/faculty/eugstp/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/patrickeugster/bf8c955c-8902-4678-8c57-4b75cbd4f3c0/small.jpg</picture_url>
          <person_id>patrickeugster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lukasz</first_name>
          <last_name>Ziarek</last_name>
          <affiliation>University at Buffalo, SUNY</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.buffalo.edu/~lziarek/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lukaszziarek/78ff4fd0-ef3b-4aed-ba86-2d6e66f85f65/small.jpg</picture_url>
          <person_id>lukaszziarek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>179277cf-1331-433b-b364-686b4527ef2e</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6fd1f1cf-d08b-4cf8-802c-ea32e99eb5c8</slot_id>
      <event_id>cdc5b0cb-32bc-47df-a54d-5dd5e4516932</event_id>
      <submission_id>364</submission_id>
      <title>QuickSilver: Modeling and Parameterized Verification for Distributed Agreement-Based Systems</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>16:25</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:40</end_time>
      <description>The last decade has sparked several valiant efforts in deductive verification of distributed agreement protocols such as consensus and leader election. Oddly, there have been far fewer verification efforts that go beyond the core protocols and target applications that are built on top of agreement protocols. This is unfortunate, as agreement-based distributed services such as data stores, locks, and ledgers are ubiquitous and potentially permit modular, scalable verification approaches that mimic their modular design. 
We address this need for verification of distributed agreement-based systems through our novel modeling and verification framework, QuickSilver, that is not only modular, but also fully automated. The key enabling feature of QuickSilver is our encoding of abstractions of verified agreement protocols that facilitates modular, decidable, and scalable automated verification. We demonstrate the potential of QuickSilver by modeling and efficiently verifying a series of tricky case studies, adapted from real-world applications, such as a data store, a lock service, a surveillance system, a pathfinding algorithm for mobile robots, and more.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nouraldin</first_name>
          <last_name>Jaber</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/nouraldinjaber/0aeeca1f-ae9b-4220-85ef-02510d406a10/small.jpg</picture_url>
          <person_id>nouraldinjaber</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christopher</first_name>
          <last_name>Wagner</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/christopherwagner/571f9f20-6c46-40bb-a5b5-0ac8ad448fdf/small.jpg</picture_url>
          <person_id>christopherwagner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Swen</first_name>
          <last_name>Jacobs</last_name>
          <affiliation>CISPA Helmholtz Center for Information Security</affiliation>
          <bio>undefined</bio>
          <person_id>swenjacobs1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University. 
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures. 
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University. I received an NSF CAREER Award in 2012, a Department of Energy Early Career Research Award in 2013, and the Presidential Early Career Award for Scientists and Engineers in 2016.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
          <person_id>milindkulkarni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Roopsha</first_name>
          <last_name>Samanta</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/roopsha/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/roopshasamanta/3d74f41a-6adb-447b-8426-4a7fd9079dd4/small.jpg</picture_url>
          <person_id>roopshasamanta</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>de4d210a-6a98-4e20-bc06-f4e4ee9b0023</slot_id>
      <event_id>2c375f32-8c80-4300-b328-20661ab229e4</event_id>
      <submission_id>2</submission_id>
      <title>Much ADO about Failures: A Fault-Aware Model for Compositional Verification of Strongly Consistent Distributed Systems</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>15:55</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:10</end_time>
      <description>Despite recent advances, guaranteeing the correctness of large-scale distributed applications without compromising performance remains a challenging problem. Network and node failures are inevitable and, for some applications, careful control over how they are handled is essential. Unfortunately, existing approaches either completely hide these failures behind an atomic state machine replication (SMR) interface, or expose all of the network-level details, sacrificing atomicity. We propose a novel, compositional, atomic distributed object (ADO) model for strongly consistent distributed systems that combines the best of both options. The object-oriented API abstracts over protocol-specific details and decouples high-level correctness reasoning from implementation choices. At the same time, it intentionally exposes an abstract view of certain key distributed failure cases, thus allowing for more fine-grained control over them than SMR-like models. We demonstrate that proving properties even of composite distributed systems can be straightforward with our Coq verification framework, Advert, thanks to the ADO model. We also show that a variety of common protocols including multi-Paxos and Chain Replication refine the ADO semantics, which allows one to freely choose among them for an application’s implementation without modifying ADO-level correctness proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wolf</first_name>
          <last_name>Honore</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <person_id>wolfhonore</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jieung</first_name>
          <last_name>Kim</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/jkim</homepage_url>
          <person_id>jieungkim</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ji-Yong</first_name>
          <last_name>Shin</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.jiyongshin.info</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jiyongshin/887e7089-7e73-4b28-8c02-9dc79624fe5d/small.jpg</picture_url>
          <person_id>jiyongshin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
          <person_id>zhongshao</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9acec159-f093-4b84-8791-dda108158926</subevent_id>
    <title>SPLASH OOPSLA: Shared Memory</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>fb1ca30b-1dc7-4f39-8e7e-b95bc2e607c8</slot_id>
      <title>Session: SPLASH OOPSLA - Shared Memory</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Doug</first_name>
          <last_name>Lea</last_name>
          <affiliation>State University of New York (SUNY) Oswego</affiliation>
          <bio>Doug Lea is a professor of Computer Science at the State University of New York at Oswego. He is an author of books, articles, reports, and standardization efforts on object oriented software development including those on specification, design and implementation techniques, distributed, concurrent, and parallel object systems, and software reusability; and has served as chair, organizer, or program committee member for many conferences and workshops in these areas. He is the primary author of several widely used software packages and components.</bio>
          <homepage_url>http://gee.cs.oswego.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/douglea/3419ce80-c31d-4958-b043-53f6d89a34cd/small.jpg</picture_url>
          <person_id>douglea</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>061ee6ea-d630-4c99-a98a-a657425dd84b</slot_id>
      <event_id>ebe80fc8-3b07-494a-a4ca-22e80b3c5b6e</event_id>
      <submission_id>14</submission_id>
      <title>SecRSL: Security Separation Logic for C11 Release-Acquire Concurrency</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>15:55</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:10</end_time>
      <description>We present Security Relaxed Separation Logic (SecRSL), a separation logic for proving information-flow security of C11 programs in the Release-Acquire fragment with relaxed accesses. SecRSL is the first security logic that (1)~supports weak-memory reasoning about programs in a high-level language; (2)~inherits separation logic’s virtues of compositional, local reasoning about (3)~expressive security policies like value-dependent classification. 
SecRSL is also, to our knowledge, the first security logic developed over an axiomatic memory model. Thus we also present the first definitions of information-flow security for an axiomatic weak memory model, against which we prove SecRSL sound. SecRSL ensures that programs satisfy a constant-time security guarantee, while being free of undefined behaviour. 
We apply SecRSL to implement and verify the functional correctness and constant-time security of a range of concurrency primitives, including a spinlock module, a mixed-sensitivity mutex, and multiple synchronous channel implementations. Empirical performance evaluations of the latter demonstrate SecRSL’s power to support the development of secure and performant concurrent C programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pengbo</first_name>
          <last_name>Yan</last_name>
          <affiliation>University of Melbourne</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/pengboyan1/e18d6038-3acb-4c3d-8c02-3c0448477791/small.jpg</picture_url>
          <person_id>pengboyan1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Toby</first_name>
          <last_name>Murray</last_name>
          <affiliation>University of Melbourne, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.eng.unimelb.edu.au/tobym</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobymurray/b22e1351-c7fc-420a-acef-492aadfce115/small.jpg</picture_url>
          <person_id>tobymurray</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>13ccc3f1-ca7c-40b5-a00f-e5c1c110d394</slot_id>
      <event_id>14c40490-ef1d-49cd-9483-5f093e37fb06</event_id>
      <submission_id>490</submission_id>
      <title>The Reads-From Equivalence for the TSO and PSO Memory Models</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>16:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:25</end_time>
      <description>The verification of concurrent programs remains an open challenge due to the non-determinism in inter-process communication. One recurring algorithmic problem in this challenge is the consistency verification of concurrent executions. In particular, consistency verification under a reads-from map allows to compute the \emph{reads-from (RF) equivalence} between concurrent traces, with direct applications to areas such as Stateless Model Checking (SMC). Importantly, the RF equivalence was recently shown to be coarser than the standard Mazurkiewicz equivalence, leading to impressive scalability improvements for SMC under SC (sequential consistency). However, for the \emph{relaxed memory} models of TSO and PSO (total/partial store order), the algorithmic problem of deciding the RF equivalence, as well as its impact on SMC, has been elusive. 
In this work we solve the algorithmic problem of consistency verification for the TSO and PSO memory models given a reads-from map, denoted $\operatorname{VTSO-rf}$ and $\operatorname{VPSO-rf}$, respectively. For an execution of $n$ events over $k$ threads and $d$ variables, we establish novel bounds that scale as $n^{k+1}$ for TSO and as $n^{k+1}\cdot \min(n^{k^2}, 2^{k\cdot d})$ for PSO. Moreover, based on our solution to these problems, we develop an SMC algorithm under TSO and PSO that uses the RF equivalence. The algorithm is \emph{exploration-optimal}, in the sense that it is guaranteed to explore each class of the RF partitioning exactly once, and spends polynomial time per class when $k$ is bounded. Finally, we implement all our algorithms in the SMC tool Nidhugg, and perform a large number of experiments over benchmarks from existing literature. Our experimental results show that our algorithms for $\operatorname{VTSO-rf}$ and $\operatorname{VPSO-rf}$ provide significant scalability improvements over standard alternatives. Moreover, when used for SMC, the RF partitioning is often much coarser than the standard Shasha-Snir partitioning for TSO/PSO, which yields a significant speedup in the model checking task.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Truc Lam</first_name>
          <last_name>Bui</last_name>
          <affiliation>Comenius University Bratislava</affiliation>
          <bio>undefined</bio>
          <person_id>truclambui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Krishnendu</first_name>
          <last_name>Chatterjee</last_name>
          <affiliation>IST Austria, Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pub.ist.ac.at/~kchatterjee/</homepage_url>
          <person_id>krishnenduchatterjee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tushar</first_name>
          <last_name>Gautam</last_name>
          <affiliation>IIT Bombay</affiliation>
          <bio>undefined</bio>
          <person_id>tushargautam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Pavlogiannis</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.au.dk/~pavlogiannis/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/andreaspavlogiannis1/e756b107-52cb-4474-b2a4-c5d3174d8d5c/small.jpg</picture_url>
          <person_id>andreaspavlogiannis1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Toman</last_name>
          <affiliation>IST Austria (Institute of Science and Technology Austria)</affiliation>
          <bio>undefined</bio>
          <person_id>viktortoman</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>1f01d3d2-864d-477e-90f8-917f115f876e</slot_id>
      <event_id>6aa106ca-9202-4ee8-904b-b032fcb07a70</event_id>
      <submission_id>99</submission_id>
      <title>The Semantics of Shared Memory in Intel CPU/FPGA Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>16:25</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>16:40</end_time>
      <description>Heterogeneous CPU/FPGA devices, in which a CPU and an FPGA can execute together while sharing memory, are becoming popular in several computing sectors. In this paper, we study the shared-memory semantics of these devices, with a view to providing a firm foundation for reasoning about the programs that run on them. We focus on Intel platforms that combine an Intel FPGA with a multicore Xeon CPU. We describe the weak-memory behaviours that are allowed (and observable) on these devices when CPU threads and an FPGA thread access common memory locations in a fine-grained manner through multiple channels. Some of these behaviours are familiar from well-studied CPU and GPU concurrency; others are weaker still. We encode these behaviours in two formal memory models: one operational, one axiomatic. We develop executable implementations of both models, using the CBMC bounded model-checking tool for our operational model and the Alloy modelling language for our axiomatic model. Using these, we cross-check our models against each other via a translator that converts Alloy-generated executions into queries for the CBMC model. We also validate our models against actual hardware by translating 477 Alloy-generated executions into litmus tests that we run on CPU/FPGA devices; when doing this, we avoid the prohibitive cost of synthesising a hardware design per litmus test by creating our own ‘litmus-test processor’ in hardware. We expect that our models, one of which has been deemed ‘definitive’ by a Senior Principal Engineer at Intel, will be useful for low-level programmers, compiler writers, and designers of analysis tools. Indeed, as a demonstration of the utility of our work, we use our operational model to reason about a producer/consumer buffer implemented across the CPU and the FPGA. When the buffer uses insufficient synchronisation – a situation that our model is able to detect – we observe that its performance improves at the cost of occasional data corruption.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dan</first_name>
          <last_name>Iorga</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~di13/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/daniorga/dac1a236-b8e7-462e-a2c3-2713314bf843/small.jpg</picture_url>
          <person_id>daniorga</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alastair F.</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I’m a PhD student at Imperial College London supervised by Alastair Donaldson. I study testing and modeling of many-core systems, with an emphasis on fine-grained communication idioms.</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~trs15/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tylersorensen/a5910621-6b59-4729-be27-e5dfae22a495/small.jpg</picture_url>
          <person_id>tylersorensen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>67d2dc7f-3d3c-4c41-9512-0559896c77a8</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f0e1e423-1f73-44ee-b7f8-144248fbfb45</slot_id>
      <event_id>ad86ee65-6cc2-442d-97e9-4761304ac507</event_id>
      <submission_id>9</submission_id>
      <title>Making Weak Memory Models Fair</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:55</end_time>
      <description>Liveness properties, such as termination, of even the simplest shared-memory concurrent programs under sequential consistency typically require some fairness assumptions about the scheduler. Under weak memory models we observe that the standard notions of thread fairness are insufficient, and, an additional fairness property, which we call memory fairness, is needed. 
In this paper, we propose a uniform definition for memory fairness that can be integrated in any declarative memory model enforcing porf-acyclicity. For models, such as SC, TSO, RA, and StrongCOH, with equivalent operational and declarative presentations, we show that our declarative memory fairness condition is equivalent to an intuitive model-specific operational notion of memory fairness, which requires the memory system to fairly execute its internal propagation steps. Our fairness condition preserves the correctness of local transformations and the compilation scheme from RC11 to x86-TSO, and also enables the first formal proofs of termination of mutual exclusion lock implementations under declarative weak memory models.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Egor</first_name>
          <last_name>Namakonov</last_name>
          <affiliation>JetBrains Research, St Petersburg University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/egornamakonov/441c64d6-cf63-4751-9ba9-a8ae7d54216c/small.jpg</picture_url>
          <person_id>egornamakonov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonas</first_name>
          <last_name>Oberhauser</last_name>
          <affiliation>Huawei Dresden Research Center, Huawei OS Kernel Lab</affiliation>
          <bio>undefined</bio>
          <person_id>jonasoberhauser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anton</first_name>
          <last_name>Podkopaev</last_name>
          <affiliation>HSE University, JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://podkopaev.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/antonpodkopaev/b00dceb2-5b55-4c0b-afe0-17581b19dfee/small.jpg</picture_url>
          <person_id>antonpodkopaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>Viktor Vafeiadis is a tenured researcher at the Max Planck Institute for Software Systems (MPI-SWS), working on weak memory consistency and persistency. He has made numerous contributions on the semantics of weak memory consistency as well as on verification of concurrent programs with program logics and/or model checking, having published over 60 articles at top-tier venues. He got his PhD from the University of Cambridge in 2008 on concurrent program logics, for which he received the ACM SIGPLAN distinguished dissertation award. After postdoc positions at Microsoft Research and at the University of Cambridge, he joined the MPI-SWS in 2010 and got tenure in 2016.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
          <person_id>viktorvafeiadis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8d0693c5-0cfe-436d-8e56-02a8877a467c</subevent_id>
    <title>SPLASH OOPSLA: Corpus and User Studies - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>8153f459-3cfe-49cd-8d4e-9d4e71696db5</slot_id>
      <title>Session: SPLASH OOPSLA - Corpus and User Studies - mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Alastair F.</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>75b8eaac-5ea7-4297-b6e0-126c27db131d</slot_id>
      <event_id>75978bcc-89d2-43d2-9ca9-77bb20edeb87</event_id>
      <submission_id>117</submission_id>
      <title>Well-Typed Programs Can Go Wrong: A Study of Typing-Related Bugs in JVM Compilers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>07:55</end_time>
      <description>Despite the substantial progress in compiler testing, the research endeavors have mainly focused on detecting compiler crashes and subtle miscompilations caused by bugs in the implementation of compiler optimizations. Surprisingly, this growing body of work neglects other compiler components, most notably the front-end. In statically-typed programming languages with rich and expressive type systems and modern features, such as type inference or a mix of object-oriented with functional programming features, the process of static typing in compiler front-ends is complicated by a high-density of bugs. Such bugs can lead to the acceptance of incorrect programs (breaking code portability or the type system’s soundness), the rejection of correct (e.g. well-typed) programs, and the reporting of misleading errors and warnings. 
We conduct, what is to the best of our knowledge, the first empirical study for understanding and characterizing typing-related compiler bugs. To do so, we manually study 320 typing-related bugs (along with their fixes and test cases) that are randomly sampled from four mainstream JVM languages, namely Java, Scala, Kotlin, and Groovy. We evaluate each bug in terms of several aspects, including their symptom, root cause, bug fix’s size, and the characteristics of the bug-revealing test cases. Some representative observations indicate that: 1) more than a half of the typing-related bugs manifest as unexpected compile-time errors: the buggy compiler wrongly rejects semantically correct programs, 2) the majority of typing-related bugs lie in the implementations of the underlying type systems and in other core components related to operations on types, 3) parametric polymorphism is the most pervasive feature in the corresponding test cases, 4) one third of typing-related bugs are triggered by non-compilable programs. 
We believe that our study opens up a new research direction by driving future researchers to build appropriate methods and techniques for a more holistic testing of compilers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefanos</first_name>
          <last_name>Chaliasos</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Stefanos Chaliasos is a PhD candidate advised by Dr Ben Livshits and Dr Arthur Gervais at Imperial College London. He holds an MSc in Computer Science from the National and Kapodistrian University of Athens and a BSc in Management Science and Technology from the Athens University of Economics and Business. He has previously worked in the industry as a software engineer at Greek Research and Technology Network (GRNET) and as a researcher in the FASTEN project. His main research interests involve Computer Security, Software Testing, Program Analysis, and Programming Languages.</bio>
          <homepage_url>https://stefanoschaliasos.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefanoschaliasos/abb30586-5ab6-4e4e-9363-d2604af831ec/small.jpg</picture_url>
          <person_id>stefanoschaliasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thodoris</first_name>
          <last_name>Sotiropoulos</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>Thodoris Sotiropoulos is a PhD candidate at the Department of Management Science and Technology. He holds an MSc with distinction in Advanced Computing from Imperial College London, and a BSc in Management Science and Technology from the Athens University of Economics and Business. He has previously worked in industry as a software engineer at the Greek Research and Technology Network (GRNET).</bio>
          <homepage_url>https://theosotr.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thodorissotiropoulos/9e48a9b1-ba8a-4565-97da-0ed90ead2047/small.jpg</picture_url>
          <person_id>thodorissotiropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Georgios-Petros</first_name>
          <last_name>Drosos</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/georgiospetrosdrosos/94bab4c6-9f9f-4a22-b4f7-b111515d1936/small.jpg</picture_url>
          <person_id>georgiospetrosdrosos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charalambos Ioannis</first_name>
          <last_name>Mitropoulos</last_name>
          <affiliation>Technical University of Crete</affiliation>
          <bio>undefined</bio>
          <person_id>charalambosioannismitropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Mitropoulos</last_name>
          <affiliation>National and Kapodistrian University of Athens</affiliation>
          <bio>Dimitris Mitropoulos is an Assistant Professor at the National and Kapodistrian University of Athens and the Head of Reliability Engineering at the Greek National Infrastructures for Research and Technology (GRNET). Previously, he has been a Postdoctoral Researcher at the Network Security Laboratory (NSL) of Columbia University in the City of New York. Dimitris holds a PhD in Computer Security from the Athens University of Economics and Business and has been involved in several EU and US funded R&amp;amp;D projects. His research interests include software engineering, computer security and software reliability. He is a member of ACM, IEEE, SysSec, and an official writer for the ACM Computing Reviews journal.</bio>
          <homepage_url>https://dimitro.gr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dimitrismitropoulos/a0d64ae8-d979-4ed9-a834-b808d3cc40d2/small.jpg</picture_url>
          <person_id>dimitrismitropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Diomidis</first_name>
          <last_name>Spinellis</last_name>
          <affiliation>Athens University of Economics and Business  &amp; TU Delft</affiliation>
          <bio>Diomidis Spinellis is Professor of Software Engineering in the Department of Management Science and Technology heading the Business Analytics Laboratory (BALab) at the Athens University of Economics and Business, Greece and Professor of Software Analytics in the Department of Software Technology at the Delft University of Technology. His research interests include software engineering, IT security, and computing systems. He has written two award-winning, widely-translated books: Code Reading and Code Quality: The Open Source Perspective. In 2016 he published the book Effective Debugging: 66 Specific Ways to Debug Software and Systems. Dr. Spinellis has also published more than 300 technical papers in journals and refereed conference proceedings, which have received more than 10500 citations. He served for a decade as a member of the IEEE Software editorial board, authoring the regular “Tools of the Trade” column and for four years at the magazine’s Editor in Chief. He has contributed code that ships with Apple’s macOS and BSD Unix and is the developer of CScout, UMLGraph, dgsh, and other open-source software packages, libraries, and tools. He holds an MEng in Software Engineering and a PhD in Computer Science, both from Imperial College London. Dr. Spinellis has served as an elected member of the IEEE Computer Society Board of Governors (2013–2015), and is a senior member of the ACM and the IEEE.</bio>
          <homepage_url>https://www.dmst.aueb.gr/dds</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/diomidisspinellis/a7f21db5-04c0-4282-85ab-614b4394c90a/small.jpg</picture_url>
          <person_id>diomidisspinellis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>787347b9-de22-44d5-b96f-227252fd0205</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>08:25</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>98e58ad0-22ab-4cd0-8ede-f97536a24f74</slot_id>
      <event_id>da83cec0-6c60-4185-8177-b65b19357468</event_id>
      <submission_id>331</submission_id>
      <title>How Statically-Typed Functional Programmers Write Code</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>08:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>08:25</end_time>
      <description>How working statically-typed functional programmers write code is largely understudied. And yet, a better understanding of developer practices could pave the way for the design of more useful and usable tooling, more ergonomic languages, and more effective on-ramps into programming communities. The goal of this work is to address this knowledge gap: to better understand the high-level authoring patterns that statically-typed functional programmers employ. We conducted a grounded theory analysis of 30 programming sessions of practicing statically-typed functional programmers, 15 of which also included a semi-structured interview. The theory we developed gives insight into how the specific affordances of statically-typed functional programming affect domain modeling, type construction, focusing techniques, exploratory and reasoning strategies, and expressions of intent. We conducted a set of quantitative lab experiments to validate our findings, including that statically-typed functional programmers often iterate between editing types and expressions, that they often run their compiler on code they fully believed will not successfully compile, and that they often make textual program edits that reliably signal future edits that they intend to make. Lastly, we outline the implications of our findings for language and tool design. The success of this approach in revealing program authorship patterns suggests that the same methodology could be used to study other understudied programmer populations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Justin</first_name>
          <last_name>Lubin</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jlubin.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/justinlubin1/20ea84ad-9355-48d7-924c-af6d84fdb568/small.jpg</picture_url>
          <person_id>justinlubin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sarah E.</first_name>
          <last_name>Chasins</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~schasins/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sarahchasins/11334835-84ec-45c0-8ba1-2b87910eb7f7/small.jpg</picture_url>
          <person_id>sarahchasins</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>b0441656-3f10-41a3-bbe7-4c23758dbfa7</slot_id>
      <event_id>24a8f69d-0191-4166-b3f5-353579f8fe38</event_id>
      <submission_id>121</submission_id>
      <title>What we Eval in the Shadows</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>07:55</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>08:10</end_time>
      <description>Most dynamic languages allow users to turn text into code using various functions, often named eval, with language-dependent semantics. The widespread use of these reflective functions hinders static analysis and prevents compilers from performing optimizations. This paper aims to provide a better sense of why programmers use eval. Understanding why eval is used in practice is key to finding ways to mitigate its negative impact. We have reasons to believe that reflective feature usage is language and application domain specific; we focus on data science code written in R, and compare our results to previous work that analyzed web programming in JavaScript. This paper studied 240,327 scripts extracted from 15,401 R packages, for a total of 49,296,059 calls to eval. We find that eval is indeed in widespread use; R’s eval is more pervasive and arguably dangerous than what was previously reported for JavaScript.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Donat-Bouillud</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.pdonatbouillud.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/pierredonatbouillud/3887f7f4-a8bf-4d04-af05-af6cd45e2423/small.jpg</picture_url>
          <person_id>pierredonatbouillud</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Filip</first_name>
          <last_name>Křikava</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fikovnik.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/filipkrikava/12cc1e57-732c-4b7e-880e-ca7b51a07d77/small.jpg</picture_url>
          <person_id>filipkrikava</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Kirsch</last_name>
          <affiliation>University of Salzburg</affiliation>
          <bio>Christoph Kirsch is Professor at the Department of Computer Sciences of the University of Salzburg, Austria. He received his Dr.Ing. degree from Saarland University in 1999 while at the Max Planck Institute for Computer Science in Saarbrücken, Germany. From 1999 to 2004 he worked as Postdoctoral Researcher at the Department of Electrical Engineering and Computer Sciences of the University of California, Berkeley. He later returned to Berkeley as Visiting Scholar (2008-2013) and Visiting Professor (2014) at the Department of Civil and Environmental Engineering. His research interests are in concurrent programming, memory management, virtualization, and formal verification. Dr. Kirsch co-invented embedded programming languages and systems such as Giotto, HTL, and the Embedded Machine, and more recently co-designed high-performance, multicore-scalable concurrent data structures and memory management systems. He co-founded the International Conference on Embedded Software (EMSOFT) in 2001 and served as ACM SIGBED chair from 2011 until 2013. He has been IEEE TCAD and ACM TODAES associate editor, and is ACM Distinguished Speaker since 2017.</bio>
          <homepage_url>http://cs.uni-salzburg.at/~ck</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophkirsch/2adc8995-a32a-49c9-b820-8427e5a1f25a/small.jpg</picture_url>
          <person_id>christophkirsch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>af0c6941-3b7f-4e4c-9875-79e315238790</subevent_id>
    <title>SPLASH OOPSLA: Test and Verification - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>c8d659a5-dfbb-4bfd-b77a-99d196decdb2</slot_id>
      <title>Session: SPLASH OOPSLA - Test and Verification - mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Shigeru</first_name>
          <last_name>Chiba</last_name>
          <affiliation>The University of Tokyo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csg.ci.i.u-tokyo.ac.jp/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/shigeruchiba/b57db719-4160-4e39-9f41-ef3facc9e449/small.jpg</picture_url>
          <person_id>shigeruchiba</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>2efdf859-c73b-4086-9dbc-aca64c21f394</slot_id>
      <event_id>dec21536-5710-4cea-9e64-3c18c13c7578</event_id>
      <submission_id>86</submission_id>
      <title>Formal Verification of High-Level Synthesis</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>22:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>22:20</end_time>
      <description>High-level synthesis (HLS), which refers to the automatic compilation of software into hardware, is rapidly gaining popularity. In a world increasingly reliant on application-specific hardware accelerators, HLS promises hardware designs of comparable performance and energy efficiency to those coded by hand in a hardware description language such as Verilog, while maintaining the convenience and the rich ecosystem of software development. However, current HLS tools cannot always guarantee that the hardware designs they produce are equivalent to the software they were given, thus undermining any reasoning conducted at the software level. Furthermore, there is mounting evidence that existing HLS tools are quite unreliable, sometimes generating wrong hardware or crashing when given valid inputs. 
To address this problem, we present the first HLS tool that is mechanically verified to preserve the behaviour of its input software. Our tool, called Vericert, extends the CompCert verified C compiler with a new hardware-oriented intermediate language and a Verilog back end, and has been proven correct in Coq. Vericert supports most C constructs, including all integer operations, function calls, local arrays, structs, unions, and general control-flow statements. An evaluation on the PolyBench/C benchmark suite indicates that Vericert generates hardware that is around an order of magnitude slower (only around 2× slower in the absence of division) and about the same size as hardware generated by an existing, optimising (but unverified) HLS tool.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yann</first_name>
          <last_name>Herklotz</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>My research focuses on formalising the process of converting high-level programming language descriptions to correct hardware that is functionally equivalent to the input. This process is called high-level synthesis (HLS), and allows software to be turned into custom accelerators automatically, which can then be placed on field-programmable gate arrays (FPGAs). An implementation in the Coq theorem prover called Vericert can be found on Github.</bio>
          <homepage_url>https://yannherklotz.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannherklotz/8a826a69-2e1a-4062-b141-594d84b9d987/small.jpg</picture_url>
          <person_id>yannherklotz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>Pollard</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>jamespollard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nadesh</first_name>
          <last_name>Ramanathan</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>nadeshramanathan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>78986357-ae60-46fa-baaa-f8f281035d7c</slot_id>
      <event_id>ffbfc4af-f8a6-43e6-9e8b-c1c5253ab739</event_id>
      <submission_id>143</submission_id>
      <title>Specifying and Testing GPU Workgroup Progress Models</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>22:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>22:35</end_time>
      <description>As GPU availability has increased and programming support has matured, a wider variety of applications are being ported to these platforms. Many parallel applications contain fine-grained synchronization idioms; as such, their correct execution depends on a degree of relative forward progress between threads (or thread groups). Unfortunately, many GPU programming specifications (e.g. Vulkan and Metal) say almost nothing about relative forward progress guarantees between workgroups. Although prior work has proposed a spectrum of plausible progress models for GPUs, cross-vendor specifications have yet to commit to any model. 
This work is a collection of tools experimental data to aid specification designers when considering forward progress guarantees in programming frameworks. As a foundation, we formalize a small parallel programming language that captures the essence of fine-grained synchronization. We then provide a means of formally specifying a progress model, and develop a termination oracle that decides whether a given program is guaranteed to eventually terminate with respect to a given progress model. Next, we formalize a constraint for concurrent programs that require relative forward progress to terminate. Using this constraint, we synthesize a large set of 483 progress litmus tests. Combined with the termination oracle, this allows us to determine the expected status of each litmus test – i.e. whether it is guaranteed eventual termination – under various progress models. We present a large experimental campaign running the litmus tests across 8 GPUs from 5 different vendors. Our results highlight that GPUs have significantly different termination behaviors under our test suite. Most notably, we find that Apple and ARM GPUs do not support the linear occupancy-bound model, an intuitive progress model defined by prior work and hypothesized to describe the workgroup schedulers of existing GPUs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>University of California at Santa Cruz</affiliation>
          <bio>I am a Post Doc researcher at Princeton University working in Margaret Martonosi’s group. My research interests are in concurrency: programming, modeling, testing, and architecture. In particular, I am interested in exploring new heterogeneous architectures and how programming models can enable development of secure and efficient applications. 
I received my PhD from the Multicore Programming Group at Imperial College London supervised by Alastair Donaldson. Previously, I worked with Ganesh Gopalakrishnan and Zvonimir Rakamaric at University of Utah.</bio>
          <homepage_url>https://www.cs.princeton.edu/~ts20/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tylersorensen1/e6c9c5cc-65e1-4a42-87c2-5e4a7d347b0d/small.jpg</picture_url>
          <person_id>tylersorensen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lucas Fernan</first_name>
          <last_name>Salvador</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>I am a software engineer at the Xbox Platform team, and used to be a Master’s student at Princeton University (having graduated in May 2021). My main area of interest is parallel computing in its multiple facets (algorithms, architecture and verification).</bio>
          <homepage_url>https://www.cs.princeton.edu/~ls24/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lucasfernansalvador/b45303b8-06e1-4f08-be26-369bff1b5628/small.jpg</picture_url>
          <person_id>lucasfernansalvador</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Harmit</first_name>
          <last_name>Raval</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>harmitraval</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hugues</first_name>
          <last_name>Evrard</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/huguesevrard1/4685a366-8c64-4450-8368-0839b97cf75d/small.jpg</picture_url>
          <person_id>huguesevrard1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Margaret</first_name>
          <last_name>Martonosi</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>margaretrmartonosi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Alastair F.</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>8d59326a-c468-4b0c-afe0-2af3492a713f</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>22:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a6922131-e626-4aba-95fc-aae684ec3304</slot_id>
      <event_id>b5f75101-c8be-4cba-88b6-888ea6deaadc</event_id>
      <submission_id>150</submission_id>
      <title>MonkeyDB: Effectively Testing Correctness under Weak Isolation Levels</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>22:05</end_time>
      <description>Modern applications, such as social networking systems and e-commerce platforms are centered around using large-scale storage systems for storing and retrieving data. In the presence of concurrent accesses, these storage systems trade off isolation for performance. The weaker the isolation level, the more behaviors a storage system is allowed to exhibit and it is up to the developer to ensure that their application can tolerate those behaviors. However, these weak behaviors only occur rarely in practice, that too outside the control of the application, making it difficult for developers to test the robustness of their code against weak isolation levels. 
This paper presents MonkeyDB, a mock storage system for testing storage-backed applications. MonkeyDB supports a Key-Value interface as well as SQL queries under multiple isolation levels. It uses a logical specification of the isolation level to compute, on a read operation, the set of all possible return values. MonkeyDB then returns a value randomly from this set. We show that MonkeyDB provides good coverage of weak behaviors, which is complete in the limit. We test a variety of applications for assertions that fail only under weak isolation. MonkeyDB is able to break each of those assertions in a small number of attempts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ranadeep</first_name>
          <last_name>Biswas</last_name>
          <affiliation>Informal Systems</affiliation>
          <bio>undefined</bio>
          <person_id>ranadeepbiswas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Diptanshu</first_name>
          <last_name>Kakwani</last_name>
          <affiliation>Microsoft, India</affiliation>
          <bio>undefined</bio>
          <person_id>diptanshukakwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jyothi</first_name>
          <last_name>Vedurada</last_name>
          <affiliation>IIT Hyderabad</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jyothivedurada.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jyothivedurada/669c2067-2bb1-4cfd-9ecd-ad4dc7772314/small.jpg</picture_url>
          <person_id>jyothivedurada</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>University of Paris / IRIF / CNRS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
          <person_id>constantinenea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Akash</first_name>
          <last_name>Lal</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/akashl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/akashlal/96032ffc-99b4-4b90-b99d-01b1f833751a/small.jpg</picture_url>
          <person_id>akashlal</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>98d3b139-8908-41ec-859f-f81d1f2f42a8</subevent_id>
    <title>SPLASH OOPSLA: Types</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>c7234353-bb35-4b83-97fe-a3710677c304</slot_id>
      <title>Session: SPLASH OOPSLA - Types</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>268b4ba2-16c3-4ae7-a4f7-95ce5e6a73e6</slot_id>
      <event_id>41174c70-3ab0-4594-8b81-6dea9b1c3735</event_id>
      <submission_id>47</submission_id>
      <title>Relational Nullable Types with Boolean Unification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:35</end_time>
      <description>We present a simple, practical, and expressive relational nullable type system. A relational nullable type system captures whether an expression may evaluate to null based on its type, but also based on the type of other related expressions. The type system extends the Hindley-Milner type system with Boolean constraints, supports parametric polymorphism, and preserves principal types modulo Boolean equivalence. We show how to support full Hindley-Milner style type inference with an extension of Algorithm W. 
We conduct a preliminary study of open source projects showing that there is a need for relational nullable type systems across a wide range of programming languages. The most important findings from the study are: (i) programmers use programming patterns where the nullability of one expression depends on the nullability of other related expressions, (ii) such invariants are commonly enforced with run-time exceptions, and (iii) reasoning about these programming patterns requires not only knowledge of when an expression may evaluate to null, but also when it may evaluate to a non-null value. We incorporate these observations in the design of the proposed relational nullable type system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jaco</first_name>
          <last_name>van de Pol</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Jaco van de Pol did his PhD research in Utrecht University on rewrite systems, in particular termination of higher-order rewrite systems. At CWI Amsterdam, he published several papers on theorem proving and model checking for concurrent systems in process algebra and contributed to the µCRL toolset. In Twente, he started a new research line on parallel model checking algorithms. This resulted in the LTSmin toolset for high-performance model checking. He worked on applications in embedded systems, safety &amp;amp; security and systems biology. 
Jaco van de Pol is now professor of Computer Science at Aarhus University, working on automated verification and synthesis. Publications at Google Scholar and DBLP. 
Affiliations: 
 
 MSc Utrecht University (supervisor Hans Zantema) 
 PhD Utrecht University (supervisor Jan Bergstra) 
 Research Assistant LMU Mathematisches Institute Munich (with Helmut Schwichtenberg) 
 Postdoc Technical University of Eindhoven (with Jozef Hooman) 
 Senior Researcher CWI (1999-2007) 
 Associate Professor Technical University of Eindhoven (2004-2007, 20%) 
 Professor Formal Methods and Tools at University of Twente (2007-2018; from Nov 2018 10%) 
 Professor Computer Science at Aarhus University (from Nov 2018) 
</bio>
          <homepage_url>https://www.cs.au.dk/~jaco</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jacovandepol/b053e08d-fe52-46a9-b4cd-b863ea6c9c07/small.jpg</picture_url>
          <person_id>jacovandepol</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>3ce90a8d-bd20-482e-9f78-d65cb3aefda5</slot_id>
      <event_id>3d8946fe-98b1-4684-8c3c-05faf136ee3f</event_id>
      <submission_id>43</submission_id>
      <title>Label Dependent Lambda Calculus and Gradual Typing</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:20</end_time>
      <description>Dependently-typed programming languages are gaining importance, because they can guarantee a wide range of properties at compile time. Their use in practice is often hampered because programmers have to provide very precise types. Gradual typing is a means to vary the level of typing precision between program fragments and to transition smoothly towards more precisely typed programs. The combination of gradual typing and dependent types seems promising to promote the widespread use of dependent types. 
We investigate a gradual version of a minimalist value-dependent lambda calculus. Compile-time calculations and thus dependencies are restricted to labels, drawn from a generic enumeration type. The calculus supports the usual Pi and Sigma types as well as singleton types and subtyping. It is sufficiently powerful to provide flexible encodings of variant and record types with first-class labels. 
We provide type checking algorithms for the underlying label-dependent lambda calculus and its gradual extension. The gradual type checker drives the translation into a cast calculus, which extends the original language. The cast calculus comes with several innovations: refined typing for casts in the presence of singletons, type reduction in casts, and fully dependent Sigma types. Besides standard metatheoretical results, we establish the gradual guarantee for the gradual language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Weili</first_name>
          <last_name>Fu</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>weilifu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fabian</first_name>
          <last_name>Krause</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <person_id>fabiankrause</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Thiemann</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/peterthiemann/43fc0175-1745-4b3a-b626-86e10da76b86/small.jpg</picture_url>
          <person_id>peterthiemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>5ef3e14b-448a-4aa2-8904-f6ae7a969898</slot_id>
      <event_id>ca540410-cf87-4a60-a719-2ad9b0f97620</event_id>
      <submission_id>170</submission_id>
      <title>Study of the Subtyping Machine of Nominal Subtyping with Variance</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:05</end_time>
      <description>This is a study of the computing power of the subtyping machine behind Kennedy and Pierce’s nominal subtyping with variance. We depict the lattice of fragments of Kennedy and Pierce’s type system and characterize their computing power in terms of regular, context-free, deterministic, and non-deterministic tree languages. Based on the theory, we present Treetop—a generator of C# implementations of subtyping machines. The software artifact constitutes the first feasible (yet POC) fluent API generator to support context-free API protocols in a decidable type system fragment.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ori</first_name>
          <last_name>Roth</last_name>
          <affiliation>Technion</affiliation>
          <bio>Ori Roth is a PhD student at the Technion—Israel Institute of Technology. His research interests include programming languages, software engineering, and automata theory.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/oriroth/f303c081-564f-4bb5-8037-c59de38bd235/small.jpg</picture_url>
          <person_id>oriroth</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>a35b0137-4a12-4ad1-b4d0-fc30fce8582d</slot_id>
      <event_id>3aad0c8c-c620-4cea-b83f-3ef19cdf6d5f</event_id>
      <submission_id>237</submission_id>
      <title>Type Stability in Julia: Avoiding Performance Pathologies in JIT Compilation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:50</end_time>
      <description>As a scientific programming language, Julia strives for performance but also provides high-level productivity features. To avoid performance pathologies, Julia users are expected to adhere to a coding discipline that enables so-called type stability. Informally, a function is type stable if the type of the output depends only on the types of the inputs, not their values. This paper provides a formal definition of type stability as well as a stronger property of type groundedness, shows that groundedness enables compiler optimizations, and proves the compiler correct. We also perform a corpus analysis to uncover how these type-related properties manifest in practice.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Artem</first_name>
          <last_name>Pelenitsyn</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mmcs.sfedu.ru/~ulysses/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/artempelenitsyn/747a7a15-5a78-4871-857b-53cbbe5f6e1e/small.jpg</picture_url>
          <person_id>artempelenitsyn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julia</first_name>
          <last_name>Belyakova</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Sep 2018 – present: PhD Student, Northeastern University, USA. Sep 2017 – Jul 2018: Researcher, Czech Technical University in Prague, Czech Republic. Jan 2017 – Jun 2017: Research Scientist, Northeastern University, USA. 2014–2016: teaching assistant/lecturer at Southern Federal University, Russia. Received MS in Computer Science from Southern Federal University, Russia in 2014.</bio>
          <homepage_url>https://julbinb.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juliabelyakova/b35236df-c22a-44f1-8048-aecfeba8ac2e/small.jpg</picture_url>
          <person_id>juliabelyakova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin W</first_name>
          <last_name>Chung</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <person_id>benjaminwchung</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ross</first_name>
          <last_name>Tate</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~ross/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rosstate/cbcbd066-943d-46a2-a301-1f4084076400/small.jpg</picture_url>
          <person_id>rosstate</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>aff00e6e-8fa5-4a66-8e75-841beb004fc1</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9daeb789-ba31-4abf-9aba-5b7d5ec343bc</subevent_id>
    <title>SPLASH OOPSLA: Smart Contracts and Distributed Programming</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>a06c9a13-291e-416e-ab8b-0a1738403aa1</slot_id>
      <title>Session: SPLASH OOPSLA - Smart Contracts and Distributed Programming</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Mohsen</first_name>
          <last_name>Lesani</last_name>
          <affiliation>University of California at Riverside</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucr.edu/~lesani/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mohsenlesani/9891c046-f676-41fd-a333-3603988b9484/small.jpg</picture_url>
          <person_id>mohsenlesani</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2071aa56-1d3b-4d08-b639-82fe941b482e</slot_id>
      <event_id>1d8597cd-3c9f-4c45-b22a-ec533b6faaba</event_id>
      <submission_id>222</submission_id>
      <title>Rich Specifications for Ethereum Smart Contract Verification</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:55</end_time>
      <description>Smart contracts are programs that execute inside blockchains such as Ethereum to manipulate digital assets. Since bugs in smart contracts may lead to substantial financial losses, there is considerable interest in formally proving their correctness. However, the specification and verification of smart contracts faces challenges that do not arise in other application domains. Smart contracts frequently interact with unverified, potentially adversarial outside code, which substantially weakens the assumptions that formal analyses can (soundly) make. Moreover, the core functionality of smart contracts is to manipulate and transfer resources; describing this functionality concisely requires dedicated specification support. Current reasoning techniques do not fully address these challenges, being restricted in their scope or expressiveness (in particular, in the presence of re-entrant calls), and offering limited means of expressing the resource transfers a contract performs. 
In this paper, we present a novel specification methodology tailored to the domain of smart contracts. Our specification constructs and associated reasoning technique are the first to enable: (1) sound and precise reasoning in the presence of unverified code and arbitrary re-entrancy, (2) modular reasoning about collaborating smart contracts, and (3) domain-specific specifications based on resources and resource transfers, which allow expressing a contract’s behavior in intuitive and concise ways and exclude typical errors by default. We have implemented our approach in 2vyper, an SMT-based automated verification tool for Ethereum smart contracts written in the Vyper language, and demonstrated its effectiveness in succinctly capturing and verifying strong correctness guarantees for real-world contracts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Braem</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christianbraem</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marco</first_name>
          <last_name>Eilers</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch/people/personal/meilers-pers.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marcoeilers/fbfa4a0a-c277-440b-af64-20c5dbf19d0c/small.jpg</picture_url>
          <person_id>marcoeilers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robin</first_name>
          <last_name>Sierra</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>robinsierra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Alexander J.</first_name>
          <last_name>Summers</last_name>
          <affiliation>University of British Columbia (UBC)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.ubc.ca/~alexsumm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexanderjsummers/f97b84a8-d46a-4e76-aa73-cc4b38c4ec41/small.jpg</picture_url>
          <person_id>alexanderjsummers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>6a711623-b03c-4a9e-b8bd-98e209e99ba2</slot_id>
      <event_id>70fddf0a-a865-4d6d-a00e-3c602d4f2336</event_id>
      <submission_id>42</submission_id>
      <title>ECROs: Building Global Scale Systems from Sequential Code</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>16:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:25</end_time>
      <description>To ease the development of geo-distributed applications, replicated data types (RDTs) offer a familiar programming interface while ensuring state convergence, low latency, and high availability. However, RDTs are still designed exclusively by experts using ad-hoc solutions that are error-prone and result in brittle systems. Recent works statically detect conflicting operations on existing data types and coordinate those at runtime to guarantee convergence and preserve application invariants. However, these approaches are too conservative, imposing coordination on a large number of operations. In this work, we propose a principled approach to design and implement efficient RDTs taking into account application invariants. Developers extend sequential data types with a distributed specification, which together form a RDT. We statically analyze the specification to detect conflicts and unravel their cause. This information is then used at runtime to serialize concurrent operations safely and efficiently. Our approach derives a correct RDT from any sequential data type without changes to the data type’s implementation and with minimal coordination. We implement our approach in Scala and develop an extensive portfolio of RDTs. The evaluation shows that our approach provides performance similar to conflict-free replicated data types for commutative operations, and considerably improves the performance of non-commutative operations, compared to existing solutions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kevin</first_name>
          <last_name>De Porre</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.kevindp.be</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kevindeporre1/3842a3bd-3338-4a6c-80b6-8fe72b9ca44b/small.jpg</picture_url>
          <person_id>kevindeporre1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carla</first_name>
          <last_name>Ferreira</last_name>
          <affiliation>NOVA LINCS &amp; Nova School of Sciences and Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ctp.di.fct.unl.pt/~cf/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/carlaferreira/84cdc5a2-f01b-44cd-b28f-73ae8baed899/small.jpg</picture_url>
          <person_id>carlaferreira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nuno</first_name>
          <last_name>Preguica</last_name>
          <affiliation>Universidade Nova Lisboa</affiliation>
          <bio>undefined</bio>
          <person_id>nunopreguica</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Gonzalez Boix</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/elisagonzalezboix/51a3d0ba-7330-40d4-ad16-4568d31fe2e4/small.jpg</picture_url>
          <person_id>elisagonzalezboix</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>849eccc2-b096-4723-a647-a1a0863ba84b</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>16:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca88cf46-5d91-4a04-9093-b4a203616eb4</slot_id>
      <event_id>3864f6b3-a74b-4f39-89f7-b15e107b4a2a</event_id>
      <submission_id>476</submission_id>
      <title>Symbolic Value-Flow Static Analysis: Deep, Precise, Complete Modeling of Ethereum Smart Contracts</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>15:55</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:10</end_time>
      <description>We present a static analysis approach that combines concrete values and symbolic expressions. This symbolic value-flow (“symvalic”) analysis models program behavior with high precision, e.g., full path sensitivity. To achieve deep modeling of program semantics, the analysis relies on a symbiotic relationship between a traditional static analysis fixpoint computation and a symbolic solver: the solver does not merely receive a complex “path condition” to solve, but is instead invoked repeatedly (often tens or hundreds of thousands of times), in close cooperation with the flow computation of the analysis. 
The result of the symvalic analysis architecture is a static modeling of program behavior that is much more complete than symbolic execution, much more precise than conventional static analysis, and domain-agnostic: no special-purpose definition of anti-patterns is necessary in order to compute violations of safety conditions with high precision. 
We apply the analysis to the domain of Ethereum smart contracts. This domain represents a fundamental challenge for program analysis approaches: despite numerous publications, research work has not been effective at uncovering vulnerabilities of high real-world value. 
In systematic comparison of symvalic analysis with past tools, we find significantly increased completeness (shown as 83-96% statement coverage and more true error reports) combined with much higher precision, as measured by rate of true positive reports. In terms of real-world impact, since the beginning of 2021, the analysis has resulted in the discovery and disclosure of several critical vulnerabilities, over funds in the many millions of dollars. Six separate bug bounties totaling over $350K have been awarded for these disclosures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neville</first_name>
          <last_name>Grech</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>My expertise is focused on program analysis, mostly applied to security applications. My work in this area has been recently highlighted by ACM SIGPLAN and Communications of the ACM. I am also interested in the areas of energy efficient systems, smart contracts, semantics and generative programming. Some popular tools I have codeveloped include decompilers and security analyzers for the Ethereum platform (MadMax and Gigahorse) and Java pointer and taint analysis frameworks (Doop, P/Taint and HeapDL). Previously, I was Reach High Fellow at the University of Athens, a Senior Research Associate at the University of Bristol, and have worked in industry as a Data Scientist and Software Engineer. I hold a PhD from the University of Southampton.</bio>
          <homepage_url>http://www.nevillegrech.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
          <person_id>nevillegrech</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sifis</first_name>
          <last_name>Lagouvardos</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/sifislagouvardos/7bff730b-e719-4f0c-935c-245291f18d9d/small.jpg</picture_url>
          <person_id>sifislagouvardos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Triantafyllou</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <person_id>konstantinostriantafyllou1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ilias</first_name>
          <last_name>Tsatiris</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/iliastsatiris/b33fd835-f771-4b76-b5e8-00452e460cf7/small.jpg</picture_url>
          <person_id>iliastsatiris</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>e43c8207-2a0f-4c35-a8c3-6503bbc7f849</slot_id>
      <event_id>f2687be1-d8a0-434b-942c-242aef9f826d</event_id>
      <submission_id>153</submission_id>
      <title>Durable Functions: Semantics for Stateful Serverless</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>16:25</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:40</end_time>
      <description>Serverless, or Functions-as-a-Service (FaaS), is an increasingly popular paradigm for application development, as it provides implicit elastic scaling and load based billing. However, the weak execution guarantees and intrinsic compute-storage separation of FaaS create serious challenges when developing applications that require persistent state, reliable progress, or synchronization. This has motivated a new generation of serverless frameworks that provide stateful abstractions. For instance, Azure’s Durable Functions (DF) programming model enhances FaaS with actors, workflows, and critical sections. As a programming model, DF is interesting because it combines task and actor parallelism, which makes it suitable for a wide range of serverless applications. We describe DF both informally, using examples, and formally, using an idealized high-level model based on the untyped lambda calculus. Next, we demystify how the DF runtime can (1) execute in a distributed unreliable serverless environment with compute-storage separation, yet still conform to the fault-free high-level model, and (2) persist execution progress without requiring checkpointing support by the language runtime. To this end we define two progressively more complex execution models, which contain the compute-storage separation and the record-replay, and prove that they are equivalent to the high-level model.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Burckhardt</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Sebastian Burckhardt was born and raised in Basel, Switzerland, where he studied Mathematics at the local University. During an exchange year at Brandeis University, he discovered his affinity to Computer Science and immigrated to the United States. After a few years of industry experience at IBM, he returned to academia and earned his PhD in Computer Science at the University of Pennsylvania. Since then, he has worked as a researcher at Microsoft Research in Redmond. His general research interest is the study of programming models for of concurrent, parallel, and distributed systems. More specific interests include consistency models, concurrency testing, self-adjusting computation, and the concurrent revisions programming model.</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/sburckha/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sebastianburckhardt/726ac702-681a-40f8-94d6-c0465e108867/small.jpg</picture_url>
          <person_id>sebastianburckhardt</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chris</first_name>
          <last_name>Gillum</last_name>
          <affiliation>Microsoft Azure</affiliation>
          <bio>undefined</bio>
          <person_id>chrisgillum</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Justo</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>David Justo is a Software Engineer at Microsoft, working on programming models for distributed systems and developer tooling more broadly. Previously, he was an MS student at UC San Diego working on program synthesis and polyglot programming. He’s interested in programming languages, programming environments, database theory, and formal methods.</bio>
          <homepage_url>https://davidmrdavid.github.io/about.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidjusto/1f7a0dc6-330d-47c6-9738-4e120b9e56bb/small.jpg</picture_url>
          <person_id>davidjusto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Kallas</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://angelhof.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/konstantinoskallas/532ec21f-35f9-482a-afc9-d7c8b7118a65/small.jpg</picture_url>
          <person_id>konstantinoskallas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Connor</first_name>
          <last_name>McMahon</last_name>
          <affiliation>Microsoft Azure</affiliation>
          <bio>undefined</bio>
          <person_id>connormcmahon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Christopher S.</first_name>
          <last_name>Meiklejohn</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>christophersmeiklejohn</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>30b33d29-b088-4297-874d-fd400615ee4d</subevent_id>
    <title>SPLASH OOPSLA: Rust</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>ef5128d1-9903-4f28-846a-013c71b754cb</slot_id>
      <title>Session: SPLASH OOPSLA - Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of 2020 Intel Rising Stars Award and the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0a5edf4c-5239-4054-897b-3c85dbf1550a</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8757f43f-995a-498a-989a-11de3166a255</slot_id>
      <event_id>d6067c7f-9230-454c-9672-66c980a2da21</event_id>
      <submission_id>27</submission_id>
      <title>Safer at Any Speed: Automatic Context-Aware Safety Enhancement for Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:35</end_time>
      <description>Type-safe languages improve application safety by eliminating whole classes of vulnerabilities, such as buffer overflows, by construction. But safety sometimes comes at a cost. As a result, modern type-safe languages often provide escape hatches that allow developers to manually bypass dynamic safety checks in hopes of improving performance. However, this requires applications to implicitly inherit whatever performance vs. safety trade-offs are made in libraries they depend on. Without knowing the importance of safety to each application, their performance requirements, the compiler used, or the hardware upon which applications will run, library developers have no hope of navigating such trade-offs appropriately for all cases. We find that in the Rust ecosystem, library developers have given up type safety in at least 10% of the 500 most downloaded packages in exchange for very little or no performance gains in many contexts. We present NADER, a Rust development tool that makes applications safer by automatically transforming unsafe code into equivalent safe code according to developer preferences and application context. In an end-to-end system evaluation, NADER automatically reintroduces dozens of bounds checks with no performance loss.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Natalie</first_name>
          <last_name>Popescu</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.princeton.edu/~npopescu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nataliepopescu1/7e11a54e-61c9-49bc-bc69-07f19db73a1b/small.jpg</picture_url>
          <person_id>nataliepopescu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ziyang</first_name>
          <last_name>Xu</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.princeton.edu/~ziyangx/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ziyangxu/4d095217-b7d0-4159-9508-7cae73aa6bf5/small.jpg</picture_url>
          <person_id>ziyangxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sotiris</first_name>
          <last_name>Apostolakis</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sapostolakis.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sotirisapostolakis/538416ca-ec5a-4441-b330-832a65a0bac2/small.jpg</picture_url>
          <person_id>sotirisapostolakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>David I.</first_name>
          <last_name>August</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>davidiaugust</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Amit</first_name>
          <last_name>Levy</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>amitlevy</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>e53480a7-b1f8-41ce-ab61-4e4566589840</slot_id>
      <event_id>9c148540-5a2f-4370-b1e1-f409b281e5e6</event_id>
      <submission_id>215</submission_id>
      <title>Modular Specification and Verification of Closures in Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:20</end_time>
      <description>Closures are a language feature supported by many mainstream languages, combining the ability to package up references to code blocks with the possibility of capturing state from the environment of the closure’s declaration. Closures are powerful, but complicate understanding and formal reasoning, especially when closure invocations may mutate objects reachable from the captured state or from closure arguments. This paper presents a novel technique for the modular specification and verification of closure-manipulating code in Rust. Our technique combines Rust’s type system guarantees and novel specification features to enable formal verification of rich functional properties. It encodes higher-order concerns into a first-order logic, which enables automation via SMT solvers. Our technique is implemented as an extension of the deductive verifier Prusti, with which we have successfully verified many common idioms of closure usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabian</first_name>
          <last_name>Wolff</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>fabianwolff</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aurel</first_name>
          <last_name>Bílý</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>aurelbily</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Matheja</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christophmatheja1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Alexander J.</first_name>
          <last_name>Summers</last_name>
          <affiliation>University of British Columbia (UBC)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.ubc.ca/~alexsumm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexanderjsummers/f97b84a8-d46a-4e76-aa73-cc4b38c4ec41/small.jpg</picture_url>
          <person_id>alexanderjsummers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>f127293d-9649-4e0f-9c50-3f9e4a433441</slot_id>
      <event_id>66f57c5c-e9da-44bf-9914-726337159123</event_id>
      <submission_id>101</submission_id>
      <title>Translating C to Safer Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>14:05</end_time>
      <description>Rust is a relatively new programming language that targets efficient and safe systems-level applications. It includes a sophisticated type system that allows for provable memory- and thread-safety, and is explicitly designed to take the place of unsafe languages such as C and C++ in the coding ecosystem. There is a large existing C and C++ codebase (many of which have been affected by bugs and security vulnerabilities due to unsafety) that would benefit from being rewritten in Rust to remove an entire class of potential bugs. However, porting these applications to Rust manually is a daunting task. 
In this paper we investigate the problem of automatically translating C programs into safer Rust programs—that is, Rust programs that improve on the safety guarantees of the original C programs. We conduct an in-depth study into the underlying causes of unsafety in translated programs and the relative impact of fixing each cause. We also describe a novel technique for automatically removing a particular cause of unsafety and evaluate its effectiveness and impact. This paper presents the first empirical study of unsafety in translated Rust programs (as opposed to programs originally written in Rust) and also the first technique for automatically removing causes of unsafety in translated Rust programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mehmet</first_name>
          <last_name>Emre</last_name>
          <affiliation>University of California, Santa Barbara</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.ucsb.edu/~emre</homepage_url>
          <person_id>mehmetemre</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Schroeder</last_name>
          <affiliation>University of California, Santa Barbara</affiliation>
          <bio>undefined</bio>
          <person_id>ryanschroeder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kyle</first_name>
          <last_name>Dewey</last_name>
          <affiliation>California State University, Northridge</affiliation>
          <bio>undefined</bio>
          <person_id>kyledewey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ben</first_name>
          <last_name>Hardekopf</last_name>
          <affiliation>UC Santa Barbara</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.cs.ucsb.edu/~benh</homepage_url>
          <person_id>benhardekopf</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0077f585-0c74-4d9d-91eb-ffbca7321026</subevent_id>
    <title>SPLASH OOPSLA: Dynamic Languages</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8181d564-03ea-4023-8229-135ee1e55a1a</slot_id>
      <title>Session: SPLASH OOPSLA - Dynamic Languages</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Julia</first_name>
          <last_name>Belyakova</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Sep 2018 – present: PhD Student, Northeastern University, USA. Sep 2017 – Jul 2018: Researcher, Czech Technical University in Prague, Czech Republic. Jan 2017 – Jun 2017: Research Scientist, Northeastern University, USA. 2014–2016: teaching assistant/lecturer at Southern Federal University, Russia. Received MS in Computer Science from Southern Federal University, Russia in 2014.</bio>
          <homepage_url>https://julbinb.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juliabelyakova/b35236df-c22a-44f1-8048-aecfeba8ac2e/small.jpg</picture_url>
          <person_id>juliabelyakova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3a36c8d0-e603-4151-a0ba-6d5abc8a1b9f</slot_id>
      <event_id>4a141d82-81f5-4f25-b5aa-659e52e64f49</event_id>
      <submission_id>49</submission_id>
      <title>Solver-based Gradual Type Migration</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:50</end_time>
      <description>Gradually typed languages allow programmers to mix statically and dynamically typed code, enabling them to incrementally reap the benefits of static typing as they add type annotations to their code. However, this type migration process is typically a manual effort with limited tool support. This paper examines the problem of automated type migration: given a dynamic program, infer additional or improved type annotations. 
Existing type migration algorithms prioritize different goals, such as maximizing type precision, maintaining compatibility with unmigrated code, and preserving the semantics of the original program. We argue that the type migration problem involves fundamental compromises: optimizing for a single goal often comes at the expense of others. Ideally, a type migration tool would flexibly accommodate a range of user priorities. 
We present TypeWhich, a new approach to automated type migration for an extension of the gradually-typed lambda calculus. Unlike prior work, which relies on custom solvers, TypeWhich produces constraints that can be solved by an off-the-shelf MaxSMT solver. This allows us to easily express objectives, such as minimizing the number of necessary syntactic coercions, and constraining the type of the migration to be compatible with unmigrated code. 
We present the first comprehensive evaluation of GTLC type migration algorithms, and compare TypeWhich to four other tools from the literature. Our evaluation uses prior benchmarks, and a new set of ``challenge problems''. Moreover, we design a new evaluation methodology that highlights the subtleties of gradual type migration. In addition, we apply TypeWhich to a suite of benchmarks for Grift, a programming language based on the GTLC. TypeWhich is able to reconstruct all human-written annotations on all but one program.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luna</first_name>
          <last_name>Phipps-Costin</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>undefined</bio>
          <person_id>lunaphippscostin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carolyn</first_name>
          <last_name>Anderson</last_name>
          <affiliation>Wellesley College</affiliation>
          <bio>undefined</bio>
          <person_id>carolynanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mgree.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>56c5ae90-3cf0-4675-8e13-431d50861312</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>79ba39ce-1153-4406-abf8-bc688920cf2c</slot_id>
      <event_id>499d1ade-0a8a-4045-884c-ebba85519ad6</event_id>
      <submission_id>125</submission_id>
      <title>Gradually Structured Data</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:35</end_time>
      <description>Dynamically-typed languages offer easy interaction with ad hoc data such as JSON and S-expressions; statically-typed languages offer powerful tools for working with structured data, notably algebraic datatypes, which are a core feature of typed functional languages such as OCaml and Haskell, or otherwise such as Scala and Rust. Gradual typing aims to reconcile dynamic and static typing smoothly. The gradual typing literature has extensively focused on the computational aspect of types, such as type safety, effects, noninterference, or parametricity, but the application of graduality to data structuring mechanisms has been much less explored. While row polymorphism and set-theoretic types have been studied in the context of gradual typing, algebraic datatypes in particular have not, which is surprising considering their wide use in practice. We develop, formalize and prototype a novel approach to gradually structured data with algebraic datatypes. Gradually structured data bridges the gap between traditional algebraic datatypes and flexible data management mechanisms such as tagged data in dynamic languages, or polymorphic variants in OCaml. We illustrate the key ideas of gradual algebraic datatypes through the evolution of a small server application from dynamic to progressively more static checking, formalize a core functional language with gradually structured data, and establish its metatheory, including the gradual guarantees.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Malewski</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://users.dcc.uchile.cl/~smalewsk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefanmalewski/cb42d4d7-af16-4e9d-b2a4-b8ce774834d7/small.jpg</picture_url>
          <person_id>stefanmalewski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mgree.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>a8e677b6-02b1-41e2-93b0-038a4a78dc69</slot_id>
      <event_id>05e9115b-0577-4202-ab11-ae1224cdc112</event_id>
      <submission_id>18</submission_id>
      <title>Promises Are Made to be Broken</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:05</end_time>
      <description>Function calls in the R language do not evaluate their arguments; these are passed to the callee as suspended computations and only evaluated if needed. After 25 years of experience with the language, there are very few cases where programmers leverage delayed evaluation intentionally. Yet, being lazy comes at a price in performance and complexity. This paper explores how to evolve the semantics of the language towards strictness by default and laziness on demand. To provide a migration path, it is necessary to change the semantics of the language and provide tooling for developers to migrate libraries and user code without introducing errors. This paper reports on a dynamic analysis that infers strictness signatures for functions to capture both intentional and accidental laziness. To assess the robustness of the inferred signatures we tested them on 2,000 R packages and found that inference was wrong in only 0.56% of the client programs. Finally, we report on the potential for performance improvements due to strictness. By modifying a just-in-time compiler to remove promises, we achieved an average speedup of 1.17X.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Ječmen</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <person_id>janjecmen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sebastián</first_name>
          <last_name>Krynski</last_name>
          <affiliation>Czech Technical University in Prague</affiliation>
          <bio>undefined</bio>
          <person_id>sebastiankrynski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>c62bca9d-0b47-42f5-a45e-d86bce2d8687</slot_id>
      <event_id>27a5d755-7c49-43c3-aea7-317ade9e584c</event_id>
      <submission_id>40</submission_id>
      <title>SimTyper: Sound Type Inference for Ruby using Type Equality Prediction</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:20</end_time>
      <description>Many researchers have explored type inference for dynamic languages. However, traditional type inference computes most general types which, for complex type systems—which are often needed to type dynamic languages—can be verbose, complex, and difficult to understand. In this paper, we introduce SimTyper, a Ruby type inference system that aims to infer \emph{usable} types—specifically, nominal and generic types—that match the types programmers write. SimTyper builds on InferDL, a recent Ruby type inference system that soundly combines standard type inference with heuristics. The key novelty of SimTyper is \emph{type equality prediction}, a new, machine learning-based technique that predicts when method arguments or returns are likely to have the same type. SimTyper finds pairs of positions that are predicted to have the same type yet one has a verbose, overly general solution and the other has a usable solution. It then guesses the two types are equal, keeping the guess if it is consistent with the rest of the program, and discarding it if not. In this way, types inferred by SimTyper are guaranteed to be sound. Type equality prediction is performed by a \emph{deep similarity} (DeepSim) neural network, which follows the Siamese network architecture, and uses CodeBERT, a pre-trained model, to embed source tokens into vectors that capture tokens and their contexts. DeepSim is trained on 100,000 pairs labeled with type similarity information extracted from 371 Ruby programs with manually documented, but not checked, types. We evaluated SimTyper on eight Ruby programs and found that, compared to standard type inference, SimTyper finds 71% more types that match programmer-written type information. Moreover, DeepSim can predict rare types that appear neither in the Ruby standard library nor in the training data. Our results show that type equality prediction can help type inference systems effectively produce more usable types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milod</first_name>
          <last_name>Kazerounian</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>undefined</bio>
          <person_id>milodkazerounian1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeffrey S.</first_name>
          <last_name>Foster</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.tufts.edu/~jfoster/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeffreysfoster/b22ce952-32b0-48bd-be56-12fd87bf3469/small.jpg</picture_url>
          <person_id>jeffreysfoster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bonan</first_name>
          <last_name>Min</last_name>
          <affiliation>Raytheon BBN Technologies</affiliation>
          <bio>undefined</bio>
          <person_id>bonanmin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2a53dbc8-8ad6-4ed9-b1e5-c439d967e7d2</subevent_id>
    <title>SPLASH OOPSLA: Optimization</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>42225286-08fb-4b9a-8764-22c2e94c4aec</slot_id>
      <title>Session: SPLASH OOPSLA - Optimization</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5d2ccc4a-0cdf-46df-88a1-1599ce5b6b77</slot_id>
      <event_id>e78d6285-c5ed-4a96-8242-9315d1c25ef4</event_id>
      <submission_id>194</submission_id>
      <title>VESPA: Static Profiling for Binary Optimization</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:20</end_time>
      <description>Over the past few years, there has been a surge in the popularity of binary optimizers such as BOLT, Propeller, Janus and HALO. These tools use dynamic profiling information to make optimization decisions. Although effective, gathering runtime data presents developers with inconveniences such as unrepresentative inputs, the need to accommodate software modifications, and longer build times. In this paper, we revisit the static profiling technique proposed by Calder et al. in the late 90’s, and investigate its application to drive binary optimizations, in the context of the BOLT binary optimizer, as a replacement for dynamic profiling. A few core modifications to Calder et al.’s original proposal, consisting of new program features and a new regression model, are sufficient to enable some of the gains obtained through runtime profiling. An evaluation of BOLT powered by our static profiler on four large benchmarks (clang, GCC, MySQL and PostgreSQL) yields binaries that are 5.50% faster than the executables produced by clang -O3.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Angelica Aparecida</first_name>
          <last_name>Moreira</last_name>
          <affiliation>Universidade Federal de Minas Gerais</affiliation>
          <bio>Angélica Moreira is a late 3rd year PhD candidate in the Computer Science Department at Federal University of Minas Gerais (UFMG). She is a member of the Compilers Laboratory (LAC), where she is advised by Professor Fernando Magno Quintão Pereira. She holds an M.Sc degree in Computer Science from the Federal University of Ouro Preto (UFOP) and a B.Sc degree in Computer Science from the Pontifical Catholic University of Minas Gerais (PUC Minas). 
Angélica’s research interest lies in pursuing the design and implementation of techniques that reduce program binary size and make them run faster on heterogeneous architectures. Her research focuses on combining machine learning and compilation techniques to achieve her goal. Her dream is to contribute to a better world through the development of science and technology.</bio>
          <homepage_url>https://homepages.dcc.ufmg.br/~angelica.moreira/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/angelicaaparecidamoreira/8e228596-dcff-49ff-9b56-e77a499f89d8/small.jpg</picture_url>
          <person_id>angelicaaparecidamoreira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guilherme</first_name>
          <last_name>Ottoni</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~ottoni</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guilhermeottoni/a60389de-a60b-4624-949a-574fd53ea7ab/small.jpg</picture_url>
          <person_id>guilhermeottoni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>Federal University of Minas Gerais</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an associate professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
          <person_id>fernandomagnoquintaopereira</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>5d59cc95-38b3-44e7-90e6-bcc4d0b84f55</slot_id>
      <event_id>b07a5fb5-66c7-4797-a121-2c07df02ff9d</event_id>
      <submission_id>169</submission_id>
      <title>Copy-and-Patch Compilation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:05</end_time>
      <description>Fast compilation is important when compilation occurs at runtime, such as query compilers in modern database systems and WebAssembly virtual machines in modern browsers. We present copy-and-patch, an extremely fast compilation technique that also produces good quality code. It is capable of lowering both high-level languages and low-level bytecode programs to binary code, by stitching together code from a large library of binary implementation variants. We call these binary implementations stencils because they have holes where missing values must be inserted during code generation. We show how to construct a stencil library and describe the copy-and-patch algorithm that generates optimized binary code. 
We demonstrate two use cases of copy-and-patch: a compiler for a high-level C-like language intended for metaprogramming and a compiler for WebAssembly. Our high-level language compiler has negligible compilation cost: it produces code from an AST in less time than it takes to construct the AST. We have implemented an SQL database query compiler on top of this metaprogramming system and show that on TPC-H database benchmarks, copy-and-patch generates code two orders of magnitude faster than LLVM -O0 and three orders of magnitude faster than higher optimization levels. The generated code runs an order of magnitude faster than interpretation and 15% faster than LLVM -O0. Our WebAssembly compiler generates code 4.9X-6.5X faster than Liftoff, the WebAssembly baseline compiler in Google Chrome. The generated code also outperforms Liftoff’s by 46%-63% on the Coremark and PolyBenchC WebAssembly benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Haoran</first_name>
          <last_name>Xu</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>haoranxu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>8376eb9d-b37e-4a1a-9347-7373327cfb97</slot_id>
      <event_id>a07657bd-7670-4ce9-b59c-c0d4a5733ee1</event_id>
      <submission_id>245</submission_id>
      <title>A Derivative-based Parser Generator for Visibly Pushdown Grammars</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:35</end_time>
      <description>In this paper, we present a derivative-based, functional recognizer and parser generator for visibly pushdown grammars. The generated parser accepts ambiguous grammars and produces a parse forest containing all valid parse trees for an input string in linear time. Each parse tree in the forest can then be extracted also in linear time. Besides the parser generator, to allow more flexible forms of the visibly pushdown grammars, we also present a translator that converts a tagged CFG to a visibly pushdown grammar in a sound way, and the parse trees of the tagged CFG are further produced by running the semantic actions embedded in the parse trees of the translated visibly pushdown grammar. The performance of the parser is compared with a popular parsing tool ANTLR on parsing JSON and HTML files. The correctness of the core parsing algorithm is formally verified in the proof assistant Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaodong</first_name>
          <last_name>Jia</last_name>
          <affiliation>The Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>xiaodongjia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ashish</first_name>
          <last_name>Kumar</last_name>
          <affiliation>The Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>ashishkumar1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gang</first_name>
          <last_name>Tan</last_name>
          <affiliation>Penn State University</affiliation>
          <bio>Dr. Gang Tan is the James F. Will Career Development Associate Professor in Computer Science and Engineering at Pennsylvania State University, PA. He leads the Security of Software (SOS) Lab. His research is at the interface between computer security, programming languages, and formal methods. He received his bachelor’s degree in Computer Science with honors from Tsinghua University in 1999 and his Ph.D. degree from Princeton University in 2005. He has received an NSF CAREER award, two Google Research Awards, and a Francis Upton Graduate Fellowship.</bio>
          <homepage_url>http://www.cse.psu.edu/~gxt29/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gangtan/e101adef-54fb-4fcc-bce0-381da3d1aace/small.jpg</picture_url>
          <person_id>gangtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>bc72eebd-3d99-433f-afeb-7c3a07ab4666</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9e7eea66-f426-41d4-80d4-01bf91dfc8b4</subevent_id>
    <title>SPLASH OOPSLA: Testing</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>9012807a-7ef6-4353-bac4-046e2daa2f08</slot_id>
      <title>Session: SPLASH OOPSLA - Testing</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Iulian</first_name>
          <last_name>Neamtiu</last_name>
          <affiliation>New Jersey Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://web.njit.edu/~ineamtiu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/iulianneamtiu/59a11852-72df-4d67-9331-8720d3d19a64/small.jpg</picture_url>
          <person_id>iulianneamtiu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>031a9473-cdc1-4b67-879e-fbb89fd8e10b</slot_id>
      <event_id>4e7d7fa2-4fd4-42e1-9e44-961a43dfab85</event_id>
      <submission_id>344</submission_id>
      <title>Fully Automated Functional Fuzzing of Android Apps for Detecting Non-Crashing Logic Bugs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:05</end_time>
      <description>Android apps are GUI-based event-driven software and have become ubiquitous in recent years. Obviously, functional correctness is critical for an app’s success. However, in addition to crash bugs, \emph{non-crashing functional bugs} (in short as “non-crashing bugs” in this work) like inadvertent function failures, silent user data lost and incorrect display information are prevalent, even in popular, well-tested apps. These non-crashing functional bugs are usually caused by program logic errors and manifest themselves on the graphic user interfaces (GUIs). In practice, such bugs pose significant challenges in effectively detecting them because (1) current practices heavily rely on expensive, small-scale manual validation (\emph{the lack of automation}); and (2) modern \emph{fully automated} testing has been limited to crash bugs (\emph{the lack of test oracles}). 
This paper fills this gap by introducing \emph{independent view fuzzing}, \emph{a novel, fully automated approach} for detecting non-crashing functional bugs in Android apps. Inspired by metamorphic testing, our key insight is to leverage the commonly-held \emph{independent view property} of Android apps to manufacture property-preserving mutant tests from a set of seed tests that validate certain app properties. The mutated tests help exercise the tested apps under additional, adverse conditions. Any property violations indicate likely functional bugs for further manual confirmation. We have realized our approach as an automated, end-to-end functional fuzzing tool, Genie. Given an app, (1) Genie automatically detects non-crashing bugs without requiring human-provided tests and oracles (thus \emph{fully automated}); and (2) the detected non-crashing bugs are diverse (thus \emph{general and not limited to specific functional properties}), which set Genie apart from prior work. 
We have evaluated Genie on 12 real-world Android apps and successfully uncovered 34 previously unknown non-crashing bugs in their latest releases — all have been confirmed, and 22 have already been fixed. Most of the detected bugs are nontrivial and have escaped developer (and user) testing for at least one year and affected many app releases, thus clearly demonstrating Genie’s effectiveness. These 34 non-crashing bugs could not been detected by prior fully automated GUI testing tools (as our evaluation confirms). Thus, our work complements and enhances existing manual testing and fully automated testing for crash bugs. 
To facilitate reviewing and replication of our work, we have open-sourced Genie and provided additional information (\emph{fully anonymized}) at https://github.com/functional-fuzzing-android-apps/home.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ting</first_name>
          <last_name>Su</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://tingsu.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tingsu/a7bc2f83-b98a-44ba-954c-da631ab86471/small.jpg</picture_url>
          <person_id>tingsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yichen</first_name>
          <last_name>Yan</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>yichenyan1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jue</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/juewang1/989813f5-0a9c-4617-8f83-9690a0e6b253/small.jpg</picture_url>
          <person_id>juewang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Sun</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>jinglingsun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yiheng</first_name>
          <last_name>Xiong</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>yihengxiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Geguang</first_name>
          <last_name>Pu</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <person_id>geguangpu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Ke</first_name>
          <last_name>Wang</last_name>
          <affiliation>Visa Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://kbwang.bitbucket.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kewang/37ef656e-ca92-475f-8a51-902dbe44fb72/small.jpg</picture_url>
          <person_id>kewang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>17f14932-3f40-41eb-b324-df1ff158261d</slot_id>
      <event_id>033e9d5c-0599-4e16-95be-bf846cf24376</event_id>
      <submission_id>236</submission_id>
      <title>Permchecker: A Toolchain for Debugging Memory Managers with Typestate</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:20</end_time>
      <description>Dynamic memory managers are a crucial component of almost every modern software system. In addition to implementing efficient allocation and reclamation, memory managers provide the essential abstraction of memory as distinct objects, which underpins the properties of memory safety and type safety. Bugs in memory managers, while not common, are extremely hard to diagnose and fix. One reason is that their implementations often involve tricky pointer calculations, raw memory manipulation, and complex memory state invariants. While these properties are often documented, they are not specified in any precise, machine-checkable form. A second reason is that memory manager bugs can break the client application in bizarre ways that do not immediately implicate the memory manager at all. A third reason is that existing tools for debugging memory errors, such as Memcheck, cannot help because they rely on correct allocation and deallocation information to work. 
In this paper we present Permchecker, a tool designed specifically to detect and diagnose bugs in memory managers. The key idea in Permchecker is to make the expected structure of the heap explicit by associating \emph{typestates} with each piece of memory. Typestate captures elements of both type (e.g., page, block, or cell) and state (e.g., allocated, free, or forwarded). Memory manager developers annotate their implementation with information about the expected typestates of memory and how heap operations change those typestates. At runtime, our system tracks the typestates and ensures that each memory access is consistent with the expected typestates. This technique detects errors quickly, before they corrupt the application or the memory manager itself, and it often provides accurate information about the reason for the error. 
The implementation of Permchecker uses a combination of compile-time annotation and instrumentation, and dynamic binary instrumention. Because the overhead of DBI is fairly high, Permchecker is suitable for a testing and debugging setting and not for deployment. It works on a wide variety of existing systems, including explict malloc/free memory managers and garbage collectors, such as those found in JikesRVM and OpenJDK. Since bugs in these systems are not numerous, we developed a testing methodology in which we automatically inject bugs into the code using bug patterns derived from real bugs. This technique allows us to test Permchecker on hundreds or thousands of buggy variants of the code. We find that Permchecker effectively detects and localizes errors in the vast majority of cases; without it, these bugs result in strange, incorrect behaviors usually long after the actual error occurs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Karl</first_name>
          <last_name>Cronburg</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.eecs.tufts.edu/~karl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/karlcronburg/1487b759-23be-47d5-adb2-f6e6b4013d52/small.jpg</picture_url>
          <person_id>karlcronburg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Guyer</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/samguyer/94906fdc-2110-48fb-a0cd-afd1464b9262/small.jpg</picture_url>
          <person_id>samguyer</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>2abb50ed-5999-400e-810d-f006a599ae35</slot_id>
      <event_id>1f6ab670-2e0d-4713-b59c-0e28fbaea895</event_id>
      <submission_id>532</submission_id>
      <title>Programming and Execution Models for Parallel Bounded Exhaustive Testing</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:50</end_time>
      <description>Bounded-exhaustive testing (BET), which exercises a program under test for all inputs up to some bounds, is an effective method for detecting software bugs. Systematic property-based testing is a BET approach where developers write test generation programs that describe properties of test inputs. Hybrid test generation programs offer the most expressive way to write desired properties by freely combining declarative filters and imperative generators. However, exploring hybrid test generation programs, to obtain test inputs, is both computationally demanding and challenging to parallelize. We present the first programming and execution models, dubbed Tempo, for parallel exploration of hybrid test generation programs. We describe two different strategies for mapping the computation to parallel hardware and implement them both for GPUs and CPUs. We evaluated Tempo by generating instances of various data structures commonly used for benchmarking in the BET domain. Additionally, we generated CUDA programs to stress test CUDA compilers, finding four bugs confirmed by the developers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nader</first_name>
          <last_name>Al Awar</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>naderalawar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kush</first_name>
          <last_name>Jain</last_name>
          <affiliation>The University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <person_id>kushjain</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chris</first_name>
          <last_name>Rossbach</last_name>
          <affiliation>The University of Texas at Austin and VMware Research Group</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.utexas.edu/~rossbach</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chrisrossbach/d36775ec-4ad9-4010-ae6e-ba41c5f9d61d/small.jpg</picture_url>
          <person_id>chrisrossbach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Milos</first_name>
          <last_name>Gligoric</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/milosgligoric/4d0671ae-937e-4f08-b499-092379ff7ad3/small.jpg</picture_url>
          <person_id>milosgligoric</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>67f4ede8-9e06-4251-ba78-3600b74b8176</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>73b86ac8-38fa-4453-a7b9-b90b02ab78c4</slot_id>
      <event_id>26e88f75-7306-434e-afa1-624701a72947</event_id>
      <submission_id>264</submission_id>
      <title>Generative Type-Aware Mutation for Testing SMT Solvers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/20</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:35</end_time>
      <description>We propose Generative Type-Aware Mutation, an effective approach for testing SMT solvers. The key idea is to realize generation through the mutation of expressions with parametric operators from the SMT-LIB specification. Generative Type-Aware Mutation is a hybrid of mutation-based and grammar-based type-ware mutations and features an unbounded mutation space—overcoming a major limitation of OpFuzz, the state-of-the-art fuzzer for SMT solvers. We have realized Generative Type-Aware Mutation in a practical SMT solver bug hunting tool, TypeFuzz. During three months of testing with TypeFuzz, we reported over 70 bugs in the state-of-the-art SMT solvers Z3 and CVC4. Among these, 48 bugs were confirmed and 35 bugs were fixed. Perhaps most notably, we found 9 soundness bugs in CVC4’s default mode alone. CVC4 has proven to be a very stable SMT solver and has resisted several fuzzing campaigns. A third of the soundness bugs in CVC4 (3/9) are at least 2 years latent and pre-date any previous SMT solver fuzzing campaigns.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jiwon</first_name>
          <last_name>Park</last_name>
          <affiliation>École Polytechnique</affiliation>
          <bio>undefined</bio>
          <person_id>jiwonpark</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Winterer</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wintered.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dominikwinterer/f89f4b13-8156-4541-b618-d5128446e27f/small.jpg</picture_url>
          <person_id>dominikwinterer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chengyu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>East China Normal University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.chengyuzhang.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chengyuzhang/eee80413-7fee-43ac-88d2-72212b8b352a/small.jpg</picture_url>
          <person_id>chengyuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.inf.ethz.ch/suz/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
          <person_id>zhendongsu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6af725b8-1750-4a30-9eb3-099b5aaabcc1</subevent_id>
    <title>SPLASH OOPSLA: Synthesis of models, tools and programs -- mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>b5d1f561-5a97-4653-98b7-180431dac4d1</slot_id>
      <title>Session: SPLASH OOPSLA - Synthesis of models, tools and programs -- mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Alex</first_name>
          <last_name>Potanin</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>I am an Associate Professor in the School of Engineering and Computer Science at Victoria University of Wellington, New Zealand. 
I am originally from Moscow, Russia with a background in Mathematics. I have completed my PhD in programming languages in 2006 and took up a job as a Lecturer in Software Engineering at Victoria University of Wellington. During my studies, I took short breaks to work as a Visiting Researcher at Purdue University, and Software Engineer at two Wellington start-ups. I spent 2013 on sabbatical at Carnegie Mellon University in Pittsburgh, PA, USA. I spent winter 2019/2020 on sabbatical at Kyoto University in Japan.</bio>
          <homepage_url>http://homepages.ecs.vuw.ac.nz/~alex/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexpotanin/614f887b-90a3-4626-b67d-fa63309b44c8/small.jpg</picture_url>
          <person_id>alexpotanin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>59414d9a-7616-453a-9e08-c8d152d22846</slot_id>
      <event_id>44632a19-da24-4769-9abf-fb6b1a1b8dab</event_id>
      <submission_id>410</submission_id>
      <title>Multi-modal Program Inference: a Marriage of Pre-trained Language Models and Component-based Synthesis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>19:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:50</end_time>
      <description>Multi-modal program synthesis refers to the task of synthesizing programs (code) from their specification given in different forms, such as a combination of natural language and examples. Examples provide a precise but incomplete specification, and natural language provides an ambiguous but more “complete” task description. Machine-learned pre-trained models (PTMs) are adept at handling ambiguous natural language, but struggle with generating syntactically and semantically precise code. Program synthesis techniques can generate correct code, often even from incomplete but precise specifications, such as examples, but they are unable to work with the ambiguity of natural languages. We present an approach that combines PTMs with component-based synthesis (CBS): PTMs are used to generate candidate programs from the natural language description of the task, which are then used to guide the CBS procedure to find the program that matches the precise examples-based specification. We use our combination approach to instantiate multi-modal synthesis systems for two programming domains: the domain of regular expressions and the domain of CSS selectors. Our evaluation demonstrates the effectiveness of our domain-agnostic approach in comparison to a state-of-the-art specialized system, and the generality of our approach in providing multi-modal program synthesis from natural language and examples in different programming domains.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kia</first_name>
          <last_name>Rahmani</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am a PhD candidate of computer science at Purdue University. I am a member of the programming languages group, working under the supervision of Professor Suresh Jagannathan and Professor Benjamin Delaware. 
My PhD thesis is focused around compilation, synthesis, and testing of modern database-backed programs. More broadly, I am interested in all formal methods for modeling and analysis of (classical or quantum) computer programs. 
I was previously a research intern at Microsoft, working on a new program synthesis technique based on pre-trained language models. My work was supervised by Dr. Mohammad Raza and Dr. Sumit Gulwani.</bio>
          <homepage_url>https://kiarahmani.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kiarahmani/745190a9-35f0-49e9-b5a9-f8831bce9162/small.jpg</picture_url>
          <person_id>kiarahmani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mohammad</first_name>
          <last_name>Raza</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>mohammadraza</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Vu</first_name>
          <last_name>Le</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>I am a Researcher at Microsoft, working on the Microsoft Program Synthesis using Examples (PROSE) framework. I obtained my PhD in 2015 at UC Davis, advised by Zhendong Su and Sumit Gulwani. My research is about developing novel and practical techniques to help improve the quality of critical software (e.g., compilers and database engines) and make programming accessible for end users. My work has led to the discovery of hundreds of bugs in GCC and LLVM, most of which have been fixed, and shipped in various Microsoft products.</bio>
          <homepage_url>http://vuminhle.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vule/8674b9d0-747d-4a80-b8f0-3c7a435cd9b7/small.jpg</picture_url>
          <person_id>vule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Morris</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>danielmorris</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Soares</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/gsoares/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gustavosoares/fc1e5a17-f939-4c3d-ab30-85467cb2610b/small.jpg</picture_url>
          <person_id>gustavosoares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Ashish</first_name>
          <last_name>Tiwari</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csl.sri.com/users/tiwari/</homepage_url>
          <person_id>ashishtiwari</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>91e24019-5406-4d22-961b-b97be409022f</slot_id>
      <event_id>984afe45-291b-4657-9b18-5d36553b8fcb</event_id>
      <submission_id>107</submission_id>
      <title>One Down, 699 to Go: or, synthesising compositional desugarings</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>19:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:20</end_time>
      <description>Programming or scripting languages used in real-world systems are seldom designed with a formal semantics in mind from the outset. Therefore, developing well-founded analysis tools for these systems requires reverse-engineering a formal semantics as a first step. This can take months or years of effort. 
Can we (at least partially) automate this process? Though desirable, automatically reverse-engineering semantics rules from an implementation is very challenging, as found by Krishnamurthi et al. [2019]. In this paper, we highlight that scaling methods with the size of the language is very difficult due to state space explosion, so we propose to learn semantics incrementally, in smaller parts. We give a formalisation of Krishnamurthi et al's desugaring learning framework in order to clarify the assumptions necessary for an incremental learning algorithm to be feasible.

We show that this reformulation allows us to extend the search space and express rules that Krishnamurthi et al. described as challenging, while still retaining feasibility. We evaluate enumerative synthesis as a baseline algorithm, and demonstrate that, with our reformulation of the problem, it is possible to learn correct  desugaring rules for the example source and core languages proposed by Krishnamurthi et al., in most cases identical to the intended rules.
</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sándor</first_name>
          <last_name>Bartha</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>sandorbartha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>Cheney</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/jcheney/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamescheney/fad2c5e0-4605-4bd7-a0bb-aa02ec0b60ba/small.jpg</picture_url>
          <person_id>jamescheney</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vaishak</first_name>
          <last_name>Belle</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>vaishakbelle</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>e8ac9e87-2082-4ff9-84a9-3029d269f30c</slot_id>
      <event_id>5a37cd42-11e4-4df2-a92f-376c879a05e3</event_id>
      <submission_id>94</submission_id>
      <title>Rewrite Rule Inference Using Equality Saturation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:05</end_time>
      <description>Many compilers, synthesizers, and theorem provers rely on rewrite rules to simplify expressions or prove equivalences. Developing rewrite rules can be difficult: rules may be subtly incorrect, profitable rules are easy to miss, and rulesets must be rechecked or extended whenever semantics are tweaked. Large rulesets can also be challenging to apply: redundant rules can slow down rule-based search and frustrate debugging. 
This paper explores how equality saturation, a promising technique that uses e-graphs to apply rewrite rules, can also be used to infer rewrite rules. E-graphs can compactly represent the exponentially large sets of enumerated terms and potential rewrite rules. We show that equality saturation efficiently shrinks both sets,leading to faster synthesis of smaller, more general rulesets. 
We prototyped these strategies in a tool dubbed Ruler. Compared to a similar tool built on CVC4, Ruler synthesizes 5.8× smaller rulesets 25× faster without compromising on proving power. In an end-to-end case study, we show Ruler-synthesized rules which perform as well as those crafted by domain experts, addressing a longstanding issue in a popular open source tool.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chandrakana</first_name>
          <last_name>Nandi</last_name>
          <affiliation>Certora, inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cnandi.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chandrakananandi/a90ad233-62bb-4a90-8e9d-9afd969ef245/small.jpg</picture_url>
          <person_id>chandrakananandi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Max</first_name>
          <last_name>Willsey</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.mwillsey.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/maxwillsey/ff552459-e263-42a5-b17b-1301d482943d/small.jpg</picture_url>
          <person_id>maxwillsey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Amy</first_name>
          <last_name>Zhu</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <person_id>amyzhu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Brett</first_name>
          <last_name>Saiki</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <person_id>brettsaiki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yisu Remy</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>PhD student at University of Washington.</bio>
          <homepage_url>https://remy.wang</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yisuremywang1/5aec4d9a-13a9-460e-8154-fc72a368b4f9/small.jpg</picture_url>
          <person_id>yisuremywang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Adam</first_name>
          <last_name>Anderson</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <person_id>adamanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Adriana</first_name>
          <last_name>Schulz</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <person_id>adrianaschulz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Dan</first_name>
          <last_name>Grossman</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~djg/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dangrossman/941e0321-e962-4f03-9027-ba9f0448e7df/small.jpg</picture_url>
          <person_id>dangrossman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Tatlock</last_name>
          <affiliation>University of Washington, Seattle</affiliation>
          <bio>Associate Professor at the University of Washington</bio>
          <homepage_url>https://ztatlock.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zacharytatlock/87af1196-2d8d-4bd5-a692-018d3939a00f/small.jpg</picture_url>
          <person_id>zacharytatlock</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>e9f05f39-4114-48e9-9b23-5f7d71644d9c</slot_id>
      <event_id>c534281c-22ac-4d12-b79c-ef3db26a300f</event_id>
      <submission_id>17</submission_id>
      <title>Semantic programming by example with pre-trained models</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>19:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:35</end_time>
      <description>The ability to learn programs from few examples is a powerful technology with disruptive applications in many domains, as it allows users to automate repetitive tasks in an intuitive way. Existing frameworks on inductive synthesis only perform syntactic manipulations, where they rely on the syntactic structure of the given examples and not their meaning. Any semantic manipulations, such as transforming dates, have to be manually encoded by the designer of the inductive programming framework. Recent advances in large language models have shown these models to be very adept at performing semantic transformations of its input by simply providing a few examples of the task at hand. When it comes to syntactic transformations, however, these models are limited in their expressive power. In this paper, we propose a novel framework for integrating inductive synthesis with few-shot learning language models to combine the strength of these two popular technologies. In particular, the inductive synthesis is tasked with breaking down the problem in smaller subproblems, among which those that cannot be solved syntactically are passed to the language model. We formalise three semantic operators that can be integrated with inductive synthesizers. To minimize invoking expensive semantic operators during learning, we introduce a novel deferred query execution algorithm that considers the operators to be oracles during learning. We evaluate our approach in the domain of string transformations: the combination methodology can automate tasks that cannot be handled using either technologies by themselves. Finally, we demonstrate the generality of our approach via a case study in the domain of string profiling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gust</first_name>
          <last_name>Verbruggen</last_name>
          <affiliation>Department of Computer Science, KU Leuven</affiliation>
          <bio>undefined</bio>
          <person_id>gustverbruggen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vu</first_name>
          <last_name>Le</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>I am a Researcher at Microsoft, working on the Microsoft Program Synthesis using Examples (PROSE) framework. I obtained my PhD in 2015 at UC Davis, advised by Zhendong Su and Sumit Gulwani. My research is about developing novel and practical techniques to help improve the quality of critical software (e.g., compilers and database engines) and make programming accessible for end users. My work has led to the discovery of hundreds of bugs in GCC and LLVM, most of which have been fixed, and shipped in various Microsoft products.</bio>
          <homepage_url>http://vuminhle.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vule/8674b9d0-747d-4a80-b8f0-3c7a435cd9b7/small.jpg</picture_url>
          <person_id>vule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>ea328dc8-7806-4dae-9e84-49f7ca09907c</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a1951cbd-47b6-4312-a4ab-916543ab6e32</subevent_id>
    <title>SPLASH OOPSLA: Specification Synthesis</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>b0ba1f76-cf50-425a-b721-72baa428a293</slot_id>
      <title>Session: SPLASH OOPSLA - Specification Synthesis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3ae5447c-3b96-47da-a249-dea254923827</slot_id>
      <event_id>b1cf329e-5f00-41ab-a8ac-2a2f2ba72e9f</event_id>
      <submission_id>83</submission_id>
      <title>Data-Driven Abductive Inference of Library Specifications</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:35</end_time>
      <description>Programmers often leverage data structure libraries that provide useful and reusable abstractions. Modular verification of programs that make use of these libraries naturally rely on specifications that capture important properties about how the library expects these data structures to be accessed and manipulated. However, these specifications are often missing or incomplete, making it hard for clients to be confident they are using the library safely. When library source code is also unavailable, as is often the case, the challenge to infer meaningful specifications is further exacerbated. In this paper, we present a novel data-driven abductive inference mechanism that infers specifications for library methods sufficient to enable verification of the library’s clients. Our technique combines a data-driven learning-based framework to postulate candidate specifications, along with SMT-provided counterexamples to refine these candidates, taking special care to prevent generating specifications that overfit to sampled tests. The resulting specifications form a minimal set of requirements on the behavior of library implementations that ensures safety of a particular client program. Our solution thus provides a new multi-abduction procedure for precise specification inference of data structure libraries guided by client-side verification tasks. Experimental results on a wide range of realistic OCaml data structure programs demonstrate the effectiveness of the approach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhe</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhezhou/278a17cb-759b-46f2-98ca-6cb67f839b0b/small.jpg</picture_url>
          <person_id>zhezhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robert</first_name>
          <last_name>Dickerson</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://robd.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/robertdickerson/e65391dc-1815-4ecc-b58f-6afd1e1ac81d/small.jpg</picture_url>
          <person_id>robertdickerson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Delaware</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/bendy/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benjamindelaware/39bbf6b3-d145-435c-8956-8acf8cfcaffa/small.jpg</picture_url>
          <person_id>benjamindelaware</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Suresh</first_name>
          <last_name>Jagannathan</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/suresh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sureshjagannathan/70e51299-573f-4211-a895-b2028c19c585/small.jpg</picture_url>
          <person_id>sureshjagannathan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>54d87c19-1e53-4160-84a9-2e61cd78510a</slot_id>
      <event_id>f48451af-33ee-4d30-9177-5142a5caec22</event_id>
      <submission_id>30</submission_id>
      <title>Synthesizing Contracts Correct Modulo a Test Generator</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:50</end_time>
      <description>We present an approach that learns contracts for object-oriented programs where guarantees of correctness of the contracts are made with respect to a test generator. Our contract synthesis approach is based on a novel notion of tight contracts and an online learning algorithm (for tight contracts) that works in tandem with a test generator. We implement our approach and evaluate it on a suite of programs written in C#, studying the safety and strength of the synthesized contracts, and compare them to those synthesized by Daikon.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Angello</first_name>
          <last_name>Astorga</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>angelloastorga1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shambwaditya</first_name>
          <last_name>Saha</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <person_id>shambwadityasaha2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ahmad</first_name>
          <last_name>Dinkins</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>ahmaddinkins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Felicia</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>feliciawang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>P.</first_name>
          <last_name>Madhusudan</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://madhu.cs.illinois.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/pmadhusudan/3775a90b-eb5d-4825-86d8-2a91a1e68fdf/small.jpg</picture_url>
          <person_id>pmadhusudan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tao</first_name>
          <last_name>Xie</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://taoxiease.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/taoxie/14ae8022-1dd6-4455-a54f-157c86bc406d/small.jpg</picture_url>
          <person_id>taoxie</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>b5f1fdff-ff31-47e1-ae15-3585eef991b5</slot_id>
      <event_id>63e652b6-5919-48e6-b8bb-c7ed0009804e</event_id>
      <submission_id>183</submission_id>
      <title>Static Detection of Silent Misconfigurations with Deep Interaction Analysis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:20</end_time>
      <description>The behavior of large systems is guided by their configurations: users set parameters in the configuration file to dictate which corresponding part of the system code is executed. However, it is often the case that, although some parameters are set in the configuration file, they do not influence the system runtime behavior, thus failing to meet the user’s intent. Moreover, such misconfigurations rarely lead to an error message or raising an exception. We introduce the notion of silent misconfigurations which are prohibitively hard to identify due to (1) lack of feedback and (2) complex interactions between configurations and code. 
This paper presents ConfigX, the first tool for the detection of silent configurations. The main challenge is to understand complex interactions between configuration and the code that is affected by them. Our goal is to derive a specification describing non-trivial dependencies between the configuration parameters that lead to silent misconfigurations. To this end, ConfigX uses static analysis to determine which parts of the system code are associated with configuration parameters. ConfigX then infers the connections between configuration parameters by analyzing their associated code blocks. We design customized control- and data-flow analysis to derive a specification of configurations. Additionally, we conduct reachability analysis to eliminate spurious rules to reduce false positives. Upon evaluation on five real-world datasets across three widely-used systems, Apache, vsftpd, and PostgreSQL, ConfigX detected more than 2200 silent misconfigurations. We additionally conducted a user study where we ran ConfigX on misconfigurations reported on user forums by real-world users. ConfigX easily detected issues and suggested a repair for those misconfigurations. Our solutions were accepted and confirmed in the interaction with the users, who originally posted the problems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jialu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jialuzhang/7427a686-f97e-42da-9f0b-4b94122d30f3/small.jpg</picture_url>
          <person_id>jialuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ruzica</first_name>
          <last_name>Piskac</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/~piskac/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ruzicapiskac/5643c034-322b-49cb-9686-ebb925bd37ed/small.jpg</picture_url>
          <person_id>ruzicapiskac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ennan</first_name>
          <last_name>Zhai</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ennanzhai.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ennanzhai/4ab41fb7-50ce-4cde-b173-2b1b7d957b82/small.jpg</picture_url>
          <person_id>ennanzhai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tianyin</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://tianyin.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tianyinxu1/e97e4373-f937-4b16-b4e0-4eec79f5eb77/small.jpg</picture_url>
          <person_id>tianyinxu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>dd6ab95d-8b36-48c9-96d4-faedc40bbc87</slot_id>
      <event_id>42d71fb3-b56f-4be5-89c7-9df2b25795da</event_id>
      <submission_id>180</submission_id>
      <title>Dynaplex: Analyzing Program Complexity using Dynamically Inferred Recurrence Relations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>11:05</end_time>
      <description>Being able to detect program runtime complexity is useful in many tasks (e.g., checking expected performance and identifying potential security vulnerabilities such as DoS attacks and information leakage). In this work, we introduce a new dynamic approach for inferring the asymptotic complexity bounds of recursive programs. From program execution traces, we learn \emph{recurrence relations} and solve them using pattern matching to obtain closed-form solutions representing asymptotic complexity bounds. This approach allows us to efficiently infer simple recurrence relations that represent nontrivial, potentially nonlinear polynomial and non-polynomial, complexity bounds. 
We present Dynaplex, a tool that implements these ideas to automatically generate recurrence relations from execution traces. Our preliminary results on popular and challenging recursive programs show that Dynaplex can learn precise relations capturing worst-case complexity bounds (e.g., $\mathtt{O(n \lg n)}$ for mergesort, $\mathtt{O(2^n)}$ for Tower of Hanoi and $\mathtt{O(n^{1.58})}$ for Karatsuba’s multiplication algorithm).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Didier</first_name>
          <last_name>Ishimwe</last_name>
          <affiliation>University of Nebraska-Lincoln</affiliation>
          <bio>undefined</bio>
          <person_id>didierishimwe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>KimHao</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>University of Nebraska-Lincoln</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ndkimhao.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kimhaonguyen/6a6755d8-13f3-4b86-b4aa-068f378b1ff2/small.jpg</picture_url>
          <person_id>kimhaonguyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>ThanhVu</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>George Mason University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nguyenthanhvuh.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thanhvunguyen/db337089-c863-4086-ad33-88d7dbfeb025/small.jpg</picture_url>
          <person_id>thanhvunguyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>eb5a06a0-be09-42f2-9e21-7d3115c7c52b</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b189e22e-f983-46fe-bbfd-1d0b2ee308c7</subevent_id>
    <title>SPLASH OOPSLA: Implementation of special Paradigms</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>cf4f853f-ea30-4422-99f7-d9933b7f6e8f</slot_id>
      <title>Session: SPLASH OOPSLA - Implementation of special Paradigms</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Frank</first_name>
          <last_name>Tip</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Frank Tip is a Professor and Associate Dean for Graduate Programs at Northeastern University. Previously, he was a Senior Principal Engineer at Samsung Research America in Mountain View, California (2014-2016), a Professor and Cheriton Research Chair in the David R. Cheriton School of Computer Science at the University of Waterloo (2012-2014), and a Research Staff Member and Manager at the Software Technology Department at the IBM T.J. Watson Research Center (1995-2012). He received his PhD in 1995 from the University of Amsterdam.</bio>
          <homepage_url>http://www.franktip.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/franktip/b4b4c804-cf32-45fa-afc8-3058f718b160/small.jpg</picture_url>
          <person_id>franktip</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>06d47352-20f8-47a7-ae2e-3d3dc3174c14</slot_id>
      <event_id>2a3bd10f-d88a-4ac7-b023-0ee9946d5e84</event_id>
      <submission_id>133</submission_id>
      <title>Compilation of Sparse Array Programming Models</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:50</end_time>
      <description>This paper shows how to compile sparse array programming languages. A sparse array programming language is an array programming language that supports element-wise application, reduction, and broadcasting of arbitrary functions over dense and sparse arrays with any fill value. Such a language has great expressive power and can express sparse and dense linear and tensor algebra, functions over images, exclusion and inclusion filters, and even graph algorithms. 
Our compiler strategy generalizes prior work in the literature on sparse tensor algebra compilation to support any function applied to sparse arrays, instead of only addition and multiplication. To achieve this, we generalize the notion of sparse iteration spaces beyond intersections and unions. These iteration spaces are automatically derived by considering how algebraic properties annotated onto functions interact with the fill values of the arrays. We then show how to compile these iteration spaces to efficient code. 
When compared with two widely-used Python sparse array packages, our evaluation shows that we generate built-in sparse array library features with a performance of 1.4$\times$ to 53.7$\times$ when measured against PyData/Sparse for user-defined functions and between 0.98$\times$ and 5.53$\times$ when measured against SciPy/Sparse for array slicing. Our technique outperforms PyData/Sparse by 6.58$\times$ to 70.3$\times$, and (where applicable) performs between 0.96$\times$ and 28.9$\times$ that of a dense NumPy implementation, on end-to-end sparse array applications. We also implement graph linear algebra kernels in our system with a performance of between 0.56$\times$ and 3.50$\times$ compared to that of the hand-optimized SuiteSparse:GraphBLAS library.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rawn</first_name>
          <last_name>Henry</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>rawnhenry</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivia</first_name>
          <last_name>Hsu</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>oliviahsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rohan</first_name>
          <last_name>Yadav</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>rohanyadav1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Kunle</first_name>
          <last_name>Olukotun</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arsenalfc.stanford.edu/kunle</homepage_url>
          <person_id>kunleolukotun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>samanamarsinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>42ece315-6d7f-4f80-8716-dbcd81a0be27</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d8fe5a64-0f97-4c0a-be4c-9b51852de1fd</slot_id>
      <event_id>dfc8e21a-b4fb-4095-9b67-790f96f35c7b</event_id>
      <submission_id>142</submission_id>
      <title>Coarsening Optimization for Differentiable Programming</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:05</end_time>
      <description>This paper presents a novel optimization for differentiable programming named coarsening optimization. It offers a systematic way to synergize symbolic differentiation and algorithmic differentiation (AD). Through it, the granularity of the computations differentiated by each step in AD can become much larger than a single operation, and hence lead to much reduced runtime computations and data allocations in AD. To circumvent the difficulties that control flow creates to symbolic differentiation in coarsening, this work introduces $\phi$-calculus, a novel method to allow symbolic reasoning and differentiation of computations that involve branches and loops. It further avoids “expression swell” in symbolic differentiation and balance reuse and coarsening through the design of reuse-centric segment of interest(SOI) identification. Experiments on a collection of real-world applications show that coarsening optimization is effective in speeding up AD, producing several times to an order of magnitude speedups.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xipeng</first_name>
          <last_name>Shen</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>Xipeng Shen is an associate professor at the Computer Science Department, North Carolina State University (NCSU). He is a receipt of NSF CAREER Award, DOE Early Career Award, and Google Faculty Research Award. He is an ACM Distinguished Speaker, and a senior member of IEEE. Prior to joining NC State in 2014, Shen was the Adina Allen Term Distinguished Associate Professor at The College of William and Mary. He had served as a consultant to Intel Labs and Cisco, and a Visiting Researcher at MIT and Microsoft Research. He received his Ph.D. in Computer Science from University of Rochester in 2006.</bio>
          <homepage_url>http://people.engr.ncsu.edu/xshen5/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xipengshen/7ba54e69-f90a-4cf7-90d2-19fdd5f42e87/small.jpg</picture_url>
          <person_id>xipengshen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guoqiang</first_name>
          <last_name>Zhang</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
          <person_id>guoqiangzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Irene</first_name>
          <last_name>Dea</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>irenedea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Samantha</first_name>
          <last_name>Andow</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>samanthaandow</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Emilio</first_name>
          <last_name>Arroyo-Fang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>emilioarroyofang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Neal</first_name>
          <last_name>Gafter</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>nealgafter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Johann</first_name>
          <last_name>George</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/johanngeorge/f99a55e9-45f5-4516-9791-9d211a03e432/small.jpg</picture_url>
          <person_id>johanngeorge</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Melissa</first_name>
          <last_name>Grueter</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>melissagrueter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Erik</first_name>
          <last_name>Meijer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>erikmeijer1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Olin</first_name>
          <last_name>Shivers</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>olinshivers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Steffi</first_name>
          <last_name>Stumpos</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>steffistumpos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>12</sort_key>
          <first_name>Alanna</first_name>
          <last_name>Tempest</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>alannatempest</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>13</sort_key>
          <first_name>Christy</first_name>
          <last_name>Warden</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>christywarden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>14</sort_key>
          <first_name>Shannon</first_name>
          <last_name>Yang</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>shannonyang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>e1a0dd77-238f-48d0-942b-0556f8dbfa6a</slot_id>
      <event_id>a9b6a816-8bad-42e4-8254-5769ef450530</event_id>
      <submission_id>81</submission_id>
      <title>Statically Bounded-Memory Delayed Sampling for Probabilistic Streams</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:20</end_time>
      <description>\emph{Probabilistic programming languages} aid developers performing Bayesian inference. These languages provide programming constructs and tools for probabilistic modeling and automating the process of developing a probabilistic inference procedure. Prior work introduced a probabilistic programming language, ProbZelus, to extend probabilistic programming functionality to unbounded streams of data. A key innovation of ProbZelus was to demonstrate that the \emph{delayed sampling} inference algorithm could be extended to work in a streaming context. ProbZelus showed that while delayed sampling could be effectively deployed on some programs, depending on the probabilistic model under consideration, delayed sampling is not guaranteed to use a bounded amount of memory over the course of the execution of the program. 
In this paper, we the present conditions on a probabilistic program’s execution under which delayed sampling will execute in bounded memory. The two conditions are dataflow properties of the core operations of delayed sampling: the \emph{$m$-consumed property} and \emph{the unseparated path property}. A program executes in bounded memory under delayed sampling if, and only if, it satisfies the $m$-consumed and unseparated path properties. We propose a static analysis that abstracts over these properties to soundly ensure that any program that passes the analysis satisfies these properties, and thus executes in bounded memory under delayed sampling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Baudart</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <person_id>guillaumebaudart1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charles</first_name>
          <last_name>Yuan</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>charlesyuan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>fea00bff-719d-42fb-a42c-9b40fe95f750</slot_id>
      <event_id>aac8ee13-0cef-4d91-b60c-f029b7f08587</event_id>
      <submission_id>45</submission_id>
      <title>Efficient Automatic Scheduling of Imaging &amp; Vision Pipelines for the GPU</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:35</end_time>
      <description>We present a new algorithm to quickly generate high-performance GPU implementations of complex imaging and vision pipelines, directly from high-level Halide algorithm code. It is fully automatic, requiring no schedule templates or hand-optimized kernels. We address the scalability challenge of extending search-based automatic scheduling to map large real-world programs to the deep hierarchies of memory and parallelism on GPU architectures in reasonable compile time. We achieve this using (1) a two-phase search algorithm that first ‘freezes’ decisions for the lowest cost sections of a program, allowing relatively more time to be spent on the important stages, (2) a hierarchical sampling strategy that groups schedules based on their structural similarity, then samples representatives to be evaluated, allowing us to explore a large space with few samples, and (3) memoization of repeated partial schedules, amortizing their cost over all their occurrences. We guide the process with an efficient cost model combining machine learning, program analysis, and GPU architecture knowledge. We evaluate our method’s performance on a diverse suite of real-world imaging and vision pipelines. Our scalability optimizations lead to average compile time speedups of 49x (up to 530x). We find schedules that are on average 1.7x faster than existing automatic solutions (up to 5x), and competitive with what the best human experts were able to achieve in an active effort to beat our automatic results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luke</first_name>
          <last_name>Anderson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>lukeanderson1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Adams</last_name>
          <affiliation>Adobe</affiliation>
          <bio>undefined</bio>
          <person_id>andrewadams</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Karima</first_name>
          <last_name>Ma</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>karimama1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tzu-Mao</first_name>
          <last_name>Li</last_name>
          <affiliation>UC San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~tzli/</homepage_url>
          <person_id>tzumaoli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tian</first_name>
          <last_name>Jin</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>tianjin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Ragan-Kelley</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>Assistant Professor of Computer Science</bio>
          <homepage_url>https://people.csail.mit.edu/jrk</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanragankelley/1b837cf9-1002-4ab3-8bfc-fdf6708db7e1/small.jpg</picture_url>
          <person_id>jonathanragankelley</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a465fd04-171d-4b17-b5fe-87639ad89a49</subevent_id>
    <title>SPLASH OOPSLA: Corpus and User Studies</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>8ff7ea6c-f67b-4823-a981-57063982013b</slot_id>
      <title>Session: SPLASH OOPSLA - Corpus and User Studies</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_time>17:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Iulian</first_name>
          <last_name>Neamtiu</last_name>
          <affiliation>New Jersey Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://web.njit.edu/~ineamtiu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/iulianneamtiu/59a11852-72df-4d67-9331-8720d3d19a64/small.jpg</picture_url>
          <person_id>iulianneamtiu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0ed7a3d2-ed91-4410-8c2d-765a5fda2e15</slot_id>
      <event_id>da83cec0-6c60-4185-8177-b65b19357468</event_id>
      <submission_id>331</submission_id>
      <title>How Statically-Typed Functional Programmers Write Code</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>16:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:25</end_time>
      <description>How working statically-typed functional programmers write code is largely understudied. And yet, a better understanding of developer practices could pave the way for the design of more useful and usable tooling, more ergonomic languages, and more effective on-ramps into programming communities. The goal of this work is to address this knowledge gap: to better understand the high-level authoring patterns that statically-typed functional programmers employ. We conducted a grounded theory analysis of 30 programming sessions of practicing statically-typed functional programmers, 15 of which also included a semi-structured interview. The theory we developed gives insight into how the specific affordances of statically-typed functional programming affect domain modeling, type construction, focusing techniques, exploratory and reasoning strategies, and expressions of intent. We conducted a set of quantitative lab experiments to validate our findings, including that statically-typed functional programmers often iterate between editing types and expressions, that they often run their compiler on code they fully believed will not successfully compile, and that they often make textual program edits that reliably signal future edits that they intend to make. Lastly, we outline the implications of our findings for language and tool design. The success of this approach in revealing program authorship patterns suggests that the same methodology could be used to study other understudied programmer populations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Justin</first_name>
          <last_name>Lubin</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jlubin.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/justinlubin1/20ea84ad-9355-48d7-924c-af6d84fdb568/small.jpg</picture_url>
          <person_id>justinlubin1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sarah E.</first_name>
          <last_name>Chasins</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~schasins/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sarahchasins/11334835-84ec-45c0-8ba1-2b87910eb7f7/small.jpg</picture_url>
          <person_id>sarahchasins</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>3fe676e0-e520-4648-b1bd-237bee6efd22</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>16:25</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4c1fdf43-3d85-4426-91b8-35dd7251488b</slot_id>
      <event_id>75978bcc-89d2-43d2-9ca9-77bb20edeb87</event_id>
      <submission_id>117</submission_id>
      <title>Well-Typed Programs Can Go Wrong: A Study of Typing-Related Bugs in JVM Compilers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>15:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:55</end_time>
      <description>Despite the substantial progress in compiler testing, the research endeavors have mainly focused on detecting compiler crashes and subtle miscompilations caused by bugs in the implementation of compiler optimizations. Surprisingly, this growing body of work neglects other compiler components, most notably the front-end. In statically-typed programming languages with rich and expressive type systems and modern features, such as type inference or a mix of object-oriented with functional programming features, the process of static typing in compiler front-ends is complicated by a high-density of bugs. Such bugs can lead to the acceptance of incorrect programs (breaking code portability or the type system’s soundness), the rejection of correct (e.g. well-typed) programs, and the reporting of misleading errors and warnings. 
We conduct, what is to the best of our knowledge, the first empirical study for understanding and characterizing typing-related compiler bugs. To do so, we manually study 320 typing-related bugs (along with their fixes and test cases) that are randomly sampled from four mainstream JVM languages, namely Java, Scala, Kotlin, and Groovy. We evaluate each bug in terms of several aspects, including their symptom, root cause, bug fix’s size, and the characteristics of the bug-revealing test cases. Some representative observations indicate that: 1) more than a half of the typing-related bugs manifest as unexpected compile-time errors: the buggy compiler wrongly rejects semantically correct programs, 2) the majority of typing-related bugs lie in the implementations of the underlying type systems and in other core components related to operations on types, 3) parametric polymorphism is the most pervasive feature in the corresponding test cases, 4) one third of typing-related bugs are triggered by non-compilable programs. 
We believe that our study opens up a new research direction by driving future researchers to build appropriate methods and techniques for a more holistic testing of compilers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefanos</first_name>
          <last_name>Chaliasos</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Stefanos Chaliasos is a PhD candidate advised by Dr Ben Livshits and Dr Arthur Gervais at Imperial College London. He holds an MSc in Computer Science from the National and Kapodistrian University of Athens and a BSc in Management Science and Technology from the Athens University of Economics and Business. He has previously worked in the industry as a software engineer at Greek Research and Technology Network (GRNET) and as a researcher in the FASTEN project. His main research interests involve Computer Security, Software Testing, Program Analysis, and Programming Languages.</bio>
          <homepage_url>https://stefanoschaliasos.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefanoschaliasos/abb30586-5ab6-4e4e-9363-d2604af831ec/small.jpg</picture_url>
          <person_id>stefanoschaliasos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thodoris</first_name>
          <last_name>Sotiropoulos</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>Thodoris Sotiropoulos is a PhD candidate at the Department of Management Science and Technology. He holds an MSc with distinction in Advanced Computing from Imperial College London, and a BSc in Management Science and Technology from the Athens University of Economics and Business. He has previously worked in industry as a software engineer at the Greek Research and Technology Network (GRNET).</bio>
          <homepage_url>https://theosotr.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thodorissotiropoulos/9e48a9b1-ba8a-4565-97da-0ed90ead2047/small.jpg</picture_url>
          <person_id>thodorissotiropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Georgios-Petros</first_name>
          <last_name>Drosos</last_name>
          <affiliation>Athens University of Economics and Business</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/georgiospetrosdrosos/94bab4c6-9f9f-4a22-b4f7-b111515d1936/small.jpg</picture_url>
          <person_id>georgiospetrosdrosos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charalambos Ioannis</first_name>
          <last_name>Mitropoulos</last_name>
          <affiliation>Technical University of Crete</affiliation>
          <bio>undefined</bio>
          <person_id>charalambosioannismitropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Dimitris</first_name>
          <last_name>Mitropoulos</last_name>
          <affiliation>National and Kapodistrian University of Athens</affiliation>
          <bio>Dimitris Mitropoulos is an Assistant Professor at the National and Kapodistrian University of Athens and the Head of Reliability Engineering at the Greek National Infrastructures for Research and Technology (GRNET). Previously, he has been a Postdoctoral Researcher at the Network Security Laboratory (NSL) of Columbia University in the City of New York. Dimitris holds a PhD in Computer Security from the Athens University of Economics and Business and has been involved in several EU and US funded R&amp;amp;D projects. His research interests include software engineering, computer security and software reliability. He is a member of ACM, IEEE, SysSec, and an official writer for the ACM Computing Reviews journal.</bio>
          <homepage_url>https://dimitro.gr/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dimitrismitropoulos/a0d64ae8-d979-4ed9-a834-b808d3cc40d2/small.jpg</picture_url>
          <person_id>dimitrismitropoulos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Diomidis</first_name>
          <last_name>Spinellis</last_name>
          <affiliation>Athens University of Economics and Business  &amp; TU Delft</affiliation>
          <bio>Diomidis Spinellis is Professor of Software Engineering in the Department of Management Science and Technology heading the Business Analytics Laboratory (BALab) at the Athens University of Economics and Business, Greece and Professor of Software Analytics in the Department of Software Technology at the Delft University of Technology. His research interests include software engineering, IT security, and computing systems. He has written two award-winning, widely-translated books: Code Reading and Code Quality: The Open Source Perspective. In 2016 he published the book Effective Debugging: 66 Specific Ways to Debug Software and Systems. Dr. Spinellis has also published more than 300 technical papers in journals and refereed conference proceedings, which have received more than 10500 citations. He served for a decade as a member of the IEEE Software editorial board, authoring the regular “Tools of the Trade” column and for four years at the magazine’s Editor in Chief. He has contributed code that ships with Apple’s macOS and BSD Unix and is the developer of CScout, UMLGraph, dgsh, and other open-source software packages, libraries, and tools. He holds an MEng in Software Engineering and a PhD in Computer Science, both from Imperial College London. Dr. Spinellis has served as an elected member of the IEEE Computer Society Board of Governors (2013–2015), and is a senior member of the ACM and the IEEE.</bio>
          <homepage_url>https://www.dmst.aueb.gr/dds</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/diomidisspinellis/a7f21db5-04c0-4282-85ab-614b4394c90a/small.jpg</picture_url>
          <person_id>diomidisspinellis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>599a87fd-d2ee-4acc-a1af-ee71f0d4c090</slot_id>
      <event_id>24a8f69d-0191-4166-b3f5-353579f8fe38</event_id>
      <submission_id>121</submission_id>
      <title>What we Eval in the Shadows</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>15:55</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>16:10</end_time>
      <description>Most dynamic languages allow users to turn text into code using various functions, often named eval, with language-dependent semantics. The widespread use of these reflective functions hinders static analysis and prevents compilers from performing optimizations. This paper aims to provide a better sense of why programmers use eval. Understanding why eval is used in practice is key to finding ways to mitigate its negative impact. We have reasons to believe that reflective feature usage is language and application domain specific; we focus on data science code written in R, and compare our results to previous work that analyzed web programming in JavaScript. This paper studied 240,327 scripts extracted from 15,401 R packages, for a total of 49,296,059 calls to eval. We find that eval is indeed in widespread use; R’s eval is more pervasive and arguably dangerous than what was previously reported for JavaScript.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Donat-Bouillud</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.pdonatbouillud.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/pierredonatbouillud/3887f7f4-a8bf-4d04-af05-af6cd45e2423/small.jpg</picture_url>
          <person_id>pierredonatbouillud</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Filip</first_name>
          <last_name>Křikava</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fikovnik.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/filipkrikava/12cc1e57-732c-4b7e-880e-ca7b51a07d77/small.jpg</picture_url>
          <person_id>filipkrikava</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Kirsch</last_name>
          <affiliation>University of Salzburg</affiliation>
          <bio>Christoph Kirsch is Professor at the Department of Computer Sciences of the University of Salzburg, Austria. He received his Dr.Ing. degree from Saarland University in 1999 while at the Max Planck Institute for Computer Science in Saarbrücken, Germany. From 1999 to 2004 he worked as Postdoctoral Researcher at the Department of Electrical Engineering and Computer Sciences of the University of California, Berkeley. He later returned to Berkeley as Visiting Scholar (2008-2013) and Visiting Professor (2014) at the Department of Civil and Environmental Engineering. His research interests are in concurrent programming, memory management, virtualization, and formal verification. Dr. Kirsch co-invented embedded programming languages and systems such as Giotto, HTL, and the Embedded Machine, and more recently co-designed high-performance, multicore-scalable concurrent data structures and memory management systems. He co-founded the International Conference on Embedded Software (EMSOFT) in 2001 and served as ACM SIGBED chair from 2011 until 2013. He has been IEEE TCAD and ACM TODAES associate editor, and is ACM Distinguished Speaker since 2017.</bio>
          <homepage_url>http://cs.uni-salzburg.at/~ck</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophkirsch/2adc8995-a32a-49c9-b820-8427e5a1f25a/small.jpg</picture_url>
          <person_id>christophkirsch</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3e290c5f-f0e5-4b67-b931-c8bf727342dd</subevent_id>
    <title>SPLASH OOPSLA: Program Synthesis</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>f32d5c03-62a4-4adb-90f4-e8a16544e41a</slot_id>
      <title>Session: SPLASH OOPSLA - Program Synthesis</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>491155fc-6389-4753-9700-b5eeaa84b8a4</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>14:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>68ddb3af-b6fd-40a2-9040-7c9cbdc19d72</slot_id>
      <event_id>24dd1202-bb64-4cef-86c5-251fda3fcd93</event_id>
      <submission_id>448</submission_id>
      <title>APIfix: Output-Oriented Program Synthesis for Combating Breaking Changes in Libraries</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:35</end_time>
      <description>Use of third-party libraries is extremely common in application software. The libraries evolve to accommodate new features or mitigate security vulnerabilities, thereby breaking the Application Programming Interface (API) used by the software. Such breaking changes in the libraries may discourage client code from using the new library versions thereby keeping the application vulnerable and not up-to-date. We propose a novel output-oriented program synthesis algorithm to automate API usage adaptations via program transformation. Our aim is not only to rely on the few example human adaptations of the clients from the old library to the new library, since this can lead to over-fitting transformation rules. Instead, we also rely on example usages of the new updated library in clients, which provide valuable context for synthesizing and applying the transformation rules. Our tool APIFix provides an automated mechanism to transform application code using the old library versions to code using the new library versions - thereby achieving automated API usage adaptation to fix the effect of breaking changes. Our evaluation shows that the transformation rules inferred by APIFix achieve 98.7% precision and 91.5% recall. By comparing our approach to state-of-the-art program synthesis approaches, we show that our approach significantly reduces over-fitting while synthesizing transformation rules for API usage adaptations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiang</first_name>
          <last_name>Gao</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.comp.nus.edu.sg/~gaoxiang/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xianggao/482ff4c5-f003-40e7-90cc-d888adbd1e2f/small.jpg</picture_url>
          <person_id>xianggao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Soares</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/gsoares/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gustavosoares/fc1e5a17-f939-4c3d-ab30-85467cb2610b/small.jpg</picture_url>
          <person_id>gustavosoares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ridwan Salihin</first_name>
          <last_name>Shariffdeen</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>I am a fourth-year PhD student in Department of Computer Science at School of Computing, National University of Singapore, where I am advised by Abhik Roychoudhury. The current focus of my research is on automated program repair, software security and software engineering automation.</bio>
          <homepage_url>https://rshariffdeen.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ridwansalihinshariffdeen/4ac6e84f-a4cb-4547-b8d7-026e9e142f00/small.jpg</picture_url>
          <person_id>ridwansalihinshariffdeen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Abhik</first_name>
          <last_name>Roychoudhury</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>Abhik Roychoudhury is a Professor of Computer Science at National University of Singapore. His research focuses on software testing and analysis, software security and trust-worthy software construction. His research group has built scalable techniques for testing, debugging and repair of programs using systematic semantic analysis. The capability to automatically repair programs at a large scale contributes to the vision of self-healing software. He is currently directing the National Satellite of Excellence in Trustworthy Software Systems in Singapore. He is also the Lead Principal Investigator of the Singapore Cyber-security Consortium, which is a consortium of 25 companies in the cyber-security space engaging with academia for research and collaboration.</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~abhik</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/abhikroychoudhury/7017e73b-76d1-4dd4-a4b4-def2881fc2c9/small.jpg</picture_url>
          <person_id>abhikroychoudhury</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>b01bb567-84a8-4917-9b85-2b96a9f90096</slot_id>
      <event_id>25bb8503-88a2-4ba4-b253-0fc9a52e05dc</event_id>
      <submission_id>157</submission_id>
      <title>Gauss: Program Synthesis by Reasoning Over Graphs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:20</end_time>
      <description>While input-output examples are a natural form of specification for program synthesis engines, they can be imprecise. In this paper, we investigate how extracting readily-available information about the user intent \emph{behind} these input-output examples helps speed up synthesis and reduce overfitting. We present Gauss, a synthesis algorithm that accepts partial input-output examples, along with \emph{user intent graphs}. Gauss includes a novel conflict-resolution reasoning algorithm over graphs that enables it to learn from mistakes made during the search and use that knowledge to explore the space of programs even faster. It also ensures the final program is consistent with the user intent specification, reducing overfitting. We implement Gauss for the domain of table transformations (supporting Pandas and R), and compare it to two state-of-the-art synthesizers accepting only input-output examples. We find that it is able to reduce the search space by 56$\times$, 73$\times$ and 664$\times$ on average, resulting in 7$\times$, 26$\times$ and 7$\times$ speedups in synthesis times on average, respectively.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rohan</first_name>
          <last_name>Bavishi</last_name>
          <affiliation>UC Berkeley</affiliation>
          <bio>I am a 3rd Year PhD student advised by Prof. Koushik Sen.</bio>
          <homepage_url>https://rbavishi.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rohanbavishi/9512af7a-f463-4f18-9edd-f4634cd69487/small.jpg</picture_url>
          <person_id>rohanbavishi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Caroline</first_name>
          <last_name>Lemieux</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Caroline Lemieux is a postdoctoral researcher at Microsoft Research, and will be starting as an Assistant Professor at UBC in Fall 2022. Her research interests center around improving the correctness and reliability of software systems by developing automated methods for engineering tasks such as testing, debugging, and comprehension. Her work on fuzz testing has been awarded an ACM SIGSOFT Distinguished Paper Award, Distinguished Artifact Award, Tool Demonstration Award, and Best Paper Award (Industry Track). She completed her PhD at UC Berkeley, advised by Koushik Sen; there, she was the recipient of a Berkeley Fellowship for Graduate Study, and a Google PhD Fellowship in Programming Technologies and Software Engineering. She received her B.Sc. in Computer Science and Mathematics at the University of British Columbia, where she won the Governor General’s Silver Medal in Science, awarded to the undergraduate student with highest standing in the Faculty of Science.</bio>
          <homepage_url>https://www.carolemieux.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/carolinelemieux/e43ab970-fd4b-43bd-83fe-eada347d47c9/small.jpg</picture_url>
          <person_id>carolinelemieux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Koushik</first_name>
          <last_name>Sen</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>Koushik Sen is a professor in the Department of Electrical Engineering and Computer Sciences at the University of California, Berkeley. His research interest lies in Software Engineering, Programming Languages, and Formal methods. He is interested in developing software tools and methodologies that improve programmer productivity and software quality. He holds a B.Tech from Indian Institute of Technology, Kanpur, and M.S. and Ph.D. in CS from University of Illinois at Urbana-Champaign.</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~ksen/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/koushiksen/9f417f8a-40b9-40a7-866c-9c44cd81859a/small.jpg</picture_url>
          <person_id>koushiksen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ion</first_name>
          <last_name>Stoica</last_name>
          <affiliation>UC Berkeley</affiliation>
          <bio>undefined</bio>
          <person_id>ionstoica</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>c82e9b18-f2b0-4fec-bf11-c9a7794cfdef</slot_id>
      <event_id>d4737a93-8cd6-4e8c-833c-7ed194f21b7a</event_id>
      <submission_id>294</submission_id>
      <title>LooPy: Interactive Program Synthesis with Control Structures</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:50</end_time>
      <description>One vision for program synthesis, and specifically for Programming by Example (PBE), is an interactive programmer’s assistant, integrated into the development environment. To make program synthesis practical for interactive use, prior work on Small-Step Live PBE has proposed to limit the scope of synthesis to small code snippets, and enable the users to provide local specifications for those snippets. This paradigm, however, does not work well in the presence of loops. We present LooPy, a synthesizer integrated into a Live Programming environment, which extends Small-Step Live PBE to work inside loops and scales it up to synthesize larger code snippets, while remaining fast enough for interactive use. To allow users to effectively provide examples at various loop iterations, even when the loop body is incomplete, LooPy makes use of live execution, a technique that leverages the programmer as an oracle to step over incomplete parts of the loop. To enable synthesis of loop bodies at interactive speeds, LooPy introduces Intermediate State Graph, a new data structure, which compactly represents a large space of code snippets composed of multiple assignment statements and conditionals. We evaluate LooPy empirically using benchmarks from competitive programming and previous synthesizers, and show that it can solve a wide variety of synthesis tasks at interactive speeds. We also performed a small qualitative user study which shows that LooPy’s block-level specifications are easy for programmers to provide.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kasra</first_name>
          <last_name>Ferdowsifard</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>I’m a PhD student in the Programming Languages and Systems group at UC San Diego, co-advised by Nadia Polikarpova and Sorin Lerner. I completed my Bachelor’s in Electrical Engineering and Computer Science a UC Berkeley in 2019. 
My research interests are at the intersection of Programming Languages and Human-Computer Interactions, with a focus on Program Synthesis, and using PL and Synthesis techniques to build useful and usable tools.</bio>
          <homepage_url>https://weirdmachine.me/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kasraferdowsifard/6568a44f-7c63-4840-88a0-1ec3c49463e0/small.jpg</picture_url>
          <person_id>kasraferdowsifard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/shraddhabarke1/4e11ed13-0f46-4d77-8a6d-dd4c07b7fd4b/small.jpg</picture_url>
          <person_id>shraddhabarke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.technion.ac.il/~hilap</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sorin</first_name>
          <last_name>Lerner</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/users/lerner/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sorinlerner/3d3b1a70-e2f8-4d3a-a1bc-9c4e17dad80b/small.jpg</picture_url>
          <person_id>sorinlerner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of 2020 Intel Rising Stars Award and the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>e673ae02-9d71-4390-bd07-58bc57185f6c</slot_id>
      <event_id>43ca20c2-56eb-45a4-ba22-83f5f26257c4</event_id>
      <submission_id>542</submission_id>
      <title>Generalizable Synthesis Through Unification</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>14:05</end_time>
      <description>The generalizability of PBE solvers is the key to the empirical synthesis performance. Despite the importance of generalizability, related studies on PBE solvers are still limited. In theory, few existing solvers provide theoretical guarantees on generalizability, and in practice, there is a lack of PBE solvers with satisfactory generalizability on important domains such as conditional linear integer arithmetic (CLIA). In this paper, we adopt a concept from the computational learning theory, Occam learning, and perform a comprehensive study on the framework of synthesis through unification (STUN), a state-of-the-art framework for synthesizing programs with nested if-then-else operators. We prove that Eusolver, a state-of-the-art STUN solver, does not satisfy the condition of Occam learning, and then we design a novel STUN solver, PolyGen, of which the generalizability is theoretically guaranteed by Occam learning. We evaluate PolyGen on the domains of CLIA and demonstrate that PolyGen significantly outperforms two state-of-the-art PBE solvers on CLIA, Eusolver and Euphony, on both generalizability and efficiency.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruyi</first_name>
          <last_name>Ji</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>ruyiji</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jingtao</first_name>
          <last_name>Xia</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>jingtaoxia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhenjiang</first_name>
          <last_name>Hu</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~hu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhenjianghu/5d426480-5589-46be-b4f6-f98cf2acc80e/small.jpg</picture_url>
          <person_id>zhenjianghu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c8ba9b31-4faa-4f9b-bc7d-84a007267d47</subevent_id>
    <title>SPLASH OOPSLA: Types &amp; Verification -- mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>375e13b1-a4ff-4a0b-83a1-8c4345bbb63e</slot_id>
      <title>Session: SPLASH OOPSLA - Types &amp; Verification -- mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
          <person_id>atsushiigarashi</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>076a59a0-8d0d-4812-9f1b-8d05be432673</slot_id>
      <event_id>1d37dffb-2929-4565-b632-7873f6a12ea7</event_id>
      <submission_id>130</submission_id>
      <title>Transitioning from Structural to Nominal Code with Efficient Gradual Typing</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>22:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>22:35</end_time>
      <description>Gradual typing is a principled means for mixing typed and untyped code. But typed and untyped code often exhibit different programming patterns. Significant research has investigated gradually giving types to code exhibiting typical untyped patterns, while some research has investigated gradually removing types from code exhibiting typical typed patterns. This paper investigates how to extend established gradual-typing concepts so that one can give formal guarantees not only about how types can change as code evolves but also about how such patterns can change as well. 
In particular, we explore mixing untyped structural code with typed nominal code in an object-oriented language. But whereas previous work only allowed nominal values to be treated as structural values, we also allow structural values to dynamically acquire certain nominal types, namely interfaces. We demonstrate that this choice to support structures as nominal interfaces, but not nominal classes, can still be implemented efficiently despite the fact that not all values have concrete types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabian</first_name>
          <last_name>Muehlboeck</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ist.ac.at/~fmuehlbo</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fabianmuehlboeck/4fb2ec06-e164-4813-bb8b-499adc17c869/small.jpg</picture_url>
          <person_id>fabianmuehlboeck</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ross</first_name>
          <last_name>Tate</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~ross/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rosstate/cbcbd066-943d-46a2-a301-1f4084076400/small.jpg</picture_url>
          <person_id>rosstate</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>2f0a850b-662f-4724-8f93-4452ec4f6f97</slot_id>
      <event_id>7776cd20-1ef0-46d3-ba4d-606e81ee96fe</event_id>
      <submission_id>191</submission_id>
      <title>Scalability and Precision by Combining Expressive Type Systems and Deductive Verification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>22:05</end_time>
      <description>Type systems and modern type checkers can be used very successfully to obtain formal correctness guarantees with little specification overhead. However, type systems in practical scenarios have to trade precision for decidability and scalability. Tools for deductive verification, on the other hand, can prove general properties in more cases than a typical type checker can, but they do not scale well. We present a method to complement the scalability of expressive type systems with the precision of deductive program verification approaches. Our novel approach is introduced both conceptually by a proven formalization and practically by a concrete implementation for the Java programming language. The usefulness and power of our approach has been evaluated by discharging known false positives from a real-world program and by a small case study.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Lanzinger</last_name>
          <affiliation>Karlsruhe Institute of Technology (KIT)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://formal.iti.kit.edu/~lanzinger/</homepage_url>
          <person_id>florianlanzinger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Weigl</last_name>
          <affiliation>Karlsruhe Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>alexanderweigl</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mattias</first_name>
          <last_name>Ulbrich</last_name>
          <affiliation>Karlsruhe Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://formal.iti.kit.edu/~ulbrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mattiasulbrich/93c421cd-7529-43d3-8968-366d6ba1753d/small.jpg</picture_url>
          <person_id>mattiasulbrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Werner</first_name>
          <last_name>Dietl</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ece.uwaterloo.ca/~wdietl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wernerdietl/f6ddc3ef-7134-4260-a182-a71ed88842cb/small.jpg</picture_url>
          <person_id>wernerdietl</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>79135465-ce74-4ace-a2b3-46827be21917</slot_id>
      <event_id>c535117f-4286-427b-a999-ec9db64e4b2c</event_id>
      <submission_id>161</submission_id>
      <title>A Type System for Extracting Functional Specifications from Memory-Safe Imperative Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>22:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>22:20</end_time>
      <description>Verifying imperative programs is hard. A key difficulty is that the specification of what an imperative program does is often intertwined with details about pointers and imperative state. Although there are a number of powerful separation logics that allow the details of imperative state to be captured and managed, these details are complicated and reasoning about them requires significant time and expertise. In this paper, we take a different approach: a memory-safe type system that, as part of type-checking, extracts functional specifications from imperative programs. This disentangles imperative state, which is handled by the type system, from functional specifications, which can be verified without reference to pointers. A key difficulty is that sometimes memory safety depends crucially on the functional specification of a program; e.g., an array index is only memory-safe if the index is in bounds. To handle this case, our specification extraction inserts dynamic checks into the specification. Verification then requires the additional proof that none of these checks fail. However, these checks are in a purely functional language, and so this proof also requires no reasoning about pointers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paul</first_name>
          <last_name>He</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>I am a PhD student at the University of Pennsylvania.</bio>
          <homepage_url>https://paulhe.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/paulhe/0d514283-c73f-4e42-aca3-b62e5080b1b8/small.jpg</picture_url>
          <person_id>paulhe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Westbrook</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>edwinwestbrook</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brent</first_name>
          <last_name>Carmer</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>brentcarmer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Chris</first_name>
          <last_name>Phifer</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>chrisphifer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Valentin</first_name>
          <last_name>Robert</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>valentinrobert2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Karl</first_name>
          <last_name>Smeltzer</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>karlsmeltzer1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Andrei</first_name>
          <last_name>Stefanescu</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>andreistefanescu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Tomb</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://galois.com/team/aaron-tomb/</homepage_url>
          <person_id>aarontomb</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Adam</first_name>
          <last_name>Wick</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>adamwick</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Yacavone</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>matthewyacavone</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Steve</first_name>
          <last_name>Zdancewic</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~stevez</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stevezdancewic/41b883c6-4689-4ae3-b6f1-6b7a24622e99/small.jpg</picture_url>
          <person_id>stevezdancewic</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>9b437d7d-6bcb-4877-8eaa-a5d59724d1d8</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>22:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>78c4f22f-a120-458a-b749-ea736ff4baac</subevent_id>
    <title>SPLASH OOPSLA: Rust - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>4426a3c5-f277-4432-a3f8-6e68112cefb0</slot_id>
      <title>Session: SPLASH OOPSLA - Rust - mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Toby</first_name>
          <last_name>Murray</last_name>
          <affiliation>University of Melbourne, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.eng.unimelb.edu.au/tobym</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobymurray/b22e1351-c7fc-420a-acef-492aadfce115/small.jpg</picture_url>
          <person_id>tobymurray</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>292df5aa-7eb3-4bc1-972b-1038f415e5ef</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>22:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>2ec7edc8-a01c-4de0-9735-ca966c4021a0</slot_id>
      <event_id>9c148540-5a2f-4370-b1e1-f409b281e5e6</event_id>
      <submission_id>215</submission_id>
      <title>Modular Specification and Verification of Closures in Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>22:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:20</end_time>
      <description>Closures are a language feature supported by many mainstream languages, combining the ability to package up references to code blocks with the possibility of capturing state from the environment of the closure’s declaration. Closures are powerful, but complicate understanding and formal reasoning, especially when closure invocations may mutate objects reachable from the captured state or from closure arguments. This paper presents a novel technique for the modular specification and verification of closure-manipulating code in Rust. Our technique combines Rust’s type system guarantees and novel specification features to enable formal verification of rich functional properties. It encodes higher-order concerns into a first-order logic, which enables automation via SMT solvers. Our technique is implemented as an extension of the deductive verifier Prusti, with which we have successfully verified many common idioms of closure usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabian</first_name>
          <last_name>Wolff</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>fabianwolff</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aurel</first_name>
          <last_name>Bílý</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>aurelbily</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Matheja</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christophmatheja1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Alexander J.</first_name>
          <last_name>Summers</last_name>
          <affiliation>University of British Columbia (UBC)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.ubc.ca/~alexsumm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexanderjsummers/f97b84a8-d46a-4e76-aa73-cc4b38c4ec41/small.jpg</picture_url>
          <person_id>alexanderjsummers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>3598eb7a-c40d-43d2-89f3-ea3fcaa4d013</slot_id>
      <event_id>d6067c7f-9230-454c-9672-66c980a2da21</event_id>
      <submission_id>27</submission_id>
      <title>Safer at Any Speed: Automatic Context-Aware Safety Enhancement for Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>22:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:35</end_time>
      <description>Type-safe languages improve application safety by eliminating whole classes of vulnerabilities, such as buffer overflows, by construction. But safety sometimes comes at a cost. As a result, modern type-safe languages often provide escape hatches that allow developers to manually bypass dynamic safety checks in hopes of improving performance. However, this requires applications to implicitly inherit whatever performance vs. safety trade-offs are made in libraries they depend on. Without knowing the importance of safety to each application, their performance requirements, the compiler used, or the hardware upon which applications will run, library developers have no hope of navigating such trade-offs appropriately for all cases. We find that in the Rust ecosystem, library developers have given up type safety in at least 10% of the 500 most downloaded packages in exchange for very little or no performance gains in many contexts. We present NADER, a Rust development tool that makes applications safer by automatically transforming unsafe code into equivalent safe code according to developer preferences and application context. In an end-to-end system evaluation, NADER automatically reintroduces dozens of bounds checks with no performance loss.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Natalie</first_name>
          <last_name>Popescu</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.princeton.edu/~npopescu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nataliepopescu1/7e11a54e-61c9-49bc-bc69-07f19db73a1b/small.jpg</picture_url>
          <person_id>nataliepopescu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ziyang</first_name>
          <last_name>Xu</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.princeton.edu/~ziyangx/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ziyangxu/4d095217-b7d0-4159-9508-7cae73aa6bf5/small.jpg</picture_url>
          <person_id>ziyangxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sotiris</first_name>
          <last_name>Apostolakis</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sapostolakis.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sotirisapostolakis/538416ca-ec5a-4441-b330-832a65a0bac2/small.jpg</picture_url>
          <person_id>sotirisapostolakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>David I.</first_name>
          <last_name>August</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>davidiaugust</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Amit</first_name>
          <last_name>Levy</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>amitlevy</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>cd67f289-4480-487b-8df0-f4b18caaad55</slot_id>
      <event_id>66f57c5c-e9da-44bf-9914-726337159123</event_id>
      <submission_id>101</submission_id>
      <title>Translating C to Safer Rust</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>22:05</end_time>
      <description>Rust is a relatively new programming language that targets efficient and safe systems-level applications. It includes a sophisticated type system that allows for provable memory- and thread-safety, and is explicitly designed to take the place of unsafe languages such as C and C++ in the coding ecosystem. There is a large existing C and C++ codebase (many of which have been affected by bugs and security vulnerabilities due to unsafety) that would benefit from being rewritten in Rust to remove an entire class of potential bugs. However, porting these applications to Rust manually is a daunting task. 
In this paper we investigate the problem of automatically translating C programs into safer Rust programs—that is, Rust programs that improve on the safety guarantees of the original C programs. We conduct an in-depth study into the underlying causes of unsafety in translated programs and the relative impact of fixing each cause. We also describe a novel technique for automatically removing a particular cause of unsafety and evaluate its effectiveness and impact. This paper presents the first empirical study of unsafety in translated Rust programs (as opposed to programs originally written in Rust) and also the first technique for automatically removing causes of unsafety in translated Rust programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mehmet</first_name>
          <last_name>Emre</last_name>
          <affiliation>University of California, Santa Barbara</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.ucsb.edu/~emre</homepage_url>
          <person_id>mehmetemre</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Schroeder</last_name>
          <affiliation>University of California, Santa Barbara</affiliation>
          <bio>undefined</bio>
          <person_id>ryanschroeder</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kyle</first_name>
          <last_name>Dewey</last_name>
          <affiliation>California State University, Northridge</affiliation>
          <bio>undefined</bio>
          <person_id>kyledewey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ben</first_name>
          <last_name>Hardekopf</last_name>
          <affiliation>UC Santa Barbara</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.cs.ucsb.edu/~benh</homepage_url>
          <person_id>benhardekopf</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>505c7019-b9d3-49b4-a29e-02bdec1b65cd</subevent_id>
    <title>SPLASH OOPSLA: Synthesis of models, tools and programs</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>bae1691a-1dde-41bd-9e3d-46e02287b378</slot_id>
      <title>Session: SPLASH OOPSLA - Synthesis of models, tools and programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages, software engineering, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. 
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006), the Dahl-Nygaard Junior Prize (2007), the DARPA Computer Science Study Group, and an ICSE most influential paper award (2012). He served as general chair (2015), program chair (2017), and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
          <person_id>jonathanaldrich</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18fb8fc7-0642-4e69-baaf-f2bfe56a8609</slot_id>
      <event_id>44632a19-da24-4769-9abf-fb6b1a1b8dab</event_id>
      <submission_id>410</submission_id>
      <title>Multi-modal Program Inference: a Marriage of Pre-trained Language Models and Component-based Synthesis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:50</end_time>
      <description>Multi-modal program synthesis refers to the task of synthesizing programs (code) from their specification given in different forms, such as a combination of natural language and examples. Examples provide a precise but incomplete specification, and natural language provides an ambiguous but more “complete” task description. Machine-learned pre-trained models (PTMs) are adept at handling ambiguous natural language, but struggle with generating syntactically and semantically precise code. Program synthesis techniques can generate correct code, often even from incomplete but precise specifications, such as examples, but they are unable to work with the ambiguity of natural languages. We present an approach that combines PTMs with component-based synthesis (CBS): PTMs are used to generate candidate programs from the natural language description of the task, which are then used to guide the CBS procedure to find the program that matches the precise examples-based specification. We use our combination approach to instantiate multi-modal synthesis systems for two programming domains: the domain of regular expressions and the domain of CSS selectors. Our evaluation demonstrates the effectiveness of our domain-agnostic approach in comparison to a state-of-the-art specialized system, and the generality of our approach in providing multi-modal program synthesis from natural language and examples in different programming domains.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kia</first_name>
          <last_name>Rahmani</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am a PhD candidate of computer science at Purdue University. I am a member of the programming languages group, working under the supervision of Professor Suresh Jagannathan and Professor Benjamin Delaware. 
My PhD thesis is focused around compilation, synthesis, and testing of modern database-backed programs. More broadly, I am interested in all formal methods for modeling and analysis of (classical or quantum) computer programs. 
I was previously a research intern at Microsoft, working on a new program synthesis technique based on pre-trained language models. My work was supervised by Dr. Mohammad Raza and Dr. Sumit Gulwani.</bio>
          <homepage_url>https://kiarahmani.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kiarahmani/745190a9-35f0-49e9-b5a9-f8831bce9162/small.jpg</picture_url>
          <person_id>kiarahmani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mohammad</first_name>
          <last_name>Raza</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>mohammadraza</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Vu</first_name>
          <last_name>Le</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>I am a Researcher at Microsoft, working on the Microsoft Program Synthesis using Examples (PROSE) framework. I obtained my PhD in 2015 at UC Davis, advised by Zhendong Su and Sumit Gulwani. My research is about developing novel and practical techniques to help improve the quality of critical software (e.g., compilers and database engines) and make programming accessible for end users. My work has led to the discovery of hundreds of bugs in GCC and LLVM, most of which have been fixed, and shipped in various Microsoft products.</bio>
          <homepage_url>http://vuminhle.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vule/8674b9d0-747d-4a80-b8f0-3c7a435cd9b7/small.jpg</picture_url>
          <person_id>vule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Morris</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <person_id>danielmorris</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Soares</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/gsoares/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gustavosoares/fc1e5a17-f939-4c3d-ab30-85467cb2610b/small.jpg</picture_url>
          <person_id>gustavosoares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Ashish</first_name>
          <last_name>Tiwari</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csl.sri.com/users/tiwari/</homepage_url>
          <person_id>ashishtiwari</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>7c497d6a-686e-4d73-91da-19de32e324f2</slot_id>
      <event_id>5a37cd42-11e4-4df2-a92f-376c879a05e3</event_id>
      <submission_id>94</submission_id>
      <title>Rewrite Rule Inference Using Equality Saturation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:05</end_time>
      <description>Many compilers, synthesizers, and theorem provers rely on rewrite rules to simplify expressions or prove equivalences. Developing rewrite rules can be difficult: rules may be subtly incorrect, profitable rules are easy to miss, and rulesets must be rechecked or extended whenever semantics are tweaked. Large rulesets can also be challenging to apply: redundant rules can slow down rule-based search and frustrate debugging. 
This paper explores how equality saturation, a promising technique that uses e-graphs to apply rewrite rules, can also be used to infer rewrite rules. E-graphs can compactly represent the exponentially large sets of enumerated terms and potential rewrite rules. We show that equality saturation efficiently shrinks both sets,leading to faster synthesis of smaller, more general rulesets. 
We prototyped these strategies in a tool dubbed Ruler. Compared to a similar tool built on CVC4, Ruler synthesizes 5.8× smaller rulesets 25× faster without compromising on proving power. In an end-to-end case study, we show Ruler-synthesized rules which perform as well as those crafted by domain experts, addressing a longstanding issue in a popular open source tool.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chandrakana</first_name>
          <last_name>Nandi</last_name>
          <affiliation>Certora, inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cnandi.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/chandrakananandi/a90ad233-62bb-4a90-8e9d-9afd969ef245/small.jpg</picture_url>
          <person_id>chandrakananandi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Max</first_name>
          <last_name>Willsey</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.mwillsey.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/maxwillsey/ff552459-e263-42a5-b17b-1301d482943d/small.jpg</picture_url>
          <person_id>maxwillsey</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Amy</first_name>
          <last_name>Zhu</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <person_id>amyzhu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Brett</first_name>
          <last_name>Saiki</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <person_id>brettsaiki</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yisu Remy</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>PhD student at University of Washington.</bio>
          <homepage_url>https://remy.wang</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yisuremywang1/5aec4d9a-13a9-460e-8154-fc72a368b4f9/small.jpg</picture_url>
          <person_id>yisuremywang1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Adam</first_name>
          <last_name>Anderson</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <person_id>adamanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Adriana</first_name>
          <last_name>Schulz</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <person_id>adrianaschulz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Dan</first_name>
          <last_name>Grossman</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~djg/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/dangrossman/941e0321-e962-4f03-9027-ba9f0448e7df/small.jpg</picture_url>
          <person_id>dangrossman</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Tatlock</last_name>
          <affiliation>University of Washington, Seattle</affiliation>
          <bio>Associate Professor at the University of Washington</bio>
          <homepage_url>https://ztatlock.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zacharytatlock/87af1196-2d8d-4bd5-a692-018d3939a00f/small.jpg</picture_url>
          <person_id>zacharytatlock</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>99674ca7-7721-4eb9-b5bf-1fcb49d4ff96</slot_id>
      <event_id>c534281c-22ac-4d12-b79c-ef3db26a300f</event_id>
      <submission_id>17</submission_id>
      <title>Semantic programming by example with pre-trained models</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:35</end_time>
      <description>The ability to learn programs from few examples is a powerful technology with disruptive applications in many domains, as it allows users to automate repetitive tasks in an intuitive way. Existing frameworks on inductive synthesis only perform syntactic manipulations, where they rely on the syntactic structure of the given examples and not their meaning. Any semantic manipulations, such as transforming dates, have to be manually encoded by the designer of the inductive programming framework. Recent advances in large language models have shown these models to be very adept at performing semantic transformations of its input by simply providing a few examples of the task at hand. When it comes to syntactic transformations, however, these models are limited in their expressive power. In this paper, we propose a novel framework for integrating inductive synthesis with few-shot learning language models to combine the strength of these two popular technologies. In particular, the inductive synthesis is tasked with breaking down the problem in smaller subproblems, among which those that cannot be solved syntactically are passed to the language model. We formalise three semantic operators that can be integrated with inductive synthesizers. To minimize invoking expensive semantic operators during learning, we introduce a novel deferred query execution algorithm that considers the operators to be oracles during learning. We evaluate our approach in the domain of string transformations: the combination methodology can automate tasks that cannot be handled using either technologies by themselves. Finally, we demonstrate the generality of our approach via a case study in the domain of string profiling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gust</first_name>
          <last_name>Verbruggen</last_name>
          <affiliation>Department of Computer Science, KU Leuven</affiliation>
          <bio>undefined</bio>
          <person_id>gustverbruggen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vu</first_name>
          <last_name>Le</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>I am a Researcher at Microsoft, working on the Microsoft Program Synthesis using Examples (PROSE) framework. I obtained my PhD in 2015 at UC Davis, advised by Zhendong Su and Sumit Gulwani. My research is about developing novel and practical techniques to help improve the quality of critical software (e.g., compilers and database engines) and make programming accessible for end users. My work has led to the discovery of hundreds of bugs in GCC and LLVM, most of which have been fixed, and shipped in various Microsoft products.</bio>
          <homepage_url>http://vuminhle.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/vule/8674b9d0-747d-4a80-b8f0-3c7a435cd9b7/small.jpg</picture_url>
          <person_id>vule</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>d6cc17d7-fe36-42f5-8df9-b6860facb65d</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d954d87e-9377-4e79-8439-a42f37856d1b</slot_id>
      <event_id>984afe45-291b-4657-9b18-5d36553b8fcb</event_id>
      <submission_id>107</submission_id>
      <title>One Down, 699 to Go: or, synthesising compositional desugarings</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>11:20</end_time>
      <description>Programming or scripting languages used in real-world systems are seldom designed with a formal semantics in mind from the outset. Therefore, developing well-founded analysis tools for these systems requires reverse-engineering a formal semantics as a first step. This can take months or years of effort. 
Can we (at least partially) automate this process? Though desirable, automatically reverse-engineering semantics rules from an implementation is very challenging, as found by Krishnamurthi et al. [2019]. In this paper, we highlight that scaling methods with the size of the language is very difficult due to state space explosion, so we propose to learn semantics incrementally, in smaller parts. We give a formalisation of Krishnamurthi et al's desugaring learning framework in order to clarify the assumptions necessary for an incremental learning algorithm to be feasible.

We show that this reformulation allows us to extend the search space and express rules that Krishnamurthi et al. described as challenging, while still retaining feasibility. We evaluate enumerative synthesis as a baseline algorithm, and demonstrate that, with our reformulation of the problem, it is possible to learn correct  desugaring rules for the example source and core languages proposed by Krishnamurthi et al., in most cases identical to the intended rules.
</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sándor</first_name>
          <last_name>Bartha</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>sandorbartha</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>Cheney</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/jcheney/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jamescheney/fad2c5e0-4605-4bd7-a0bb-aa02ec0b60ba/small.jpg</picture_url>
          <person_id>jamescheney</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vaishak</first_name>
          <last_name>Belle</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>vaishakbelle</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>236943f2-f2a7-4e8a-962c-5c1e7c6f70fb</subevent_id>
    <title>SPLASH OOPSLA: Specification Synthesis - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>52220131-aaac-43d0-a6aa-8542c265e505</slot_id>
      <title>Session: SPLASH OOPSLA - Specification Synthesis - mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Toby</first_name>
          <last_name>Murray</last_name>
          <affiliation>University of Melbourne, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.eng.unimelb.edu.au/tobym</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobymurray/b22e1351-c7fc-420a-acef-492aadfce115/small.jpg</picture_url>
          <person_id>tobymurray</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>739a4d31-084e-43c6-9d0b-dd59e44aa7b3</slot_id>
      <event_id>b1cf329e-5f00-41ab-a8ac-2a2f2ba72e9f</event_id>
      <submission_id>83</submission_id>
      <title>Data-Driven Abductive Inference of Library Specifications</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>19:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:35</end_time>
      <description>Programmers often leverage data structure libraries that provide useful and reusable abstractions. Modular verification of programs that make use of these libraries naturally rely on specifications that capture important properties about how the library expects these data structures to be accessed and manipulated. However, these specifications are often missing or incomplete, making it hard for clients to be confident they are using the library safely. When library source code is also unavailable, as is often the case, the challenge to infer meaningful specifications is further exacerbated. In this paper, we present a novel data-driven abductive inference mechanism that infers specifications for library methods sufficient to enable verification of the library’s clients. Our technique combines a data-driven learning-based framework to postulate candidate specifications, along with SMT-provided counterexamples to refine these candidates, taking special care to prevent generating specifications that overfit to sampled tests. The resulting specifications form a minimal set of requirements on the behavior of library implementations that ensures safety of a particular client program. Our solution thus provides a new multi-abduction procedure for precise specification inference of data structure libraries guided by client-side verification tasks. Experimental results on a wide range of realistic OCaml data structure programs demonstrate the effectiveness of the approach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhe</first_name>
          <last_name>Zhou</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhezhou/278a17cb-759b-46f2-98ca-6cb67f839b0b/small.jpg</picture_url>
          <person_id>zhezhou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robert</first_name>
          <last_name>Dickerson</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://robd.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/robertdickerson/e65391dc-1815-4ecc-b58f-6afd1e1ac81d/small.jpg</picture_url>
          <person_id>robertdickerson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Delaware</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/bendy/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/benjamindelaware/39bbf6b3-d145-435c-8956-8acf8cfcaffa/small.jpg</picture_url>
          <person_id>benjamindelaware</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Suresh</first_name>
          <last_name>Jagannathan</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/suresh/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sureshjagannathan/70e51299-573f-4211-a895-b2028c19c585/small.jpg</picture_url>
          <person_id>sureshjagannathan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>8a159243-799e-4a57-965a-9d4ed0173bb1</slot_id>
      <event_id>f48451af-33ee-4d30-9177-5142a5caec22</event_id>
      <submission_id>30</submission_id>
      <title>Synthesizing Contracts Correct Modulo a Test Generator</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>19:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:50</end_time>
      <description>We present an approach that learns contracts for object-oriented programs where guarantees of correctness of the contracts are made with respect to a test generator. Our contract synthesis approach is based on a novel notion of tight contracts and an online learning algorithm (for tight contracts) that works in tandem with a test generator. We implement our approach and evaluate it on a suite of programs written in C#, studying the safety and strength of the synthesized contracts, and compare them to those synthesized by Daikon.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Angello</first_name>
          <last_name>Astorga</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>angelloastorga1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shambwaditya</first_name>
          <last_name>Saha</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <person_id>shambwadityasaha2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ahmad</first_name>
          <last_name>Dinkins</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>ahmaddinkins</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Felicia</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <person_id>feliciawang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>P.</first_name>
          <last_name>Madhusudan</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://madhu.cs.illinois.edu</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/pmadhusudan/3775a90b-eb5d-4825-86d8-2a91a1e68fdf/small.jpg</picture_url>
          <person_id>pmadhusudan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tao</first_name>
          <last_name>Xie</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://taoxiease.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/taoxie/14ae8022-1dd6-4455-a54f-157c86bc406d/small.jpg</picture_url>
          <person_id>taoxie</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>c21c51d4-de12-4296-92e6-a7db54f5d126</slot_id>
      <event_id>63e652b6-5919-48e6-b8bb-c7ed0009804e</event_id>
      <submission_id>183</submission_id>
      <title>Static Detection of Silent Misconfigurations with Deep Interaction Analysis</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>19:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:20</end_time>
      <description>The behavior of large systems is guided by their configurations: users set parameters in the configuration file to dictate which corresponding part of the system code is executed. However, it is often the case that, although some parameters are set in the configuration file, they do not influence the system runtime behavior, thus failing to meet the user’s intent. Moreover, such misconfigurations rarely lead to an error message or raising an exception. We introduce the notion of silent misconfigurations which are prohibitively hard to identify due to (1) lack of feedback and (2) complex interactions between configurations and code. 
This paper presents ConfigX, the first tool for the detection of silent configurations. The main challenge is to understand complex interactions between configuration and the code that is affected by them. Our goal is to derive a specification describing non-trivial dependencies between the configuration parameters that lead to silent misconfigurations. To this end, ConfigX uses static analysis to determine which parts of the system code are associated with configuration parameters. ConfigX then infers the connections between configuration parameters by analyzing their associated code blocks. We design customized control- and data-flow analysis to derive a specification of configurations. Additionally, we conduct reachability analysis to eliminate spurious rules to reduce false positives. Upon evaluation on five real-world datasets across three widely-used systems, Apache, vsftpd, and PostgreSQL, ConfigX detected more than 2200 silent misconfigurations. We additionally conducted a user study where we ran ConfigX on misconfigurations reported on user forums by real-world users. ConfigX easily detected issues and suggested a repair for those misconfigurations. Our solutions were accepted and confirmed in the interaction with the users, who originally posted the problems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jialu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/jialuzhang/7427a686-f97e-42da-9f0b-4b94122d30f3/small.jpg</picture_url>
          <person_id>jialuzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ruzica</first_name>
          <last_name>Piskac</last_name>
          <affiliation>Yale University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/~piskac/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ruzicapiskac/5643c034-322b-49cb-9686-ebb925bd37ed/small.jpg</picture_url>
          <person_id>ruzicapiskac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ennan</first_name>
          <last_name>Zhai</last_name>
          <affiliation>Alibaba Group</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ennanzhai.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ennanzhai/4ab41fb7-50ce-4cde-b173-2b1b7d957b82/small.jpg</picture_url>
          <person_id>ennanzhai</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tianyin</first_name>
          <last_name>Xu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://tianyin.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tianyinxu1/e97e4373-f937-4b16-b4e0-4eec79f5eb77/small.jpg</picture_url>
          <person_id>tianyinxu1</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>ee0d102a-302a-42a2-93f3-d3bb2d1c6c8c</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>f7bea629-2705-42bd-993d-9510ba088906</slot_id>
      <event_id>42d71fb3-b56f-4be5-89c7-9df2b25795da</event_id>
      <submission_id>180</submission_id>
      <title>Dynaplex: Analyzing Program Complexity using Dynamically Inferred Recurrence Relations</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:05</end_time>
      <description>Being able to detect program runtime complexity is useful in many tasks (e.g., checking expected performance and identifying potential security vulnerabilities such as DoS attacks and information leakage). In this work, we introduce a new dynamic approach for inferring the asymptotic complexity bounds of recursive programs. From program execution traces, we learn \emph{recurrence relations} and solve them using pattern matching to obtain closed-form solutions representing asymptotic complexity bounds. This approach allows us to efficiently infer simple recurrence relations that represent nontrivial, potentially nonlinear polynomial and non-polynomial, complexity bounds. 
We present Dynaplex, a tool that implements these ideas to automatically generate recurrence relations from execution traces. Our preliminary results on popular and challenging recursive programs show that Dynaplex can learn precise relations capturing worst-case complexity bounds (e.g., $\mathtt{O(n \lg n)}$ for mergesort, $\mathtt{O(2^n)}$ for Tower of Hanoi and $\mathtt{O(n^{1.58})}$ for Karatsuba’s multiplication algorithm).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Didier</first_name>
          <last_name>Ishimwe</last_name>
          <affiliation>University of Nebraska-Lincoln</affiliation>
          <bio>undefined</bio>
          <person_id>didierishimwe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>KimHao</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>University of Nebraska-Lincoln</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ndkimhao.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kimhaonguyen/6a6755d8-13f3-4b86-b4aa-068f378b1ff2/small.jpg</picture_url>
          <person_id>kimhaonguyen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>ThanhVu</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>George Mason University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nguyenthanhvuh.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/thanhvunguyen/db337089-c863-4086-ad33-88d7dbfeb025/small.jpg</picture_url>
          <person_id>thanhvunguyen</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3a487e5d-273f-4588-aaf2-e29980f4aae3</subevent_id>
    <title>SPLASH OOPSLA: Dynamic Languages - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>9c1678ac-f9f3-4394-bb5f-dcf6d2c8a157</slot_id>
      <title>Session: SPLASH OOPSLA - Dynamic Languages - mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Julia</first_name>
          <last_name>Belyakova</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Sep 2018 – present: PhD Student, Northeastern University, USA. Sep 2017 – Jul 2018: Researcher, Czech Technical University in Prague, Czech Republic. Jan 2017 – Jun 2017: Research Scientist, Northeastern University, USA. 2014–2016: teaching assistant/lecturer at Southern Federal University, Russia. Received MS in Computer Science from Southern Federal University, Russia in 2014.</bio>
          <homepage_url>https://julbinb.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juliabelyakova/b35236df-c22a-44f1-8048-aecfeba8ac2e/small.jpg</picture_url>
          <person_id>juliabelyakova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>01c5df6d-286f-45e0-a5e7-796ce7925ded</slot_id>
      <event_id>499d1ade-0a8a-4045-884c-ebba85519ad6</event_id>
      <submission_id>125</submission_id>
      <title>Gradually Structured Data</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>19:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:35</end_time>
      <description>Dynamically-typed languages offer easy interaction with ad hoc data such as JSON and S-expressions; statically-typed languages offer powerful tools for working with structured data, notably algebraic datatypes, which are a core feature of typed functional languages such as OCaml and Haskell, or otherwise such as Scala and Rust. Gradual typing aims to reconcile dynamic and static typing smoothly. The gradual typing literature has extensively focused on the computational aspect of types, such as type safety, effects, noninterference, or parametricity, but the application of graduality to data structuring mechanisms has been much less explored. While row polymorphism and set-theoretic types have been studied in the context of gradual typing, algebraic datatypes in particular have not, which is surprising considering their wide use in practice. We develop, formalize and prototype a novel approach to gradually structured data with algebraic datatypes. Gradually structured data bridges the gap between traditional algebraic datatypes and flexible data management mechanisms such as tagged data in dynamic languages, or polymorphic variants in OCaml. We illustrate the key ideas of gradual algebraic datatypes through the evolution of a small server application from dynamic to progressively more static checking, formalize a core functional language with gradually structured data, and establish its metatheory, including the gradual guarantees.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Malewski</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://users.dcc.uchile.cl/~smalewsk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stefanmalewski/cb42d4d7-af16-4e9d-b2a4-b8ce774834d7/small.jpg</picture_url>
          <person_id>stefanmalewski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mgree.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
          <person_id>etanter</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>441cec5f-ac9b-46f9-836d-f29811756433</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>5d57069f-89f7-47e2-8afd-48ee42649455</slot_id>
      <event_id>4a141d82-81f5-4f25-b5aa-659e52e64f49</event_id>
      <submission_id>49</submission_id>
      <title>Solver-based Gradual Type Migration</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>19:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:50</end_time>
      <description>Gradually typed languages allow programmers to mix statically and dynamically typed code, enabling them to incrementally reap the benefits of static typing as they add type annotations to their code. However, this type migration process is typically a manual effort with limited tool support. This paper examines the problem of automated type migration: given a dynamic program, infer additional or improved type annotations. 
Existing type migration algorithms prioritize different goals, such as maximizing type precision, maintaining compatibility with unmigrated code, and preserving the semantics of the original program. We argue that the type migration problem involves fundamental compromises: optimizing for a single goal often comes at the expense of others. Ideally, a type migration tool would flexibly accommodate a range of user priorities. 
We present TypeWhich, a new approach to automated type migration for an extension of the gradually-typed lambda calculus. Unlike prior work, which relies on custom solvers, TypeWhich produces constraints that can be solved by an off-the-shelf MaxSMT solver. This allows us to easily express objectives, such as minimizing the number of necessary syntactic coercions, and constraining the type of the migration to be compatible with unmigrated code. 
We present the first comprehensive evaluation of GTLC type migration algorithms, and compare TypeWhich to four other tools from the literature. Our evaluation uses prior benchmarks, and a new set of ``challenge problems''. Moreover, we design a new evaluation methodology that highlights the subtleties of gradual type migration. In addition, we apply TypeWhich to a suite of benchmarks for Grift, a programming language based on the GTLC. TypeWhich is able to reconstruct all human-written annotations on all but one program.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luna</first_name>
          <last_name>Phipps-Costin</last_name>
          <affiliation>University of Massachusetts Amherst</affiliation>
          <bio>undefined</bio>
          <person_id>lunaphippscostin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carolyn</first_name>
          <last_name>Anderson</last_name>
          <affiliation>Wellesley College</affiliation>
          <bio>undefined</bio>
          <person_id>carolynanderson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mgree.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
          <person_id>michaelgreenberg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Guha</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://khoury.northeastern.edu/~arjunguha</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunguha/284e0782-ec24-4ad9-b6a4-b6a1d0e2fe9a/small.jpg</picture_url>
          <person_id>arjunguha</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a86c125d-c53a-485e-993a-0385b0752982</slot_id>
      <event_id>05e9115b-0577-4202-ab11-ae1224cdc112</event_id>
      <submission_id>18</submission_id>
      <title>Promises Are Made to be Broken</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:05</end_time>
      <description>Function calls in the R language do not evaluate their arguments; these are passed to the callee as suspended computations and only evaluated if needed. After 25 years of experience with the language, there are very few cases where programmers leverage delayed evaluation intentionally. Yet, being lazy comes at a price in performance and complexity. This paper explores how to evolve the semantics of the language towards strictness by default and laziness on demand. To provide a migration path, it is necessary to change the semantics of the language and provide tooling for developers to migrate libraries and user code without introducing errors. This paper reports on a dynamic analysis that infers strictness signatures for functions to capture both intentional and accidental laziness. To assess the robustness of the inferred signatures we tested them on 2,000 R packages and found that inference was wrong in only 0.56% of the client programs. Finally, we report on the potential for performance improvements due to strictness. By modifying a just-in-time compiler to remove promises, we achieved an average speedup of 1.17X.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Aviral Goel is a Ph.D. candidate at Northeastern University. His research interests are primarily focused around Program Analysis, Type Systems and Compilers. Currently he is investigating the use of laziness in R.</bio>
          <homepage_url>http://aviral.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
          <person_id>aviralgoel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Ječmen</last_name>
          <affiliation>Czech Technical University</affiliation>
          <bio>undefined</bio>
          <person_id>janjecmen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sebastián</first_name>
          <last_name>Krynski</last_name>
          <affiliation>Czech Technical University in Prague</affiliation>
          <bio>undefined</bio>
          <person_id>sebastiankrynski</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Flückiger</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.o1o.ch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
          <person_id>olivierfluckiger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>f8e154dc-79df-459a-b3aa-5869bf215669</slot_id>
      <event_id>27a5d755-7c49-43c3-aea7-317ade9e584c</event_id>
      <submission_id>40</submission_id>
      <title>SimTyper: Sound Type Inference for Ruby using Type Equality Prediction</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>19:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>19:20</end_time>
      <description>Many researchers have explored type inference for dynamic languages. However, traditional type inference computes most general types which, for complex type systems—which are often needed to type dynamic languages—can be verbose, complex, and difficult to understand. In this paper, we introduce SimTyper, a Ruby type inference system that aims to infer \emph{usable} types—specifically, nominal and generic types—that match the types programmers write. SimTyper builds on InferDL, a recent Ruby type inference system that soundly combines standard type inference with heuristics. The key novelty of SimTyper is \emph{type equality prediction}, a new, machine learning-based technique that predicts when method arguments or returns are likely to have the same type. SimTyper finds pairs of positions that are predicted to have the same type yet one has a verbose, overly general solution and the other has a usable solution. It then guesses the two types are equal, keeping the guess if it is consistent with the rest of the program, and discarding it if not. In this way, types inferred by SimTyper are guaranteed to be sound. Type equality prediction is performed by a \emph{deep similarity} (DeepSim) neural network, which follows the Siamese network architecture, and uses CodeBERT, a pre-trained model, to embed source tokens into vectors that capture tokens and their contexts. DeepSim is trained on 100,000 pairs labeled with type similarity information extracted from 371 Ruby programs with manually documented, but not checked, types. We evaluated SimTyper on eight Ruby programs and found that, compared to standard type inference, SimTyper finds 71% more types that match programmer-written type information. Moreover, DeepSim can predict rare types that appear neither in the Ruby standard library nor in the training data. Our results show that type equality prediction can help type inference systems effectively produce more usable types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milod</first_name>
          <last_name>Kazerounian</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>undefined</bio>
          <person_id>milodkazerounian1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeffrey S.</first_name>
          <last_name>Foster</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.tufts.edu/~jfoster/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jeffreysfoster/b22ce952-32b0-48bd-be56-12fd87bf3469/small.jpg</picture_url>
          <person_id>jeffreysfoster</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bonan</first_name>
          <last_name>Min</last_name>
          <affiliation>Raytheon BBN Technologies</affiliation>
          <bio>undefined</bio>
          <person_id>bonanmin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c5b15de0-086a-4a9c-8af8-1713ec940e75</subevent_id>
    <title>SPLASH OOPSLA: Analysis - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>322b7dcc-5e03-4dd7-a39e-cafc2a04605e</slot_id>
      <title>Session: SPLASH OOPSLA - Analysis - mirror</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>1ee69b3f-ed6c-4eee-8601-91fa96b79fb4</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>6e6a1ffc-0c1a-477f-9a8e-dea6f6267250</slot_id>
      <event_id>6ff2a930-bcaf-47ae-9930-b8baa0788972</event_id>
      <submission_id>90</submission_id>
      <title>Program Analysis via Efficient Symbolic Abstraction</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>08:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:25</end_time>
      <description>This paper addresses the scalability challenges of symbolic abstraction: given a formula $\varphi$ in a logic $\mathcal{L}$ and an abstract domain $\mathcal{A}$, find a most precise element in the abstract domain that over-approximates the meaning of $\varphi$. Symbolic abstraction is an important point in the space of abstract interpretation, as it allows for automatically synthesizing the best abstract transformers. However, current techniques for symbolic abstraction can have difficulty delivering on its practical strengths, due to performance issues. 
In this work, we introduce two algorithms for the symbolic abstraction of quantifier-free bit-vector formulas, which apply to the bit-vector interval domain and a certain kind of polyhedral domain, respectively. We implement and evaluate the proposed techniques on two machine code analysis clients, static memory corruption analysis and constrained random fuzzing. Using a suite of 57,933 queries from the clients, we compare our approach against a diverse group of state-of-the-art algorithms. The experiments show that our algorithms achieve a substantial speedup over existing techniques, and illustrate significant precision advantages for the clients. Our work presents strong evidence that symbolic abstraction of numeric domains can be efficient and practical for large and realistic programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Peisen</first_name>
          <last_name>Yao</last_name>
          <affiliation>The Hong Kong University of Science and Technology</affiliation>
          <bio>I am broadly interested in topics related to programming languages, software engineering, formal method, and cybersecurity, with an emphasis on using program reasoning techniques to ensure software reliability.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/yaopeisen/afec483a-bef9-4542-b208-b84c15344696/small.jpg</picture_url>
          <person_id>yaopeisen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Qingkai</first_name>
          <last_name>Shi</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Qingkai Shi is a Postdoc Research Associate in the department of computer science, Purdue University. His major research interest is the use of compiler techniques to ensure software reliability. He has published extensively at premium venues of programming languages (PLDI, OOPSLA), software engineering (ICSE, FSE, TSE, ISSTA), and cybersecurity (S&amp;amp;P). His research received many awards including ACM SIGSOFT Distinguished Paper Award and Hong Kong Ph.D. Fellowship. His research has led to the discovery of over a hundred software vulnerabilities in open-source software and has been successfully commercialized in Sourcebrella Inc, a static analysis tool vendor. Qingkai obtained his Ph.D. and B.S. from Nanjing University and the Hong Kong University of Science and Technology, respectively.</bio>
          <homepage_url>https://qingkaishi.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/qingkaishi/99eef1fd-60de-40bf-888f-38d77b3db376/small.jpg</picture_url>
          <person_id>qingkaishi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Heqing</first_name>
          <last_name>Huang</last_name>
          <affiliation>Hong Kong University of Science and Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://5hadowblad3.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/heqinghuang/726be0ec-989d-4ddd-b27c-6559ebc40835/small.jpg</picture_url>
          <person_id>heqinghuang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charles</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Hong Kong University of Science and Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ust.hk/~charlesz</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/charleszhang/d5404cd7-dca8-4033-b79f-500613a981b9/small.jpg</picture_url>
          <person_id>charleszhang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>9a43d50f-14fe-43fa-bf7b-74da0cdac194</slot_id>
      <event_id>4f4af528-c989-4120-8b8e-ab1590c33f65</event_id>
      <submission_id>426</submission_id>
      <title>Compacting Points-To Sets Through Object Clustering</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>07:55</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:10</end_time>
      <description>Inclusion-based set constraint solving is the most popular technique for whole-program points-to analysis whereby an analysis is typically formulated as repeatedly resolving constraints between points-to sets of program variables. The set union operation is central to this process. The number and size of points-to sets grow as analyses become more precise and input programs become larger, resulting in more time spent performing unions. Most existing approaches focus on improving scalability of precise points-to analyses from an algorithmic perspective and there has been less research into improving the data structures behind the analyses. 
Bit-vectors as one of the more popular data structures have been used in several mainstream analysis frameworks to represent points-to sets. To store memory objects in bit-vectors, objects need to mapped to integral identifiers. We observe that this object-to-identifier mapping is critical for a compact points-to set representation and the set union operation. If objects in the same points-to sets (co-pointees) are not given numerically close identifiers, points-to resolution can cost significantly more space and time. Without data on the unpredictable points-to relations discovered by the analysis, an ideal mapping is extremely challenging. 
In this paper, we present a new approach to inclusion-based analysis by compacting points-to sets through object clustering. Inspired by recent staged analysis where an auxiliary analysis produces results approximating a more precise main analysis, we formulate points-to set compaction as an optimisation problem solved by integer programming using constraints generated from the auxiliary analysis’s results in order to produce an effective mapping. We then develop a more approximate mapping, yet much more efficiently, using hierarchical clustering to compact bit-vectors. We also develop an improved representation of bit-vectors (called core bit-vectors) to fully take advantage of the newly produced mapping. Our approach requires no algorithmic change to the points-to analysis. We evaluate our object clustering on flow-sensitive points-to analysis using 9 open-source programs (&amp;gt;5.3 millions lines of LLVM instructions) and Our results show that our approach can successfully improve the analysis with an up to 1.75$\times$ speed up and up to 3.25$\times$ reduction in memory usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohamad</first_name>
          <last_name>Barbar</last_name>
          <affiliation>University of Technology Sydney, Australia and CSIRO's Data61, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mbarbar.net</homepage_url>
          <person_id>mohamadbarbar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yulei</first_name>
          <last_name>Sui</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuleisui.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuleisui/e6ce6e88-3cd8-4595-9c61-a8da6f7319f6/small.jpg</picture_url>
          <person_id>yuleisui</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>e8aa17c9-3a57-4a32-b32b-dd6e4ac64a3d</slot_id>
      <event_id>15b825cc-d30b-4dc1-97c4-9068619d905b</event_id>
      <submission_id>223</submission_id>
      <title>Making Pointer Analysis More Precise by Unleashing the Power of Selective Context Sensitivity</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>07:55</end_time>
      <description>Traditional context-sensitive pointer analysis is hard to scale for large and complex Java programs. To address this issue, a series of selective context-sensitivity approaches have been proposed and exhibit promising results. In this work, we move one step further towards producing highly-precise pointer analyses for hard-to-analyze Java programs by presenting the Unity-Relay framework, which takes selective context sensitivity to the next level. Briefly, Unity-Relay is a one-two punch: given a set of different selective context-sensitivity approaches, say $S = {S_1, \ldots, S_n}$, Unity-Relay first provides a mechanism (called Unity) to combine and maximize the precision of all components of $S$. When Unity fails to scale, Unity-Relay offers a scheme (called Relay) to pass and accumulate the precision from one approach $S_i$ in $S$ to the next, $S_{i+1}$, leading to an analysis that is more precise than all approaches in $S$. 
As a proof-of-concept, we instantiate Unity-Relay into a tool called Baton and extensively evaluate it on a set of hard-to-analyze Java programs, using general precision metrics and popular clients. Compared with the state of the art, Baton achieves the best precision for \emph{all} metrics and clients for \emph{all} evaluated programs. The difference in precision is often dramatic—up to 71% of alias pairs reported by previously-best algorithms are found to be spurious and eliminated.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tian</first_name>
          <last_name>Tan</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://silverbullettt.bitbucket.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiantan/4b1e811e-fce9-4642-92fb-d629f222b572/small.jpg</picture_url>
          <person_id>tiantan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yue</first_name>
          <last_name>Li</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuelee.bitbucket.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yueli/c0b3b5ef-ffac-472c-9a05-5b9c8f165d7d/small.jpg</picture_url>
          <person_id>yueli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xiaoxing</first_name>
          <last_name>Ma</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ics.nju.edu.cn/people/xiaoxingma/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xiaoxingma1/5add1977-f0a4-458b-b59b-71cf18017400/small.jpg</picture_url>
          <person_id>xiaoxingma1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Chang</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nanjing University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.nju.edu.cn/changxu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/changxu/e28fcdd7-83f6-43c4-9ac8-20a3fa1137d8/small.jpg</picture_url>
          <person_id>changxu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>f2a13135-2f97-4197-90fc-99212f5e46f8</slot_id>
      <event_id>9ea1d9f0-04dc-4462-8e51-cc113731d741</event_id>
      <submission_id>507</submission_id>
      <title>JavaDL: Automatically Incrementalizing Java Bug Pattern Detection</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/20</date>
      <start_time>08:25</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:40</end_time>
      <description>Static checker frameworks support software developers by automatically discovering bugs that fit general-purpose bug patterns. These frameworks ship with hundreds of detectors for such patterns and allow developers to add custom detectors for their own projects. However, existing frameworks generally encode detectors in imperative specifications, with extensive details of not only what to detect but also how. These details not only add complexity to maintenance and extensibility, but also interfere with the framework’s ability to change how detection is done, for instance, to make the detectors incremental. 
In this paper, we present JavaDL, a Datalog-based declarative specification language for bug pattern detection in Java code. JavaDL seamlessly supports both exhaustive and incremental evaluation from the same detector specification . The system further allows developers to concisely describe bug detectors via syntactic pattern matching for local AST matching, and via Datalog-style logical rules for nonlocal reasoning. We compare our approach against the well-established SpotBugs and Error Prone tools by re-implementing several of their detectors in JavaDL. We find that our implementations are substantially smaller and similarly effective at detecting bugs on the Defects4J benchmark suite, and run with competitive runtime performance. In our experiments, neither incremental nor exhaustive analysis is able to consistently outperform the other analysis mode, which highlights the value of our ability to transparently switch execution modes. We argue that our approach highlights the potential of clear-box static checker frameworks that constrain the bug detector specification language to enable the framework to adapt and enhance the detectors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexandru</first_name>
          <last_name>Dura</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <person_id>alexandrudura1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Reichenbach</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/christophreichenbach/04687677-a813-459e-8929-d1e4a32627c6/small.jpg</picture_url>
          <person_id>christophreichenbach</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Emma</first_name>
          <last_name>Söderberg</last_name>
          <affiliation>Lund University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/emmasoderberg/2edc9865-4e98-41ee-a89e-1568465852e0/small.jpg</picture_url>
          <person_id>emmasoderberg</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>169af1b0-2e2e-4ad1-ad71-97a921d38142</subevent_id>
    <title>SPLASH OOPSLA: Types - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>3b5a71fa-a93b-4849-8955-4c631c0461ec</slot_id>
      <title>Session: SPLASH OOPSLA - Types - mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Wei-Ngan</first_name>
          <last_name>Chin</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <person_id>weinganchin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>2eb69533-e384-4477-97d7-16389221519c</slot_id>
      <event_id>41174c70-3ab0-4594-8b81-6dea9b1c3735</event_id>
      <submission_id>47</submission_id>
      <title>Relational Nullable Types with Boolean Unification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>22:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:35</end_time>
      <description>We present a simple, practical, and expressive relational nullable type system. A relational nullable type system captures whether an expression may evaluate to null based on its type, but also based on the type of other related expressions. The type system extends the Hindley-Milner type system with Boolean constraints, supports parametric polymorphism, and preserves principal types modulo Boolean equivalence. We show how to support full Hindley-Milner style type inference with an extension of Algorithm W. 
We conduct a preliminary study of open source projects showing that there is a need for relational nullable type systems across a wide range of programming languages. The most important findings from the study are: (i) programmers use programming patterns where the nullability of one expression depends on the nullability of other related expressions, (ii) such invariants are commonly enforced with run-time exceptions, and (iii) reasoning about these programming patterns requires not only knowledge of when an expression may evaluate to null, but also when it may evaluate to a non-null value. We incorporate these observations in the design of the proposed relational nullable type system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus</first_name>
          <last_name>Madsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~magnusm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/magnusmadsen/9a82da88-7b35-4d85-8b5b-d129bcc4d296/small.jpg</picture_url>
          <person_id>magnusmadsen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jaco</first_name>
          <last_name>van de Pol</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Jaco van de Pol did his PhD research in Utrecht University on rewrite systems, in particular termination of higher-order rewrite systems. At CWI Amsterdam, he published several papers on theorem proving and model checking for concurrent systems in process algebra and contributed to the µCRL toolset. In Twente, he started a new research line on parallel model checking algorithms. This resulted in the LTSmin toolset for high-performance model checking. He worked on applications in embedded systems, safety &amp;amp; security and systems biology. 
Jaco van de Pol is now professor of Computer Science at Aarhus University, working on automated verification and synthesis. Publications at Google Scholar and DBLP. 
Affiliations: 
 
 MSc Utrecht University (supervisor Hans Zantema) 
 PhD Utrecht University (supervisor Jan Bergstra) 
 Research Assistant LMU Mathematisches Institute Munich (with Helmut Schwichtenberg) 
 Postdoc Technical University of Eindhoven (with Jozef Hooman) 
 Senior Researcher CWI (1999-2007) 
 Associate Professor Technical University of Eindhoven (2004-2007, 20%) 
 Professor Formal Methods and Tools at University of Twente (2007-2018; from Nov 2018 10%) 
 Professor Computer Science at Aarhus University (from Nov 2018) 
</bio>
          <homepage_url>https://www.cs.au.dk/~jaco</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jacovandepol/b053e08d-fe52-46a9-b4cd-b863ea6c9c07/small.jpg</picture_url>
          <person_id>jacovandepol</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>4c0ffa54-c1a7-45b1-a606-8c216af69649</slot_id>
      <event_id>3aad0c8c-c620-4cea-b83f-3ef19cdf6d5f</event_id>
      <submission_id>237</submission_id>
      <title>Type Stability in Julia: Avoiding Performance Pathologies in JIT Compilation</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>22:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:50</end_time>
      <description>As a scientific programming language, Julia strives for performance but also provides high-level productivity features. To avoid performance pathologies, Julia users are expected to adhere to a coding discipline that enables so-called type stability. Informally, a function is type stable if the type of the output depends only on the types of the inputs, not their values. This paper provides a formal definition of type stability as well as a stronger property of type groundedness, shows that groundedness enables compiler optimizations, and proves the compiler correct. We also perform a corpus analysis to uncover how these type-related properties manifest in practice.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Artem</first_name>
          <last_name>Pelenitsyn</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mmcs.sfedu.ru/~ulysses/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/artempelenitsyn/747a7a15-5a78-4871-857b-53cbbe5f6e1e/small.jpg</picture_url>
          <person_id>artempelenitsyn</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julia</first_name>
          <last_name>Belyakova</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Sep 2018 – present: PhD Student, Northeastern University, USA. Sep 2017 – Jul 2018: Researcher, Czech Technical University in Prague, Czech Republic. Jan 2017 – Jun 2017: Research Scientist, Northeastern University, USA. 2014–2016: teaching assistant/lecturer at Southern Federal University, Russia. Received MS in Computer Science from Southern Federal University, Russia in 2014.</bio>
          <homepage_url>https://julbinb.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/juliabelyakova/b35236df-c22a-44f1-8048-aecfeba8ac2e/small.jpg</picture_url>
          <person_id>juliabelyakova</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin W</first_name>
          <last_name>Chung</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <person_id>benjaminwchung</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ross</first_name>
          <last_name>Tate</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~ross/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rosstate/cbcbd066-943d-46a2-a301-1f4084076400/small.jpg</picture_url>
          <person_id>rosstate</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University / Czech Technical University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
          <person_id>janvitek</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>bb3e1cca-69ed-4767-b2a0-b8f20e19e96e</slot_id>
      <event_id>ca540410-cf87-4a60-a719-2ad9b0f97620</event_id>
      <submission_id>170</submission_id>
      <title>Study of the Subtyping Machine of Nominal Subtyping with Variance</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:05</end_time>
      <description>This is a study of the computing power of the subtyping machine behind Kennedy and Pierce’s nominal subtyping with variance. We depict the lattice of fragments of Kennedy and Pierce’s type system and characterize their computing power in terms of regular, context-free, deterministic, and non-deterministic tree languages. Based on the theory, we present Treetop—a generator of C# implementations of subtyping machines. The software artifact constitutes the first feasible (yet POC) fluent API generator to support context-free API protocols in a decidable type system fragment.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ori</first_name>
          <last_name>Roth</last_name>
          <affiliation>Technion</affiliation>
          <bio>Ori Roth is a PhD student at the Technion—Israel Institute of Technology. His research interests include programming languages, software engineering, and automata theory.</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/oriroth/f303c081-564f-4bb5-8037-c59de38bd235/small.jpg</picture_url>
          <person_id>oriroth</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>be154f86-b7f0-4fa0-9daa-b96c00567176</slot_id>
      <event_id>3d8946fe-98b1-4684-8c3c-05faf136ee3f</event_id>
      <submission_id>43</submission_id>
      <title>Label Dependent Lambda Calculus and Gradual Typing</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>22:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:20</end_time>
      <description>Dependently-typed programming languages are gaining importance, because they can guarantee a wide range of properties at compile time. Their use in practice is often hampered because programmers have to provide very precise types. Gradual typing is a means to vary the level of typing precision between program fragments and to transition smoothly towards more precisely typed programs. The combination of gradual typing and dependent types seems promising to promote the widespread use of dependent types. 
We investigate a gradual version of a minimalist value-dependent lambda calculus. Compile-time calculations and thus dependencies are restricted to labels, drawn from a generic enumeration type. The calculus supports the usual Pi and Sigma types as well as singleton types and subtyping. It is sufficiently powerful to provide flexible encodings of variant and record types with first-class labels. 
We provide type checking algorithms for the underlying label-dependent lambda calculus and its gradual extension. The gradual type checker drives the translation into a cast calculus, which extends the original language. The cast calculus comes with several innovations: refined typing for casts in the presence of singletons, type reduction in casts, and fully dependent Sigma types. Besides standard metatheoretical results, we establish the gradual guarantee for the gradual language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Weili</first_name>
          <last_name>Fu</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <person_id>weilifu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fabian</first_name>
          <last_name>Krause</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <person_id>fabiankrause</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Thiemann</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/peterthiemann/43fc0175-1745-4b3a-b626-86e10da76b86/small.jpg</picture_url>
          <person_id>peterthiemann</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>eaa8a4ca-8b77-4aab-bc2a-8943329ed46f</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/21</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c15f1b97-c675-427b-86cb-80b09a9f03e5</subevent_id>
    <title>SPLASH OOPSLA: Smart Contracts and Distributed Programming - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>d6b893e4-4379-493d-a976-07255b29e178</slot_id>
      <title>Session: SPLASH OOPSLA - Smart Contracts and Distributed Programming - mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>00c58c00-636e-4ab1-bf76-f324c06feb72</slot_id>
      <event_id>f2687be1-d8a0-434b-942c-242aef9f826d</event_id>
      <submission_id>153</submission_id>
      <title>Durable Functions: Semantics for Stateful Serverless</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>08:25</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>08:40</end_time>
      <description>Serverless, or Functions-as-a-Service (FaaS), is an increasingly popular paradigm for application development, as it provides implicit elastic scaling and load based billing. However, the weak execution guarantees and intrinsic compute-storage separation of FaaS create serious challenges when developing applications that require persistent state, reliable progress, or synchronization. This has motivated a new generation of serverless frameworks that provide stateful abstractions. For instance, Azure’s Durable Functions (DF) programming model enhances FaaS with actors, workflows, and critical sections. As a programming model, DF is interesting because it combines task and actor parallelism, which makes it suitable for a wide range of serverless applications. We describe DF both informally, using examples, and formally, using an idealized high-level model based on the untyped lambda calculus. Next, we demystify how the DF runtime can (1) execute in a distributed unreliable serverless environment with compute-storage separation, yet still conform to the fault-free high-level model, and (2) persist execution progress without requiring checkpointing support by the language runtime. To this end we define two progressively more complex execution models, which contain the compute-storage separation and the record-replay, and prove that they are equivalent to the high-level model.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Burckhardt</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Sebastian Burckhardt was born and raised in Basel, Switzerland, where he studied Mathematics at the local University. During an exchange year at Brandeis University, he discovered his affinity to Computer Science and immigrated to the United States. After a few years of industry experience at IBM, he returned to academia and earned his PhD in Computer Science at the University of Pennsylvania. Since then, he has worked as a researcher at Microsoft Research in Redmond. His general research interest is the study of programming models for of concurrent, parallel, and distributed systems. More specific interests include consistency models, concurrency testing, self-adjusting computation, and the concurrent revisions programming model.</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/sburckha/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sebastianburckhardt/726ac702-681a-40f8-94d6-c0465e108867/small.jpg</picture_url>
          <person_id>sebastianburckhardt</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chris</first_name>
          <last_name>Gillum</last_name>
          <affiliation>Microsoft Azure</affiliation>
          <bio>undefined</bio>
          <person_id>chrisgillum</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Justo</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>David Justo is a Software Engineer at Microsoft, working on programming models for distributed systems and developer tooling more broadly. Previously, he was an MS student at UC San Diego working on program synthesis and polyglot programming. He’s interested in programming languages, programming environments, database theory, and formal methods.</bio>
          <homepage_url>https://davidmrdavid.github.io/about.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/davidjusto/1f7a0dc6-330d-47c6-9738-4e120b9e56bb/small.jpg</picture_url>
          <person_id>davidjusto</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Kallas</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://angelhof.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/konstantinoskallas/532ec21f-35f9-482a-afc9-d7c8b7118a65/small.jpg</picture_url>
          <person_id>konstantinoskallas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Connor</first_name>
          <last_name>McMahon</last_name>
          <affiliation>Microsoft Azure</affiliation>
          <bio>undefined</bio>
          <person_id>connormcmahon</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Christopher S.</first_name>
          <last_name>Meiklejohn</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <person_id>christophersmeiklejohn</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>52a62ecb-10d2-4f3a-ac3a-d8167fa61c47</slot_id>
      <event_id>1d8597cd-3c9f-4c45-b22a-ec533b6faaba</event_id>
      <submission_id>222</submission_id>
      <title>Rich Specifications for Ethereum Smart Contract Verification</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>07:55</end_time>
      <description>Smart contracts are programs that execute inside blockchains such as Ethereum to manipulate digital assets. Since bugs in smart contracts may lead to substantial financial losses, there is considerable interest in formally proving their correctness. However, the specification and verification of smart contracts faces challenges that do not arise in other application domains. Smart contracts frequently interact with unverified, potentially adversarial outside code, which substantially weakens the assumptions that formal analyses can (soundly) make. Moreover, the core functionality of smart contracts is to manipulate and transfer resources; describing this functionality concisely requires dedicated specification support. Current reasoning techniques do not fully address these challenges, being restricted in their scope or expressiveness (in particular, in the presence of re-entrant calls), and offering limited means of expressing the resource transfers a contract performs. 
In this paper, we present a novel specification methodology tailored to the domain of smart contracts. Our specification constructs and associated reasoning technique are the first to enable: (1) sound and precise reasoning in the presence of unverified code and arbitrary re-entrancy, (2) modular reasoning about collaborating smart contracts, and (3) domain-specific specifications based on resources and resource transfers, which allow expressing a contract’s behavior in intuitive and concise ways and exclude typical errors by default. We have implemented our approach in 2vyper, an SMT-based automated verification tool for Ethereum smart contracts written in the Vyper language, and demonstrated its effectiveness in succinctly capturing and verifying strong correctness guarantees for real-world contracts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Braem</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <person_id>christianbraem</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marco</first_name>
          <last_name>Eilers</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch/people/personal/meilers-pers.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/marcoeilers/fbfa4a0a-c277-440b-af64-20c5dbf19d0c/small.jpg</picture_url>
          <person_id>marcoeilers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Müller</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pm.inf.ethz.ch</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/petermller/aeb8e276-62cb-4ad1-aa7d-96f76c0c405d/small.jpg</picture_url>
          <person_id>petermller</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robin</first_name>
          <last_name>Sierra</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>robinsierra</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Alexander J.</first_name>
          <last_name>Summers</last_name>
          <affiliation>University of British Columbia (UBC)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.ubc.ca/~alexsumm/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alexanderjsummers/f97b84a8-d46a-4e76-aa73-cc4b38c4ec41/small.jpg</picture_url>
          <person_id>alexanderjsummers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>59604b67-99f1-439a-b8da-4a50a6d74203</slot_id>
      <event_id>70fddf0a-a865-4d6d-a00e-3c602d4f2336</event_id>
      <submission_id>42</submission_id>
      <title>ECROs: Building Global Scale Systems from Sequential Code</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>08:10</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>08:25</end_time>
      <description>To ease the development of geo-distributed applications, replicated data types (RDTs) offer a familiar programming interface while ensuring state convergence, low latency, and high availability. However, RDTs are still designed exclusively by experts using ad-hoc solutions that are error-prone and result in brittle systems. Recent works statically detect conflicting operations on existing data types and coordinate those at runtime to guarantee convergence and preserve application invariants. However, these approaches are too conservative, imposing coordination on a large number of operations. In this work, we propose a principled approach to design and implement efficient RDTs taking into account application invariants. Developers extend sequential data types with a distributed specification, which together form a RDT. We statically analyze the specification to detect conflicts and unravel their cause. This information is then used at runtime to serialize concurrent operations safely and efficiently. Our approach derives a correct RDT from any sequential data type without changes to the data type’s implementation and with minimal coordination. We implement our approach in Scala and develop an extensive portfolio of RDTs. The evaluation shows that our approach provides performance similar to conflict-free replicated data types for commutative operations, and considerably improves the performance of non-commutative operations, compared to existing solutions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kevin</first_name>
          <last_name>De Porre</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.kevindp.be</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kevindeporre1/3842a3bd-3338-4a6c-80b6-8fe72b9ca44b/small.jpg</picture_url>
          <person_id>kevindeporre1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carla</first_name>
          <last_name>Ferreira</last_name>
          <affiliation>NOVA LINCS &amp; Nova School of Sciences and Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ctp.di.fct.unl.pt/~cf/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/carlaferreira/84cdc5a2-f01b-44cd-b28f-73ae8baed899/small.jpg</picture_url>
          <person_id>carlaferreira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nuno</first_name>
          <last_name>Preguica</last_name>
          <affiliation>Universidade Nova Lisboa</affiliation>
          <bio>undefined</bio>
          <person_id>nunopreguica</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Elisa</first_name>
          <last_name>Gonzalez Boix</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~egonzale</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/elisagonzalezboix/51a3d0ba-7330-40d4-ad16-4568d31fe2e4/small.jpg</picture_url>
          <person_id>elisagonzalezboix</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>aafea98a-1654-42b3-a5ee-188d08506e47</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>ec352f48-b220-4545-bfe1-e7c476737204</slot_id>
      <event_id>3864f6b3-a74b-4f39-89f7-b15e107b4a2a</event_id>
      <submission_id>476</submission_id>
      <title>Symbolic Value-Flow Static Analysis: Deep, Precise, Complete Modeling of Ethereum Smart Contracts</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>07:55</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>08:10</end_time>
      <description>We present a static analysis approach that combines concrete values and symbolic expressions. This symbolic value-flow (“symvalic”) analysis models program behavior with high precision, e.g., full path sensitivity. To achieve deep modeling of program semantics, the analysis relies on a symbiotic relationship between a traditional static analysis fixpoint computation and a symbolic solver: the solver does not merely receive a complex “path condition” to solve, but is instead invoked repeatedly (often tens or hundreds of thousands of times), in close cooperation with the flow computation of the analysis. 
The result of the symvalic analysis architecture is a static modeling of program behavior that is much more complete than symbolic execution, much more precise than conventional static analysis, and domain-agnostic: no special-purpose definition of anti-patterns is necessary in order to compute violations of safety conditions with high precision. 
We apply the analysis to the domain of Ethereum smart contracts. This domain represents a fundamental challenge for program analysis approaches: despite numerous publications, research work has not been effective at uncovering vulnerabilities of high real-world value. 
In systematic comparison of symvalic analysis with past tools, we find significantly increased completeness (shown as 83-96% statement coverage and more true error reports) combined with much higher precision, as measured by rate of true positive reports. In terms of real-world impact, since the beginning of 2021, the analysis has resulted in the discovery and disclosure of several critical vulnerabilities, over funds in the many millions of dollars. Six separate bug bounties totaling over $350K have been awarded for these disclosures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>Research Interests: programming languages and software engineering 
 
 Program analysis (static analysis, test generation, invariant inference, symbolic execution) 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality) 
</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
          <person_id>yannissmaragdakis</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neville</first_name>
          <last_name>Grech</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>My expertise is focused on program analysis, mostly applied to security applications. My work in this area has been recently highlighted by ACM SIGPLAN and Communications of the ACM. I am also interested in the areas of energy efficient systems, smart contracts, semantics and generative programming. Some popular tools I have codeveloped include decompilers and security analyzers for the Ethereum platform (MadMax and Gigahorse) and Java pointer and taint analysis frameworks (Doop, P/Taint and HeapDL). Previously, I was Reach High Fellow at the University of Athens, a Senior Research Associate at the University of Bristol, and have worked in industry as a Data Scientist and Software Engineer. I hold a PhD from the University of Southampton.</bio>
          <homepage_url>http://www.nevillegrech.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nevillegrech/e0405613-3240-4ef2-a51f-cb7536870dc5/small.jpg</picture_url>
          <person_id>nevillegrech</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sifis</first_name>
          <last_name>Lagouvardos</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/sifislagouvardos/7bff730b-e719-4f0c-935c-245291f18d9d/small.jpg</picture_url>
          <person_id>sifislagouvardos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Triantafyllou</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <person_id>konstantinostriantafyllou1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ilias</first_name>
          <last_name>Tsatiris</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/iliastsatiris/b33fd835-f771-4b76-b5e8-00452e460cf7/small.jpg</picture_url>
          <person_id>iliastsatiris</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f27d91c7-6da9-4bd9-b07d-9b61b11e532c</subevent_id>
    <title>SPLASH OOPSLA: Functional Programming</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>05e4b6e7-b27b-4575-97a3-f1c007c5a29a</slot_id>
      <title>Session: SPLASH OOPSLA - Functional Programming</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_time>12:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Nada</first_name>
          <last_name>Amin</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://namin.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadaamin/b083e70b-31f9-4a88-89ba-ae54f8ec9315/small.jpg</picture_url>
          <person_id>nadaamin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0c00b2be-ccdc-48f6-be5a-d8a2a3a8c0f4</slot_id>
      <event_id>7e72ede0-84a8-45df-97b4-f2b728e7a48d</event_id>
      <submission_id>75</submission_id>
      <title>Compiling with Continuations, Correctly</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>10:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:05</end_time>
      <description>In this paper we present a novel simulation relation for proving correctness of program transformations that combines syntactic simulations and logical relations. In particular, we establish a new kind of simulation diagram that uses a small-step or big-step semantics in the source language and an untyped, step-indexed logical relation in the target language. Our technique provides a practical solution for proving semantics preservation for transformations that do not preserve reductions in the source language. This is common when transformations generate new binder names, and hence $\alpha$-conversion must be explicitly accounted for, or when transformations introduce administrative redexes. Our technique does not require reductions in the source language to correspond directly to reductions in the target language. Instead, we enforce a weaker notion of semantic preorder, which suffices to show that semantics are preserved for both whole-program and separate compilation. Because our logical relation is transitive, we can transition between intermediate program states in a small-step fashion and hence the shape of the proof resembles that of a simple small-step simulation. 
We use this technique to revisit the semantic correctness of a continuation-passing style (CPS) transformation and we demonstrate how it allows us to overcome well-known complications of this proof related to $\alpha$-conversion and administrative reductions. In addition, by using a logical relation that is indexed by invariants that relate the resource consumption of two programs, we are able show that the transformation preserves diverging behaviors and that our CPS transformation asymptotically preserves the running time of the source program. 
Our results are formalized in the Coq proof assistant. Our continuation-passing style transformation is part of the CertiCoq compiler for Gallina, the specification language of Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zoe</first_name>
          <last_name>Paraskevopoulou</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zoep.github.io/</homepage_url>
          <person_id>zoeparaskevopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anvay</first_name>
          <last_name>Grover</last_name>
          <affiliation>University of Wisconsin–Madison</affiliation>
          <bio>undefined</bio>
          <person_id>anvaygrover</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>15bbe8cb-08f4-4c63-a3f6-ce9ae9f29b37</slot_id>
      <event_id>f0e509f9-0fba-48ca-8b45-d1c318f1c895</event_id>
      <submission_id>181</submission_id>
      <title>Reachability Types: Tracking Aliasing and Separation in Higher-Order Functional Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>11:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:35</end_time>
      <description>Ownership type systems, based on the idea of enforcing unique access paths, have been primarily focused on objects and top-level classes. However, existing models do not as readily reflect the finer aspects of nested lexical scopes, capturing, or escaping closures in higher-order functional programming patterns, which are increasingly adopted even in mainstream OO languages. We present a new type system, $\lambda^{\ast}$, which enables expressive ownership-style reasoning across higher-order functions. It tracks sharing and separation through reachability sets, and layers additional mechanisms for selectively enforcing uniqueness on top of it. Based on reachability sets, we extend the type system with an expressive flow-sensitive effect system, which enables flavors of move semantics and ownership transfer. In addition, we present several case studies and extensions, including applications to capabilities for algebraic effects, one-shot continuations, and safe parallelization.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuyan</first_name>
          <last_name>Bao</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuyanbao.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuyanbao/29054831-172d-4005-9e61-a5f62bd70c76/small.jpg</picture_url>
          <person_id>yuyanbao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guannan</first_name>
          <last_name>Wei</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://continuation.passing.style</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guannanwei/e1971b4b-ebd3-429b-b28c-0c2cfb0f0289/small.jpg</picture_url>
          <person_id>guannanwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Bračevac</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://bracevac.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/oliverbracevac/17c0ac71-a156-4868-8df9-d4ae4cd669e7/small.jpg</picture_url>
          <person_id>oliverbracevac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yuxuan</first_name>
          <last_name>Jiang</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>yuxuanjiang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Qiyang</first_name>
          <last_name>He</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>qiyanghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>afe91681-d0b1-4dda-b78d-3c9e892161e4</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>11:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b92d6597-9025-471b-a543-359ea439fada</slot_id>
      <event_id>fc877a4c-cd99-491d-bb86-11c7282681b5</event_id>
      <submission_id>24</submission_id>
      <title>Efficient Compilation of Algebraic Effect Handlers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>11:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:50</end_time>
      <description>The popularity of algebraic effect handlers as a programming language feature for user-defined computational effects is steadily growing. Yet, even though efficient runtime representations have already been studied, most handler-based programs are still much slower than hand-written code. This paper shows that the performance gap can be drastically narrowed (in some cases even closed) by means of type-and-effect directed optimising compilation. Our approach consists of source-to-source transformations in two phases of the compilation pipeline. Firstly, elementary rewrites, aided by judicious function specialisation, exploit the explicit type and effect information of the compiler’s core language to agressively reduce handler applications. Secondly, after erasing the effect information further rewrites in the backend of the compiler emit tight code. This work comes with a practical implementation: an optimizing compiler from Eff, an ML style language with algebraic effect handlers, to OCaml. Experimental evaluation with this implementation demonstrates that in a number of benchmarks, our approach eliminates much of the overhead of handlers, outperforms capability-passing style compilation and yields competitive performance compared to hand-written OCaml code as well Multicore OCaml’s dedicated runtime support.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Karachalias</last_name>
          <affiliation>Tweag</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gkaracha.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/georgekarachalias/cb10a8f5-6b72-4883-aef0-c9978070378a/small.jpg</picture_url>
          <person_id>georgekarachalias</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Filip</first_name>
          <last_name>Koprivec</last_name>
          <affiliation>University of Ljubljana</affiliation>
          <bio>undefined</bio>
          <person_id>filipkoprivec1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matija</first_name>
          <last_name>Pretnar</last_name>
          <affiliation>University of Ljubljana</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://matija.pretnar.info/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/matijapretnar/87fb17f8-8e61-4088-8c8f-88c5c9174485/small.jpg</picture_url>
          <person_id>matijapretnar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>d1959753-ad03-4810-b070-8c6b6a7cf071</slot_id>
      <event_id>c37258b4-1df6-476e-b6e1-b5168f6b0ece</event_id>
      <submission_id>32</submission_id>
      <title>Synbit: Synthesizing Bidirectional Programs using Unidirectional Sketches</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>11:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>11:20</end_time>
      <description>We propose a technique for synthesizing bidirectional programs from the corresponding unidirectional code plus a few input/output examples. The core ideas are: (1) \emph{constructing a sketch} using the given unidirectional program as a specification, and (2) \emph{filling the sketch} in a modular fashion by exploiting the properties of bidirectional programs. These ideas are enabled by our choice of programming language, HOBiT, which is specifically designed to maintain the unidirectional program structure in bidirectional programming, and keep the parts that control bidirectional behavior modular. To evaluate our approach, we implemented it in a tool called Synbit and used it to generate bidirectional programs for intricate microbenchmarks, as well as for a few larger, more realistic problems. We also compared Synbit to a state-of-the-art unidirectional synthesis tool on the task of synthesizing backward computations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Masaomi</first_name>
          <last_name>Yamaguchi</last_name>
          <affiliation>Graduate School of Information Sciences, Tohoku University</affiliation>
          <bio>undefined</bio>
          <person_id>masaomiyamaguchi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kazutaka</first_name>
          <last_name>Matsuda</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.sf.ecei.tohoku.ac.jp/~kztk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kazutakamatsuda/2262653d-0d0f-4641-8ac2-7b653c0e3683/small.jpg</picture_url>
          <person_id>kazutakamatsuda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cristina</first_name>
          <last_name>David</last_name>
          <affiliation>University of Bristol</affiliation>
          <bio>undefined</bio>
          <person_id>cristinadavid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Meng</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Bristol, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mengwangoxf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mengwang/2aba9176-828a-4227-9392-75f364770330/small.jpg</picture_url>
          <person_id>mengwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2daf5026-e857-4e32-a9e0-c5c28cd539d7</subevent_id>
    <title>SPLASH OOPSLA: Types &amp; Verification</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>6661d152-d406-464e-b9eb-fa286e69c3e2</slot_id>
      <title>Session: SPLASH OOPSLA - Types &amp; Verification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>870d0a92-458a-482f-bf95-222c4c503cca</slot_id>
      <event_id>c535117f-4286-427b-a999-ec9db64e4b2c</event_id>
      <submission_id>161</submission_id>
      <title>A Type System for Extracting Functional Specifications from Memory-Safe Imperative Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:20</end_time>
      <description>Verifying imperative programs is hard. A key difficulty is that the specification of what an imperative program does is often intertwined with details about pointers and imperative state. Although there are a number of powerful separation logics that allow the details of imperative state to be captured and managed, these details are complicated and reasoning about them requires significant time and expertise. In this paper, we take a different approach: a memory-safe type system that, as part of type-checking, extracts functional specifications from imperative programs. This disentangles imperative state, which is handled by the type system, from functional specifications, which can be verified without reference to pointers. A key difficulty is that sometimes memory safety depends crucially on the functional specification of a program; e.g., an array index is only memory-safe if the index is in bounds. To handle this case, our specification extraction inserts dynamic checks into the specification. Verification then requires the additional proof that none of these checks fail. However, these checks are in a purely functional language, and so this proof also requires no reasoning about pointers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paul</first_name>
          <last_name>He</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>I am a PhD student at the University of Pennsylvania.</bio>
          <homepage_url>https://paulhe.com/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/paulhe/0d514283-c73f-4e42-aca3-b62e5080b1b8/small.jpg</picture_url>
          <person_id>paulhe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Westbrook</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>edwinwestbrook</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brent</first_name>
          <last_name>Carmer</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>brentcarmer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Chris</first_name>
          <last_name>Phifer</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>chrisphifer</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Valentin</first_name>
          <last_name>Robert</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>valentinrobert2</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Karl</first_name>
          <last_name>Smeltzer</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>karlsmeltzer1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Andrei</first_name>
          <last_name>Stefanescu</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>andreistefanescu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Tomb</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://galois.com/team/aaron-tomb/</homepage_url>
          <person_id>aarontomb</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Adam</first_name>
          <last_name>Wick</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>adamwick</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Yacavone</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <person_id>matthewyacavone</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Steve</first_name>
          <last_name>Zdancewic</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~stevez</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/stevezdancewic/41b883c6-4689-4ae3-b6f1-6b7a24622e99/small.jpg</picture_url>
          <person_id>stevezdancewic</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>9ad29c43-19ad-4ff5-92c3-3bcf4fbd2451</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b25b2443-1253-4342-b457-5709328b81b8</slot_id>
      <event_id>7776cd20-1ef0-46d3-ba4d-606e81ee96fe</event_id>
      <submission_id>191</submission_id>
      <title>Scalability and Precision by Combining Expressive Type Systems and Deductive Verification</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:05</end_time>
      <description>Type systems and modern type checkers can be used very successfully to obtain formal correctness guarantees with little specification overhead. However, type systems in practical scenarios have to trade precision for decidability and scalability. Tools for deductive verification, on the other hand, can prove general properties in more cases than a typical type checker can, but they do not scale well. We present a method to complement the scalability of expressive type systems with the precision of deductive program verification approaches. Our novel approach is introduced both conceptually by a proven formalization and practically by a concrete implementation for the Java programming language. The usefulness and power of our approach has been evaluated by discharging known false positives from a real-world program and by a small case study.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Lanzinger</last_name>
          <affiliation>Karlsruhe Institute of Technology (KIT)</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://formal.iti.kit.edu/~lanzinger/</homepage_url>
          <person_id>florianlanzinger</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Weigl</last_name>
          <affiliation>Karlsruhe Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>alexanderweigl</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mattias</first_name>
          <last_name>Ulbrich</last_name>
          <affiliation>Karlsruhe Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://formal.iti.kit.edu/~ulbrich/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mattiasulbrich/93c421cd-7529-43d3-8968-366d6ba1753d/small.jpg</picture_url>
          <person_id>mattiasulbrich</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Werner</first_name>
          <last_name>Dietl</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://ece.uwaterloo.ca/~wdietl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/wernerdietl/f6ddc3ef-7134-4260-a182-a71ed88842cb/small.jpg</picture_url>
          <person_id>wernerdietl</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>dafcb1c4-986e-441c-959c-cde2c4c6a280</slot_id>
      <event_id>1d37dffb-2929-4565-b632-7873f6a12ea7</event_id>
      <submission_id>130</submission_id>
      <title>Transitioning from Structural to Nominal Code with Efficient Gradual Typing</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/22</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:35</end_time>
      <description>Gradual typing is a principled means for mixing typed and untyped code. But typed and untyped code often exhibit different programming patterns. Significant research has investigated gradually giving types to code exhibiting typical untyped patterns, while some research has investigated gradually removing types from code exhibiting typical typed patterns. This paper investigates how to extend established gradual-typing concepts so that one can give formal guarantees not only about how types can change as code evolves but also about how such patterns can change as well. 
In particular, we explore mixing untyped structural code with typed nominal code in an object-oriented language. But whereas previous work only allowed nominal values to be treated as structural values, we also allow structural values to dynamically acquire certain nominal types, namely interfaces. We demonstrate that this choice to support structures as nominal interfaces, but not nominal classes, can still be implemented efficiently despite the fact that not all values have concrete types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabian</first_name>
          <last_name>Muehlboeck</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ist.ac.at/~fmuehlbo</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fabianmuehlboeck/4fb2ec06-e164-4813-bb8b-499adc17c869/small.jpg</picture_url>
          <person_id>fabianmuehlboeck</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ross</first_name>
          <last_name>Tate</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~ross/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rosstate/cbcbd066-943d-46a2-a301-1f4084076400/small.jpg</picture_url>
          <person_id>rosstate</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a2854896-06d6-4f97-84e7-10c78fff6496</subevent_id>
    <title>SPLASH OOPSLA: Functional Programming - Mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>8e0d34df-b3fd-4312-999a-ed7e301bf584</slot_id>
      <title>Session: SPLASH OOPSLA - Functional Programming - Mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
          <person_id>atsushiigarashi</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>1b9393da-cc9d-4307-98e8-03dd6215eb94</slot_id>
      <event_id>c37258b4-1df6-476e-b6e1-b5168f6b0ece</event_id>
      <submission_id>32</submission_id>
      <title>Synbit: Synthesizing Bidirectional Programs using Unidirectional Sketches</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>19:05</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:20</end_time>
      <description>We propose a technique for synthesizing bidirectional programs from the corresponding unidirectional code plus a few input/output examples. The core ideas are: (1) \emph{constructing a sketch} using the given unidirectional program as a specification, and (2) \emph{filling the sketch} in a modular fashion by exploiting the properties of bidirectional programs. These ideas are enabled by our choice of programming language, HOBiT, which is specifically designed to maintain the unidirectional program structure in bidirectional programming, and keep the parts that control bidirectional behavior modular. To evaluate our approach, we implemented it in a tool called Synbit and used it to generate bidirectional programs for intricate microbenchmarks, as well as for a few larger, more realistic problems. We also compared Synbit to a state-of-the-art unidirectional synthesis tool on the task of synthesizing backward computations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Masaomi</first_name>
          <last_name>Yamaguchi</last_name>
          <affiliation>Graduate School of Information Sciences, Tohoku University</affiliation>
          <bio>undefined</bio>
          <person_id>masaomiyamaguchi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kazutaka</first_name>
          <last_name>Matsuda</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.sf.ecei.tohoku.ac.jp/~kztk/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kazutakamatsuda/2262653d-0d0f-4641-8ac2-7b653c0e3683/small.jpg</picture_url>
          <person_id>kazutakamatsuda</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cristina</first_name>
          <last_name>David</last_name>
          <affiliation>University of Bristol</affiliation>
          <bio>undefined</bio>
          <person_id>cristinadavid</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Meng</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Bristol, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mengwangoxf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/mengwang/2aba9176-828a-4227-9392-75f364770330/small.jpg</picture_url>
          <person_id>mengwang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>852ee1fb-6de7-4ac3-a96a-e4c69a691d74</slot_id>
      <event_id>7e72ede0-84a8-45df-97b4-f2b728e7a48d</event_id>
      <submission_id>75</submission_id>
      <title>Compiling with Continuations, Correctly</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:05</end_time>
      <description>In this paper we present a novel simulation relation for proving correctness of program transformations that combines syntactic simulations and logical relations. In particular, we establish a new kind of simulation diagram that uses a small-step or big-step semantics in the source language and an untyped, step-indexed logical relation in the target language. Our technique provides a practical solution for proving semantics preservation for transformations that do not preserve reductions in the source language. This is common when transformations generate new binder names, and hence $\alpha$-conversion must be explicitly accounted for, or when transformations introduce administrative redexes. Our technique does not require reductions in the source language to correspond directly to reductions in the target language. Instead, we enforce a weaker notion of semantic preorder, which suffices to show that semantics are preserved for both whole-program and separate compilation. Because our logical relation is transitive, we can transition between intermediate program states in a small-step fashion and hence the shape of the proof resembles that of a simple small-step simulation. 
We use this technique to revisit the semantic correctness of a continuation-passing style (CPS) transformation and we demonstrate how it allows us to overcome well-known complications of this proof related to $\alpha$-conversion and administrative reductions. In addition, by using a logical relation that is indexed by invariants that relate the resource consumption of two programs, we are able show that the transformation preserves diverging behaviors and that our CPS transformation asymptotically preserves the running time of the source program. 
Our results are formalized in the Coq proof assistant. Our continuation-passing style transformation is part of the CertiCoq compiler for Gallina, the specification language of Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zoe</first_name>
          <last_name>Paraskevopoulou</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zoep.github.io/</homepage_url>
          <person_id>zoeparaskevopoulou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anvay</first_name>
          <last_name>Grover</last_name>
          <affiliation>University of Wisconsin–Madison</affiliation>
          <bio>undefined</bio>
          <person_id>anvaygrover</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>9935e976-d33e-4b76-a94c-45fa4fe9e891</slot_id>
      <event_id>fc877a4c-cd99-491d-bb86-11c7282681b5</event_id>
      <submission_id>24</submission_id>
      <title>Efficient Compilation of Algebraic Effect Handlers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>19:35</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:50</end_time>
      <description>The popularity of algebraic effect handlers as a programming language feature for user-defined computational effects is steadily growing. Yet, even though efficient runtime representations have already been studied, most handler-based programs are still much slower than hand-written code. This paper shows that the performance gap can be drastically narrowed (in some cases even closed) by means of type-and-effect directed optimising compilation. Our approach consists of source-to-source transformations in two phases of the compilation pipeline. Firstly, elementary rewrites, aided by judicious function specialisation, exploit the explicit type and effect information of the compiler’s core language to agressively reduce handler applications. Secondly, after erasing the effect information further rewrites in the backend of the compiler emit tight code. This work comes with a practical implementation: an optimizing compiler from Eff, an ML style language with algebraic effect handlers, to OCaml. Experimental evaluation with this implementation demonstrates that in a number of benchmarks, our approach eliminates much of the overhead of handlers, outperforms capability-passing style compilation and yields competitive performance compared to hand-written OCaml code as well Multicore OCaml’s dedicated runtime support.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Georgios</first_name>
          <last_name>Karachalias</last_name>
          <affiliation>Tweag</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gkaracha.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/georgekarachalias/cb10a8f5-6b72-4883-aef0-c9978070378a/small.jpg</picture_url>
          <person_id>georgekarachalias</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Filip</first_name>
          <last_name>Koprivec</last_name>
          <affiliation>University of Ljubljana</affiliation>
          <bio>undefined</bio>
          <person_id>filipkoprivec1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matija</first_name>
          <last_name>Pretnar</last_name>
          <affiliation>University of Ljubljana</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://matija.pretnar.info/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/matijapretnar/87fb17f8-8e61-4088-8c8f-88c5c9174485/small.jpg</picture_url>
          <person_id>matijapretnar</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
          <person_id>tomschrijvers</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>e25e936e-96a6-4c05-bbce-1f9b468664e4</slot_id>
      <event_id>f0e509f9-0fba-48ca-8b45-d1c318f1c895</event_id>
      <submission_id>181</submission_id>
      <title>Reachability Types: Tracking Aliasing and Separation in Higher-Order Functional Programs</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>19:20</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>19:35</end_time>
      <description>Ownership type systems, based on the idea of enforcing unique access paths, have been primarily focused on objects and top-level classes. However, existing models do not as readily reflect the finer aspects of nested lexical scopes, capturing, or escaping closures in higher-order functional programming patterns, which are increasingly adopted even in mainstream OO languages. We present a new type system, $\lambda^{\ast}$, which enables expressive ownership-style reasoning across higher-order functions. It tracks sharing and separation through reachability sets, and layers additional mechanisms for selectively enforcing uniqueness on top of it. Based on reachability sets, we extend the type system with an expressive flow-sensitive effect system, which enables flavors of move semantics and ownership transfer. In addition, we present several case studies and extensions, including applications to capabilities for algebraic effects, one-shot continuations, and safe parallelization.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuyan</first_name>
          <last_name>Bao</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://yuyanbao.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yuyanbao/29054831-172d-4005-9e61-a5f62bd70c76/small.jpg</picture_url>
          <person_id>yuyanbao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guannan</first_name>
          <last_name>Wei</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://continuation.passing.style</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guannanwei/e1971b4b-ebd3-429b-b28c-0c2cfb0f0289/small.jpg</picture_url>
          <person_id>guannanwei</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Bračevac</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://bracevac.org</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/oliverbracevac/17c0ac71-a156-4868-8df9-d4ae4cd669e7/small.jpg</picture_url>
          <person_id>oliverbracevac</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yuxuan</first_name>
          <last_name>Jiang</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>yuxuanjiang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Qiyang</first_name>
          <last_name>He</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <person_id>qiyanghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
          <person_id>tiarkrompf</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>e39dafac-31e1-4327-a29d-9430e76ff6fb</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>19:50</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a1dc5cbc-2fd9-446b-8687-b52c4f2f7107</subevent_id>
    <title>SPLASH OOPSLA: Shared Memory - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich A</room>
    <date>2021/10/20</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>e720dc2a-c28f-409b-b845-195b7acbd998</slot_id>
      <title>Session: SPLASH OOPSLA - Shared Memory - mirror</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>07:40</start_time>
      <end_time>09:00</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Burckhardt</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Sebastian Burckhardt was born and raised in Basel, Switzerland, where he studied Mathematics at the local University. During an exchange year at Brandeis University, he discovered his affinity to Computer Science and immigrated to the United States. After a few years of industry experience at IBM, he returned to academia and earned his PhD in Computer Science at the University of Pennsylvania. Since then, he has worked as a researcher at Microsoft Research in Redmond. His general research interest is the study of programming models for of concurrent, parallel, and distributed systems. More specific interests include consistency models, concurrency testing, self-adjusting computation, and the concurrent revisions programming model.</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/sburckha/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sebastianburckhardt/726ac702-681a-40f8-94d6-c0465e108867/small.jpg</picture_url>
          <person_id>sebastianburckhardt</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>11272339-eca4-4e1f-acb1-e86adece70f6</slot_id>
      <event_id>ebe80fc8-3b07-494a-a4ca-22e80b3c5b6e</event_id>
      <submission_id>14</submission_id>
      <title>SecRSL: Security Separation Logic for C11 Release-Acquire Concurrency</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>07:55</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:10</end_time>
      <description>We present Security Relaxed Separation Logic (SecRSL), a separation logic for proving information-flow security of C11 programs in the Release-Acquire fragment with relaxed accesses. SecRSL is the first security logic that (1)~supports weak-memory reasoning about programs in a high-level language; (2)~inherits separation logic’s virtues of compositional, local reasoning about (3)~expressive security policies like value-dependent classification. 
SecRSL is also, to our knowledge, the first security logic developed over an axiomatic memory model. Thus we also present the first definitions of information-flow security for an axiomatic weak memory model, against which we prove SecRSL sound. SecRSL ensures that programs satisfy a constant-time security guarantee, while being free of undefined behaviour. 
We apply SecRSL to implement and verify the functional correctness and constant-time security of a range of concurrency primitives, including a spinlock module, a mixed-sensitivity mutex, and multiple synchronous channel implementations. Empirical performance evaluations of the latter demonstrate SecRSL’s power to support the development of secure and performant concurrent C programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pengbo</first_name>
          <last_name>Yan</last_name>
          <affiliation>University of Melbourne</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/pengboyan1/e18d6038-3acb-4c3d-8c02-3c0448477791/small.jpg</picture_url>
          <person_id>pengboyan1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Toby</first_name>
          <last_name>Murray</last_name>
          <affiliation>University of Melbourne, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.eng.unimelb.edu.au/tobym</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tobymurray/b22e1351-c7fc-420a-acef-492aadfce115/small.jpg</picture_url>
          <person_id>tobymurray</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>3e103d6c-b3e1-4d80-a0e4-71fef8024a60</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>08:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>09:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>d2c19f6b-4891-44d8-a0a3-8b5f79364c97</slot_id>
      <event_id>6aa106ca-9202-4ee8-904b-b032fcb07a70</event_id>
      <submission_id>99</submission_id>
      <title>The Semantics of Shared Memory in Intel CPU/FPGA Systems</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>08:25</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:40</end_time>
      <description>Heterogeneous CPU/FPGA devices, in which a CPU and an FPGA can execute together while sharing memory, are becoming popular in several computing sectors. In this paper, we study the shared-memory semantics of these devices, with a view to providing a firm foundation for reasoning about the programs that run on them. We focus on Intel platforms that combine an Intel FPGA with a multicore Xeon CPU. We describe the weak-memory behaviours that are allowed (and observable) on these devices when CPU threads and an FPGA thread access common memory locations in a fine-grained manner through multiple channels. Some of these behaviours are familiar from well-studied CPU and GPU concurrency; others are weaker still. We encode these behaviours in two formal memory models: one operational, one axiomatic. We develop executable implementations of both models, using the CBMC bounded model-checking tool for our operational model and the Alloy modelling language for our axiomatic model. Using these, we cross-check our models against each other via a translator that converts Alloy-generated executions into queries for the CBMC model. We also validate our models against actual hardware by translating 477 Alloy-generated executions into litmus tests that we run on CPU/FPGA devices; when doing this, we avoid the prohibitive cost of synthesising a hardware design per litmus test by creating our own ‘litmus-test processor’ in hardware. We expect that our models, one of which has been deemed ‘definitive’ by a Senior Principal Engineer at Intel, will be useful for low-level programmers, compiler writers, and designers of analysis tools. Indeed, as a demonstration of the utility of our work, we use our operational model to reason about a producer/consumer buffer implemented across the CPU and the FPGA. When the buffer uses insufficient synchronisation – a situation that our model is able to detect – we observe that its performance improves at the cost of occasional data corruption.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dan</first_name>
          <last_name>Iorga</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~di13/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/daniorga/dac1a236-b8e7-462e-a2c3-2713314bf843/small.jpg</picture_url>
          <person_id>daniorga</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alastair F.</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I’m a PhD student at Imperial College London supervised by Alastair Donaldson. I study testing and modeling of many-core systems, with an emphasis on fine-grained communication idioms.</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~trs15/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tylersorensen/a5910621-6b59-4729-be27-e5dfae22a495/small.jpg</picture_url>
          <person_id>tylersorensen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>dbbc9422-0634-48bd-bec7-2282cd918f63</slot_id>
      <event_id>14c40490-ef1d-49cd-9483-5f093e37fb06</event_id>
      <submission_id>490</submission_id>
      <title>The Reads-From Equivalence for the TSO and PSO Memory Models</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>08:10</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>08:25</end_time>
      <description>The verification of concurrent programs remains an open challenge due to the non-determinism in inter-process communication. One recurring algorithmic problem in this challenge is the consistency verification of concurrent executions. In particular, consistency verification under a reads-from map allows to compute the \emph{reads-from (RF) equivalence} between concurrent traces, with direct applications to areas such as Stateless Model Checking (SMC). Importantly, the RF equivalence was recently shown to be coarser than the standard Mazurkiewicz equivalence, leading to impressive scalability improvements for SMC under SC (sequential consistency). However, for the \emph{relaxed memory} models of TSO and PSO (total/partial store order), the algorithmic problem of deciding the RF equivalence, as well as its impact on SMC, has been elusive. 
In this work we solve the algorithmic problem of consistency verification for the TSO and PSO memory models given a reads-from map, denoted $\operatorname{VTSO-rf}$ and $\operatorname{VPSO-rf}$, respectively. For an execution of $n$ events over $k$ threads and $d$ variables, we establish novel bounds that scale as $n^{k+1}$ for TSO and as $n^{k+1}\cdot \min(n^{k^2}, 2^{k\cdot d})$ for PSO. Moreover, based on our solution to these problems, we develop an SMC algorithm under TSO and PSO that uses the RF equivalence. The algorithm is \emph{exploration-optimal}, in the sense that it is guaranteed to explore each class of the RF partitioning exactly once, and spends polynomial time per class when $k$ is bounded. Finally, we implement all our algorithms in the SMC tool Nidhugg, and perform a large number of experiments over benchmarks from existing literature. Our experimental results show that our algorithms for $\operatorname{VTSO-rf}$ and $\operatorname{VPSO-rf}$ provide significant scalability improvements over standard alternatives. Moreover, when used for SMC, the RF partitioning is often much coarser than the standard Shasha-Snir partitioning for TSO/PSO, which yields a significant speedup in the model checking task.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Truc Lam</first_name>
          <last_name>Bui</last_name>
          <affiliation>Comenius University Bratislava</affiliation>
          <bio>undefined</bio>
          <person_id>truclambui</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Krishnendu</first_name>
          <last_name>Chatterjee</last_name>
          <affiliation>IST Austria, Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pub.ist.ac.at/~kchatterjee/</homepage_url>
          <person_id>krishnenduchatterjee</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tushar</first_name>
          <last_name>Gautam</last_name>
          <affiliation>IIT Bombay</affiliation>
          <bio>undefined</bio>
          <person_id>tushargautam</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Pavlogiannis</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.au.dk/~pavlogiannis/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/andreaspavlogiannis1/e756b107-52cb-4474-b2a4-c5d3174d8d5c/small.jpg</picture_url>
          <person_id>andreaspavlogiannis1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Toman</last_name>
          <affiliation>IST Austria (Institute of Science and Technology Austria)</affiliation>
          <bio>undefined</bio>
          <person_id>viktortoman</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>f0a05798-8d9b-41df-ac1c-dd9b1c047df6</slot_id>
      <event_id>ad86ee65-6cc2-442d-97e9-4761304ac507</event_id>
      <submission_id>9</submission_id>
      <title>Making Weak Memory Models Fair</title>
      <room>Swissotel Chicago | Zurich A</room>
      <date>2021/10/20</date>
      <start_time>07:40</start_time>
      <end_date>2021/10/20</end_date>
      <end_time>07:55</end_time>
      <description>Liveness properties, such as termination, of even the simplest shared-memory concurrent programs under sequential consistency typically require some fairness assumptions about the scheduler. Under weak memory models we observe that the standard notions of thread fairness are insufficient, and, an additional fairness property, which we call memory fairness, is needed. 
In this paper, we propose a uniform definition for memory fairness that can be integrated in any declarative memory model enforcing porf-acyclicity. For models, such as SC, TSO, RA, and StrongCOH, with equivalent operational and declarative presentations, we show that our declarative memory fairness condition is equivalent to an intuitive model-specific operational notion of memory fairness, which requires the memory system to fairly execute its internal propagation steps. Our fairness condition preserves the correctness of local transformations and the compilation scheme from RC11 to x86-TSO, and also enables the first formal proofs of termination of mutual exclusion lock implementations under declarative weak memory models.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
          <person_id>orilahav</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Egor</first_name>
          <last_name>Namakonov</last_name>
          <affiliation>JetBrains Research, St Petersburg University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/egornamakonov/441c64d6-cf63-4751-9ba9-a8ae7d54216c/small.jpg</picture_url>
          <person_id>egornamakonov</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonas</first_name>
          <last_name>Oberhauser</last_name>
          <affiliation>Huawei Dresden Research Center, Huawei OS Kernel Lab</affiliation>
          <bio>undefined</bio>
          <person_id>jonasoberhauser</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anton</first_name>
          <last_name>Podkopaev</last_name>
          <affiliation>HSE University, JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://podkopaev.net</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/antonpodkopaev/b00dceb2-5b55-4c0b-afe0-17581b19dfee/small.jpg</picture_url>
          <person_id>antonpodkopaev</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>Viktor Vafeiadis is a tenured researcher at the Max Planck Institute for Software Systems (MPI-SWS), working on weak memory consistency and persistency. He has made numerous contributions on the semantics of weak memory consistency as well as on verification of concurrent programs with program logics and/or model checking, having published over 60 articles at top-tier venues. He got his PhD from the University of Cambridge in 2008 on concurrent program logics, for which he received the ACM SIGPLAN distinguished dissertation award. After postdoc positions at Microsoft Research and at the University of Cambridge, he joined the MPI-SWS in 2010 and got tenure in 2016.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
          <person_id>viktorvafeiadis</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a23929a7-e348-4414-841c-06716b1f3a1d</subevent_id>
    <title>SPLASH OOPSLA: Program Synthesis - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>4b1b228a-e73a-44d1-be09-d3d0b8750ca0</slot_id>
      <title>Session: SPLASH OOPSLA - Program Synthesis - mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>55ed420c-2bf4-45bd-b7c0-8566455b3cec</slot_id>
      <event_id>43ca20c2-56eb-45a4-ba22-83f5f26257c4</event_id>
      <submission_id>542</submission_id>
      <title>Generalizable Synthesis Through Unification</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:05</end_time>
      <description>The generalizability of PBE solvers is the key to the empirical synthesis performance. Despite the importance of generalizability, related studies on PBE solvers are still limited. In theory, few existing solvers provide theoretical guarantees on generalizability, and in practice, there is a lack of PBE solvers with satisfactory generalizability on important domains such as conditional linear integer arithmetic (CLIA). In this paper, we adopt a concept from the computational learning theory, Occam learning, and perform a comprehensive study on the framework of synthesis through unification (STUN), a state-of-the-art framework for synthesizing programs with nested if-then-else operators. We prove that Eusolver, a state-of-the-art STUN solver, does not satisfy the condition of Occam learning, and then we design a novel STUN solver, PolyGen, of which the generalizability is theoretically guaranteed by Occam learning. We evaluate PolyGen on the domains of CLIA and demonstrate that PolyGen significantly outperforms two state-of-the-art PBE solvers on CLIA, Eusolver and Euphony, on both generalizability and efficiency.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruyi</first_name>
          <last_name>Ji</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>ruyiji</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jingtao</first_name>
          <last_name>Xia</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <person_id>jingtaoxia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yingfei</first_name>
          <last_name>Xiong</last_name>
          <affiliation>Peking University</affiliation>
          <bio>Associate Professor</bio>
          <homepage_url>http://sei.pku.edu.cn/~xiongyf04/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yingfeixiong/18fb7368-4f14-462a-b038-9990eebb7a9c/small.jpg</picture_url>
          <person_id>yingfeixiong</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zhenjiang</first_name>
          <last_name>Hu</last_name>
          <affiliation>Peking University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sei.pku.edu.cn/~hu/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/zhenjianghu/5d426480-5589-46be-b4f6-f98cf2acc80e/small.jpg</picture_url>
          <person_id>zhenjianghu</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>67cf58e2-d6e5-49d2-b403-1ff51bf1704a</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a479a497-b908-4a11-a3c2-17c8e0554d36</slot_id>
      <event_id>d4737a93-8cd6-4e8c-833c-7ed194f21b7a</event_id>
      <submission_id>294</submission_id>
      <title>LooPy: Interactive Program Synthesis with Control Structures</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>22:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:50</end_time>
      <description>One vision for program synthesis, and specifically for Programming by Example (PBE), is an interactive programmer’s assistant, integrated into the development environment. To make program synthesis practical for interactive use, prior work on Small-Step Live PBE has proposed to limit the scope of synthesis to small code snippets, and enable the users to provide local specifications for those snippets. This paradigm, however, does not work well in the presence of loops. We present LooPy, a synthesizer integrated into a Live Programming environment, which extends Small-Step Live PBE to work inside loops and scales it up to synthesize larger code snippets, while remaining fast enough for interactive use. To allow users to effectively provide examples at various loop iterations, even when the loop body is incomplete, LooPy makes use of live execution, a technique that leverages the programmer as an oracle to step over incomplete parts of the loop. To enable synthesis of loop bodies at interactive speeds, LooPy introduces Intermediate State Graph, a new data structure, which compactly represents a large space of code snippets composed of multiple assignment statements and conditionals. We evaluate LooPy empirically using benchmarks from competitive programming and previous synthesizers, and show that it can solve a wide variety of synthesis tasks at interactive speeds. We also performed a small qualitative user study which shows that LooPy’s block-level specifications are easy for programmers to provide.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kasra</first_name>
          <last_name>Ferdowsifard</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>I’m a PhD student in the Programming Languages and Systems group at UC San Diego, co-advised by Nadia Polikarpova and Sorin Lerner. I completed my Bachelor’s in Electrical Engineering and Computer Science a UC Berkeley in 2019. 
My research interests are at the intersection of Programming Languages and Human-Computer Interactions, with a focus on Program Synthesis, and using PL and Synthesis techniques to build useful and usable tools.</bio>
          <homepage_url>https://weirdmachine.me/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/kasraferdowsifard/6568a44f-7c63-4840-88a0-1ec3c49463e0/small.jpg</picture_url>
          <person_id>kasraferdowsifard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shraddha</first_name>
          <last_name>Barke</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/shraddhabarke1/4e11ed13-0f46-4d77-8a6d-dd4c07b7fd4b/small.jpg</picture_url>
          <person_id>shraddhabarke1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.technion.ac.il/~hilap</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/hilapeleg/8b96ae5e-cd0b-4964-be13-07a17dbbd043/small.jpg</picture_url>
          <person_id>hilapeleg</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sorin</first_name>
          <last_name>Lerner</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cseweb.ucsd.edu/users/lerner/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sorinlerner/3d3b1a70-e2f8-4d3a-a1bc-9c4e17dad80b/small.jpg</picture_url>
          <person_id>sorinlerner</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California at San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor of Computer Science and Engineering at the University of California, San Diego. She received her PhD from ETH Zurich (Switzerland), and spent a couple of years as a postdoc at MIT CSAIL. She is a 2020 Sloan Fellow and a recipient of 2020 Intel Rising Stars Award and the 2020 NSF Career Award. Her research interests are in program synthesis, program verification, and type systems.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
          <person_id>nadiapolikarpova</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>bfc296e9-1636-49ac-b6d9-5c805e70cf6e</slot_id>
      <event_id>24dd1202-bb64-4cef-86c5-251fda3fcd93</event_id>
      <submission_id>448</submission_id>
      <title>APIfix: Output-Oriented Program Synthesis for Combating Breaking Changes in Libraries</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>22:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:35</end_time>
      <description>Use of third-party libraries is extremely common in application software. The libraries evolve to accommodate new features or mitigate security vulnerabilities, thereby breaking the Application Programming Interface (API) used by the software. Such breaking changes in the libraries may discourage client code from using the new library versions thereby keeping the application vulnerable and not up-to-date. We propose a novel output-oriented program synthesis algorithm to automate API usage adaptations via program transformation. Our aim is not only to rely on the few example human adaptations of the clients from the old library to the new library, since this can lead to over-fitting transformation rules. Instead, we also rely on example usages of the new updated library in clients, which provide valuable context for synthesizing and applying the transformation rules. Our tool APIFix provides an automated mechanism to transform application code using the old library versions to code using the new library versions - thereby achieving automated API usage adaptation to fix the effect of breaking changes. Our evaluation shows that the transformation rules inferred by APIFix achieve 98.7% precision and 91.5% recall. By comparing our approach to state-of-the-art program synthesis approaches, we show that our approach significantly reduces over-fitting while synthesizing transformation rules for API usage adaptations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiang</first_name>
          <last_name>Gao</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.comp.nus.edu.sg/~gaoxiang/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xianggao/482ff4c5-f003-40e7-90cc-d888adbd1e2f/small.jpg</picture_url>
          <person_id>xianggao</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arjun</first_name>
          <last_name>Radhakrishna</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://arjunradhakrishna.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/arjunradhakrishna/5187c933-18de-4045-9119-d97023dd12b7/small.jpg</picture_url>
          <person_id>arjunradhakrishna</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Soares</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/gsoares/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gustavosoares/fc1e5a17-f939-4c3d-ab30-85467cb2610b/small.jpg</picture_url>
          <person_id>gustavosoares</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ridwan Salihin</first_name>
          <last_name>Shariffdeen</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>I am a fourth-year PhD student in Department of Computer Science at School of Computing, National University of Singapore, where I am advised by Abhik Roychoudhury. The current focus of my research is on automated program repair, software security and software engineering automation.</bio>
          <homepage_url>https://rshariffdeen.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/ridwansalihinshariffdeen/4ac6e84f-a4cb-4547-b8d7-026e9e142f00/small.jpg</picture_url>
          <person_id>ridwansalihinshariffdeen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sumit</first_name>
          <last_name>Gulwani</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>Sumit Gulwani is a computer scientist seeking connections: between ideas, between research &amp;amp; practice, and with people with varied roles. He is the inventor of many intent-understanding technologies including the popular Flash Fill feature in Excel. He founded the PROSE research and engineering team at Microsoft that develops APIs for program synthesis and has incorporated them into various products including Office, Visual Studio, SQL, PowerQuery, and Powershell. He has co-authored 10 award winning papers and a total of 125+ peer-reviewed papers across multiple computer science areas, delivered 50+ keynotes and invited talks at various forums, and authored 65+ patent applications. He is a recipient of the ACM SIGPLAN Robin Milner Young Researcher Award (for pioneering contributions to program synthesis and intelligent tutoring systems), ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the President’s Gold Medal from IIT Kanpur.</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/sumitg/index.html</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/sumitgulwani/f3a9ffb3-b99e-49b0-a286-ee171937c45e/small.jpg</picture_url>
          <person_id>sumitgulwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Abhik</first_name>
          <last_name>Roychoudhury</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>Abhik Roychoudhury is a Professor of Computer Science at National University of Singapore. His research focuses on software testing and analysis, software security and trust-worthy software construction. His research group has built scalable techniques for testing, debugging and repair of programs using systematic semantic analysis. The capability to automatically repair programs at a large scale contributes to the vision of self-healing software. He is currently directing the National Satellite of Excellence in Trustworthy Software Systems in Singapore. He is also the Lead Principal Investigator of the Singapore Cyber-security Consortium, which is a consortium of 25 companies in the cyber-security space engaging with academia for research and collaboration.</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~abhik</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/abhikroychoudhury/7017e73b-76d1-4dd4-a4b4-def2881fc2c9/small.jpg</picture_url>
          <person_id>abhikroychoudhury</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>e74679b8-faae-4fa8-b819-021a4772058d</slot_id>
      <event_id>25bb8503-88a2-4ba4-b253-0fc9a52e05dc</event_id>
      <submission_id>157</submission_id>
      <title>Gauss: Program Synthesis by Reasoning Over Graphs</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/21</date>
      <start_time>22:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:20</end_time>
      <description>While input-output examples are a natural form of specification for program synthesis engines, they can be imprecise. In this paper, we investigate how extracting readily-available information about the user intent \emph{behind} these input-output examples helps speed up synthesis and reduce overfitting. We present Gauss, a synthesis algorithm that accepts partial input-output examples, along with \emph{user intent graphs}. Gauss includes a novel conflict-resolution reasoning algorithm over graphs that enables it to learn from mistakes made during the search and use that knowledge to explore the space of programs even faster. It also ensures the final program is consistent with the user intent specification, reducing overfitting. We implement Gauss for the domain of table transformations (supporting Pandas and R), and compare it to two state-of-the-art synthesizers accepting only input-output examples. We find that it is able to reduce the search space by 56$\times$, 73$\times$ and 664$\times$ on average, resulting in 7$\times$, 26$\times$ and 7$\times$ speedups in synthesis times on average, respectively.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rohan</first_name>
          <last_name>Bavishi</last_name>
          <affiliation>UC Berkeley</affiliation>
          <bio>I am a 3rd Year PhD student advised by Prof. Koushik Sen.</bio>
          <homepage_url>https://rbavishi.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/rohanbavishi/9512af7a-f463-4f18-9edd-f4634cd69487/small.jpg</picture_url>
          <person_id>rohanbavishi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Caroline</first_name>
          <last_name>Lemieux</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Caroline Lemieux is a postdoctoral researcher at Microsoft Research, and will be starting as an Assistant Professor at UBC in Fall 2022. Her research interests center around improving the correctness and reliability of software systems by developing automated methods for engineering tasks such as testing, debugging, and comprehension. Her work on fuzz testing has been awarded an ACM SIGSOFT Distinguished Paper Award, Distinguished Artifact Award, Tool Demonstration Award, and Best Paper Award (Industry Track). She completed her PhD at UC Berkeley, advised by Koushik Sen; there, she was the recipient of a Berkeley Fellowship for Graduate Study, and a Google PhD Fellowship in Programming Technologies and Software Engineering. She received her B.Sc. in Computer Science and Mathematics at the University of British Columbia, where she won the Governor General’s Silver Medal in Science, awarded to the undergraduate student with highest standing in the Faculty of Science.</bio>
          <homepage_url>https://www.carolemieux.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/carolinelemieux/e43ab970-fd4b-43bd-83fe-eada347d47c9/small.jpg</picture_url>
          <person_id>carolinelemieux</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Koushik</first_name>
          <last_name>Sen</last_name>
          <affiliation>University of California, Berkeley</affiliation>
          <bio>Koushik Sen is a professor in the Department of Electrical Engineering and Computer Sciences at the University of California, Berkeley. His research interest lies in Software Engineering, Programming Languages, and Formal methods. He is interested in developing software tools and methodologies that improve programmer productivity and software quality. He holds a B.Tech from Indian Institute of Technology, Kanpur, and M.S. and Ph.D. in CS from University of Illinois at Urbana-Champaign.</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~ksen/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/koushiksen/9f417f8a-40b9-40a7-866c-9c44cd81859a/small.jpg</picture_url>
          <person_id>koushiksen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ion</first_name>
          <last_name>Stoica</last_name>
          <affiliation>UC Berkeley</affiliation>
          <bio>undefined</bio>
          <person_id>ionstoica</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>14e681a9-7ea3-49fa-b190-74aec050364c</subevent_id>
    <title>SPLASH OOPSLA: Implementation of special Paradigms - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich C</room>
    <date>2021/10/21</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>688199a3-e3ee-4326-b3c9-f8e197a9aada</slot_id>
      <title>Session: SPLASH OOPSLA - Implementation of special Paradigms - mirror</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>21:50</start_time>
      <end_time>23:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Steve</first_name>
          <last_name>Blackburn</last_name>
          <affiliation>Australian National University</affiliation>
          <bio>My research interests are centered on the challenge of making software run faster and more power-efficiently on modern hardware. My primary interests include: microarchitectural support for managed languages, fast and efficient garbage collection, and the design and implementation of virtual machines. As a backdrop to this I have a longstanding interest in role of sound methodology and infrastructure in successful research innovation.</bio>
          <homepage_url>http://users.cecs.anu.edu.au/~steveb/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/steveblackburn/1deee732-405d-4403-a974-a418751399c2/small.jpg</picture_url>
          <person_id>steveblackburn</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>02d115cd-f530-4201-a82c-158edd660183</slot_id>
      <event_id>dfc8e21a-b4fb-4095-9b67-790f96f35c7b</event_id>
      <submission_id>142</submission_id>
      <title>Coarsening Optimization for Differentiable Programming</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>21:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:05</end_time>
      <description>This paper presents a novel optimization for differentiable programming named coarsening optimization. It offers a systematic way to synergize symbolic differentiation and algorithmic differentiation (AD). Through it, the granularity of the computations differentiated by each step in AD can become much larger than a single operation, and hence lead to much reduced runtime computations and data allocations in AD. To circumvent the difficulties that control flow creates to symbolic differentiation in coarsening, this work introduces $\phi$-calculus, a novel method to allow symbolic reasoning and differentiation of computations that involve branches and loops. It further avoids “expression swell” in symbolic differentiation and balance reuse and coarsening through the design of reuse-centric segment of interest(SOI) identification. Experiments on a collection of real-world applications show that coarsening optimization is effective in speeding up AD, producing several times to an order of magnitude speedups.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xipeng</first_name>
          <last_name>Shen</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>Xipeng Shen is an associate professor at the Computer Science Department, North Carolina State University (NCSU). He is a receipt of NSF CAREER Award, DOE Early Career Award, and Google Faculty Research Award. He is an ACM Distinguished Speaker, and a senior member of IEEE. Prior to joining NC State in 2014, Shen was the Adina Allen Term Distinguished Associate Professor at The College of William and Mary. He had served as a consultant to Intel Labs and Cisco, and a Visiting Researcher at MIT and Microsoft Research. He received his Ph.D. in Computer Science from University of Rochester in 2006.</bio>
          <homepage_url>http://people.engr.ncsu.edu/xshen5/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/xipengshen/7ba54e69-f90a-4cf7-90d2-19fdd5f42e87/small.jpg</picture_url>
          <person_id>xipengshen</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guoqiang</first_name>
          <last_name>Zhang</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
          <person_id>guoqiangzhang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Irene</first_name>
          <last_name>Dea</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>irenedea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Samantha</first_name>
          <last_name>Andow</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>samanthaandow</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Emilio</first_name>
          <last_name>Arroyo-Fang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>emilioarroyofang</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Neal</first_name>
          <last_name>Gafter</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>nealgafter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Johann</first_name>
          <last_name>George</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/johanngeorge/f99a55e9-45f5-4516-9791-9d211a03e432/small.jpg</picture_url>
          <person_id>johanngeorge</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Melissa</first_name>
          <last_name>Grueter</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>melissagrueter</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Erik</first_name>
          <last_name>Meijer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <person_id>erikmeijer1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Olin</first_name>
          <last_name>Shivers</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <person_id>olinshivers</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Steffi</first_name>
          <last_name>Stumpos</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>steffistumpos</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>12</sort_key>
          <first_name>Alanna</first_name>
          <last_name>Tempest</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>alannatempest</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>13</sort_key>
          <first_name>Christy</first_name>
          <last_name>Warden</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>christywarden</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>14</sort_key>
          <first_name>Shannon</first_name>
          <last_name>Yang</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <person_id>shannonyang</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>3cc08e01-8cdd-4d59-b253-2c5bce3ead3b</slot_id>
      <event_id>2a3bd10f-d88a-4ac7-b023-0ee9946d5e84</event_id>
      <submission_id>133</submission_id>
      <title>Compilation of Sparse Array Programming Models</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>22:35</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:50</end_time>
      <description>This paper shows how to compile sparse array programming languages. A sparse array programming language is an array programming language that supports element-wise application, reduction, and broadcasting of arbitrary functions over dense and sparse arrays with any fill value. Such a language has great expressive power and can express sparse and dense linear and tensor algebra, functions over images, exclusion and inclusion filters, and even graph algorithms. 
Our compiler strategy generalizes prior work in the literature on sparse tensor algebra compilation to support any function applied to sparse arrays, instead of only addition and multiplication. To achieve this, we generalize the notion of sparse iteration spaces beyond intersections and unions. These iteration spaces are automatically derived by considering how algebraic properties annotated onto functions interact with the fill values of the arrays. We then show how to compile these iteration spaces to efficient code. 
When compared with two widely-used Python sparse array packages, our evaluation shows that we generate built-in sparse array library features with a performance of 1.4$\times$ to 53.7$\times$ when measured against PyData/Sparse for user-defined functions and between 0.98$\times$ and 5.53$\times$ when measured against SciPy/Sparse for array slicing. Our technique outperforms PyData/Sparse by 6.58$\times$ to 70.3$\times$, and (where applicable) performs between 0.96$\times$ and 28.9$\times$ that of a dense NumPy implementation, on end-to-end sparse array applications. We also implement graph linear algebra kernels in our system with a performance of between 0.56$\times$ and 3.50$\times$ compared to that of the hand-optimized SuiteSparse:GraphBLAS library.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rawn</first_name>
          <last_name>Henry</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <person_id>rawnhenry</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivia</first_name>
          <last_name>Hsu</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>oliviahsu</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rohan</first_name>
          <last_name>Yadav</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>rohanyadav1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chou</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.csail.mit.edu/s3chou</homepage_url>
          <person_id>stephenchou</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Kunle</first_name>
          <last_name>Olukotun</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arsenalfc.stanford.edu/kunle</homepage_url>
          <person_id>kunleolukotun</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Saman</first_name>
          <last_name>Amarasinghe</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
          <person_id>samanamarsinghe</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>58469ca1-f603-48ce-82bf-8b4ffe5ac6bf</slot_id>
      <event_id>aac8ee13-0cef-4d91-b60c-f029b7f08587</event_id>
      <submission_id>45</submission_id>
      <title>Efficient Automatic Scheduling of Imaging &amp; Vision Pipelines for the GPU</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>22:20</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:35</end_time>
      <description>We present a new algorithm to quickly generate high-performance GPU implementations of complex imaging and vision pipelines, directly from high-level Halide algorithm code. It is fully automatic, requiring no schedule templates or hand-optimized kernels. We address the scalability challenge of extending search-based automatic scheduling to map large real-world programs to the deep hierarchies of memory and parallelism on GPU architectures in reasonable compile time. We achieve this using (1) a two-phase search algorithm that first ‘freezes’ decisions for the lowest cost sections of a program, allowing relatively more time to be spent on the important stages, (2) a hierarchical sampling strategy that groups schedules based on their structural similarity, then samples representatives to be evaluated, allowing us to explore a large space with few samples, and (3) memoization of repeated partial schedules, amortizing their cost over all their occurrences. We guide the process with an efficient cost model combining machine learning, program analysis, and GPU architecture knowledge. We evaluate our method’s performance on a diverse suite of real-world imaging and vision pipelines. Our scalability optimizations lead to average compile time speedups of 49x (up to 530x). We find schedules that are on average 1.7x faster than existing automatic solutions (up to 5x), and competitive with what the best human experts were able to achieve in an active effort to beat our automatic results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luke</first_name>
          <last_name>Anderson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>lukeanderson1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Adams</last_name>
          <affiliation>Adobe</affiliation>
          <bio>undefined</bio>
          <person_id>andrewadams</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Karima</first_name>
          <last_name>Ma</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>karimama1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tzu-Mao</first_name>
          <last_name>Li</last_name>
          <affiliation>UC San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~tzli/</homepage_url>
          <person_id>tzumaoli</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tian</first_name>
          <last_name>Jin</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>tianjin</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Ragan-Kelley</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>Assistant Professor of Computer Science</bio>
          <homepage_url>https://people.csail.mit.edu/jrk</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jonathanragankelley/1b837cf9-1002-4ab3-8bfc-fdf6708db7e1/small.jpg</picture_url>
          <person_id>jonathanragankelley</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>67dad211-ae8c-4596-a540-b236875ad378</slot_id>
      <event_id>a9b6a816-8bad-42e4-8254-5769ef450530</event_id>
      <submission_id>81</submission_id>
      <title>Statically Bounded-Memory Delayed Sampling for Probabilistic Streams</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>22:05</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>22:20</end_time>
      <description>\emph{Probabilistic programming languages} aid developers performing Bayesian inference. These languages provide programming constructs and tools for probabilistic modeling and automating the process of developing a probabilistic inference procedure. Prior work introduced a probabilistic programming language, ProbZelus, to extend probabilistic programming functionality to unbounded streams of data. A key innovation of ProbZelus was to demonstrate that the \emph{delayed sampling} inference algorithm could be extended to work in a streaming context. ProbZelus showed that while delayed sampling could be effectively deployed on some programs, depending on the probabilistic model under consideration, delayed sampling is not guaranteed to use a bounded amount of memory over the course of the execution of the program. 
In this paper, we the present conditions on a probabilistic program’s execution under which delayed sampling will execute in bounded memory. The two conditions are dataflow properties of the core operations of delayed sampling: the \emph{$m$-consumed property} and \emph{the unseparated path property}. A program executes in bounded memory under delayed sampling if, and only if, it satisfies the $m$-consumed and unseparated path properties. We propose a static analysis that abstracts over these properties to soundly ensure that any program that passes the analysis satisfies these properties, and thus executes in bounded memory under delayed sampling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Atkinson</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>ericatkinson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guillaume</first_name>
          <last_name>Baudart</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <person_id>guillaumebaudart1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Louis</first_name>
          <last_name>Mandel</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/person/us-lmandel</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/louismandel/65f833e1-aaa0-4e12-8953-73294e30b407/small.jpg</picture_url>
          <person_id>louismandel</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Charles</first_name>
          <last_name>Yuan</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <person_id>charlesyuan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Carbin</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>Michael Carbin is the Jamieson Career Development Assistant Professor of Electrical Engineering and Computer Science at the Massachusetts Institute of Technology. 
His primary research focus is the design of programming systems that manipulate system uncertainty to deliver improved performance, energy consumption, and resilience. Uncertainty — in the form of sampled and sensed values, dynamic computation structure, and intermittently available computing — is a first-order challenge in modern computing systems. 
His research on verifying the reliability of programs that execute on unreliable hardware has received best paper awards at leading programming languages conferences (OOPSLA 2013 and OOPSLA 2014) as well as a Communications of the ACM Research Highlight in 2016.&amp;nbsp;He has also published work at leading programming languages and systems conferences, including PLDI, OOPSLA, ASPLOS, LICS, SOSP, ICSE, and PPoPP.</bio>
          <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
          <person_id>michaelcarbin</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>a1dfdef2-017e-48de-a170-0c4cab31b51e</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich C</room>
      <date>2021/10/21</date>
      <start_time>22:50</start_time>
      <end_date>2021/10/21</end_date>
      <end_time>23:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>215b386c-5fd8-4a20-bc1f-35e6539e9127</subevent_id>
    <title>SPLASH OOPSLA: Optimization - mirror</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot is_mirror="true">
      <slot_id>09cc35f9-916b-4d5a-a7cf-eeaafc88fe22</slot_id>
      <title>Session: SPLASH OOPSLA - Optimization - mirror</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>18:50</start_time>
      <end_time>20:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Antony</first_name>
          <last_name>Hosking</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/hosking/Antony_Hosking/Home.html</homepage_url>
          <person_id>anthonyhosking</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>4f8f3862-a0f2-4606-b6a9-820ad1446521</slot_id>
      <event_id>e78d6285-c5ed-4a96-8242-9315d1c25ef4</event_id>
      <submission_id>194</submission_id>
      <title>VESPA: Static Profiling for Binary Optimization</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>19:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:20</end_time>
      <description>Over the past few years, there has been a surge in the popularity of binary optimizers such as BOLT, Propeller, Janus and HALO. These tools use dynamic profiling information to make optimization decisions. Although effective, gathering runtime data presents developers with inconveniences such as unrepresentative inputs, the need to accommodate software modifications, and longer build times. In this paper, we revisit the static profiling technique proposed by Calder et al. in the late 90’s, and investigate its application to drive binary optimizations, in the context of the BOLT binary optimizer, as a replacement for dynamic profiling. A few core modifications to Calder et al.’s original proposal, consisting of new program features and a new regression model, are sufficient to enable some of the gains obtained through runtime profiling. An evaluation of BOLT powered by our static profiler on four large benchmarks (clang, GCC, MySQL and PostgreSQL) yields binaries that are 5.50% faster than the executables produced by clang -O3.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Angelica Aparecida</first_name>
          <last_name>Moreira</last_name>
          <affiliation>Universidade Federal de Minas Gerais</affiliation>
          <bio>Angélica Moreira is a late 3rd year PhD candidate in the Computer Science Department at Federal University of Minas Gerais (UFMG). She is a member of the Compilers Laboratory (LAC), where she is advised by Professor Fernando Magno Quintão Pereira. She holds an M.Sc degree in Computer Science from the Federal University of Ouro Preto (UFOP) and a B.Sc degree in Computer Science from the Pontifical Catholic University of Minas Gerais (PUC Minas). 
Angélica’s research interest lies in pursuing the design and implementation of techniques that reduce program binary size and make them run faster on heterogeneous architectures. Her research focuses on combining machine learning and compilation techniques to achieve her goal. Her dream is to contribute to a better world through the development of science and technology.</bio>
          <homepage_url>https://homepages.dcc.ufmg.br/~angelica.moreira/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/angelicaaparecidamoreira/8e228596-dcff-49ff-9b56-e77a499f89d8/small.jpg</picture_url>
          <person_id>angelicaaparecidamoreira</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Guilherme</first_name>
          <last_name>Ottoni</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~ottoni</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/guilhermeottoni/a60389de-a60b-4624-949a-574fd53ea7ab/small.jpg</picture_url>
          <person_id>guilhermeottoni</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>Federal University of Minas Gerais</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an associate professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
          <person_id>fernandomagnoquintaopereira</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>673da911-a6ef-4694-9060-2f33f99a74a5</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>19:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>20:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>c0a553bd-f733-401d-ba14-549846caebe2</slot_id>
      <event_id>a07657bd-7670-4ce9-b59c-c0d4a5733ee1</event_id>
      <submission_id>245</submission_id>
      <title>A Derivative-based Parser Generator for Visibly Pushdown Grammars</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>19:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:35</end_time>
      <description>In this paper, we present a derivative-based, functional recognizer and parser generator for visibly pushdown grammars. The generated parser accepts ambiguous grammars and produces a parse forest containing all valid parse trees for an input string in linear time. Each parse tree in the forest can then be extracted also in linear time. Besides the parser generator, to allow more flexible forms of the visibly pushdown grammars, we also present a translator that converts a tagged CFG to a visibly pushdown grammar in a sound way, and the parse trees of the tagged CFG are further produced by running the semantic actions embedded in the parse trees of the translated visibly pushdown grammar. The performance of the parser is compared with a popular parsing tool ANTLR on parsing JSON and HTML files. The correctness of the core parsing algorithm is formally verified in the proof assistant Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaodong</first_name>
          <last_name>Jia</last_name>
          <affiliation>The Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>xiaodongjia</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ashish</first_name>
          <last_name>Kumar</last_name>
          <affiliation>The Pennsylvania State University</affiliation>
          <bio>undefined</bio>
          <person_id>ashishkumar1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gang</first_name>
          <last_name>Tan</last_name>
          <affiliation>Penn State University</affiliation>
          <bio>Dr. Gang Tan is the James F. Will Career Development Associate Professor in Computer Science and Engineering at Pennsylvania State University, PA. He leads the Security of Software (SOS) Lab. His research is at the interface between computer security, programming languages, and formal methods. He received his bachelor’s degree in Computer Science with honors from Tsinghua University in 1999 and his Ph.D. degree from Princeton University in 2005. He has received an NSF CAREER award, two Google Research Awards, and a Francis Upton Graduate Fellowship.</bio>
          <homepage_url>http://www.cse.psu.edu/~gxt29/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/gangtan/e101adef-54fb-4fcc-bce0-381da3d1aace/small.jpg</picture_url>
          <person_id>gangtan</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot is_mirror="true">
      <slot_id>ed0d0bb3-1d5b-4325-a611-db9415eb772e</slot_id>
      <event_id>b07a5fb5-66c7-4797-a121-2c07df02ff9d</event_id>
      <submission_id>169</submission_id>
      <title>Copy-and-Patch Compilation</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>18:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>19:05</end_time>
      <description>Fast compilation is important when compilation occurs at runtime, such as query compilers in modern database systems and WebAssembly virtual machines in modern browsers. We present copy-and-patch, an extremely fast compilation technique that also produces good quality code. It is capable of lowering both high-level languages and low-level bytecode programs to binary code, by stitching together code from a large library of binary implementation variants. We call these binary implementations stencils because they have holes where missing values must be inserted during code generation. We show how to construct a stencil library and describe the copy-and-patch algorithm that generates optimized binary code. 
We demonstrate two use cases of copy-and-patch: a compiler for a high-level C-like language intended for metaprogramming and a compiler for WebAssembly. Our high-level language compiler has negligible compilation cost: it produces code from an AST in less time than it takes to construct the AST. We have implemented an SQL database query compiler on top of this metaprogramming system and show that on TPC-H database benchmarks, copy-and-patch generates code two orders of magnitude faster than LLVM -O0 and three orders of magnitude faster than higher optimization levels. The generated code runs an order of magnitude faster than interpretation and 15% faster than LLVM -O0. Our WebAssembly compiler generates code 4.9X-6.5X faster than Liftoff, the WebAssembly baseline compiler in Google Chrome. The generated code also outperforms Liftoff’s by 46%-63% on the Coremark and PolyBenchC WebAssembly benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Haoran</first_name>
          <last_name>Xu</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <person_id>haoranxu1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fredrik</first_name>
          <last_name>Kjolstad</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fredrikbk.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/fredrikkjolstad/16c6dd09-6e4a-4def-9785-7383a71441ec/small.jpg</picture_url>
          <person_id>fredrikkjolstad</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>85290b7b-4c12-4b6c-a3a7-e5f54050e9ea</subevent_id>
    <title>SPLASH OOPSLA: Test and Verification</title>
    <subevent_type type="regular"/>
    <room>Swissotel Chicago | Zurich B</room>
    <date>2021/10/22</date>
    <url>https://2021.splashcon.org/track/splash-2021-oopsla</url>
    <url_link_display>OOPSLA</url_link_display>
    <tracks>
      <track>OOPSLA</track>
    </tracks>
    <timeslot>
      <slot_id>74d84ace-0c1f-4647-81e9-4b68b1ceb8ce</slot_id>
      <title>Session: SPLASH OOPSLA - Test and Verification</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_time>15:10</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Mike</first_name>
          <last_name>Dodds</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/mikedodds/30647857-a527-43a0-bf42-16e6c1acc297/small.jpg</picture_url>
          <person_id>mikedodds</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>13a41445-4703-42dd-b190-4c8aee396596</slot_id>
      <event_id>1608901f-c7e7-4e37-b5d4-9d39b4e807b6</event_id>
      <title>Discussion, Questions and Answers</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>14:35</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>15:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e098cd8a-2d4e-42c5-9094-56d7ef26f5cc</slot_id>
      <event_id>ffbfc4af-f8a6-43e6-9e8b-c1c5253ab739</event_id>
      <submission_id>143</submission_id>
      <title>Specifying and Testing GPU Workgroup Progress Models</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>14:20</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:35</end_time>
      <description>As GPU availability has increased and programming support has matured, a wider variety of applications are being ported to these platforms. Many parallel applications contain fine-grained synchronization idioms; as such, their correct execution depends on a degree of relative forward progress between threads (or thread groups). Unfortunately, many GPU programming specifications (e.g. Vulkan and Metal) say almost nothing about relative forward progress guarantees between workgroups. Although prior work has proposed a spectrum of plausible progress models for GPUs, cross-vendor specifications have yet to commit to any model. 
This work is a collection of tools experimental data to aid specification designers when considering forward progress guarantees in programming frameworks. As a foundation, we formalize a small parallel programming language that captures the essence of fine-grained synchronization. We then provide a means of formally specifying a progress model, and develop a termination oracle that decides whether a given program is guaranteed to eventually terminate with respect to a given progress model. Next, we formalize a constraint for concurrent programs that require relative forward progress to terminate. Using this constraint, we synthesize a large set of 483 progress litmus tests. Combined with the termination oracle, this allows us to determine the expected status of each litmus test – i.e. whether it is guaranteed eventual termination – under various progress models. We present a large experimental campaign running the litmus tests across 8 GPUs from 5 different vendors. Our results highlight that GPUs have significantly different termination behaviors under our test suite. Most notably, we find that Apple and ARM GPUs do not support the linear occupancy-bound model, an intuitive progress model defined by prior work and hypothesized to describe the workgroup schedulers of existing GPUs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tyler</first_name>
          <last_name>Sorensen</last_name>
          <affiliation>University of California at Santa Cruz</affiliation>
          <bio>I am a Post Doc researcher at Princeton University working in Margaret Martonosi’s group. My research interests are in concurrency: programming, modeling, testing, and architecture. In particular, I am interested in exploring new heterogeneous architectures and how programming models can enable development of secure and efficient applications. 
I received my PhD from the Multicore Programming Group at Imperial College London supervised by Alastair Donaldson. Previously, I worked with Ganesh Gopalakrishnan and Zvonimir Rakamaric at University of Utah.</bio>
          <homepage_url>https://www.cs.princeton.edu/~ts20/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/tylersorensen1/e6c9c5cc-65e1-4a42-87c2-5e4a7d347b0d/small.jpg</picture_url>
          <person_id>tylersorensen1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lucas Fernan</first_name>
          <last_name>Salvador</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>I am a software engineer at the Xbox Platform team, and used to be a Master’s student at Princeton University (having graduated in May 2021). My main area of interest is parallel computing in its multiple facets (algorithms, architecture and verification).</bio>
          <homepage_url>https://www.cs.princeton.edu/~ls24/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/lucasfernansalvador/b45303b8-06e1-4f08-be26-369bff1b5628/small.jpg</picture_url>
          <person_id>lucasfernansalvador</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Harmit</first_name>
          <last_name>Raval</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>harmitraval</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hugues</first_name>
          <last_name>Evrard</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <picture_url>https://2021.splashcon.org/getProfileImage/huguesevrard1/4685a366-8c64-4450-8368-0839b97cf75d/small.jpg</picture_url>
          <person_id>huguesevrard1</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Margaret</first_name>
          <last_name>Martonosi</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <person_id>margaretrmartonosi</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Alastair F.</first_name>
          <last_name>Donaldson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>Alastair F. Donaldson is a Software Engineer at Google in the Android Graphics Team, and a Reader in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Google he was Director of GraphicsFuzz, an Imperial College spinout company which Google acquired in 2018. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
          <person_id>alastairdonaldson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">In-Person</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>e7da96db-48d7-4442-bfbc-35c3340b5c94</slot_id>
      <event_id>b5f75101-c8be-4cba-88b6-888ea6deaadc</event_id>
      <submission_id>150</submission_id>
      <title>MonkeyDB: Effectively Testing Correctness under Weak Isolation Levels</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>13:50</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:05</end_time>
      <description>Modern applications, such as social networking systems and e-commerce platforms are centered around using large-scale storage systems for storing and retrieving data. In the presence of concurrent accesses, these storage systems trade off isolation for performance. The weaker the isolation level, the more behaviors a storage system is allowed to exhibit and it is up to the developer to ensure that their application can tolerate those behaviors. However, these weak behaviors only occur rarely in practice, that too outside the control of the application, making it difficult for developers to test the robustness of their code against weak isolation levels. 
This paper presents MonkeyDB, a mock storage system for testing storage-backed applications. MonkeyDB supports a Key-Value interface as well as SQL queries under multiple isolation levels. It uses a logical specification of the isolation level to compute, on a read operation, the set of all possible return values. MonkeyDB then returns a value randomly from this set. We show that MonkeyDB provides good coverage of weak behaviors, which is complete in the limit. We test a variety of applications for assertions that fail only under weak isolation. MonkeyDB is able to break each of those assertions in a small number of attempts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ranadeep</first_name>
          <last_name>Biswas</last_name>
          <affiliation>Informal Systems</affiliation>
          <bio>undefined</bio>
          <person_id>ranadeepbiswas</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Diptanshu</first_name>
          <last_name>Kakwani</last_name>
          <affiliation>Microsoft, India</affiliation>
          <bio>undefined</bio>
          <person_id>diptanshukakwani</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jyothi</first_name>
          <last_name>Vedurada</last_name>
          <affiliation>IIT Hyderabad</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jyothivedurada.github.io/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/jyothivedurada/669c2067-2bb1-4cfd-9ecd-ad4dc7772314/small.jpg</picture_url>
          <person_id>jyothivedurada</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>University of Paris / IRIF / CNRS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
          <person_id>constantinenea</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Akash</first_name>
          <last_name>Lal</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/akashl/</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/akashlal/96032ffc-99b4-4b90-b99d-01b1f833751a/small.jpg</picture_url>
          <person_id>akashlal</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
    <timeslot>
      <slot_id>fe186d8e-a13f-4ed7-85f5-a8be6e5d2535</slot_id>
      <event_id>dec21536-5710-4cea-9e64-3c18c13c7578</event_id>
      <submission_id>86</submission_id>
      <title>Formal Verification of High-Level Synthesis</title>
      <room>Swissotel Chicago | Zurich B</room>
      <date>2021/10/22</date>
      <start_time>14:05</start_time>
      <end_date>2021/10/22</end_date>
      <end_time>14:20</end_time>
      <description>High-level synthesis (HLS), which refers to the automatic compilation of software into hardware, is rapidly gaining popularity. In a world increasingly reliant on application-specific hardware accelerators, HLS promises hardware designs of comparable performance and energy efficiency to those coded by hand in a hardware description language such as Verilog, while maintaining the convenience and the rich ecosystem of software development. However, current HLS tools cannot always guarantee that the hardware designs they produce are equivalent to the software they were given, thus undermining any reasoning conducted at the software level. Furthermore, there is mounting evidence that existing HLS tools are quite unreliable, sometimes generating wrong hardware or crashing when given valid inputs. 
To address this problem, we present the first HLS tool that is mechanically verified to preserve the behaviour of its input software. Our tool, called Vericert, extends the CompCert verified C compiler with a new hardware-oriented intermediate language and a Verilog back end, and has been proven correct in Coq. Vericert supports most C constructs, including all integer operations, function calls, local arrays, structs, unions, and general control-flow statements. An evaluation on the PolyBench/C benchmark suite indicates that Vericert generates hardware that is around an order of magnitude slower (only around 2× slower in the absence of division) and about the same size as hardware generated by an existing, optimising (but unverified) HLS tool.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yann</first_name>
          <last_name>Herklotz</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>My research focuses on formalising the process of converting high-level programming language descriptions to correct hardware that is functionally equivalent to the input. This process is called high-level synthesis (HLS), and allows software to be turned into custom accelerators automatically, which can then be placed on field-programmable gate arrays (FPGAs). An implementation in the Coq theorem prover called Vericert can be found on Github.</bio>
          <homepage_url>https://yannherklotz.com</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/yannherklotz/8a826a69-2e1a-4062-b141-594d84b9d987/small.jpg</picture_url>
          <person_id>yannherklotz</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>Pollard</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>jamespollard</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nadesh</first_name>
          <last_name>Ramanathan</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <person_id>nadeshramanathan</person_id>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>John</first_name>
          <last_name>Wickerson</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I am a Lecturer in the Department of Electrical and Electronic Engineering at Imperial College London.</bio>
          <homepage_url>http://johnwickerson.github.io</homepage_url>
          <picture_url>https://2021.splashcon.org/getProfileImage/johnwickerson/e74d4ce8-1ae7-4f7a-a53d-0aa35c361396/small.jpg</picture_url>
          <person_id>johnwickerson</person_id>
        </person>
      </persons>
      <tracks>
        <track>OOPSLA</track>
      </tracks>
      <badges>
        <badge property="Event Form">Virtual</badge>
      </badges>
    </timeslot>
  </subevent>
  <timezone_id>America/Chicago</timezone_id>
</event>
